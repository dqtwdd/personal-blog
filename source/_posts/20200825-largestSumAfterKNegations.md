---
title: K 次取反后最大化的数组和
tags: ['算法','贪心算法']
categories: 算法
date: 2020-08-25
---

给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）

以这种方式修改数组后，返回数组可能的最大和。

 <!--more-->

示例 1：

输入：A = [4,2,3], K = 1
输出：5
解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。
示例 2：

输入：A = [3,-1,0,2], K = 3
输出：6
解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。
示例 3：

输入：A = [2,-3,-1,5,-4], K = 2
输出：13
解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。
 

提示：

1 <= A.length <= 10000
1 <= K <= 10000
-100 <= A[i] <= 100

这道题还是给出两个思路吧。

第一种，先排序，然后找出数组中一共有多少个负数和0，如果负数和0的个数大于给出的K，直接将最小的K个负数反转（或者取绝对值）后计算数组和。如果负数和0的个数小于给出的K，先用K减去负数的个数，如果差是偶数，还是直接取和就行，如果差是奇数，将最小的正数反转计算和就行。

官方大部分题解都是这种思路，但是我觉得这样做不算是贪心算法。

贪心算法应该是只考虑当前状况的最优解，所以我觉得这道题应该是先将数组排序，然后将最小值反转，然后将反转后的数组再重新排序，如果反转次数小于K，那么继续将最小值，反转。

我觉得这样的做法才是贪心算法，由此可以看出，本题的最优解并不是贪心算法。

昨天老婆说我的拓扑图没有开始和结束，今天特地查了一下，作为记录

开始和结束使用椭圆

输入输出使用平行四边形

判断使用菱形

语句执行使用矩形

![解法拓扑图](https://s1.ax1x.com/2020/08/25/d6GQX9.png)


```javascript
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var largestSumAfterKNegations = function(A, K) {
  let sortArr = A.sort(function (a,b) {
    return a-b
  })
  for (let i = 0; i < K; i++) {
    sortArr[0] = -sortArr[0]
    sortArr.sort(function (a,b) {
      return a-b
    })
  }
  let res = sortArr.reduce(function (sum,curr) {
    return sum + curr
  })
  return res
};
```
