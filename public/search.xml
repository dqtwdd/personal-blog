<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>卡牌分组问题，求最大公约数</title>
    <url>/2020/08/10/20200810-deckGroup/</url>
    <content><![CDATA[<p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<p>每组都有 X 张牌。</p>
<p>组内所有的牌上都写着相同的整数。</p>
<p>仅当你可选的 X &gt;= 2 时返回 true。</p>
<span id="more"></span>

<p>示例 1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：可行的分组是 [<span class="number">1</span>,<span class="number">1</span>]，[<span class="number">2</span>,<span class="number">2</span>]，[<span class="number">3</span>,<span class="number">3</span>]，[<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,2,2,2,3,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：可行的分组是 [<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>示例 5：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：可行的分组是 [<span class="number">1</span>,<span class="number">1</span>]，[<span class="number">2</span>,<span class="number">2</span>]，[<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasGroupsSizeX = <span class="keyword">function</span>(<span class="params">deck</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % b === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> c = b</span><br><span class="line">        <span class="keyword">let</span> d = a % b</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">gcd</span>(c,d)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> deckLength = deck.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> noRepetArr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(deck)]</span><br><span class="line">    <span class="keyword">let</span> noRepetArrLength = noRepetArr.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> minDivisor = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (deckLength === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;noRepetArrLength; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> itemArr = deck.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item === noRepetArr[i]</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> itemMinDivisor = itemArr.<span class="property">length</span></span><br><span class="line">        <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">            minDivisor = itemMinDivisor</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minDivisor = <span class="title function_">gcd</span>(minDivisor,itemMinDivisor)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minDivisor === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用辗转相除法 递归方式算最大公因数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a % b === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> c = b</span><br><span class="line">    <span class="keyword">let</span> d = a % b</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">gcd</span>(c,d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划实现斐波那契数列</title>
    <url>/2020/08/10/20200810-fibonacci/</url>
    <content><![CDATA[<p>如果是index是0，1，2直接返回对应值（使用空间换时间）</p>
<p>如果index&gt;2，使用动态规划遍历一次获得需要的值。</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span> || n===<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> curr = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">3</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = curr + prev</span><br><span class="line">        prev = curr</span><br><span class="line">        curr = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fib</span>(<span class="number">0</span>)<span class="comment">//0</span></span><br><span class="line"><span class="title function_">fib</span>(<span class="number">1</span>)<span class="comment">//1</span></span><br><span class="line"><span class="title function_">fib</span>(<span class="number">2</span>)<span class="comment">//1</span></span><br><span class="line"><span class="title function_">fib</span>(<span class="number">3</span>)<span class="comment">//2</span></span><br><span class="line"><span class="title function_">fib</span>(<span class="number">4</span>)<span class="comment">//3</span></span><br><span class="line"><span class="title function_">fib</span>(<span class="number">5</span>)<span class="comment">//5</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2020/08/11/20200811-twoSum/</url>
    <content><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<span id="more"></span>

<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9</p>
<p>所以返回 [0, 1]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> resHash = &#123;&#125; <span class="comment">// 结果哈希表</span></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tempNum = target - nums[i]  <span class="comment">// 计算当前值和目标值的差</span></span><br><span class="line">        <span class="comment">// 查看结果哈希表中是否有以差值为索引的键值对，如果有的话直接将键值对中的值返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> resHash[tempNum] === <span class="string">&#x27;number&#x27;</span>) <span class="keyword">return</span> [resHash[tempNum],i] </span><br><span class="line">        resHash[nums[i]] = i <span class="comment">// 如果不存在，以当前值作为哈希表的键，以当前值的索引为值传入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一道简单小题引发的思考</title>
    <url>/2020/08/12/20200812-mergeArr/</url>
    <content><![CDATA[<p>今天刷leecode刷到一道简单的小题</p>
<p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>
<p>初始化 A 和 B 的元素数量分别为 m 和 n。</p>
<span id="more"></span>

<p>示例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">B = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">说明:</span><br><span class="line">A.<span class="property">length</span> == n + m</span><br></pre></td></tr></table></figure>

<p>看到这题的第一眼感觉是</p>
<p>就这？？</p>
<p>然后马不停蹄的敲了起来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">A</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">B</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify A in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">A, m, B, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> resArr = A</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        resArr[m+i] = B[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resArr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>写完之后发现好像不太对，只是实现了两个数组混合，但是没按大小排序啊。</p>
<p>easy，我嘴角翘起一抹微笑，js array中有数组排序的方法sort()，于是乎</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">A</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">B</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify A in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">A, m, B, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> resArr = A</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        resArr[m+i] = B[i]</span><br><span class="line">    &#125;</span><br><span class="line">    resArr.<span class="title function_">sort</span>()</span><br><span class="line">    <span class="keyword">return</span> resArr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>run，提交。我仿佛已经看到绿色的运行通过了。</p>
<p>结果嘛。肯定是不对的。</p>
<p>纳尼？</p>
<p>看过文档之后，才发现，原来sort()排序负数需要加上函数参数，是从大到小还是从小到大。</p>
<p>例子中是这样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> points = [<span class="number">40</span>,<span class="number">100</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">25</span>,<span class="number">10</span>];</span><br><span class="line">points.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> b-a&#125;); <span class="comment">// 大到小</span></span><br><span class="line">points.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a-b&#125;); <span class="comment">// 小到大</span></span><br></pre></td></tr></table></figure>

<p>修改一哈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">A</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">B</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify A in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">A, m, B, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> resArr = A</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        resArr[m+i] = B[i]</span><br><span class="line">    &#125;</span><br><span class="line">    resArr.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a-b&#125;)</span><br><span class="line">    <span class="keyword">return</span> resArr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>run，OK。</p>
<p>本文完结撒花！</p>
<hr>
<p>开玩笑的。其实我一开始并没有意识到是我sort方法没用对，还以为是sort对负数排序不支持。</p>
<p>好吧，我是菜鸡。</p>
<p>然后我去查了排序算法。</p>
<p>其实排序算法有很多种，不过印象最深的应该还是冒泡算法。简单粗暴，今天又详细了解之后，才更明确了几种比较经典的排序算法</p>
<p>冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序 计数排序 桶排序 基数排序</p>
<p><a href="https://zhuanlan.zhihu.com/p/73714165">知乎-十大算法排序（带动图）</a></p>
<p>不过，本文并不是想说这十种排序算法，而是在查看冒泡排序中发现了这样一种写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">// 相邻元素两两对比</span></span><br><span class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">// 元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接对传入参数进行赋值修改，这不禁深深困扰了我，不是说不能对传入的参数直接赋值直接操作么？为什么可以这么写</p>
<p>至此，本文正式进入正文（没想到吧，啊哈哈哈哈）</p>
<p>首先，看下面几个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    a=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    a.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="comment">// 例3</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,<span class="title function_">foo</span>(a)); <span class="comment">// 2 3</span></span><br></pre></td></tr></table></figure>

<p>发现不同了没？都是同时对传入的参数进行修改，例1中运行之后打印出来的a没有任何变化，而例2中却改变了原数组。</p>
<p>这个情况不禁让我陷入了深深的沉思，为什么呢？</p>
<p>对此，在查阅了资料之后我得出了如下结论</p>
<p><strong>在函数内部对传入参数进行的赋值都是对形参的操作。既：在函数内部对传入的参数进行赋值操作时，隐式的对参数进行了一次赋值，使函数内部的参数和外部的变量指向了不同的内存地址，所以在函数内部修改参数值时不会修改外部变量的值。</strong></p>
<p>有例外吗？<strong>有的</strong></p>
<p><strong>在函数内部调用传入参数的内部方法，或直接修改变量的基本数据类型，会直接修改外部变量</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例4</span></span><br><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [3,2,3]</span></span><br><span class="line"><span class="comment">// 例5</span></span><br><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    a.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="comment">// 例6</span></span><br><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,<span class="title function_">foo</span>(a)); <span class="comment">// [3,2,3]，[3,2,3]</span></span><br></pre></td></tr></table></figure>

<p>对此，比较好的做法是什么呢？</p>
<p>个人认为，如果参数是简单数据类型，可以直接进行操作，不会对全局变量产生影响，如果是复杂数据类型（Obj，Array），如果不希望对全局变量产生印象，最好还是在内部对参数进行深拷贝，然后再进行操作。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>判断括号有效性---bilibili笔试题</title>
    <url>/2020/08/14/20200814-validParentheses/</url>
    <content><![CDATA[<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<span id="more"></span>
<p>示例 1:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;()&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;(]&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>示例 4:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;([)]&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>示例 5:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;&#123;[]&#125;&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>先说说我自己的想法。</p>
<p>首先将字符串分割成数组，将所有括号分成6种（圆括号 左 右、方括号 左 右、花括号 左 右），然后记录每种括号所在的位置，记录index，然后分三类，圆括号方括号和花括号，然后判断每种括号的左右数量是不是一致（isDouble），不一致直接返回false。</p>
<p>然后重点来了，数组一定是以左括号开始的，并且每种类型的第一个右括号一定和最后一个左括号配对。</p>
<p>配对括号中间一定要间隔偶数个位置，如果是奇数就说明中间有没配对的。根据这个再判断一次成对括号的index之差是不是奇数（isSingle）。</p>
<p>只有满足两个条件才返回true，否则返回false。上代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sArr = s.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sArr)</span><br><span class="line">  <span class="keyword">let</span> squareLArr = []</span><br><span class="line">  <span class="keyword">let</span> circleLArr = []</span><br><span class="line">  <span class="keyword">let</span> flowerLArr = []</span><br><span class="line">  <span class="keyword">let</span> squareRArr = []</span><br><span class="line">  <span class="keyword">let</span> circleRArr = []</span><br><span class="line">  <span class="keyword">let</span> flowerRArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (sArr[i]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span> :</span><br><span class="line">        circleLArr.<span class="title function_">push</span>(i)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span> :</span><br><span class="line">        squareLArr.<span class="title function_">push</span>(i)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span> :</span><br><span class="line">        flowerLArr.<span class="title function_">push</span>(i)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span> :</span><br><span class="line">        circleRArr.<span class="title function_">push</span>(i)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span> :</span><br><span class="line">        squareRArr.<span class="title function_">push</span>(i)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span> :</span><br><span class="line">        flowerRArr.<span class="title function_">push</span>(i)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> circleArr = [circleLArr,circleRArr]</span><br><span class="line">  <span class="keyword">let</span> squareArr = [squareLArr,squareRArr]</span><br><span class="line">  <span class="keyword">let</span> flowerArr = [flowerLArr,flowerRArr]</span><br><span class="line">  <span class="keyword">let</span> isDouble = <span class="title function_">double</span>(circleArr) &amp;&amp; <span class="title function_">double</span>(squareArr) &amp;&amp; <span class="title function_">double</span>(flowerArr)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(isDouble)</span><br><span class="line">  <span class="keyword">let</span> isSingle  = <span class="title function_">single</span>(circleArr) &amp;&amp; <span class="title function_">single</span>(squareArr) &amp;&amp; <span class="title function_">single</span>(flowerArr)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(isSingle)</span><br><span class="line">  <span class="keyword">if</span> (isDouble &amp;&amp; isSingle) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> b[<span class="number">0</span>].<span class="property">length</span> === b[<span class="number">1</span>].<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">single</span>(<span class="params">b</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = b[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; b[<span class="number">1</span>].<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (b[<span class="number">0</span>][i] &lt; b[<span class="number">1</span>][j]) &#123;</span><br><span class="line">        <span class="keyword">let</span> gap = b[<span class="number">1</span>][j] - b[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">if</span> (gap % <span class="number">2</span>  === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(b,i,j,b[<span class="number">1</span>][j],b[<span class="number">0</span>][i])</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        b[<span class="number">0</span>].<span class="title function_">splice</span>(i,<span class="number">1</span>)</span><br><span class="line">        b[<span class="number">1</span>].<span class="title function_">splice</span>(j,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&#x27;[]&#123;&#125;()&#123;&#125;[](&#123;[()]&#125;)&#x27;</span></span><br><span class="line"><span class="title function_">isValid</span>(s1)</span><br></pre></td></tr></table></figure>

<p>是不是感觉我好蠢。哈哈哈哈哈哈</p>
<p>太复杂了。看题解发现一个野生大手子，虽然执行效率不高，但是思路很棒！</p>
<p>总体思路是，如果string是有效括号组，那么一定存在一对括号是左右相邻的。</p>
<p>如果将这对左右相邻的括号取出，那么一定会出现另一对左右相邻的括号，然后再取出来，反复执行之后，一定会将所有括号取空。</p>
<p>如果最后string的长度不是0，那么不是有效括号串。上代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sStr = s</span><br><span class="line">  <span class="keyword">while</span> (sStr.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sStr.<span class="title function_">includes</span>(<span class="string">&#x27;()&#x27;</span>)) &#123;</span><br><span class="line">      sStr = sStr.<span class="title function_">replace</span>(<span class="string">&#x27;()&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sStr.<span class="title function_">includes</span>(<span class="string">&#x27;[]&#x27;</span>)) &#123;</span><br><span class="line">      sStr = sStr.<span class="title function_">replace</span>(<span class="string">&#x27;[]&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sStr.<span class="title function_">includes</span>(<span class="string">&#x27;&#123;&#125;&#x27;</span>)) &#123;</span><br><span class="line">      sStr = sStr.<span class="title function_">replace</span>(<span class="string">&#x27;&#123;&#125;&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不得不说一句，妙啊！！！</p>
<p>然后是官方的解法，使用栈，每出现一个左括号，将左括号堆入栈中，当出现一个右括号后，判断是否和栈中最后一个匹配，如果匹配，将最后一个括号弹出，然后继续，如果不匹配，直接返回false。</p>
<p>这个应该是执行效率最高的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sArr = s.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (sArr.<span class="property">length</span> % <span class="number">2</span> &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> stack = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sArr[i] === <span class="string">&#x27;(&#x27;</span> || sArr[i] === <span class="string">&#x27;[&#x27;</span> || sArr[i] === <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(sArr[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sArr[i] === <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack[stack.<span class="property">length</span> - <span class="number">1</span>] === <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">          stack.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sArr[i] === <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack[stack.<span class="property">length</span> - <span class="number">1</span>] === <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">          stack.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sArr[i] === <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack[stack.<span class="property">length</span> - <span class="number">1</span>] === <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">          stack.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="property">log</span> (i,sArr[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !stack.<span class="property">length</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>OK!此题完结撒花！写了三种算法，我可真是棒棒哒！</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>两道小题-删除排序数组中的重复项，移除元素</title>
    <url>/2020/08/17/20200817-weekend/</url>
    <content><![CDATA[<h3 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h3><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>给定数组 nums = [1,1,2], </p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2:</p>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>int len = removeDuplicates(nums);</p>
<p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1:</p>
<p>给定 nums = [3,2,2,3], val = 3,</p>
<p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2:</p>
<p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p>注意这五个元素可为任意顺序。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>两道题都比较简单，只是有一个关键词**”原地删除”**需要记录一下。</p>
<p>原地删除是指改变原始数组，不创建新数组返回</p>
<p>上代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@question</span> 移除元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> currIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num !== val) &#123;</span><br><span class="line">      nums[currIndex] = num</span><br><span class="line">      currIndex ++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// nums.splice(currIndex)</span></span><br><span class="line">  <span class="keyword">return</span> currIndex</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@question</span> 删除数组中重复项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> currIndex = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] !== nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">      nums[currIndex] = nums[i]</span><br><span class="line">      currIndex++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currIndex</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子序列，亲密字符串</title>
    <url>/2020/08/18/20200818-longestPalindrome/</url>
    <content><![CDATA[<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<span id="more"></span>

<p>示例 1：</p>
<p>输入: “babad”</p>
<p>输出: “bab”</p>
<p>注意: “aba” 也是一个有效答案。</p>
<p>示例 2：</p>
<p>输入: “cbbd”</p>
<p>输出: “bb”</p>
<p>这道题是中等难度，本来是不会做的，参考了答案之后学会了使用动态规划方法解决。</p>
<p>主要思路就是双层for循环，判断两个值是否相等，然后创建二维数组，两个坐标分别对应两层for循环的key，如果相等，给对应二维数组的位置赋值true，证明两个坐标之间为回文序列。需要分三种情况考虑：</p>
<p>1.i 和 j相同，就是同一个数字，直接给dp赋值true。</p>
<p>2.i 和 j相差1，就是两个数字相邻，也是直接给dp赋值true。</p>
<p>3.第三种情况对应大部分情况，就是判断两边的数字相同，且两边夹着的内部的最外面的两个坐标对应的dp是true，既里面是回文序列，外面还相同，这样就是一个回文序列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!s || s.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span> </span><br><span class="line">  <span class="keyword">let</span> sArr = s.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> dp = []</span><br><span class="line">  <span class="keyword">let</span> res = sArr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = sArr.<span class="property">length</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    dp[i] = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; sArr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === j) &#123;</span><br><span class="line">        dp[i][j] = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j - i === <span class="number">1</span> &amp;&amp; sArr[i] === sArr[j]) &#123;</span><br><span class="line">        dp[i][j] = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sArr[i] === sArr[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; res.<span class="property">length</span>) res = sArr.<span class="title function_">slice</span>(i,j+<span class="number">1</span>)</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> res</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;ac&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">longestPalindrome</span>(s))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="亲密字符串"><a href="#亲密字符串" class="headerlink" title="亲密字符串"></a>亲密字符串</h3><p>给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。</p>
<p>示例 1：</p>
<p>输入： A = “ab”, B = “ba”<br>输出： true<br>示例 2：</p>
<p>输入： A = “ab”, B = “ab”<br>输出： false<br>示例 3:</p>
<p>输入： A = “aa”, B = “aa”<br>输出： true<br>示例 4：</p>
<p>输入： A = “aaaaaaabc”, B = “aaaaaaacb”<br>输出： true<br>示例 5：</p>
<p>输入： A = “”, B = “aa”<br>输出： false</p>
<p>这道题有点意思，但是也比较简单，只需要考虑全面情况就可以了。</p>
<p>1.如果字符串长度为0或者小于2，肯定不是。</p>
<p>2.如果字符串长度不一致，肯定不是。</p>
<p>3.如果字符串长度一致，有且只有两个不一致的地方，而且两个不一样的位置的值互换相同，返回true。</p>
<p>4.如果两个字符串完全相同，且单个字符串中没有相同元素，肯定不是；如果有一个或一个以上相同元素，返回true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">A</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">B</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buddyStrings = <span class="keyword">function</span>(<span class="params">A, B</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> aArr = []</span><br><span class="line">    <span class="keyword">let</span> bArr = []</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="property">length</span> !== B.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> aSet = [...<span class="keyword">new</span> <span class="title class_">Set</span>(A)]</span><br><span class="line">    <span class="keyword">if</span> (aSet.<span class="property">length</span> !== A.<span class="property">length</span> &amp;&amp; A === B) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] !== B[i]) &#123;</span><br><span class="line">            aArr.<span class="title function_">push</span>(A[i])</span><br><span class="line">            bArr.<span class="title function_">push</span>(B[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (aArr.<span class="property">length</span> &gt; <span class="number">2</span> || aArr.<span class="property">length</span> === <span class="number">0</span> || A === B) <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (aArr[<span class="number">1</span>] === bArr[<span class="number">0</span>] &amp;&amp; aArr[<span class="number">0</span>] === bArr[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 3</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>种花问题</title>
    <url>/2020/08/20/20200820-flower/</url>
    <content><![CDATA[<p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: flowerbed = [1,0,0,0,1], n = 1</p>
<p>输出: True</p>
<p>示例 2:</p>
<p>输入: flowerbed = [1,0,0,0,1], n = 2</p>
<p>输出: False</p>
<p>注意:</p>
<p>数组内已种好的花不会违反种植规则。</p>
<p>输入的数组长度范围为 [1, 20000]。</p>
<p>n 是非负整数，且不会超过输入数组的大小。</p>
<p>这道题我觉得我的思路比较好，虽然跟题解基本思路一致，但是我想到了一个优化点。</p>
<p>首先解题思路肯定是遍历一下数组，连续三个挨着的0可以种一个花，此外需要考虑到首位和末尾可以种花的情况，既[0,0,….,0,0]。按着这个思路直接遍历即可。</p>
<p>优化点在于每出现一个[…0,0,0,…],指针可以直接+2，因为种花位置的相邻位置不能种花，所以可以直接跳过。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">flowerbed</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canPlaceFlowers = <span class="keyword">function</span>(<span class="params">flowerbed, n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> tempBed = flowerbed</span><br><span class="line">  <span class="keyword">let</span> canPlace = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (!tempBed[<span class="number">0</span>] &amp;&amp; !tempBed[<span class="number">1</span>]) &#123;</span><br><span class="line">    tempBed[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    canPlace++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tempBed[tempBed.<span class="property">length</span> - <span class="number">1</span>] &amp;&amp; !tempBed[tempBed.<span class="property">length</span> - <span class="number">2</span>]) &#123;</span><br><span class="line">    tempBed[tempBed.<span class="property">length</span> - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    canPlace++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; tempBed.<span class="property">length</span>;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tempBed[i - <span class="number">1</span>] + tempBed[i] + tempBed[i + <span class="number">1</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">      canPlace++</span><br><span class="line">      i = i + <span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> canPlace &gt;= n ? <span class="attr">true</span>:<span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>三步问题</title>
    <url>/2020/08/20/20200820-stepProblem/</url>
    <content><![CDATA[<p>三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。</p>
<span id="more"></span>

<p>示例1:</p>
<p> 输入：n = 3 </p>
<p> 输出：4</p>
<p> 说明: 有四种走法</p>
<p>示例2:</p>
<p> 输入：n = 5</p>
<p> 输出：13</p>
<p>提示:</p>
<p>n范围在[1, 1000000]之间</p>
<p>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</p>
<p>不好意思，先让我笑一会，因为这道题，我的第一个解法实在是。</p>
<p>让我自己都不好意思说自己是一个程序员。</p>
<p>第一个方法，我竟然没有马上想到使用动态规划，而是使用了一个蠢方法，暴力递归。</p>
<p>有多暴力呢。你瞅瞅：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> waysToStep = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> walk = <span class="keyword">function</span> (<span class="params">temp</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123; </span><br><span class="line">      current = temp + i</span><br><span class="line">      <span class="keyword">if</span> (current === n) &#123;</span><br><span class="line">        res++</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current &lt; n) &#123;</span><br><span class="line">        <span class="title function_">walk</span>(temp + i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">walk</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>核心思想就是创建一个walk函数，传入参数是当前走了几步，然后函数中遍历123，模拟一次走一步两步三步，然后如果当前迈步的大小正好等于整个台阶阶数，就给结果数量+1，如果小于台阶数量，就继续一步两步三步去递归。</p>
<p>导致的结果就是当n = 20时我的电脑就崩了，res的每一个结果都是一个一个加上去的。</p>
<p>如果有哪个倒霉的小朋友按照我的代码去走这个楼梯一定能活活累死。</p>
<p>哈哈哈哈哈哈哈哈哈哈哈</p>
<hr>
<p>好了，正经的动态规划来了。其实很简单，跟计算斐波那契数列的方法类似，只要注意一下题目中提出了n的范围，所以在循环的时候注意一下就好了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> waysToStep = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> dp = []</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">  dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">  dp[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">4</span>; i &lt;= (n &lt; <span class="number">1000000</span>? <span class="attr">n</span>:<span class="number">1000000</span>); i++) &#123;</span><br><span class="line">    dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>] + dp[i - <span class="number">3</span>]) % <span class="number">1000000007</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机</title>
    <url>/2020/08/24/20200824-maxProfit/</url>
    <content><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p> <span id="more"></span></p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br>示例 2:</p>
<p>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3:</p>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>这道题么，先是用自己脑子整理了一下思路，其实以后遇到比较困难的题没有好的解决方案就可以按照接下来的流程去做，首先写根据题目写一个思路的拓扑图，然后整理一下，直接按照拓扑图的思路写就完了，优点是思路清晰，可以很容易的得出答案，缺点是这样得出来的答案一般都不是最优解，都是比较笨的办法。</p>
<p>思维拓扑图：</p>
<p><img src="https://s1.ax1x.com/2020/08/24/drZb5t.png" alt="解法拓扑图"></p>
<p>然后按部就班，按照每一个节点写代码就完了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> profitSum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> buyPrice</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buyPrice !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!prices[i+<span class="number">1</span>]) &#123;</span><br><span class="line">        profitSum = profitSum + prices[i] - buyPrice</span><br><span class="line">        buyPrice = <span class="literal">undefined</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i+<span class="number">1</span>]) &#123;</span><br><span class="line">          profitSum = profitSum + prices[i] - buyPrice</span><br><span class="line">          buyPrice = <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prices[i+<span class="number">1</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> profitSum</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; prices[i+<span class="number">1</span>]) &#123;</span><br><span class="line">          buyPrice = prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(buyPrice,profitSum)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> profitSum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果嘛emmm…不出所料的慢。</p>
<p>这里还有一个小插曲，在判断时要考虑清楚判断的对象范围，比如本题中</p>
<p><code>if (buyPrice !== undefined)</code></p>
<p>我一开始写的就是</p>
<p><code>if (!buyPrice)</code></p>
<p><strong>导致当buyPrice为0时直接跳过了，所以一定要考虑清楚判断语句中的内容！非常重要</strong></p>
<p>接下来就应该思考怎么优化，这道题就使用贪心算法，如果右边的比左边大，就直接的出来当前的利润加进去就好。</p>
<p>根据这个思路优化后，果然快了很多哦~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> profitSum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.<span class="property">length</span>;i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prices[i] === <span class="literal">undefined</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (prices[i] &lt; prices[i+<span class="number">1</span>]) &#123;</span><br><span class="line">        profitSum = profitSum + prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profitSum</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxProfit</span>(arr))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>无重复字符的最长子串</title>
    <url>/2020/08/21/20200821-lengthOfLongestSubstring/</url>
    <content><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: “abcabcbb”</p>
<p>输出: 3 </p>
<p>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>示例 2:</p>
<p>输入: “bbbbb”</p>
<p>输出: 1</p>
<p>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>示例 3:</p>
<p>输入: “pwwkew”</p>
<p>输出: 3</p>
<p>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p>
<p>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>emmmmmm…</p>
<p>这道题嘛。本来是不太会的，可是做了另一道比较类似的题，最长回文子字符串，然后这道题也就会了。</p>
<p>但是坏处是，虽然之前的思路可以给我一个思考的方向，让我做出了这道题，但是同时也束缚了我的思路，导致我的解法并不是最优解。</p>
<p>还是媳妇厉害。</p>
<p>先贴上我自己的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> longestRes = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; s.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> subStr = s.<span class="title function_">slice</span>(i,j)</span><br><span class="line">      <span class="keyword">let</span> tempLetter = s[j]</span><br><span class="line">      <span class="keyword">if</span> (!subStr.<span class="title function_">includes</span>(tempLetter)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j - i &gt; longestRes) &#123;</span><br><span class="line">          longestRes = j - i</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> longestRes + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思想就是两层遍历，然后判断当前最长无重复字符串中是否有指针指向的这个字母，如果没有并且当前长度大于当前最大长度就存一下最长长度，否则就终止，外层指针往前挪一个。</p>
<p>这个办法显然是不够优秀的，更好的做法是在重复时直接将指针移向当前最长字符串中与当前字符重复的位置，然后继续向前。</p>
<p>这么优秀的办法，老婆一次做出来。下面贴一下她的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> childStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = childStr.<span class="title function_">indexOf</span>(s[i]);</span><br><span class="line">    <span class="keyword">if</span> (index === -<span class="number">1</span>) &#123;</span><br><span class="line">      childStr += s[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      max = <span class="title class_">Math</span>.<span class="title function_">max</span>(childStr.<span class="property">length</span>,max);</span><br><span class="line">      childStr = childStr.<span class="title function_">substring</span>(index + <span class="number">1</span>) + s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max = <span class="title class_">Math</span>. max (childStr. length, max);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>七夕，致RainyDayDy</title>
    <url>/2020/08/24/20200824-toHoney/</url>
    <content><![CDATA[<p>今天是七夕前一天，我坐在宽敞的办公室里，写下这些文字。</p>
<p>很对不起，昨天跟你发了脾气，有时候我的脾气就是很臭，控制不住的臭。昨天吼完你，我也觉得很愧疚，满脑子都是我妈晚上回家晚，没给我爸做饭时候我爸吼我妈的样子。那一刻我觉得我真的和我爸一样，好像这么久以来我尽力避免，为了不变成像我父亲那样的人所做出的努力都是没用的。</p>
<p>后来我也意识到了我的错误，再想弥补已经来不及了。</p>
<p>还有上次你没带钥匙，这两件事，我都仔细思考过，如果没带钥匙的是我，如果在你休息时大声说话的人是我，你会怎么对待我。</p>
<p>很遗憾，我给自己的答案都是你会很温柔的对我。</p>
<p>我仔细思考了你平时对待我的每一个细节，好像你一直都是一个水一样温柔的女孩子，无论是对我，还是对待宝宝，说话很轻，很温柔，然后无论是我在外面偷摸吃个串还是在厕所里玩手机都是只会很温柔的笑笑，没有指责我，更不用说像我这样大吼。</p>
<p>所以我觉得很愧疚。</p>
<p>但是啊，其实我也是有一点点进步的。</p>
<p>我从一个睡觉死猪一样，一睡一宿，雷打不动的人变成了一个即使在半夜听到动静也会很平稳醒来然后给你开灯，默默看着你去卫生间的枕边人。</p>
<p>也变成了一个一到半夜一两点钟就会醒来去看看宝宝睡眠情况的年轻父亲。</p>
<p>也是一个拿着苍蝇拍当圣剑满屋追着蚊子跑的中二老男人。</p>
<p>也从一个一条内裤传一星期，半个月不换衣服的邋遢大王变成了一个每天换内衣，一周换两次衣服，一个人能把床单铺的整整齐齐的居家好男人。</p>
<p>这些，都是婚姻都是你使我改变的。</p>
<p>也是你，让我从一个不太上进，沉迷于板面和网吧无法自拔的网瘾少年变成了</p>
<p>C++小王子</p>
<p>Java总舵主</p>
<p>最后变成了一个每天刷Leecode写博客的的中年半秃顶程序员。</p>
<p>未来的路还很长，我觉得我的改变可能还是不够，在我们和谐的家庭中，我的坏脾气就像是隐藏在美好外衣下的一颗定时炸弹。有时咱们两个吵架，我也会看着我们的宝宝，然后想起来在我小时候，我的妈妈可能也是在跟爸爸吵架之后，用这样一种眼神看着我。然后我也想起当时她用那种带着浓烈不舍情绪但是依然很坚强的对我说，如果我和你爸爸分开，你跟谁？</p>
<p>我不想我们的宝宝生长在这种环境下，一点都不想。</p>
<p>我想让她知道，她的爸爸妈妈是永远爱她的，爸爸妈妈对她的爱凌驾于所有矛盾之上，我们会很恩爱，会很和睦，不是不会有家庭矛盾，只是我们的矛盾都只是生活的一种调料，就像一根火热的辣椒，吃下一口之后会很辣，甚至拉粑粑的时候会辣屁屁，但是吃下辣椒时那种热泪盈眶的感觉，也会使我们的生活变得更加鲜活，让我们的感情变得更加坚定。</p>
<p>宝宝会长大，我们也会更多地经历社会的风霜和将来可能要面对的家庭的问题，我不希望我们平淡下去，不希望我们的日子如同潺潺的溪水般漫无目的而又永不停歇的向前，如果可以，我更希望我们未来的生活如同一涛江水，冲刷岩石，奔腾而富有活力的奔涌向海洋。我也会为让我们变得更加有活力而做出更多地努力，跟你，跟宝宝一起，变得更好。</p>
]]></content>
      <categories>
        <category>家庭</category>
      </categories>
      <tags>
        <tag>爱情</tag>
      </tags>
  </entry>
  <entry>
    <title>检查数组对是否可以被 k 整除</title>
    <url>/2020/08/31/20200831-canArrange/</url>
    <content><![CDATA[<p>给你一个整数数组 arr 和一个整数 k ，其中数组长度是偶数，值为 n 。</p>
<p>现在需要把数组恰好分成 n / 2 对，以使每对数字的和都能够被 k 整除。</p>
<p>如果存在这样的分法，请返回 True ；否则，返回 False 。</p>
<span id="more"></span>

<p>示例 1：<br>输入：arr = [1,2,3,4,5,10,6,7,8,9], k = 5<br>输出：true<br>解释：划分后的数字对为 (1,9),(2,8),(3,7),(4,6) 以及 (5,10) 。</p>
<p>示例 2：<br>输入：arr = [1,2,3,4,5,6], k = 7<br>输出：true<br>解释：划分后的数字对为 (1,6),(2,5) 以及 (3,4) 。</p>
<p>示例 3：<br>输入：arr = [1,2,3,4,5,6], k = 10<br>输出：false<br>解释：无法在将数组中的数字分为三对的同时满足每对数字和能够被 10 整除的条件。</p>
<p>示例 4：<br>输入：arr = [-10,10], k = 2<br>输出：true</p>
<p>示例 5：<br>输入：arr = [-1,1,-2,2,-3,3,-4,4], k = 3<br>输出：true</p>
<p>提示：<br>arr.length == n<br>1 &lt;= n &lt;= 10^5<br>n 为偶数<br>-10^9 &lt;= arr[i] &lt;= 10^9<br>1 &lt;= k &lt;= 10^5</p>
<p>妈耶，这道题，感觉难点不是在贪心算法，而是在参数非常大时如何对传入的参数进行优化。</p>
<p>首先上一下自己的解题思路。画了 UML 图之后思路很清晰，一遍过。</p>
<p>但是问题就是太吃内存了。</p>
<p><img src="https://s1.ax1x.com/2020/08/31/dOnRrn.png" alt="解法拓扑图"></p>
<p>题解的思路很好，使用了 map 的数据结构，然后取余数作为 map 的 key。</p>
<p>自己的解法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">arr</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canArrange = <span class="keyword">function</span> (<span class="params">arr, k</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sortArr = arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> right = sortArr.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sortArr.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (left === right) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> currSum = sortArr[left] + sortArr[right]</span><br><span class="line">    <span class="keyword">if</span> (currSum % k === <span class="number">0</span>) &#123;</span><br><span class="line">      sortArr.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">      sortArr.<span class="title function_">splice</span>(right - <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">      right = sortArr.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">arr</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canArrange = <span class="keyword">function</span> (<span class="params">arr, k</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;,</span><br><span class="line">    len = arr.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计所有余数的出现次数到 map 中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> remain = arr[i] % k</span><br><span class="line">    <span class="keyword">if</span> (remain &lt; <span class="number">0</span>) remain += k</span><br><span class="line">    map[remain] === <span class="literal">undefined</span> ? (map[remain] = <span class="number">1</span>) : (map[remain] += <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有余数，看看是否对于每个余数 x，在 map 中都有相同出现次数的 k-x</span></span><br><span class="line">  <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(map),</span><br><span class="line">    n = keys.<span class="property">length</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (map[key] === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理过了，跳过</span></span><br><span class="line">      i++</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="string">&#x27;0&#x27;</span> &amp;&amp; map[key] % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 本身余数为 0，自己的出现次数是偶数即可</span></span><br><span class="line">      map[key] = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (map[k - <span class="title class_">Number</span>(key)] === map[key]) &#123;</span><br><span class="line">      <span class="comment">// map[x] === map[k-x]</span></span><br><span class="line">      map[key] = <span class="number">0</span></span><br><span class="line">      map[k - <span class="title class_">Number</span>(key)] = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 一旦不满足返回 false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咳咳，来更新下，这道题始终没跑过，今天又改了一下，发现自己的思路真的是 low 爆了，而且又发现老婆果然厉害，她的题解目前排在第一位，我也算是终于理解了她的思路。先补一下自己的做法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">arr</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canArrange = <span class="keyword">function</span> (<span class="params">arr, k</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = arr[i] % k</span><br><span class="line">    <span class="keyword">let</span> keyTrans, complementary</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个语句是根据当前值将当前值转化为小于k的非负数</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      keyTrans = k + key</span><br><span class="line">      complementary = k - keyTrans</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i], key, k, keyTrans, complementary)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="number">0</span>) &#123;</span><br><span class="line">      keyTrans = <span class="number">0</span></span><br><span class="line">      complementary = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      keyTrans = key</span><br><span class="line">      complementary = k - keyTrans</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后判断当前值的补数是否存在于map中，如果存在，删除map中的值，否则放进map里</span></span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">has</span>(complementary)) &#123;</span><br><span class="line">      <span class="keyword">let</span> num = map.<span class="title function_">get</span>(complementary)</span><br><span class="line">      <span class="keyword">if</span> (num === <span class="number">1</span>) &#123;</span><br><span class="line">        map.<span class="title function_">delete</span>(complementary)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map.<span class="title function_">set</span>(complementary, num - <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (map.<span class="title function_">has</span>(keyTrans)) &#123;</span><br><span class="line">        <span class="keyword">let</span> num = map.<span class="title function_">get</span>(keyTrans) + <span class="number">1</span></span><br><span class="line">        map.<span class="title function_">set</span>(keyTrans, num)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map.<span class="title function_">set</span>(keyTrans, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(map)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map.<span class="property">size</span> === <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [-<span class="number">4</span>, -<span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>, -<span class="number">8</span>, -<span class="number">3</span>]</span><br><span class="line">k = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">canArrange</span>(arr, k))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>K 次取反后最大化的数组和</title>
    <url>/2020/08/25/20200825-largestSumAfterKNegations/</url>
    <content><![CDATA[<p>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）</p>
<p>以这种方式修改数组后，返回数组可能的最大和。</p>
<p> <span id="more"></span></p>
<p>示例 1：</p>
<p>输入：A = [4,2,3], K = 1<br>输出：5<br>解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。<br>示例 2：</p>
<p>输入：A = [3,-1,0,2], K = 3<br>输出：6<br>解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。<br>示例 3：</p>
<p>输入：A = [2,-3,-1,5,-4], K = 2<br>输出：13<br>解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。
 </p>
<p>提示：</p>
<p>1 &lt;= A.length &lt;= 10000<br>1 &lt;= K &lt;= 10000<br>-100 &lt;= A[i] &lt;= 100</p>
<p>这道题还是给出两个思路吧。</p>
<p>第一种，先排序，然后找出数组中一共有多少个负数和0，如果负数和0的个数大于给出的K，直接将最小的K个负数反转（或者取绝对值）后计算数组和。如果负数和0的个数小于给出的K，先用K减去负数的个数，如果差是偶数，还是直接取和就行，如果差是奇数，将最小的正数反转计算和就行。</p>
<p>官方大部分题解都是这种思路，但是我觉得这样做不算是贪心算法。</p>
<p>贪心算法应该是只考虑当前状况的最优解，所以我觉得这道题应该是先将数组排序，然后将最小值反转，然后将反转后的数组再重新排序，如果反转次数小于K，那么继续将最小值，反转。</p>
<p>我觉得这样的做法才是贪心算法，由此可以看出，本题的最优解并不是贪心算法。</p>
<p>昨天老婆说我的拓扑图没有开始和结束，今天特地查了一下，作为记录</p>
<p>开始和结束使用椭圆</p>
<p>输入输出使用平行四边形</p>
<p>判断使用菱形</p>
<p>语句执行使用矩形</p>
<p><img src="https://s1.ax1x.com/2020/08/25/d6GQX9.png" alt="解法拓扑图"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">A</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">K</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> largestSumAfterKNegations = <span class="keyword">function</span>(<span class="params">A, K</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sortArr = A.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a,b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">    sortArr[<span class="number">0</span>] = -sortArr[<span class="number">0</span>]</span><br><span class="line">    sortArr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a,b</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a-b</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = sortArr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">sum,curr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum + curr</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最长快乐字符串</title>
    <url>/2020/08/31/20200831-maxHappyStr/</url>
    <content><![CDATA[<p>如果字符串中不含有任何 ‘aaa’，’bbb’ 或 ‘ccc’ 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。</p>
<p>给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：</p>
<p>s 是一个尽可能长的快乐字符串。<br>s 中 最多 有 a 个字母 ‘a’、b  个字母 ‘b’、c 个字母 ‘c’ 。<br>s 中只含有 ‘a’、’b’ 、’c’ 三种字母。<br>如果不存在这样的字符串 s ，请返回一个空字符串 “”。</p>
<span id="more"></span>

<p>示例 1：</p>
<p>输入：a = 1, b = 1, c = 7<br>输出：”ccaccbcc”<br>解释：”ccbccacc” 也是一种正确答案。<br>示例 2：</p>
<p>输入：a = 2, b = 2, c = 1<br>输出：”aabbc”<br>示例 3：</p>
<p>输入：a = 7, b = 1, c = 0<br>输出：”aabaa”<br>解释：这是该测试用例的唯一正确答案。</p>
<p>提示：</p>
<p>0 &lt;= a, b, c &lt;= 100<br>a + b + c &gt; 0</p>
<p>示例 1：</p>
<p>输入：A = [4,2,3], K = 1<br>输出：5<br>解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。<br>示例 2：</p>
<p>输入：A = [3,-1,0,2], K = 3<br>输出：6<br>解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。<br>示例 3：</p>
<p>输入：A = [2,-3,-1,5,-4], K = 2<br>输出：13<br>解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。</p>
<p>提示：</p>
<p>1 &lt;= A.length &lt;= 10000<br>1 &lt;= K &lt;= 10000<br>-100 &lt;= A[i] &lt;= 100</p>
<p>今天分享的是一道最长快乐字符串，做这道题，有一个非常重要的思路，就是当前要开始增加的字符串是次长的字符串时，要每次加一个。</p>
<p>给我的启示就是做一道题的时候一定要找到正确的思路然后再开始搞代码，然后才 ok，不然路子就走歪了，怎么写都是错的。</p>
<p><img src="https://s1.ax1x.com/2020/08/31/dL6lBn.png" alt="解法拓扑图"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">a</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">b</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">c</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestDiverseString = <span class="keyword">function</span> (<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [</span><br><span class="line">    &#123; <span class="attr">str</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">num</span>: a &#125;,</span><br><span class="line">    &#123; <span class="attr">str</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">num</span>: b &#125;,</span><br><span class="line">    &#123; <span class="attr">str</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">num</span>: c &#125;</span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">let</span> sortArr = arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">minItem, maxItem</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> maxItem.<span class="property">num</span> - minItem.<span class="property">num</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> resStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> addStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> addIndex = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (sortArr[<span class="number">0</span>].<span class="property">str</span> === resStr.<span class="title function_">slice</span>(resStr.<span class="property">length</span> - <span class="number">1</span>)) &#123;</span><br><span class="line">      addIndex = <span class="number">1</span></span><br><span class="line">      addStr = sortArr[<span class="number">1</span>].<span class="property">str</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      addIndex = <span class="number">0</span></span><br><span class="line">      addStr = sortArr[<span class="number">0</span>].<span class="property">str</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sortArr[addIndex].<span class="property">num</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (addIndex === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sortArr[addIndex].<span class="property">num</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          resStr += sortArr[addIndex].<span class="property">str</span> + sortArr[addIndex].<span class="property">str</span></span><br><span class="line">          sortArr[addIndex].<span class="property">num</span> = sortArr[addIndex].<span class="property">num</span> - <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resStr += sortArr[addIndex].<span class="property">str</span></span><br><span class="line">          sortArr[addIndex].<span class="property">num</span> = sortArr[addIndex].<span class="property">num</span> - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resStr += sortArr[addIndex].<span class="property">str</span></span><br><span class="line">        sortArr[addIndex].<span class="property">num</span> = sortArr[addIndex].<span class="property">num</span> - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> resStr</span><br><span class="line">    &#125;</span><br><span class="line">    sortArr = sortArr.<span class="title function_">sort</span>(<span class="function">(<span class="params">minItem, maxItem</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> maxItem.<span class="property">num</span> - minItem.<span class="property">num</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">longestDiverseString</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>换酒问题</title>
    <url>/2020/08/31/20200831-numWaterBottles/</url>
    <content><![CDATA[<p>小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。</p>
<p>如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。</p>
<p>请你计算 最多 能喝到多少瓶酒。</p>
<span id="more"></span>

<p>示例 1：<br>输入：numBottles = 9, numExchange = 3<br>输出：13<br>解释：你可以用 3 个空酒瓶兑换 1 瓶酒。<br>所以最多能喝到 9 + 3 + 1 = 13 瓶酒。</p>
<p>示例 2：<br>输入：numBottles = 15, numExchange = 4<br>输出：19<br>解释：你可以用 4 个空酒瓶兑换 1 瓶酒。<br>所以最多能喝到 15 + 3 + 1 = 19 瓶酒。</p>
<p>示例 3：<br>输入：numBottles = 5, numExchange = 5<br>输出：6</p>
<p>示例 4：<br>输入：numBottles = 2, numExchange = 3<br>输出：2</p>
<p>提示：<br>1 &lt;= numBottles &lt;= 100<br>2 &lt;= numExchange &lt;= 100</p>
<p>这道题就很简单咯！就是循环直到当前瓶子的数量小于换酒需要瓶子数量就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">numBottles</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">numExchange</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numWaterBottles = <span class="keyword">function</span> (<span class="params">numBottles, numExchange</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> currBottles = numBottles</span><br><span class="line">  <span class="keyword">let</span> maxBottoles = numBottles</span><br><span class="line">  <span class="keyword">while</span> (currBottles &gt;= numExchange) &#123;</span><br><span class="line">    maxBottoles += <span class="number">1</span></span><br><span class="line">    currBottles = currBottles - numExchange + <span class="number">1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;maxBottoles:&#x27;</span>, maxBottoles, <span class="string">&#x27;currBottles:&#x27;</span>, currBottles)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxBottoles</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡字符串</title>
    <url>/2020/09/01/20200901-balanceStr/</url>
    <content><![CDATA[<p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。</p>
<p>给出一个平衡字符串  s，请你将它分割成尽可能多的平衡字符串。</p>
<p>返回可以通过分割得到的平衡字符串的最大数量。</p>
<span id="more"></span>

<p>示例 1：<br>输入：s = “RLRRLLRLRL”<br>输出：4<br>解释：s 可以分割为 “RL”, “RRLL”, “RL”, “RL”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。</p>
<p>示例 2：<br>输入：s = “RLLLLRRRLR”<br>输出：3<br>解释：s 可以分割为 “RL”, “LLLRRR”, “LR”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。</p>
<p>示例 3：<br>输入：s = “LLLLRRRR”<br>输出：1<br>解释：s 只能保持原样 “LLLLRRRR”.</p>
<p>提示：<br>1 &lt;= s.length &lt;= 1000<br>s[i] = ‘L’ 或 ‘R’<br>分割得到的每个字符串都必须是平衡字符串。</p>
<p>这道题题目描述的有点不清晰，按照给的示例，应该所有的平衡字符串都是左右对称的，然鹅按照题解，只要连续的几个”L”的数量和”R”相同即可。</p>
<p>先是按照我自己的思路搞了一下，我的思路就是所有平衡字符串一定有一堆相邻的”LR”或者”RL”。以这个为判断平衡字符串的个数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> balancedStringSplit = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sArr = s.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> tempArr = []</span><br><span class="line">  <span class="keyword">let</span> balancedStrNum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tempArr.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> tempSum = sArr[i] + tempArr[tempArr.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">      <span class="keyword">if</span> (tempSum === <span class="string">&#x27;LR&#x27;</span> || tempSum === <span class="string">&#x27;RL&#x27;</span>) &#123;</span><br><span class="line">        balancedStrNum += <span class="number">1</span></span><br><span class="line">        tempArr = []</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tempArr.<span class="title function_">push</span>(sArr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> balancedStrNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据题解的思路又写了一下，很简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> balancedStringSplit = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sumArr = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> balancedStrNum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    sumArr += s[i] === <span class="string">&#x27;R&#x27;</span> ? -<span class="number">1</span> : <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (sumArr === <span class="number">0</span>) balancedStrNum += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> balancedStrNum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;LLLLRRRR&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">balancedStringSplit</span>(s))</span><br></pre></td></tr></table></figure>

<p>值得说的就是这个二元运算符的写法，这样就少写了一个 if else。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最多 K 次交换相邻数位后得到的最小整数</title>
    <url>/2020/09/01/20200901-minInteger/</url>
    <content><![CDATA[<p>给你一个字符串  num 和一个整数  k 。其中，num 表示一个很大的整数，字符串中的每个字符依次对应整数上的各个 数位 。</p>
<p>你可以交换这个整数相邻数位的数字 最多  k  次。</p>
<p>请你返回你能得到的最小整数，并以字符串形式返回。</p>
<span id="more"></span>

<p>示例 1：<br>输入：num = “4321”, k = 4<br>输出：”1342”<br>解释：4321 通过 4 次交换相邻数位得到最小整数的步骤如上图所示。</p>
<p>示例 2：<br>输入：num = “100”, k = 1<br>输出：”010”<br>解释：输出可以包含前导 0 ，但输入保证不会有前导 0 。</p>
<p>示例 3：<br>输入：num = “36789”, k = 1000<br>输出：”36789”<br>解释：不需要做任何交换。</p>
<p>示例 4：<br>输入：num = “22”, k = 22<br>输出：”22”</p>
<p>示例 5：<br>输入：num = “9438957234785635408”, k = 23<br>输出：”0345989723478563548”</p>
<p>提示：<br>1 &lt;= num.length &lt;= 30000<br>num  只包含   数字   且不含有   前导 0 。<br>1 &lt;= k &lt;= 10^9</p>
<p>来了来了！力扣征途中第一道困难题！出现了！！！！！</p>
<p>虽然没跑过。哈哈哈。</p>
<p>测试用例太大了，但是思路和方法应该没问题，所差的就是不是最优解，因为不太了解树状数组结构，以后学习一哈。</p>
<p>核心思想就是双指针，然后遍历一遍数组将区间内的最小值挪到前面就可以了。</p>
<p>虽然没跑过，但是还是要实名表扬一下自己。因为：</p>
<p>1.没用双层 for 循环。只遍历了一次。</p>
<p>2.代码比题解短。</p>
<p>3.思路清晰，养成了画 UML 图的好习惯。</p>
<p>4.学以致用，感觉最近做题时看到的视窗思想、双指针思想、和贪心算法的知识都用上了。</p>
<p>鼓掌！</p>
<p><img src="https://s1.ax1x.com/2020/09/01/dxkMlj.md.png" alt="解法拓扑图"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minInteger = <span class="keyword">function</span> (<span class="params">num, k</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> numArr = num.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 将num转化为数组</span></span><br><span class="line">  <span class="comment">// 获取右侧指针位置，由于arr.slice(i,j)方法截取的是从i位置到j位置之前的数组，所以将右侧指针+1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt; numArr.<span class="property">length</span> - i) &#123;</span><br><span class="line">      r = numArr.<span class="property">length</span> + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = i + k + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(&#x27;i:&#x27;, i, &#x27;r:&#x27;, r, &#x27;numArr.slice(i, r):&#x27;, numArr.slice(i, r))</span></span><br><span class="line">    <span class="comment">// 获取当前视窗之内的数组</span></span><br><span class="line">    <span class="keyword">let</span> newArr = numArr.<span class="title function_">slice</span>(i, r)</span><br><span class="line">    <span class="comment">// 获取当前视窗数组之内的最小值</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...newArr) + <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// 获取当前视窗数组之内的最小值的下标index，index + i为当前获取当前视窗数组之内的最小值在完整数组中的下标</span></span><br><span class="line">    <span class="keyword">let</span> minIndex = newArr.<span class="title function_">indexOf</span>(min) + i</span><br><span class="line">    <span class="comment">// console.log(&#x27;min:&#x27;, min, &#x27;minIndex:&#x27;, minIndex)</span></span><br><span class="line">    <span class="comment">// 获取当前视窗数组之内的最小值</span></span><br><span class="line">    <span class="keyword">let</span> temp = numArr[minIndex]</span><br><span class="line">    <span class="comment">// 删除数组中的当前视窗数组之内的最小值</span></span><br><span class="line">    numArr.<span class="title function_">splice</span>(minIndex, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 将当前视窗数组之内的最小值插入到右侧指针处</span></span><br><span class="line">    numArr.<span class="title function_">splice</span>(i, <span class="number">0</span>, temp)</span><br><span class="line">    <span class="comment">// 更新k值</span></span><br><span class="line">    k = k - (minIndex - i)</span><br><span class="line">    <span class="comment">// console.log(&#x27;numArr:&#x27;, numArr, &#x27;k:&#x27;, k)</span></span><br><span class="line">    <span class="comment">// 当k为0时返回</span></span><br><span class="line">    <span class="keyword">if</span> (k === <span class="number">0</span>) <span class="keyword">return</span> numArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历完成后返回</span></span><br><span class="line">  <span class="keyword">return</span> numArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="string">&#x27;51423&#x27;</span></span><br><span class="line"><span class="keyword">let</span> k = <span class="number">4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">minInteger</span>(num, k))</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新后的算法。以后尽量不要操作数组。</span></span><br><span class="line"><span class="keyword">var</span> minInteger = <span class="keyword">function</span> (<span class="params">num, k</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取最大循环次数</span></span><br><span class="line">  <span class="keyword">let</span> maxExchange = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; num.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    maxExchange += i</span><br><span class="line">  &#125;</span><br><span class="line">  k = <span class="title class_">Math</span>.<span class="title function_">min</span>(k, maxExchange)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt; num.<span class="property">length</span> - i) &#123;</span><br><span class="line">      r = num.<span class="property">length</span> + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = i + k + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newArr = num.<span class="title function_">substring</span>(i, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前视窗内数组的最小值，做题时拒绝使用Math方法</span></span><br><span class="line">    <span class="keyword">let</span> min = newArr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> minIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; newArr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = newArr[j]</span><br><span class="line">      cur &lt; min ? ((min = cur), (minIndex = j + i)) : <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加判断，只有当前最小值的位置坐标在右指针后面时才执行里面的代码</span></span><br><span class="line">    <span class="keyword">if</span> (minIndex &gt; i) &#123;</span><br><span class="line">      <span class="comment">// 之前没跑过的原因就在这里，原来的做法是操作数组，最后再合并成字符串，这样在测试用例很大时非常吃内存，也给我提了一个醒，能操作字符串就不要去操作数组。</span></span><br><span class="line">      num =</span><br><span class="line">        num.<span class="title function_">substring</span>(<span class="number">0</span>, i) +</span><br><span class="line">        num[minIndex] +</span><br><span class="line">        num.<span class="title function_">substring</span>(i, minIndex) +</span><br><span class="line">        num.<span class="title function_">substring</span>(minIndex + <span class="number">1</span>)</span><br><span class="line">      k = k - (minIndex - i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k === <span class="number">0</span>) <span class="keyword">return</span> num</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>使括号有效的最少添加</title>
    <url>/2020/09/03/20200903-minAddToMakeValid/</url>
    <content><![CDATA[<p>给定一个由  ‘(‘  和  ‘)’  括号组成的字符串 S，我们需要添加最少的括号（ ‘(‘  或是  ‘)’，可以在任何位置），以使得到的括号字符串有效。</p>
<p>从形式上讲，只有满足下面几点之一，括号字符串才是有效的：</p>
<p>它是一个空字符串，或者它可以被写成  AB （A  与  B  连接）, 其中  A 和  B  都是有效字符串，或者它可以被写作  (A)，其中  A  是有效字符串。</p>
<p>给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。</p>
<span id="more"></span>

<p>示例 1：<br>输入：”())”<br>输出：1</p>
<p>示例 2：<br>输入：”(((“<br>输出：3</p>
<p>示例 3：<br>输入：”()”<br>输出：0</p>
<p>示例 4：<br>输入：”()))((“<br>输出：4</p>
<p>提示：<br>S.length &lt;= 1000<br>S 只包含  ‘(‘ 和  ‘)’  字符。</p>
<p>中等难度的题，但是在做过有效括号的问题后，这道题就显得很简单咯！<br>给出两种方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">S</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">var</span> minAddToMakeValid = <span class="keyword">function</span> (<span class="params">S</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (S.<span class="title function_">includes</span>(<span class="string">&#x27;()&#x27;</span>)) &#123;</span><br><span class="line">    S = S.<span class="title function_">replace</span>(<span class="string">&#x27;()&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> S.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">var</span> minAddToMakeValid = <span class="keyword">function</span> (<span class="params">S</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; S.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[res.<span class="property">length</span> - <span class="number">1</span>] + S[i] === <span class="string">&#x27;()&#x27;</span>) &#123;</span><br><span class="line">      res.<span class="title function_">pop</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(S[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;((())&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">minAddToMakeValid</span>(s))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣自动选题系统</title>
    <url>/2020/09/03/20200903-leetCode/</url>
    <content><![CDATA[<p>最近开始学习 nodejs 的知识，实践是最好的老师，而且最近在做力扣的题目，所以就想开贴记录一下，计划十月一假期结束前写好一个力扣自动选题系统。</p>
<span id="more"></span>

<p>废话少说，先说思路。</p>
<p>计划实现的原型是运行脚本，然后选择题目类型，选择题目难度，然后自动选题页面效果类似下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">题目类型：</span><br><span class="line">[<span class="number">1</span>]贪心算法 [<span class="number">2</span>]堆 [<span class="number">3</span>]栈 [<span class="number">4</span>]动态规划 ...</span><br><span class="line">请输入选择的题目类型：<span class="number">1</span></span><br><span class="line">题目难度：</span><br><span class="line">[<span class="number">1</span>]简单 [<span class="number">2</span>]中等 [<span class="number">3</span>]困难</span><br><span class="line">请选择：<span class="number">1</span></span><br><span class="line">题目列表：</span><br><span class="line">[<span class="number">1</span>]玩筹码 [<span class="number">2</span>]判断子序列 [<span class="number">3</span>]换酒问题 ...</span><br><span class="line">请选择：<span class="number">3</span></span><br><span class="line">题目描述：</span><br><span class="line">xxxxxxxxxxxxxx</span><br><span class="line">是否确定(Y/N)？Y</span><br><span class="line">题目模板生成中，请稍后...</span><br></pre></td></tr></table></figure>

<p>就当前的原型来看，需要用到的模块比较简单，应该一个 http 模块和一个文件读写模块 fs 就能完成。</p>
<p>首先看一下力扣网站的页面</p>
<p><img src="https://s1.ax1x.com/2020/09/03/wPNp79.png" alt="力扣题目列表页面"></p>
<p>结构很简单，可以在右侧看见所有题目类型的标签是通过<code>https://leetcode-cn.com/problems/api/tags/</code>这个 get 接口获取到的，数据结构也并不复杂。</p>
<hr>
<p>第一次更新 2020.09.04</p>
<p>今天实现了获取标签，获取题目列表的功能。</p>
<p>先上一下代码进度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; title &#125; = <span class="built_in">require</span>(<span class="string">&#x27;process&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tagUrl = <span class="string">&#x27;https://leetcode-cn.com/problems/api/tags/&#x27;</span></span><br><span class="line"><span class="keyword">let</span> questionUrl = <span class="string">&#x27;https://leetcode-cn.com/graphql&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const readline = require(&#x27;readline&#x27;); // readline可以实现光标旋转动画效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// process.stdout.write(&#x27;请输入:&#x27;); //标准输出</span></span><br><span class="line"><span class="comment">// process.stdin.on(&#x27;data&#x27;, function (data) &#123;</span></span><br><span class="line"><span class="comment">//     var str = data.slice(0, -2);</span></span><br><span class="line"><span class="comment">//     process.stdin.emit(&#x27;end&#x27;);</span></span><br><span class="line"><span class="comment">//     process.stdout.write(&#x27;输入的:&#x27; + str + &#x27;---&#x27; + data);</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">// process.stdin.on(&#x27;end&#x27;, function () &#123;</span></span><br><span class="line"><span class="comment">//     process.stdin.pause();</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">QA</span>(<span class="params">question</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    process.<span class="property">stdout</span>.<span class="title function_">write</span>(question)</span><br><span class="line">    process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getQuestionTag</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    https.<span class="title function_">get</span>(tagUrl, <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> tagList = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">&#x27;正在获取题目类型，请等待...\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      res.<span class="title function_">setEncoding</span>(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">chunk</span>) &#123;</span><br><span class="line">        tagList += chunk</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      res.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        tagList = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(tagList).<span class="property">topics</span></span><br><span class="line">        <span class="keyword">let</span> questionListShow = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tagList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">          questionListShow[i] = &#123;</span><br><span class="line">            <span class="attr">slug</span>: tagList[i].<span class="property">slug</span>,</span><br><span class="line">            <span class="attr">title</span>: tagList[i].<span class="property">translatedName</span></span><br><span class="line">              ? tagList[i].<span class="property">translatedName</span></span><br><span class="line">              : tagList[i].<span class="property">name</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">&#x27;题目列表获取成功！\n&#x27;</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(questionListShow)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getQuestionTag().then(async (res) =&gt; &#123;</span></span><br><span class="line"><span class="comment">// 	let tagList = res</span></span><br><span class="line"><span class="comment">// 	let questionParam = &#123;&#125;</span></span><br><span class="line"><span class="comment">// 	for (let i = 0; i &lt; tagList.length; i++) &#123;</span></span><br><span class="line"><span class="comment">// 		process.stdout.write(&#x27;[&#x27; + i + &#x27;]&#x27; + tagList[i].title + &#x27;\n&#x27;);</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"><span class="comment">// 	let questionIndex = await QA(&#x27;请输入题目类型编号：&#x27;)</span></span><br><span class="line"><span class="comment">// 	process.stdout.write(&#x27;题目难度：[1]简单 [2]中等 [3]困难&#x27;);</span></span><br><span class="line"><span class="comment">// 	let difficulty = await QA(&#x27;请输入题目难度编号：&#x27;)</span></span><br><span class="line"><span class="comment">// 	process.stdout.write(questionIndex + &#x27;----&#x27; + difficulty + &#x27;-------&#x27;);</span></span><br><span class="line"><span class="comment">// 	process.stdin.emit(&#x27;end&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure>

<p>一个一个说，先列一下今天使用到的 node.js 功能点：</p>
<ol>
<li><p>process 模块，用于实现内容的提示和对输入的监听，需要注意的是监听输入时需要使用<code>process.stdin.emit(&#39;end&#39;);</code>销毁监听器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">&#x27;233&#x27;</span>) <span class="comment">// 功能类似console.log()用于输出</span></span><br><span class="line"><span class="comment">// 用于监键盘的输入。</span></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 我这里封装了一个QA函数，用于输入选择分类，选择难度等。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">QA</span>(<span class="params">question</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    process.<span class="property">stdout</span>.<span class="title function_">write</span>(question)</span><br><span class="line">    process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>http 模块，用于发出 get 或 post 请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https.<span class="title function_">get</span>(tagUrl, <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> tagList = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">&#x27;正在获取题目类型，请等待...\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">setEncoding</span>(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">chunk</span>) &#123;</span><br><span class="line">    tagList += chunk</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    tagList = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(tagList).<span class="property">topics</span></span><br><span class="line">    <span class="keyword">let</span> questionListShow = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tagList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      questionListShow[i] = &#123;</span><br><span class="line">        <span class="attr">slug</span>: tagList[i].<span class="property">slug</span>,</span><br><span class="line">        <span class="attr">title</span>: tagList[i].<span class="property">translatedName</span></span><br><span class="line">          ? tagList[i].<span class="property">translatedName</span></span><br><span class="line">          : tagList[i].<span class="property">name</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">&#x27;题目列表获取成功！\n&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(questionListShow)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>今天还解决了一个比较大的问题，就是偷偷调用了力扣的<code>https://leetcode-cn.com/graphql</code>post 接口，然后可以通过 post 请求直接获取到每个分类的题目 list。</p>
<p>接下来的目标就是在获取到题目列表之后，使用 js 将题目列表根据难度分类，由于力扣有一部分题目是付费的，在以后优化时可以将这部分题目过滤掉。然后直接根绝输入题目的类型和难度随机出题目标题，由于力扣每道题目的页面都是使用题目的英文标题区分，类似于<code>https://leetcode-cn.com/problems/maximum-subarray/</code>这种，只需要将最后的一部分<code>maximum-subarray</code>换成其他题目的英文标题，就可以使用 http 模块获取到页面信息，然后就跟做爬虫一样，将需要的信息筛选出来并展示就好啦！</p>
<h2 id="TO-BE-CONTINUE…"><a href="#TO-BE-CONTINUE…" class="headerlink" title="TO BE CONTINUE…"></a>TO BE CONTINUE…</h2>]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子序和</title>
    <url>/2020/09/04/20200904-maxSubArray/</url>
    <content><![CDATA[<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<span id="more"></span>

<p>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释:  连续子数组  [4,-1,2,1] 的和最大，为  6。</p>
<p>进阶:<br>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<p>这道题很简单，感觉动态规划的题如果有了思路的话会很简单，路子都很接近，直接上代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> dp = nums[<span class="number">0</span>],</span><br><span class="line">    max = nums[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> right = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (right &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">    dp = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp + nums[right], nums[right])</span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp, max)</span><br><span class="line">    right++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS学习汇总</title>
    <url>/2020/09/08/20200908-XSS/</url>
    <content><![CDATA[<p>前段时间花了很多精力学习了XSS攻击，感觉太久不看肯定会忘掉，所以本着这样的思路记录一下XSS攻击的相关知识。</p>
<p>主要分以下几个方面吧：</p>
<ol>
<li>什么是XSS</li>
<li>XSS的常见攻击方式</li>
<li>XSS预防方式</li>
<li>参考文献</li>
</ol>
<h2 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h2><p>XSS又叫CSS (Cross Site Script) ,跨站脚本攻击。 它指是恶意攻击者往Web页面里插入恶意html代码,当用户浏览该页之时,嵌入Web里面的html代码会被执行。</p>
<h2 id="XSS的常见攻击方式"><a href="#XSS的常见攻击方式" class="headerlink" title="XSS的常见攻击方式"></a>XSS的常见攻击方式</h2><p>XSS攻击分为两（三）种（DOM型攻击不太熟悉，所以没写）</p>
<ul>
<li>映射型（非持久）    映射型攻击就是通过恶意闭合标签然后插入恶意JavaScript代码获取用户信息。通常黑客通过发送恶意链接来获取用户的cookie信息，以此访问用户的账户，达到攻击的目的。</li>
<li>储存型  （持久）     储存型是持久型攻击，黑客在找到漏洞后将恶意代码发送到服务器（比如放在用户名中等等），所有访问受攻击站点的用户在无意中运行到恶意代码后都会受到攻击。所以储存型攻击的危害要大于映射型攻击。</li>
</ul>
<h2 id="XSS攻击常见的预防方式"><a href="#XSS攻击常见的预防方式" class="headerlink" title="XSS攻击常见的预防方式"></a>XSS攻击常见的预防方式</h2><p>根据我浅薄的网络安全知识，一般想要达到攻击的目的必不可少的步骤就是需要找到网站的漏洞，而漏洞一般就是前段没有对用户输入内容进行过滤。因此前段如果在所有用户输入时进行一些必要的转义和过滤，可以预防大部分菜鸡黑客的攻击。</p>
<h2 id="XSS预防方式"><a href="#XSS预防方式" class="headerlink" title="XSS预防方式"></a>XSS预防方式</h2><ul>
<li>输入过滤 过滤关键词如 JavaScript、&lt;、”、’ 等字符。需要注意的是也要对输入字母大小写情况和输入的是转码后的情况进行考虑。</li>
<li>改成纯前端渲染，把代码和数据分隔开。</li>
<li>对 HTML 做充分转义。</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html">美团XSS安全系列</a></p>
<p><a href="https://xss.tesla-space.com/">XSS靶场</a></p>
<p><a href="http://xssaq.com/wooyun/">乌云伤心的瘦子系列</a></p>
<p><a href="http://www.99lb.net/8467a.html">在我学习过程中费尽心机找到的实体靶场23333</a></p>
<p>还有一本书：《XSS跨站脚本攻击剖析与防御》</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>一和零</title>
    <url>/2020/09/15/20200915-findMaxForm/</url>
    <content><![CDATA[<p>在计算机界中，我们总是追求用有限的资源获取最大的收益。</p>
<p>现在，假设你分别支配着 m 个  0  和 n 个  1。另外，还有一个仅包含  0  和  1  字符串的数组。</p>
<p>你的任务是使用给定的  m 个  0  和 n 个  1 ，找到能拼出存在于数组中的字符串的最大数量。每个  0  和  1  至多被使用一次。</p>
<span id="more"></span>

<p>注意:</p>
<p>给定  0  和  1  的数量都不会超过  100。<br>给定字符串数组的长度不会超过  600。</p>
<p>示例 1:<br>输入: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3<br>输出: 4<br>解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 “10”,”0001”,”1”,”0” 。</p>
<p>示例 2:<br>输入: Array = {“10”, “0”, “1”}, m = 1, n = 1<br>输出: 2<br>解释: 你可以拼出 “10”，但之后就没有剩余数字了。更好的选择是拼出 “0” 和 “1” 。</p>
<p>咳咳。我宣布，我已经掌握了动态规划的精髓！！！！就一句话：<strong>一看就会，一做就不对！!</strong></p>
<p>真叫人脑壳痛，动态规划做了也有十几道了，还是不太能摸清规律。</p>
<p>不发牢骚啦，回归本题，这道题属于是比较有代表性的，属于背包问题。</p>
<p>看了很多篇文章，以下这篇文章讲的最好</p>
<p><a href="https://www.jianshu.com/p/a66d5ce49df5">背包问题图解</a></p>
<p>然后回归本题，个人认为比较值得记录的就是背包问题的解题办法，就是绘表法。</p>
<p>举个例子，比如本题中输入参数 <code>Array=[10,01,101,0], m=3, n=2</code></p>
<p>算了还是看题解的例子吧，感觉题解这个画表画的就很好。</p>
<p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/solution/yi-he-ling-by-leetcode/">一和零力扣官方图解</a></p>
<p>需要注意的就是这道题是从右下角往左上角画的。这个留个疑，不太理解，如果以后练习过程中理解了再回来记录下。</p>
<p>上一下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">strs</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于列表中遍历的每一个项目，都有两种情况：</span></span><br><span class="line"><span class="comment"> *  1.取当前值    取前值时，最大值为  当前货物的价值 + （总体积-当前货物体积）体积下货物的最大价值</span></span><br><span class="line"><span class="comment"> *  2.放弃当前值  放弃当前值时，不放入</span></span><br><span class="line"><span class="comment"> * 转移态方程</span></span><br><span class="line"><span class="comment"> * dp[i][j] = Math.max(dp[i][j],dp[i - strsItemZero][j - strsItemOne])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMaxForm = <span class="keyword">function</span> (<span class="params">strs, m, n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> getOneNum = <span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> item.<span class="title function_">replace</span>(<span class="regexp">/0/g</span>, <span class="string">&#x27;&#x27;</span>).<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> tempArr = []</span><br><span class="line">  <span class="keyword">let</span> dp = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> a = <span class="number">0</span>; a &lt;= m; a++) &#123;</span><br><span class="line">    dp[a] = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> b = <span class="number">0</span>; b &lt;= n; b++) &#123;</span><br><span class="line">      dp[a][b] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(dp)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> strsItem = strs[i]</span><br><span class="line">    strsItemOne = <span class="title function_">getOneNum</span>(strsItem)</span><br><span class="line">    strsItemZero = strsItem.<span class="property">length</span> - strsItemOne</span><br><span class="line">    <span class="comment">// 画表 0 =&gt; j, 1 =&gt; k</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = m; j &gt;= strsItemZero; j--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k = n; k &gt;= strsItemOne; k--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strsItemZero &lt;= j &amp;&amp; strsItemOne &lt;= k) &#123;</span><br><span class="line">          dp[j][k] = <span class="title class_">Math</span>.<span class="title function_">max</span>(</span><br><span class="line">            dp[j][k],</span><br><span class="line">            <span class="number">1</span> + dp[j - strsItemZero][k - strsItemOne]</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[j][k] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;dp:&#x27;</span>, dp)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Array</span> = [<span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;01&#x27;</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;0&#x27;</span>],</span><br><span class="line">  m = <span class="number">3</span>,</span><br><span class="line">  n = <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findMaxForm</span>(<span class="title class_">Array</span>, m, n))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划题目合集[按摩师，打家劫舍，判断子序列，连续的子数组的和]</title>
    <url>/2020/09/08/20200908-dynamicPlanning/</url>
    <content><![CDATA[<h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><p>首先让我贴上一篇我看到对动态规划最好的解释：</p>
<p>How should i explain Dynamic Programming to a 4-year-old?</p>
<p><em>writes down “1+1+1+1+1+1+1+1 =” on a sheet of paper</em><br>“What’s that equal to?”<br><em>counting</em> “Eight!”<br><em>writes down another “1+” on the left</em><br>“What about that?”<br><em>quickly</em> “Nine!”<br>“How’d you know it was nine so fast?”<br>“You just added one more”<br>“So you didn’t need to recount because you remembered there were eight! Dynamic Programming is just a fancy way to say ‘remembering stuff to save time later’”</p>
<span id="more"></span>

<p>按摩师和打家劫舍问题几乎就是一模一样的，通过这两道题找到动态规划一个很重要的解题思路，就是读题时要关注出现的数字，比如三步问题中出现了“三”，最后动态规划就是最后一个值是<code>dp[i-1]+dp[i-2]+dp[i-3]</code>,如果最后出现了“相邻”，一般最后结果都是和签名两个相关，比如打家劫舍的和按摩师的<code>dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])</code>，有了这个王老师的生活小技巧可以很大程度上帮助你迅速建立数学模型。</p>
<h2 id="按摩师"><a href="#按摩师" class="headerlink" title="按摩师"></a>按摩师</h2><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p>注意：本题相对原题稍作改动</p>
<p>示例 1：<br>输入： [1,2,3,1]<br>输出： 4<br>解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。</p>
<p>示例 2：<br>输入： [2,7,9,3,1]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。</p>
<p>示例 3：<br>输入： [2,1,4,5,3,1,1,3]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按摩师</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> * dp[i] =Math.max(dp[i-2]+nums[i],dp[i-1])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> massage = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">2</span>) <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">let</span> dp = [nums[<span class="number">0</span>], <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[dp.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1：<br>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>  偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>示例 2：<br>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>  偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
<p>提示：<br>0 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 400</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打家劫舍</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">2</span>) <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">let</span> maxArr = [nums[<span class="number">0</span>], <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    maxArr[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxArr[i - <span class="number">1</span>], maxArr[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxArr[nums.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>示例  1:<br>s = “abc”, t = “ahbgdc”<br>返回  true.</p>
<p>示例  2:<br>s = “axc”, t = “ahbgdc”<br>返回  false.</p>
<p>后续挑战 :</p>
<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10 亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p>这道题可以使用双指针的思想，因为子字符串在父字符串中出现的顺序一定是顺序的，所以子字符串的指针到最后的就可以判断为 true 了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSubsequence = <span class="keyword">function</span> (<span class="params">s, t</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> (t.<span class="property">length</span> === <span class="number">0</span> || t.<span class="property">length</span> &lt; s.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> currLetter = s[i]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; t.<span class="property">length</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t[j] === currLetter) &#123;</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= s.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      currLetter = s[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="连续的子数组和"><a href="#连续的子数组和" class="headerlink" title="连续的子数组和"></a>连续的子数组和</h2><p>给定一个包含 非负数 的数组和一个目标 整数  k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p>
<p>示例 1：<br>输入：[23,2,4,6,7], k = 6<br>输出：True<br>解释：[2,4] 是一个大小为 2 的子数组，并且和为 6。</p>
<p>示例 2：<br>输入：[23,2,6,4,7], k = 6<br>输出：True<br>解释：[23,2,6,4,7]是大小为 5 的子数组，并且和为 42。</p>
<p>这道题我看到之后想到的是使用二维数组，然后每次后一个的值都可以根据前一个的值计算，需要注意的就是考虑 k 为 0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> checkSubarraySum = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> dp = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    dp[i] = []</span><br><span class="line">    dp[i][i] = [nums[i]]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      dp[i][j] = <span class="number">1</span> * dp[i][j - <span class="number">1</span>] + nums[j]</span><br><span class="line">      <span class="keyword">if</span> (dp[i][j] % k === <span class="number">0</span> || (k === <span class="number">0</span> &amp;&amp; dp[i][j] === <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>非递减数列</title>
    <url>/2020/09/18/20200918-checkPossibility/</url>
    <content><![CDATA[<p>给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p>
<p>我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]。</p>
<span id="more"></span>

<p>示例 1:<br>输入: nums = [4,2,3]<br>输出: true<br>解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。</p>
<p>示例 2:<br>输入: nums = [4,2,1]<br>输出: false<br>解释: 你不能在只改变一个元素的情况下将其变为非递减数列。</p>
<p>说明：<br>1 &lt;= n &lt;= 10 ^ 4</p>
<ul>
<li>10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5</li>
</ul>
<p>这道简单题困扰了我很久，但是最后还是被我做出来了啊哈哈哈哈。</p>
<p>头几天状态不太好，所以做题思路不明确，后来思路明确了就简单了。</p>
<p>其实这道题最重要的思想就是找到拐点，然后判断，如果拐点大于1就返回false。</p>
<p>如果拐点等于1，就判断一下是否可以改变一个数字形成非递减数组。</p>
<p>题解的思路很清晰，跟我的区别是我将拐点定义为变小的那个数。题解的拐点定义为变小的数前一个的数字。</p>
<p>写法还有优化空间，但是没有优化。先这样吧。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> checkPossibility = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> breakPointList = []</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">1</span> ||nums.<span class="property">length</span> === <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">      breakPointList.<span class="title function_">push</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (breakPointList.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (breakPointList[<span class="number">0</span>] === <span class="number">1</span> || breakPointList[<span class="number">0</span>] === nums.<span class="property">length</span>-<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[breakPointList[<span class="number">0</span>]+<span class="number">1</span>]&gt;= nums[breakPointList[<span class="number">0</span>]-<span class="number">1</span>] ||(nums[breakPointList[<span class="number">0</span>]]&gt;= nums[breakPointList[<span class="number">0</span>]-<span class="number">2</span>] &amp;&amp;nums[breakPointList[<span class="number">0</span>]+<span class="number">1</span>]&gt;= nums[breakPointList[<span class="number">0</span>]-<span class="number">2</span>] )) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (breakPointList.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">checkPossibility</span>(nums))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>剪绳子 II</title>
    <url>/2020/09/18/20200918-cuttingRope/</url>
    <content><![CDATA[<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p> <span id="more"></span></p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：<br>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1</p>
<p>示例 2:<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p>
<p>做多了动态规划之后这种题就很简单啦</p>
<p>根据题目，首先分析一下规律：</p>
<table>
<thead>
<tr>
<th align="center">绳子总长</th>
<th align="center">最大值</th>
<th align="center">绳子各段长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1 1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1 2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">2 2</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">2 3</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">9</td>
<td align="center">3 3</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">12</td>
<td align="center">3 4</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">18</td>
<td align="center">3 3 2</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">27</td>
<td align="center">3 3 3</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">36</td>
<td align="center">3 3 2 2</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">54</td>
<td align="center">3 3 3 2</td>
</tr>
</tbody></table>
<p>不难发现，归路就是找3，余数是1的时候少减一个3，变为2+2</p>
<p>根据这个规律就很简单啦</p>
<p>需要注意的就是取模，记住一般超出大小取模都是 1 8个0 7</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> cuttingRope = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> simple = &#123;</span><br><span class="line">    <span class="number">2</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="number">3</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="number">4</span>:<span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (simple[n]) &#123;</span><br><span class="line">    <span class="keyword">return</span> simple[n]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> dp</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">4</span> || n === <span class="number">3</span>) &#123;</span><br><span class="line">      n = n - <span class="number">3</span></span><br><span class="line">      dp = (dp * <span class="number">3</span>) % <span class="number">1000000007</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n === <span class="number">4</span>) &#123;</span><br><span class="line">      n = <span class="number">0</span></span><br><span class="line">      dp = (dp * <span class="number">4</span>) % <span class="number">1000000007</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      n = <span class="number">0</span></span><br><span class="line">      dp = (<span class="number">2</span> * dp) % <span class="number">1000000007</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">127</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cuttingRope</span>(n))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>手撸datePicker</title>
    <url>/2020/10/22/20201022-datePicker/</url>
    <content><![CDATA[<p>因为工作需要，自己手撸了一个 datePicker 记录一下主要的思路内容。</p>
<span id="more"></span>

<p>要点：</p>
<ol>
<li><p>使用vant组件弹出</p>
</li>
<li><p>日期和月份每天的对照关系</p>
</li>
<li><p>传入一个可选日期区间，包括开始日期和结束日期，在只能选择日期区间内部的时间</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">van-popup</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">v-model</span>=<span class="string">&quot;showPicker&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">round</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">closeable</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">position</span>=<span class="string">&quot;bottom&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      @<span class="attr">close</span>=<span class="string">&quot;close&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;picker_header&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> @<span class="attr">click</span>=<span class="string">&quot;changeMonth(-1)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">class</span>=<span class="string">&quot;left_arrow&quot;</span> <span class="attr">icon-class</span>=<span class="string">&quot;detail&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; currYear + &quot;年&quot; + currMonth + &quot;月&quot; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> @<span class="attr">click</span>=<span class="string">&quot;changeMonth(1)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">class</span>=<span class="string">&quot;right_arrow&quot;</span> <span class="attr">icon-class</span>=<span class="string">&quot;detail&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;border_one&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;picker_content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content_title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>日<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>一<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>二<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>三<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>四<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>五<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>六<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content_mian&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">class</span>=<span class="string">&quot;content_item&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in currMonthDateList&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">:style</span>=<span class="string">&quot;item === 0 ? &#x27;opacity:0&#x27; : &#x27;&#x27;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">:class</span>=<span class="string">&quot;isAvailable(item) ? &#x27;date_available&#x27; : &#x27;&#x27;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            @<span class="attr">click</span>=<span class="string">&quot;selectDate(item)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; isAvailable(item) ? &quot;可约&quot; : &quot;不可约&quot; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">van-popup</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">inheritAttrs</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;tkDatePicker&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">showPicker</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">type</span>: <span class="title class_">Boolean</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">default</span>: <span class="literal">false</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">value</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">type</span>: <span class="title class_">String</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">default</span>: <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">availableStart</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">type</span>: <span class="title class_">Array</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">default</span>: <span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> []</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">availableEnd</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">type</span>: <span class="title class_">Array</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">default</span>: <span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> []</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  data () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">monthStartWeek</span>: <span class="string">&#x27;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">currYear</span>: <span class="string">&#x27;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">currMonth</span>: <span class="string">&#x27;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">currDate</span>: <span class="string">&#x27;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">monthDateMap</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="number">1</span>: <span class="number">31</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="number">2</span>: <span class="number">28</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="number">3</span>: <span class="number">31</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="number">4</span>: <span class="number">30</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="number">5</span>: <span class="number">31</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="number">6</span>: <span class="number">30</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="number">7</span>: <span class="number">31</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="number">8</span>: <span class="number">31</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="number">9</span>: <span class="number">30</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="number">10</span>: <span class="number">31</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="number">11</span>: <span class="number">30</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="number">12</span>: <span class="number">31</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">currMonthDateList</span>: []</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  mounted () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">this</span>.<span class="title function_">init</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    init () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">availableStart</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currYear</span> = <span class="variable language_">this</span>.<span class="property">availableStart</span>[<span class="number">0</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currMonth</span> = <span class="variable language_">this</span>.<span class="property">availableStart</span>[<span class="number">1</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currDate</span> = <span class="variable language_">this</span>.<span class="property">availableStart</span>[<span class="number">2</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> date = <span class="variable language_">this</span>.<span class="title function_">getCurrentDate</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currYear</span> = date[<span class="number">0</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currMonth</span> = date[<span class="number">1</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currDate</span> = date[<span class="number">2</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="title function_">getMonthStartWeek</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 获取当前时间</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    getCurrentDate () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> currYear = date.<span class="title function_">getFullYear</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> currMonth = date.<span class="title function_">getMonth</span>() + <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> currDate = date.<span class="title function_">getDate</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> [currYear, currMonth, currDate]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 根据当前年月计算本月一号是周几</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    getMonthStartWeek () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">currMonthDateList</span> = []</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> monthStart = <span class="variable language_">this</span>.<span class="property">currYear</span> + <span class="string">&#x27;/&#x27;</span> + <span class="variable language_">this</span>.<span class="property">currMonth</span> + <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;1&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">monthStartWeek</span> = <span class="keyword">new</span> <span class="title class_">Date</span>(monthStart).<span class="title function_">getDay</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 填充一号前面的0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="variable language_">this</span>.<span class="property">monthStartWeek</span>; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currMonthDateList</span>.<span class="title function_">push</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 填充</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="variable language_">this</span>.<span class="property">monthDateMap</span>[<span class="variable language_">this</span>.<span class="property">currMonth</span>]; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (i &lt; <span class="number">10</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          i = <span class="string">&#x27;0&#x27;</span> + i</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          i = i + <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currMonthDateList</span>.<span class="title function_">push</span>(i)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 闰年二月加一天</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currYear</span> % <span class="number">4</span> === <span class="number">0</span> &amp;&amp;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        (<span class="variable language_">this</span>.<span class="property">currYear</span> % <span class="number">100</span> !== <span class="number">0</span> || <span class="variable language_">this</span>.<span class="property">currYear</span> % <span class="number">400</span> === <span class="number">0</span>) &amp;&amp;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currMonth</span> === <span class="number">2</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      ) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currMonthDateList</span>.<span class="title function_">push</span>(<span class="number">29</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">currMonthDateList</span>.<span class="property">length</span> &lt; <span class="number">42</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currMonthDateList</span>.<span class="title function_">push</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 改月份时12月加一年，1月减一年</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    changeMonth (operate) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">currMonth</span> === <span class="number">1</span> &amp;&amp; operate === -<span class="number">1</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currYear</span> = <span class="variable language_">this</span>.<span class="property">currYear</span> - <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currMonth</span> = <span class="number">12</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">currMonth</span> === <span class="number">12</span> &amp;&amp; operate === <span class="number">1</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currYear</span> = <span class="variable language_">this</span>.<span class="property">currYear</span> + <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currMonth</span> = <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">currMonth</span> = <span class="variable language_">this</span>.<span class="property">currMonth</span> + operate</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="title function_">getMonthStartWeek</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 计算日期是否是可选的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    isAvailable (date) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> currDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="variable language_">this</span>.<span class="property">currYear</span>, <span class="variable language_">this</span>.<span class="property">currMonth</span>, date)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> dateStart = <span class="keyword">new</span> <span class="title class_">Date</span>(</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">availableStart</span>[<span class="number">0</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">availableStart</span>[<span class="number">1</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">availableStart</span>[<span class="number">2</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      )</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> dateEnd = <span class="keyword">new</span> <span class="title class_">Date</span>(</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">availableEnd</span>[<span class="number">0</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">availableEnd</span>[<span class="number">1</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">availableEnd</span>[<span class="number">2</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      )</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> currDate &gt;= dateStart &amp;&amp; currDate &lt;= dateEnd</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 选择日期</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    selectDate (date) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">isAvailable</span>(date)) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> dateArr = [<span class="variable language_">this</span>.<span class="property">currYear</span>, <span class="variable language_">this</span>.<span class="property">currMonth</span>, date * <span class="number">1</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;selectDate&#x27;</span>, dateArr)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="title function_">close</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    close () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;close&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack优化相关</title>
    <url>/2020/12/24/20201224-webpackOptimize/</url>
    <content><![CDATA[<p>webpack优化相关知识记录。</p>
<span id="more"></span>

<h3 id="1-辅助工具-：打包时间、打包分析"><a href="#1-辅助工具-：打包时间、打包分析" class="headerlink" title="1.辅助工具 ：打包时间、打包分析"></a>1.辅助工具 ：打包时间、打包分析</h3><ul>
<li><p><code>speed-measure-webpack-plugin</code> 安装后可以查看打包耗时。可以看到每个包打包用了多长时间。</p>
</li>
<li><p><code>webpack-bundle-analyzer</code> 查看打包后每个包的大小。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">cnpm install -D speed-measure-webpack-plugin</span><br><span class="line">cnpm install -D webpack-bundle-analyzer</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SpeedMeasurePlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;speed-measure-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> <span class="title class_">SpeedMeasurePlugin</span>()</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BundleAnalyzerPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).<span class="property">BundleAnalyzerPlugin</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">  <span class="attr">productionSourceMap</span>: isDev,</span><br><span class="line">  <span class="attr">pages</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="attr">configureWebpack</span>: smp.<span class="title function_">wrap</span>(&#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>(),</span><br><span class="line">      <span class="keyword">new</span> webpack.<span class="title class_">DllReferencePlugin</span>(&#123;</span><br><span class="line">        <span class="attr">context</span>: process.<span class="title function_">cwd</span>(),</span><br><span class="line">        <span class="attr">manifest</span>: <span class="built_in">require</span>(<span class="string">&#x27;./public/vendor/vant-manifest.json&#x27;</span>)</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> webpack.<span class="title class_">DllReferencePlugin</span>(&#123;</span><br><span class="line">        <span class="attr">context</span>: process.<span class="title function_">cwd</span>(),</span><br><span class="line">        <span class="attr">manifest</span>: <span class="built_in">require</span>(<span class="string">&#x27;./public/vendor/vendor-manifest.json&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">devServer</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-代码分割"><a href="#2-代码分割" class="headerlink" title="2.代码分割"></a>2.代码分割</h3><h4 id="2-1SplitChunks"><a href="#2-1SplitChunks" class="headerlink" title="2.1SplitChunks"></a>2.1SplitChunks</h4><ul>
<li><code>SplitChunks </code> 集成在webpack中，顾名思义，就是用来手动将包抽离出来，以达到减小打包大小的方法。</li>
</ul>
<p>SplitChunks 插件配置选项：</p>
<ul>
<li><p>chunks 选项，决定要提取那些模块。</p>
<ul>
<li><p>默认是 async：只提取异步加载的模块出来打包到一个文件中。</p>
</li>
<li><p>异步加载的模块：通过 import(‘xxx’)或 require([‘xxx’],() =&gt;{})加载的模块。</p>
</li>
<li><p>initial：提取同步加载和异步加载模块，如果 xxx 在项目中异步加载了，也同步加载了，那么 xxx 这个模块会被提取两次，分别打包到不同的文件中。</p>
<ul>
<li>同步加载的模块：通过 import xxx 或 require(‘xxx’)加载的模块。</li>
</ul>
</li>
<li><p>all：不管异步加载还是同步加载的模块都提取出来，打包到一个文件中。</p>
</li>
</ul>
</li>
<li><p>minSize 选项：规定被提取的模块在压缩前的大小最小值，单位为字节，默认为 30000，只有超过了 30000 字节才会被提取。</p>
</li>
<li><p>maxSize 选项：把提取出来的模块打包生成的文件大小不能超过 maxSize 值，如果超过了，要对其进行分割并打包生成新的文件。单位为字节，默认为 0，表示不限制大小。</p>
</li>
<li><p>minChunks 选项：表示要被提取的模块最小被引用次数，引用次数超过或等于 minChunks 值，才能被提取。</p>
</li>
<li><p>maxAsyncRequests 选项：最大的按需(异步)加载次数，默认为 6。</p>
</li>
<li><p>maxInitialRequests 选项：打包后的入口文件加载时，还能同时加载 js 文件的数量（包括入口文件），默认为 4。</p>
</li>
<li><p>先说一下优先级 maxInitialRequests / maxAsyncRequests &lt; maxSize&lt; minSize。<br>automaticNameDelimiter 选项：打包生成的 js 文件名的分割符，默认为~。<br>name 选项：打包生成 js 文件的名称。</p>
</li>
<li><p>cacheGroups 选项，核心重点，配置提取模块的方案。里面每一项代表一个提取模块的方案。下面是 cacheGroups 每项中特有的选项，其余选项和外面一致，若 cacheGroups 每项中有，就按配置的，没有就使用外面配置的。</p>
<ul>
<li>test 选项：用来匹配要提取的模块的资源路径或名称。值是正则或函数。<br>priority 选项：方案的优先级，值越大表示提取模块时优先采用此方案。默认值为 0。</li>
<li>reuseExistingChunk 选项：true/false。为 true 时，如果当前要提取的模块，在已经在打包生成的 js 文件中存在，则将重用该模块，而不是把当前要提取的模块打包生成新的 js 文件。</li>
<li>enforce 选项：true/false。为 true 时，忽略 minSize，minChunks，maxAsyncRequests 和 maxInitialRequests 外面选项</li>
</ul>
</li>
</ul>
<p>核心嘛，就是配置 <code>cacheGroups</code> 来根据自己的需求来分割打包代码块。</p>
<p>vuecli3 中 splitChunk 的默认配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">          <span class="attr">chunks</span>: <span class="string">&quot;async&quot;</span>,</span><br><span class="line">          <span class="attr">minSize</span>: <span class="number">30000</span>,</span><br><span class="line">          <span class="attr">maxSize</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">minChunks</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">maxAsyncRequests</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="attr">maxInitialRequests</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="attr">automaticNameDelimiter</span>: <span class="string">&quot;~&quot;</span>,</span><br><span class="line">          <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">            <span class="attr">vendors</span>: &#123;</span><br><span class="line">              <span class="attr">name</span>: <span class="string">`chunk-vendors`</span>,</span><br><span class="line">              <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">              <span class="attr">priority</span>: -<span class="number">10</span>,</span><br><span class="line">              <span class="attr">chunks</span>: <span class="string">&quot;initial&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">common</span>: &#123;</span><br><span class="line">              <span class="attr">name</span>: <span class="string">`chunk-common`</span>,</span><br><span class="line">              <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="attr">priority</span>: -<span class="number">20</span>,</span><br><span class="line">              <span class="attr">chunks</span>: <span class="string">&quot;initial&quot;</span>,</span><br><span class="line">              <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>贴一个自己项目的实验结果。</p>
<p>项目结构</p>
<p><img src="https://s3.ax1x.com/2020/12/16/rlszlt.png" alt="项目结构"></p>
<p>按照默认配置打包后的可视化解析图：</p>
<p><img src="https://s3.ax1x.com/2020/12/16/rlyQ7F.md.png" alt="before"></p>
<p>配置之后的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="attr">configureWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">      <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">        <span class="attr">chunks</span>: <span class="string">&quot;async&quot;</span>,</span><br><span class="line">        <span class="attr">minSize</span>: <span class="number">30000</span>,</span><br><span class="line">        <span class="attr">maxSize</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">minChunks</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">maxAsyncRequests</span>: <span class="number">6</span>,</span><br><span class="line">        <span class="attr">maxInitialRequests</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">automaticNameDelimiter</span>: <span class="string">&quot;~&quot;</span>,</span><br><span class="line">        <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">          <span class="attr">vendors</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;chunk-vendors&quot;</span>,</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">            <span class="attr">priority</span>: -<span class="number">10</span>,</span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">mixIn</span>: &#123;</span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;mixIn&quot;</span>,</span><br><span class="line">            <span class="attr">test</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./src/views/medicineType/typeMixin&quot;</span>),</span><br><span class="line">            <span class="attr">priority</span>: <span class="number">0</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>()],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配置之后打包完的可视化：</p>
<p><img src="https://s3.ax1x.com/2020/12/16/rly73n.md.png" alt="after"></p>
<p>可以看到变小了 20 多 K，并且把 mixin 给抽离出来单独打包了。</p>
<h3 id="2-2-DllPlugin-DllReferencePlugin"><a href="#2-2-DllPlugin-DllReferencePlugin" class="headerlink" title="2.2  DllPlugin   DllReferencePlugin"></a>2.2  <code>DllPlugin</code>   <code>DllReferencePlugin</code></h3><ul>
<li><code>DllPlugin</code> <code>DllReferencePlugin</code>  在使用webpack进行打包时候，对于依赖的第三方库，比如vue，axios，vuex等这些不会修改的依赖，我们可以让它和我们自己编写的代码分开打包，这样做的好处是每次更改我本地代码的文件的时候，webpack只需要打包我项目本身的文件代码，而不会再去编译第三方库，那么第三方库在第一次打包的时候只打包一次，以后只要我们不升级第三方包的时候，那么webpack就不会对这些库去打包，这样的可以快速的提高打包的速度。因此为了解决这个问题，DllPlugin 和 DllReferencePlugin插件就产生了。<ul>
<li><code>DllPlugin</code>  用来将dll抽离出来 </li>
<li><code>DllReferencePlugin</code>  用来告诉webpack这些东西我已经抽离出来啦，你打包时候不用打啦。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制台</span></span><br><span class="line">cnpm install webpack -g <span class="comment">// 安装webpack</span></span><br><span class="line">cnpm install webpack-cli -g <span class="comment">// 安装webpack-cli</span></span><br><span class="line">cnpm install -D clean-webpack-plugin <span class="comment">// 安装clean-webpack-plugin</span></span><br><span class="line"></span><br><span class="line">webpack -v <span class="comment">// 查看安装是否成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// issuser@ISS MINGW64 /d/work/gaokeappointment (Study-webpack)</span></span><br><span class="line"><span class="comment">// $ webpack -v</span></span><br><span class="line"><span class="comment">// webpack-cli 4.2.0</span></span><br><span class="line"><span class="comment">// webpack 5.11.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gaokeappointment&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve&quot;</span>,</span><br><span class="line">    <span class="string">&quot;serve:prod&quot;</span>: <span class="string">&quot;vue-cli-service serve --mode production&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build:dev&quot;</span>: <span class="string">&quot;vue-cli-service build --mode development&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;vue-cli-service lint&quot;</span>,</span><br><span class="line">    <span class="comment">// 新加这行</span></span><br><span class="line">    <span class="string">&quot;dll&quot;</span>: <span class="string">&quot;webpack --progress --config webpack.dll.config.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.dll.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dll文件存放的目录</span></span><br><span class="line"><span class="keyword">const</span> dllPath = <span class="string">&#x27;public/vendor&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="comment">// 需要提取的库文件</span></span><br><span class="line">    <span class="attr">vendor</span>: [<span class="string">&#x27;vue&#x27;</span>, <span class="string">&#x27;vue-router&#x27;</span>, <span class="string">&#x27;vuex&#x27;</span>, <span class="string">&#x27;axios&#x27;</span>],</span><br><span class="line">    <span class="attr">vant</span>: [<span class="string">&#x27;vant&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, dllPath),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].dll.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// vendor.dll.js中暴露出的全局变量名</span></span><br><span class="line">    <span class="comment">// 保持与 webpack.DllPlugin 中名称一致</span></span><br><span class="line">    <span class="attr">library</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 清除之前的dll文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(),</span><br><span class="line">    <span class="comment">// 设置环境变量</span></span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">      <span class="string">&#x27;process.env&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">NODE_ENV</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// manifest.json 描述动态链接库包含了哪些内容</span></span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, dllPath, <span class="string">&#x27;[name]-manifest.json&#x27;</span>),</span><br><span class="line">      <span class="comment">// 保持与 output.library 中名称一致</span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span>,</span><br><span class="line">      <span class="attr">context</span>: process.<span class="title function_">cwd</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> isDev = process.<span class="property">env</span>.<span class="property">VUE_APP_ENV</span> === <span class="string">&#x27;development&#x27;</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SpeedMeasurePlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;speed-measure-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> <span class="title class_">SpeedMeasurePlugin</span>()</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BundleAnalyzerPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).<span class="property">BundleAnalyzerPlugin</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 生成模式使用cdn打包路径根据需要修改</span></span><br><span class="line">  <span class="comment">// &#x27;https://f.taikang.com/static/&#x27;</span></span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">  <span class="attr">productionSourceMap</span>: isDev,</span><br><span class="line">  <span class="attr">pages</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="attr">configureWebpack</span>: smp.<span class="title function_">wrap</span>(&#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>(),</span><br><span class="line">      <span class="comment">// 配置DllReferencePlugin</span></span><br><span class="line">      <span class="keyword">new</span> webpack.<span class="title class_">DllReferencePlugin</span>(&#123;</span><br><span class="line">        <span class="attr">context</span>: process.<span class="title function_">cwd</span>(),</span><br><span class="line">        <span class="attr">manifest</span>: <span class="built_in">require</span>(<span class="string">&#x27;./public/vendor/vant-manifest.json&#x27;</span>)</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> webpack.<span class="title class_">DllReferencePlugin</span>(&#123;</span><br><span class="line">        <span class="attr">context</span>: process.<span class="title function_">cwd</span>(),</span><br><span class="line">        <span class="attr">manifest</span>: <span class="built_in">require</span>(<span class="string">&#x27;./public/vendor/vendor-manifest.json&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;https://sspuat.taikang.com&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后打包dll</span></span><br><span class="line">npm run dll</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vendor/vendor.dll.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vendor/vant.dll.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后就可以打包啦</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>Before</p>
<p><img src="https://s3.ax1x.com/2020/12/25/rRteDP.png" alt="before"></p>
<p>After 可以看到变小了200kb左右，<code>vant</code> 等组件被抽离出来了</p>
<p><img src="https://s3.ax1x.com/2020/12/25/rRtB8J.png" alt="After"></p>
<p>时间变化：</p>
<table>
<thead>
<tr>
<th align="center">Before</th>
<th align="center">After</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SMP  ⏱<br/>General output time took 8.35 secs</td>
<td align="center">SMP  ⏱<br/>General output time took 7.75 secs</td>
</tr>
<tr>
<td align="center">SMP  ⏱<br/>General output time took 8.55 secs</td>
<td align="center">SMP  ⏱<br/>General output time took 7.79 secs</td>
</tr>
<tr>
<td align="center">SMP  ⏱<br/>General output time took 8.33 secs</td>
<td align="center">SMP  ⏱<br/>General output time took 7.78 secs</td>
</tr>
</tbody></table>
<h3 id="3-压缩"><a href="#3-压缩" class="headerlink" title="3.压缩"></a>3.压缩</h3><p>uglifyjs-webpack-plugin 传统老牌的压缩插件，缺点是不支持 es6。</p>
<p>terser-webpack-plugin 推荐使用，可以删除console等冗余的代码。</p>
<p>vue-cli3下 terser-webpack-plugin配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isDev = process.<span class="property">env</span>.<span class="property">VUE_APP_ENV</span> === <span class="string">&#x27;development&#x27;</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">  <span class="attr">pages</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDev) <span class="keyword">return</span></span><br><span class="line">    config.<span class="property">optimization</span>.<span class="title function_">minimizer</span>(<span class="string">&#x27;terser&#x27;</span>).<span class="title function_">tap</span>(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">assign</span>(args[<span class="number">0</span>].<span class="property">terserOptions</span>.<span class="property">compress</span>, &#123;</span><br><span class="line">        <span class="comment">// pro mode drop console.log,but console.info or console.error will exist</span></span><br><span class="line">        <span class="attr">pure_funcs</span>: [<span class="string">&#x27;console.log&#x27;</span>]</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> args</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">configureWebpack</span>: smp.<span class="title function_">wrap</span>(&#123;</span><br><span class="line">    <span class="attr">plugins</span>: []</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">devServer</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始撸vue项目</title>
    <url>/2020/12/30/20201230-vue/</url>
    <content><![CDATA[<p>webpack优化相关知识记录。</p>
<p>工作需求，要开一个新项目，想想去年菜鸡的自己搭的臃肿的项目，今年做的项目大多都是二手的，所以记录一下从0搭建vue项目过程中的思考。</p>
<span id="more"></span>

<p>第一步搭建项目 <code>winpty vue.cmd create template</code> (插一句 感觉vue-cli的脚手架还挺好用的，选择自己配置很多东西都不用自己思考了，按着提示来就行)</p>
<p>搭建完成后是以下的目录结构<sup>①</sup>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">│  .<span class="property">browserslistrc</span></span><br><span class="line">│  .<span class="property">eslintrc</span>.<span class="property">js</span></span><br><span class="line">│  .<span class="property">gitignore</span></span><br><span class="line">│  babel.<span class="property">config</span>.<span class="property">js</span></span><br><span class="line">│  list.<span class="property">txt</span></span><br><span class="line">│  package.<span class="property">json</span></span><br><span class="line">│  <span class="variable constant_">README</span>.<span class="property">md</span></span><br><span class="line">│  yarn.<span class="property">lock</span></span><br><span class="line">│  </span><br><span class="line">├─node_modules</span><br><span class="line">├─public</span><br><span class="line">│      favicon.<span class="property">ico</span></span><br><span class="line">│      index.<span class="property">html</span></span><br><span class="line">│      </span><br><span class="line">└─src</span><br><span class="line">    │  <span class="title class_">App</span>.<span class="property">vue</span></span><br><span class="line">    │  main.<span class="property">js</span></span><br><span class="line">    │  </span><br><span class="line">    ├─assets</span><br><span class="line">    │      logo.<span class="property">png</span></span><br><span class="line">    │      </span><br><span class="line">    ├─components</span><br><span class="line">    │      <span class="title class_">HelloWorld</span>.<span class="property">vue</span></span><br><span class="line">    │      </span><br><span class="line">    ├─router</span><br><span class="line">    │      index.<span class="property">js</span></span><br><span class="line">    │      </span><br><span class="line">    ├─store</span><br><span class="line">    │      index.<span class="property">js</span></span><br><span class="line">    │      </span><br><span class="line">    └─views</span><br><span class="line">            <span class="title class_">About</span>.<span class="property">vue</span></span><br><span class="line">            <span class="title class_">Home</span>.<span class="property">vue</span></span><br></pre></td></tr></table></figure>

<p>项目搞出来了之后，就开始拧螺丝啦。先附上一张图，全览一下目前我的菜鸡水平想到应该做的事情，然后再一个一个说。</p>
<p><img src="https://s3.ax1x.com/2020/12/30/rLsCMF.png" alt="mind"></p>
<h3 id="1-规范"><a href="#1-规范" class="headerlink" title="1.规范"></a>1.规范</h3><p>最重要的，规范，多人协作ReadMe一定要写好，开发每个版本的时间，参与人，测试/生产服务器路径等。</p>
<p>eslint就不多bb啦。</p>
<h3 id="2-样式"><a href="#2-样式" class="headerlink" title="2.样式"></a>2.样式</h3><h4 id="2-1-scss（预处理语言）"><a href="#2-1-scss（预处理语言）" class="headerlink" title="2.1 scss（预处理语言）"></a>2.1 scss（预处理语言）</h4><p>scss在搭建项目时vue-cli就给搞定了，okk。</p>
<h4 id="2-2-reset-css（初始化公共样式）"><a href="#2-2-reset-css（初始化公共样式）" class="headerlink" title="2.2 reset.css（初始化公共样式）"></a>2.2 reset.css（初始化公共样式）</h4><p>一般来说各个公司应该有自己的初始化css cdn，在index.html中引入就好。</p>
<p>附上一份自己在用的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  -webkit-touch-<span class="attr">callout</span>: none;</span><br><span class="line">  -webkit-user-<span class="attr">select</span>: none;</span><br><span class="line">  -khtml-user-<span class="attr">select</span>: none;</span><br><span class="line">  -moz-user-<span class="attr">select</span>: none;</span><br><span class="line">  -ms-user-<span class="attr">select</span>: none;</span><br><span class="line">  user-<span class="attr">select</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body,</span><br><span class="line">div,</span><br><span class="line">dl,</span><br><span class="line">dt,</span><br><span class="line">dd,</span><br><span class="line">ul,</span><br><span class="line">ol,</span><br><span class="line">li,</span><br><span class="line">h1,</span><br><span class="line">h2,</span><br><span class="line">h3,</span><br><span class="line">h4,</span><br><span class="line">h5,</span><br><span class="line">h6,</span><br><span class="line">pre,</span><br><span class="line">code,</span><br><span class="line">form,</span><br><span class="line">fieldset,</span><br><span class="line">legend,</span><br><span class="line">input,</span><br><span class="line">textarea,</span><br><span class="line">p,</span><br><span class="line">blockquote,</span><br><span class="line">th,</span><br><span class="line">td,</span><br><span class="line">hr,</span><br><span class="line">button,</span><br><span class="line">article,</span><br><span class="line">aside,</span><br><span class="line">details,</span><br><span class="line">figcaption,</span><br><span class="line">figure,</span><br><span class="line">footer,</span><br><span class="line">header,</span><br><span class="line">hgroup,</span><br><span class="line">menu,</span><br><span class="line">nav,</span><br><span class="line">section &#123;</span><br><span class="line">  <span class="attr">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attr">padding</span>: <span class="number">0</span>;</span><br><span class="line">  -webkit-tap-highlight-<span class="attr">color</span>: <span class="title function_">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  box-<span class="attr">sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">article,</span><br><span class="line">aside,</span><br><span class="line">details,</span><br><span class="line">figcaption,</span><br><span class="line">figure,</span><br><span class="line">footer,</span><br><span class="line">header,</span><br><span class="line">hgroup,</span><br><span class="line">menu,</span><br><span class="line">nav,</span><br><span class="line">section &#123;</span><br><span class="line">  <span class="attr">display</span>: block;</span><br><span class="line">  -webkit-tap-highlight-<span class="attr">color</span>: <span class="title function_">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">audio,</span><br><span class="line">canvas,</span><br><span class="line">video &#123;</span><br><span class="line">  <span class="attr">display</span>: inline-block;</span><br><span class="line">  *<span class="attr">display</span>: inline;</span><br><span class="line">  *<span class="attr">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table &#123;</span><br><span class="line">  border-<span class="attr">collapse</span>: collapse;</span><br><span class="line">  border-<span class="attr">spacing</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">th &#123;</span><br><span class="line">  text-<span class="attr">align</span>: inherit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fieldset,</span><br><span class="line">img &#123;</span><br><span class="line">  <span class="attr">border</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iframe &#123;</span><br><span class="line">  <span class="attr">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abbr,</span><br><span class="line">acronym &#123;</span><br><span class="line">  <span class="attr">border</span>: <span class="number">0</span>;</span><br><span class="line">  font-<span class="attr">variant</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">del &#123;</span><br><span class="line">  text-<span class="attr">decoration</span>: line-through;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">address,</span><br><span class="line">caption,</span><br><span class="line">cite,</span><br><span class="line">code,</span><br><span class="line">dfn,</span><br><span class="line">em,</span><br><span class="line">th,</span><br><span class="line"><span class="keyword">var</span>,</span><br><span class="line">i,</span><br><span class="line">b &#123;</span><br><span class="line">  font-<span class="attr">style</span>: normal;</span><br><span class="line">  font-<span class="attr">weight</span>: <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ol,</span><br><span class="line">ul &#123;</span><br><span class="line">  list-<span class="attr">style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1,</span><br><span class="line">h2,</span><br><span class="line">h3,</span><br><span class="line">h4,</span><br><span class="line">h5,</span><br><span class="line">h6,</span><br><span class="line">b &#123;</span><br><span class="line">  font-<span class="attr">size</span>: inherit;</span><br><span class="line">  font-<span class="attr">weight</span>: <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">q</span>:before,</span><br><span class="line"><span class="attr">q</span>:after &#123;</span><br><span class="line">  <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">a</span>:visited,</span><br><span class="line"><span class="attr">a</span>:hover &#123;</span><br><span class="line">  <span class="attr">color</span>: #<span class="number">000</span>;</span><br><span class="line">  text-<span class="attr">decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html &#123;</span><br><span class="line">  <span class="attr">height</span>: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  min-<span class="attr">height</span>: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input,</span><br><span class="line">select,</span><br><span class="line">textarea &#123;</span><br><span class="line">  font-<span class="attr">size</span>: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ins,</span><br><span class="line">a &#123;</span><br><span class="line">  text-<span class="attr">decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a，input,</span><br><span class="line">textarea &#123;</span><br><span class="line">  <span class="attr">color</span>: #<span class="number">000</span>;</span><br><span class="line">  -webkit-tap-highlight-<span class="attr">color</span>: <span class="title function_">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">input[type=<span class="string">&#x27;button&#x27;</span>],</span><br><span class="line">input[type=<span class="string">&#x27;submit&#x27;</span>],</span><br><span class="line">input[type=<span class="string">&#x27;reset&#x27;</span>] &#123;</span><br><span class="line">  -webkit-<span class="attr">appearance</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">input &#123;</span><br><span class="line">  <span class="attr">background</span>: no-repeat <span class="number">0</span> <span class="number">0</span> scroll #eeeeee;</span><br><span class="line">  <span class="attr">border</span>: none;</span><br><span class="line">  <span class="attr">outline</span>: medium; <span class="comment">/* 在浏览器下面，点击input输入时，会有边框，只要在样式中应用：outline:medium;即可去掉边框。 */</span></span><br><span class="line">  <span class="attr">padding</span>: <span class="number">0</span>; <span class="comment">/*input默认有上下padding*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 隐藏滚动条 */</span></span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">input</span>:<span class="title function_">not</span>([type=<span class="string">&#x27;checkbox&#x27;</span>]),</span><br><span class="line">select,</span><br><span class="line">textarea &#123;</span><br><span class="line">  <span class="attr">outline</span>: none;</span><br><span class="line">  <span class="attr">border</span>: none;</span><br><span class="line">  -webkit-<span class="attr">appearance</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-全局公共样式"><a href="#2-3-全局公共样式" class="headerlink" title="2.3 全局公共样式"></a>2.3 全局公共样式</h4><p>根据项目需求，将重复性较强的样式抽离出来，单独封装。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">html,</span><br><span class="line">body,</span><br><span class="line">#app &#123;</span><br><span class="line">  <span class="attr">height</span>: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 颜色变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 行为相关颜色 */</span></span><br><span class="line">$color-<span class="attr">primary</span>: #fc5830; <span class="comment">// app主题色</span></span><br><span class="line">$color-<span class="attr">success</span>: #4cd964;</span><br><span class="line">$color-<span class="attr">warning</span>: #f0ad4e;</span><br><span class="line">$color-<span class="attr">error</span>: #dd524d;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文字基本颜色 */</span></span><br><span class="line">$text-<span class="attr">color</span>: #<span class="number">333</span>; <span class="comment">//基本色</span></span><br><span class="line">$text-color-<span class="attr">inverse</span>: #fff; <span class="comment">//反色</span></span><br><span class="line">$text-color-<span class="attr">gray</span>: #<span class="number">999</span>; <span class="comment">//辅助灰色，如加载更多的提示信息</span></span><br><span class="line">$text-color-<span class="attr">placeholder</span>: #<span class="number">999</span>;</span><br><span class="line">$text-color-<span class="attr">disable</span>: #c0c0c0;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 背景颜色 */</span></span><br><span class="line">$bg-<span class="attr">color</span>: #ffffff;</span><br><span class="line">$bg-color-<span class="attr">gray</span>: #f8f8f8;</span><br><span class="line">$bg-color-<span class="attr">hover</span>: #f1f1f1; <span class="comment">//点击状态颜色</span></span><br><span class="line">$bg-color-<span class="attr">disable</span>: #e0e0e0; <span class="comment">//点击状态颜色</span></span><br><span class="line">$bg-color-<span class="attr">mask</span>: <span class="title function_">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.4</span>); <span class="comment">//遮罩颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 边框颜色 */</span></span><br><span class="line">$border-<span class="attr">color</span>: #<span class="variable constant_">F7F7F7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Border Radius */</span></span><br><span class="line">$border-radius-<span class="attr">sm</span>: 4px;</span><br><span class="line">$border-radius-<span class="attr">base</span>: 6px;</span><br><span class="line">$border-radius-<span class="attr">lg</span>: 12px;</span><br><span class="line">$border-radius-<span class="attr">circle</span>: <span class="number">50</span>%;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文字尺寸 */</span></span><br><span class="line">$font-size-<span class="attr">sm</span>: 24px;</span><br><span class="line">$font-size-<span class="attr">base</span>: 30px;</span><br><span class="line">$font-size-<span class="attr">lg</span>: 34px;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-px2rem"><a href="#2-3-px2rem" class="headerlink" title="2.3 px2rem"></a>2.3 px2rem</h4><p>一般来说美工给的切图都是宽度750px，为了保持页面在各个设备的适应性，就需要用到px2rem，这样在写的时候就可以直接写px啦。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// postcss.config.js</span></span><br><span class="line"><span class="keyword">const</span> pxtorem = <span class="built_in">require</span>(<span class="string">&quot;postcss-pxtorem&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">&#123; file &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> rootValue;</span><br><span class="line">  <span class="keyword">if</span> (file &amp;&amp; file.<span class="property">dirname</span> &amp;&amp; file.<span class="property">dirname</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;vant&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    rootValue = <span class="number">20</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rootValue = <span class="number">40</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="title function_">pxtorem</span>(&#123;</span><br><span class="line">        <span class="attr">rootValue</span>: rootValue,</span><br><span class="line">        <span class="attr">propList</span>: [<span class="string">&quot;*&quot;</span>],</span><br><span class="line">        <span class="attr">minPixelValue</span>: <span class="number">2</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h3><h4 id="3-1-util-js-公共方法"><a href="#3-1-util-js-公共方法" class="headerlink" title="3.1 util.js 公共方法"></a>3.1 util.js 公共方法</h4><p>目的为将常用的方法单独封装（比如动态根据设备改变base font size的方法等等）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getSize</span> () &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reSize</span> () &#123; <span class="comment">// 获取屏幕的宽度</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getWdith</span> () &#123;</span><br><span class="line">      <span class="keyword">let</span> myWidth = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> (<span class="variable language_">window</span>.<span class="property">innerWidth</span>) === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// Non-IE</span></span><br><span class="line">        myWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">documentElement</span> &amp;&amp; (<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>)) &#123;</span><br><span class="line">        <span class="comment">// IE 6+ in &#x27;standards compliant mode&#x27;</span></span><br><span class="line">        myWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span> &amp;&amp; (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>)) &#123;</span><br><span class="line">        <span class="comment">// IE 4 compatible</span></span><br><span class="line">        myWidth = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">parseInt</span>(myWidth)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> screenWidth = screen.<span class="property">width</span> &gt; <span class="title function_">getWdith</span>() ? <span class="title function_">getWdith</span>() : screen.<span class="property">width</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (screenWidth &gt;= <span class="number">414</span>) &#123;</span><br><span class="line">      screenWidth = <span class="number">414</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span> = screenWidth / (<span class="number">750</span> / <span class="number">40</span>) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reSize</span>()</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reSize</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue获取地址栏参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getRequest</span> (name) &#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;(^|&amp;)&#x27;</span> + name + <span class="string">&#x27;=([^&amp;]*)(&amp;|$)&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> num = +<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> r = !<span class="regexp">/param/</span>.<span class="title function_">test</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>) ? <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">substr</span>(<span class="number">1</span>).<span class="title function_">match</span>(reg) : <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>.<span class="title function_">substr</span>(num).<span class="title function_">match</span>(reg)</span><br><span class="line">  <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">decodeURI</span>(r[<span class="number">2</span>])</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断平台</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isPlatform</span> (str) &#123;</span><br><span class="line">  <span class="comment">// 判断安卓还是ios终端</span></span><br><span class="line">  <span class="keyword">const</span> u = navigator.<span class="property">userAgent</span></span><br><span class="line">  <span class="keyword">const</span> browser = &#123;</span><br><span class="line">    <span class="attr">versions</span>: (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// let app = navigator.appVersion</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">ios</span>: !!u.<span class="title function_">match</span>(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>), <span class="comment">// ios终端</span></span><br><span class="line">        <span class="attr">android</span>: u.<span class="title function_">indexOf</span>(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.<span class="title function_">indexOf</span>(<span class="string">&#x27;Adr&#x27;</span>) &gt; -<span class="number">1</span> <span class="comment">// android终端</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;())</span><br><span class="line">  &#125;</span><br><span class="line">  str = str.<span class="title function_">toLowerCase</span>()</span><br><span class="line">  <span class="keyword">if</span> (browser.<span class="property">versions</span>.<span class="property">ios</span> &amp;&amp; str === <span class="string">&#x27;ios&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (browser.<span class="property">versions</span>.<span class="property">android</span> &amp;&amp; str === <span class="string">&#x27;android&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((u.<span class="title function_">match</span>(<span class="regexp">/MicroMessenger/i</span>) &amp;&amp; u.<span class="title function_">match</span>(<span class="regexp">/MicroMessenger/i</span>)[<span class="number">0</span>].<span class="title function_">toLowerCase</span>()) === <span class="string">&#x27;MicroMessenger&#x27;</span>.<span class="title function_">toLowerCase</span>() &amp;&amp; str === <span class="string">&#x27;micromessenger&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((u.<span class="title function_">match</span>(<span class="regexp">/isales/i</span>) &amp;&amp; u.<span class="title function_">match</span>(<span class="regexp">/isales/i</span>)[<span class="number">0</span>].<span class="title function_">toLowerCase</span>()) === <span class="string">&#x27;isales&#x27;</span>.<span class="title function_">toLowerCase</span>() &amp;&amp; str === <span class="string">&#x27;isales&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 强制在微信端打开</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">wxTest</span> (fn) &#123;</span><br><span class="line">  <span class="comment">// 对浏览器的UserAgent进行正则匹配，不含有微信独有标识的则为其他浏览器</span></span><br><span class="line">  <span class="keyword">var</span> useragent = navigator.<span class="property">userAgent</span></span><br><span class="line">  <span class="keyword">if</span> ((useragent.<span class="title function_">match</span>(<span class="regexp">/MicroMessenger/i</span>) &amp;&amp; useragent.<span class="title function_">match</span>(<span class="regexp">/MicroMessenger/i</span>)[<span class="number">0</span>].<span class="title function_">toLowerCase</span>()) !== <span class="string">&#x27;MicroMessenger&#x27;</span>.<span class="title function_">toLowerCase</span>()) &#123;</span><br><span class="line">    <span class="comment">// 这里警告框会阻塞当前页面继续加载</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&#x27;已禁止本次访问：您必须使用微信内置浏览器访问本页面！&#x27;</span>)</span><br><span class="line">    <span class="comment">// 以下代码是用javascript强行关闭当前页面</span></span><br><span class="line">    <span class="keyword">var</span> opened = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;about:blank&#x27;</span>, <span class="string">&#x27;_self&#x27;</span>)</span><br><span class="line">    opened.<span class="property">opener</span> = <span class="literal">null</span></span><br><span class="line">    opened.<span class="title function_">close</span>()</span><br><span class="line">    <span class="comment">// typeof fn == &#x27;function&#x27; &amp;&amp; fn();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 隐藏微信分享等功能</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">hideWxMenu</span> () &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">onBridgeReady</span> () &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">WeixinJSBridge</span>.<span class="title function_">call</span>(<span class="string">&#x27;hideOptionMenu&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">WeixinJSBridge</span> === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;WeixinJSBridgeReady&#x27;</span>, onBridgeReady, <span class="literal">false</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">attachEvent</span>(<span class="string">&#x27;WeixinJSBridgeReady&#x27;</span>, onBridgeReady)</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">attachEvent</span>(<span class="string">&#x27;onWeixinJSBridgeReady&#x27;</span>, onBridgeReady)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">onBridgeReady</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">base64</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">decode</span>: <span class="variable language_">window</span>.<span class="property">atob</span>.<span class="title function_">bind</span>(<span class="variable language_">window</span>),</span><br><span class="line">    <span class="attr">encode</span>: <span class="variable language_">window</span>.<span class="property">btoa</span>.<span class="title function_">bind</span>(<span class="variable language_">window</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">usfBase64</span> (buffer) &#123;</span><br><span class="line">  <span class="keyword">return</span> buffer</span><br><span class="line">    .<span class="title function_">toString</span>(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/\+/g</span>, <span class="string">&#x27;-&#x27;</span>) <span class="comment">// Convert &#x27;+&#x27; to &#x27;-&#x27;</span></span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/\//g</span>, <span class="string">&#x27;_&#x27;</span>) <span class="comment">// Convert &#x27;/&#x27; to &#x27;_&#x27;</span></span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/=+$/</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Remove ending &#x27;=&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">urlsafeB64decode</span> ($string, base64) &#123;</span><br><span class="line">  <span class="keyword">var</span> $data = $string.<span class="title function_">replace</span>(<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;+&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> $mod4 = ($data).<span class="property">length</span> % <span class="number">4</span></span><br><span class="line">  <span class="keyword">if</span> ($mod4) &#123;</span><br><span class="line">    $data += <span class="string">&#x27;====&#x27;</span>.<span class="title function_">substr</span>($mod4)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> base64 ? base64.<span class="title function_">decode</span>($data) : <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// once 函数，只执行一次</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">once</span> (fn, context) &#123;</span><br><span class="line">  <span class="keyword">let</span> res</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fn) &#123;</span><br><span class="line">      res = fn.<span class="title function_">apply</span>(context || <span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">      fn = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 防止抖动</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">debounce</span> (fn, wait, immediate) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">const</span> immediates = immediate || <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span></span><br><span class="line">    <span class="keyword">const</span> later = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      timeout = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">if</span> (!immediates) fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> call = immediates &amp;&amp; !timeout</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">    <span class="keyword">if</span> (call) <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(later, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止抖动less版</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">debounceLess</span> (fn, wait) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止重复执行</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">throttle</span> (fn, wait) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="keyword">return</span></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">      timeout = <span class="literal">null</span></span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">copymsg</span> (el, fn) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">Url2</span> = el<span class="comment">// 要复制文字的节点</span></span><br><span class="line">  <span class="comment">// if (navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) &#123; // 区分iPhone设备</span></span><br><span class="line">  <span class="comment">//   window.getSelection().removeAllRanges()// 这段代码必须放在前面否则无效</span></span><br><span class="line">  <span class="comment">//   var range = document.createRange()</span></span><br><span class="line">  <span class="comment">//   // 选中需要复制的节点</span></span><br><span class="line">  <span class="comment">//   range.selectNode(Url2)</span></span><br><span class="line">  <span class="comment">//   // 执行选中元素</span></span><br><span class="line">  <span class="comment">//   window.getSelection().addRange(range)</span></span><br><span class="line">  <span class="comment">//   // 执行 copy 操作</span></span><br><span class="line">  <span class="comment">//   var successful = document.execCommand(&#x27;copy&#x27;)</span></span><br><span class="line">  <span class="comment">//   console.log(successful)</span></span><br><span class="line">  <span class="comment">//   // 移除选中的元素</span></span><br><span class="line">  <span class="comment">//   window.getSelection().removeAllRanges()</span></span><br><span class="line">  <span class="comment">// &#125; else &#123;</span></span><br><span class="line">  <span class="title class_">Url2</span>.<span class="title function_">select</span>() <span class="comment">// 选择对象</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;Copy&#x27;</span>) <span class="comment">// 执行浏览器复制命令</span></span><br><span class="line">  <span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title function_">fn</span>()</span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getTypeof</span> (param) &#123;</span><br><span class="line">  <span class="keyword">const</span> dictionary = &#123;</span><br><span class="line">    <span class="string">&#x27;[object Object]&#x27;</span>: <span class="string">&#x27;Object&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Array]&#x27;</span>: <span class="string">&#x27;Array&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Function]&#x27;</span>: <span class="string">&#x27;Function&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object RegExp]&#x27;</span>: <span class="string">&#x27;RegExp&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Null]&#x27;</span>: <span class="string">&#x27;Null&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Undefined]&#x27;</span>: <span class="string">&#x27;Undefined&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Boolean]&#x27;</span>: <span class="string">&#x27;Boolean&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Symbool]&#x27;</span>: <span class="string">&#x27;Symbool&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object String]&#x27;</span>: <span class="string">&#x27;String&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Number]&#x27;</span>: <span class="string">&#x27;Number&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Map]&#x27;</span>: <span class="string">&#x27;Map&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object WeakMap]&#x27;</span>: <span class="string">&#x27;WeakMap&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Set]&#x27;</span>: <span class="string">&#x27;Set&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object WeakSet]&#x27;</span>: <span class="string">&#x27;WeakSet&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dictionary[<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(param)] || <span class="string">&#x27;unknow&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取当月首末日</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Date</span>&#125; <span class="variable">date</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">&#123;firstDate: Number,lastDate: Number</span>&#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getFirstLastDateOfMonth</span> (date) &#123;</span><br><span class="line">  <span class="keyword">let</span> fd = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> ld = <span class="number">31</span></span><br><span class="line">  <span class="keyword">const</span> nextMonthDate = date</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    date.<span class="title function_">setDate</span>(<span class="number">1</span>)</span><br><span class="line">    fd = date.<span class="title function_">getDate</span>()</span><br><span class="line">    ld = <span class="keyword">new</span> <span class="title class_">Date</span>(nextMonthDate.<span class="title function_">getFullYear</span>(), nextMonthDate.<span class="title function_">getMonth</span>() + <span class="number">1</span>, <span class="number">0</span>).<span class="title function_">getDate</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">firstDate</span>: fd,</span><br><span class="line">    <span class="attr">lastDate</span>: ld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sessionStorage 操作</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> session = &#123;</span><br><span class="line">  get (key) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">getItem</span>(key)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(value)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  set (key, value) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = value</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span>) val = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value)</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">setItem</span>(key, val)</span><br><span class="line">  &#125;,</span><br><span class="line">  del (key) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">removeItem</span>(key)</span><br><span class="line">  &#125;,</span><br><span class="line">  clear () &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">clear</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">deepClone</span> (targetObj) &#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(targetObj)</span><br><span class="line">  <span class="keyword">let</span> newObj</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class="line">    newObj = &#123;&#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;[object Array]&#x27;</span>) &#123;</span><br><span class="line">    newObj = []</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> targetObj</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> targetObj) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = targetObj[key]</span><br><span class="line">    newObj[key] = <span class="title function_">deepClone</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-封装axios"><a href="#3-2-封装axios" class="headerlink" title="3.2 封装axios"></a>3.2 封装axios</h4><p>目的是将请求封装，默认在header中携带token等信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getSign, isPlatform &#125; <span class="keyword">from</span> <span class="string">&quot;@/assets/js/ISALES&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Toast</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vant&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;@/store&quot;</span>;</span><br><span class="line"><span class="comment">// import url from &#x27;@/api/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> service = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="comment">// timeout: 15000 // request timeout</span></span><br><span class="line">&#125;);</span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">async</span> config =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(config);</span><br><span class="line">      store.<span class="property">state</span>.<span class="property">isLoading</span> = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isPlatform</span>(<span class="string">&quot;isales&quot;</span>)) &#123;</span><br><span class="line">        config.<span class="property">headers</span>.<span class="property">token</span> = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (config.<span class="property">method</span> === <span class="string">&quot;get&quot;</span>) &#123;</span><br><span class="line">          config.<span class="property">headers</span>.<span class="property">txxSign</span> = <span class="keyword">await</span> <span class="title function_">getSign</span>(config.<span class="property">params</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          config.<span class="property">headers</span>.<span class="property">txxSign</span> = <span class="keyword">await</span> <span class="title function_">getSign</span>(config.<span class="property">data</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;config.data&quot;</span>, config);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      store.<span class="property">state</span>.<span class="property">isLoading</span> = <span class="literal">false</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err, <span class="string">&quot;request请求异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// response interceptor</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    store.<span class="property">state</span>.<span class="property">isLoading</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> res = response.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">rspCode</span> === <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title class_">Toast</span>.<span class="title function_">fail</span>(res.<span class="property">rspDesc</span> || <span class="string">&quot;请求失败，请稍后重试！&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    store.<span class="property">state</span>.<span class="property">isLoading</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="title class_">Toast</span>.<span class="title function_">fail</span>(error.<span class="property">rspDesc</span> || <span class="string">&quot;网络异常，请稍后重试！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service;</span><br></pre></td></tr></table></figure>

<h3 id="4-组件"><a href="#4-组件" class="headerlink" title="4.组件"></a>4.组件</h3><h4 id="4-1UI框架"><a href="#4-1UI框架" class="headerlink" title="4.1UI框架"></a>4.1UI框架</h4><p>根据项目需求引入UI框架。</p>
<h4 id="4-2-布局组件"><a href="#4-2-布局组件" class="headerlink" title="4.2 布局组件"></a>4.2 布局组件</h4><p>根据需求添加header、footer、sidebar等组件。</p>
<h4 id="4-3-公共组件"><a href="#4-3-公共组件" class="headerlink" title="4.3 公共组件"></a>4.3 公共组件</h4><p>将可能重复使用的公共组件单独抽离出来封装。</p>
<h4 id="4-4-展示组件"><a href="#4-4-展示组件" class="headerlink" title="4.4 展示组件"></a>4.4 展示组件</h4><p>将所有页面放在一个文件夹中封装成页面组件。</p>
<h3 id="5-打包"><a href="#5-打包" class="headerlink" title="5.打包"></a>5.打包</h3><p>webpack打包相关的优化有单独的文章，在这里不再赘述。</p>
<p>1.windows 终端命令 <code>tree /f &gt; list.txt</code> 可以直接生成当前文件夹的目录结构。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>工作相关记录2</title>
    <url>/2021/01/19/20210119-work2/</url>
    <content><![CDATA[<p>此篇博客用来记录工作中遇到的的问题以及解决方案。</p>
<span id="more"></span>

<h3 id="20-模块化"><a href="#20-模块化" class="headerlink" title="20.模块化"></a>20.模块化</h3><p><a href="https://www.cnblogs.com/fayin/p/6831071.html">module.exports 与 exports，export 与 export default 之间的关系和区别</a></p>
<p>首先我们要明白一个前提，CommonJS 模块规范和 ES6 模块规范完全是两种不同的概念。</p>
<p>CommonJS 模块规范</p>
<p>Node 应用由模块组成，采用 CommonJS 模块规范。</p>
<p>根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>
<p>CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。</p>
<pre><code>var x = 5;
var addX = function (value) &#123;
  return value + x;
&#125;;
module.exports.x = x;
module.exports.addX = addX;
</code></pre>
<p>上面代码通过 module.exports 输出变量 x 和函数 addX。</p>
<p>require 方法用于加载模块。</p>
<pre><code>var example = require(&#39;./example.js&#39;);

console.log(example.x); // 5
console.log(example.addX(1)); // 6
</code></pre>
<p>exports 与 module.exports</p>
<p>优先使用 module.exports</p>
<p>为了方便，Node 为每个模块提供一个 exports 变量，指向 module.exports。这等同在每个模块头部，有一行这样的命令。</p>
<pre><code>var exports = module.exports;
</code></pre>
<p>于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在 module.exports 上添加一样。</p>
<p>注意，因为 Node 模块是通过 module.exports 导出的，如果直接将 exports 变量指向一个值，就切断了 exports 与 module.exports 的联系，导致意外发生：</p>
<pre><code>// a.js
exports = function a() &#123;&#125;;

// b.js
const a = require(&#39;./a.js&#39;) // a 是一个空对象
</code></pre>
<p>参考 the-difference-between-module-exports-and-exports</p>
<p>ES6 模块规范</p>
<p>不同于 CommonJS，ES6 使用 export 和 import 来导出、导入模块。</p>
<pre><code>// profile.js
var firstName = &#39;Michael&#39;;
var lastName = &#39;Jackson&#39;;
var year = 1958;

export &#123;firstName, lastName, year&#125;;
</code></pre>
<p>需要特别注意的是，export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>
<pre><code>// 写法一
export var m = 1;

// 写法二
var m = 1;
export &#123;m&#125;;

// 写法三
var n = 1;
export &#123;n as m&#125;;
</code></pre>
<p>export default 命令</p>
<p>使用 export default 命令，为模块指定默认输出。</p>
<pre><code>// export-default.js
export default function () &#123;
  console.log(&#39;foo&#39;);
&#125;
</code></pre>
<p>相关链接：<br>CommonJS 规范，<a href="http://javascript.ruanyifeng.com/nodejs/module.html">http://javascript.ruanyifeng.com/nodejs/module.html</a><br>ES6 Module 的语法，<a href="http://es6.ruanyifeng.com/#docs/module">http://es6.ruanyifeng.com/#docs/module</a></p>
<h3 id="21-Vue-set"><a href="#21-Vue-set" class="headerlink" title="21.Vue.set"></a>21.Vue.set</h3><p>在我们项目开发过程中，实例中的数据类型可以是对象、数组等。在对象中，某个属性值发生更改时，我们可以通过对象的深度监听，以达到重新渲染页面的需求。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">objVal</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;obj&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">      <span class="attr">objVal</span>:&#123;</span><br><span class="line">        <span class="title function_">handler</span>(<span class="params">val,oldval</span>)&#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">      <span class="title function_">changeObj</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">objVal</span>.<span class="property">name</span> = <span class="string">&#x27;newobj&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>但是，在使用同一种方式进行数组值更改监听时，这种做法是无效的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">arrList</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">arrList</span>: &#123;</span><br><span class="line">      <span class="title function_">handler</span>(<span class="params">val, oldval</span>) &#123;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">changeArr</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 无效</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">arrList</span>[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>上述用以监听数组值变化的方法是无效的，vue 是不会响应数据变化而重新去渲染页面。在 vue 中仅需要通过修改赋值语句的方式，即可让 vue 响应数组数据的变化。具体操作如下：</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(vm.<span class="property">items</span>, indexOfItem, newValue);</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.<span class="property">items</span>.<span class="title function_">splice</span>(indexOfItem, <span class="number">1</span>, newValue);</span><br></pre></td></tr></table></figure>

<p>具体使用案例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">arrList</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">changeArr</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// this.arrList[0] = 10;</span></span><br><span class="line">      <span class="comment">// 修改为：</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">arrList</span>.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">arrList</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">changeArr</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// this.arrList[0] = 10;</span></span><br><span class="line">      <span class="comment">// 修改为：</span></span><br><span class="line">      <span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">arrList</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>以上两种方式，均可达到监听数组值变化的效果。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>正则</title>
    <url>/2021/06/17/20210617-regexp/</url>
    <content><![CDATA[<p>正则学习</p>
<span id="more"></span>

<h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符."></a>普通字符.</h3><p><code>[ABC]</code> 匹配<code>[...]</code>中的所有字符，如<code>[abcde]</code>匹配<code>good good study day day up</code>中的所有a b c d e字母。</p>
<p><code>[^ABC]</code> 匹配除了<code>[...]</code>中字符的所有字符，  如<code>[^abcde]</code>匹配<code>good good study day day up</code>中的除了a b c d e的所有字母。</p>
<p><code>[A-Z]</code> 匹配<code>[...]</code>区间中的所有字母，如<code>[a-d]</code>匹配<code>good good study day day up</code>中的所有a b c d字母。</p>
<p>. 匹配除了换行符之外的任意单个字符，相当于<code>[^\n\r]</code>。</p>
<p><code>[\s\S]</code> 匹配所有<code>\s</code>匹配所有空白符，包括换行，<code>\S</code>匹配所有非空白符，不包括换行。</p>
<p><code>\w</code> 匹配字母，数字，下划线。等价于<code>[A-Za-z0-9]</code>。</p>
<p><code>\d</code> 匹配数字，等价于<code>[0-9]+?</code>。</p>
<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><p><code>\f</code>匹配一个换页符。</p>
<p><code>\n</code>匹配一个换行符。</p>
<p><code>\r</code>匹配一个回车符。</p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p><code>$</code>匹配输入字符的结尾位置，如果要匹配$本身，则使用<code>\$</code>。</p>
<p><code>()</code>标记一个子表达式的开始和结束位置，子表达式可以获取供以后使用，要匹配这些字符串，则使用<code>\(</code>和<code>\)</code>。子表达式可以与<code>\1 \2 \3....</code>配合使用，分别代表第一个子表达式/第二个子表达式/第三个子表达式…，值得注意的是，在使用<code>\1 \2 \3....</code>这种写法时，<code>\1</code>代表和第一个子表达式对应的值完全一致，比如字符串’abcd cdef abcd’，匹配<code>/\b([a-z]+) \1\b/gi</code>时，匹配的是<code>null</code>；而匹配<code>/\b([a-z]+) ([a-z]+)\b/gi</code>可以匹配到’abcd cdef’；匹配<code>/\b([a-z]+) ([a-z]+) \1\b/gi</code>时，可以匹配到’abcd cdef abcd’。</p>
<p><code>*</code>匹配前面的子表达式任意次数（0,1,2,…..），如果要匹配本身，则使用<code>\*</code>。</p>
<p><code>+</code>匹配前面的子表达式一次或多次（1,2,…..），如果要匹配本身，则使用<code>\+</code>。</p>
<p><code>?</code>匹配前面的子表达式零次或1次（0,1），如果要匹配本身，则使用<code>\?</code>。</p>
<p><code>[</code>标记一个中括号表达式的开始，如果要匹配本身，则使用<code>\[</code>。中括号中的表达式是单个匹配，比如<code>/abc/</code>匹配的是’abc’三个字母必须是挨着的，而<code>/[abc]/</code>是单独匹配’a’/‘b’/‘c’着三个字母。</p>
<p><code>\</code>将后一个字符标记为或特殊字符，或原意字符。如<code>\\</code>表示<code>&#39;\&#39;</code>，<code>n</code>匹配<code>&#39;n&#39;</code>而<code>\n</code>匹配换行符。</p>
<p><code>^</code>匹配字符串的开始位置，在方括号中使用时代表不接受该方括号表达式中的字符集合。</p>
<p><code>&#123;</code>标记限定符表达式的开始。</p>
<p><code>|</code>指明两项之一的选择。</p>
<h3 id="限定符（配合-使用）"><a href="#限定符（配合-使用）" class="headerlink" title="限定符（配合{}使用）"></a>限定符（配合<code>&#123;&#125;</code>使用）</h3><p><code>*</code>匹配前面的子表达式任意次数（0,1,2,…..），如果要匹配本身，则使用<code>\*</code>。</p>
<p><code>+</code>匹配前面的子表达式一次或多次（1,2,…..），如果要匹配本身，则使用<code>\+</code>。</p>
<p><code>?</code>匹配前面的子表达式零次或1次（0,1），如果要匹配本身，则使用<code>\?</code>。</p>
<p><code>&#123;n&#125;</code>匹配前面的表达式n次，n是一个非负整数。例如<code>o&#123;2&#125;</code>不能匹配’bob’中的’o’，但是可以匹配’food’中的两个’o’。</p>
<p><code>&#123;n,&#125;</code>匹配前面的表达式至少n次，n是一个非负整数。例如<code>o&#123;1,&#125;</code>可以匹配’bob’中的’o’，也可以匹配’food’中的两个’o’。</p>
<p><code>&#123;n,m&#125;</code>匹配前面的表达式最少n次，最多m次，m和n都是非负整数。例如<code>o&#123;2,3&#125;</code>不能匹配’bob’中的’o’，但是可以匹配’food’中的两个’o’，可以匹配’rooob’中的三个n。</p>
<p><code>*</code>和<code>+</code>都是贪婪的，它们会尽可能多的匹配文字，只有在他们后面加上一个<code>?</code>就可以实现非贪婪或最小匹配。</p>
<p>例如，在<code>&lt;h1&gt;RUNOOB-菜鸟教程&lt;/h1&gt;</code>中，使用正则表达式<code>/&lt;.*&gt;/</code>会匹配整个字符串，如果想匹配<code>&lt;h1&gt;</code>，则可以使用<code>/&lt;.*?&gt;/</code></p>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符能使正则表达式定位到行首或行尾，它还可以创造这样的正则表达式，这些表达式出现在一个单词内，在一个单词的开头或者一个单词的结尾。</p>
<p>定位符用来描述字符串或单词的边界：</p>
<p><code>^</code>匹配输入字符串的开始的位置，如果设置了RegExp的Multiline属性，<code>^</code>还会与<code>\n \r</code>后的位置匹配。</p>
<p><code>$</code>匹配输入字符串的开始的位置，如果设置了RegExp的Multiline属性，<code>$</code>还会与<code>\n \r</code>前的位置匹配。</p>
<p><code>\b</code>匹配一个单词的边界，即字与空格之间的位置。</p>
<p><code>\B</code>非单词边界匹配。</p>
<p>不能将定位符和限定符一起使用，如<code>^*</code>这种写法是错误的。</p>
<h3 id="选择符"><a href="#选择符" class="headerlink" title="选择符"></a>选择符</h3><p><code>|</code>代表匹配<code>|</code>前面或后面的表达式。比如想要匹配’grandfather’和’grandmother’可以使用表达式<code>/grand(father|mother)/g</code></p>
<h3 id="环视-断言-非获取匹配"><a href="#环视-断言-非获取匹配" class="headerlink" title="环视/断言/非获取匹配"></a>环视/断言/非获取匹配</h3><p>此项下所有规则都有一个特点，就是该匹配不进行存储供以后使用，具体表现看<code>?:</code>。</p>
<p><code>?:</code>子表达式是可以被记住并且在后面重复使用的，比如<code>/(y)\1/</code>其实匹配的是<code>\yy\</code>，再举个例子，使用字符串’gjrl4kfgrandfatherkrgag8fvfgrandsonfr6gaaf’分别匹配正则<code>/(g)(a)\1/</code>和<code>/(?:g)(a)\1/</code>，前一种匹配到的是’gag’，后一种匹配到的是’gaa’。</p>
<p><code>exp1(?=exp2)</code>查找<code>exp2</code>前面的<code>exp1</code>并且不获取<code>exp2</code>对应的内容，如<code>/runoob(?=[\d+])/g</code>去匹配’1234runoob345runoob7898runoob’，返回的是’runoob,runoob’，即匹配到的是’345’和’7898’前面的’runoob’，并没有匹配到最后的’runoob’，因为它后面没有数字，称为“正向肯定预查”。</p>
<p><code>exp1(!=exp2)</code>查找所有后面非<code>exp2</code>的<code>exp1</code>并且不获取<code>exp</code>后面的内容，如<code>/runoob(?![\d+])/g</code>去匹配’1234runoob345runooba7898runoob’，返回的是’runoob’，即匹配到的是’a’前面的’runoob’，并没有匹配到数字前的’runoob’，称为“正向否定预查”。</p>
<p><code>(?&lt;=exp2)exp1</code>查找<code>exp2</code>后面的<code>exp1</code>并且不获取<code>exp2</code>对应的内容，如<code>/(?&lt;=[\d+])runoob/g</code>去匹配’1234runoob345arunoob7898runoob’，返回的是’runoob,runoob’，即匹配到的是’1234’和’7898’后面的’runoob’，并没有匹配到’a’后面的’runoob’，因为它后面没有数字，称为“反向肯定预查”。</p>
<p><code>(?&lt;!exp2)exp1</code>查找非<code>exp2</code>后面的<code>exp1</code>，并且不获取非<code>exp2</code>对应的内容，如<code>/(?&lt;![\d+])runoob/g</code>去匹配’1234runoob345arunoob7898runoob’，返回的是’runoob’，即匹配到的是’a’后面的’runoob’，并没有匹配到数字后面的’runoob’，称为“反向否定预查”。</p>
<h3 id="修饰符（标记）"><a href="#修饰符（标记）" class="headerlink" title="修饰符（标记）"></a>修饰符（标记）</h3><p>修饰符的使用方法<code>/pattern/flags</code>。</p>
<p>常用修饰符：</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">含义</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td align="left">ignore - 不区分大小写</td>
<td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">global - 全局匹配</td>
<td align="left">查找所有的匹配项。</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">multi line - 多行匹配</td>
<td align="left">使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td>
<td align="left">默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td>
</tr>
</tbody></table>
<h3 id="自己写的正则"><a href="#自己写的正则" class="headerlink" title="自己写的正则"></a>自己写的正则</h3><table>
<thead>
<tr>
<th>正则</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>console.log(.*?);</td>
<td>匹配所有console</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>公共方法</title>
    <url>/2021/07/13/20210713-util/</url>
    <content><![CDATA[<p>本文记录一下自己封装的公共方法。</p>
<span id="more"></span>

<pre><code class="javascript">// 获取地址栏参数，稳定，鲁棒性强！
export function getUrlParams() &#123;
  let urlParams = decodeURI(window.location.search + window.location.hash);
  let resObj = &#123;&#125;;
  urlParams = urlParams
    .replace(/\//g, &#39;&#39;)
    .replace(/\?/g, &#39;&amp;&#39;)
    .replace(/#/g, &#39;&amp;&#39;)
    .split(&#39;&amp;&#39;)
    .filter((item) =&gt; &#123;
      return item.includes(&#39;=&#39;);
    &#125;);
  for (let i = urlParams.length - 1; i &gt;= 0; i--) &#123;
    let keyValueArr = urlParams[i].split(&#39;=&#39;);
    let key = keyValueArr[0];
    let value = keyValueArr[1];
    if (Object.prototype.toString.apply(resObj[key]) === &#39;[object Undefined]&#39;) &#123;
      resObj[key] = value;
    &#125; else if (Object.prototype.toString.apply(resObj[key]) === &#39;[object String]&#39;) &#123;
      let temp = resObj[key];
      resObj[key] = [];
      resObj[key].push(temp);
      resObj[key].push(value);
    &#125; else if (Object.prototype.toString.apply(resObj[key]) === &#39;[object Array]&#39;) &#123;
      resObj[key].push(value);
    &#125;
  &#125;
  return resObj;
&#125;
/** test url：
http://fishpano.com/Discover#/share=998?id=998?id=998?id=998?id=998&amp;ff=776fd&amp;ff=776fd&amp;ff=776fd&amp;ff=776fd&amp;ff=776fd&amp;ff=776fd#hash
http://fishpano.com/Discover/share=998?id=998&amp;ff=776fdv#hash/?array=[1,2,3]?ff=5533?array=[%E5%93%88%E5%93%88,xxi,%E6%BB%B4%E6%BB%B4]
*/


// 检测传入参数的类型
export const judgeType = &#123;
  isArray: (param) =&gt; &#123;
    return Object.prototype.toString.apply(param) === &#39;[object Array]&#39;;
  &#125;,
  isString: (param) =&gt; &#123;
    return Object.prototype.toString.apply(param) === &#39;[object String]&#39;;
  &#125;,
  isNumber: (param) =&gt; &#123;
    return Object.prototype.toString.apply(param) === &#39;[object Number]&#39;;
  &#125;,
  isNull: (param) =&gt; &#123;
    return Object.prototype.toString.apply(param) === &#39;[object Null]&#39;;
  &#125;,
  isUndifined: (param) =&gt; &#123;
    return Object.prototype.toString.apply(param) === &#39;[object Undefined]&#39;;
  &#125;,
  isFunction: (param) =&gt; &#123;
    return Object.prototype.toString.apply(param) === &#39;[object Function]&#39;;
  &#125;,
  isBoolean: (param) =&gt; &#123;
    return Object.prototype.toString.apply(param) === &#39;[object Boolean]&#39;;
  &#125;,
  isObject: (param) =&gt; &#123;
    return Object.prototype.toString.apply(param) === &#39;[object Object]&#39;;
  &#125;,
  getType: (param) =&gt; &#123;
    let type = Object.prototype.toString.apply(param);
    switch (type) &#123;
      case &#39;[object Array]&#39;:
        return &#39;Array&#39;;
        break;
      case &#39;[object String]&#39;:
        return &#39;String&#39;;
        break;
      case &#39;[object Number]&#39;:
        return &#39;Number&#39;;
        break;
      case &#39;[object Null]&#39;:
        return &#39;Null&#39;;
        break;
      case &#39;[object Undefined]&#39;:
        return &#39;Undefined&#39;;
        break;
      case &#39;[object Function]&#39;:
        return &#39;Function&#39;;
        break;
      case &#39;[object Boolean]&#39;:
        return &#39;Boolean&#39;;
        break;
      case &#39;[object Object]&#39;:
        return &#39;Object&#39;;
        break;
      default:
        break;
    &#125;
  &#125;,
&#125;;

/*
let a = 123
judgeType.getType(a)  // Number
judgeType.isNumber // true
**/


// 时间戳转换 YYYY-MM-DD HH:MM:SS
timeFormatter(timestamp) &#123;
  function addZero(num) &#123;
    if (parseInt(num) &lt; 10) &#123;
      num = &quot;0&quot; + num;
    &#125;
    return num;
  &#125;

  let oDate = new Date(timestamp * 1000);
  let oYear = oDate.getFullYear();
  let oMonth = oDate.getMonth() + 1;
  let oDay = oDate.getDate();
  let oHour = oDate.getHours();
  let oMin = oDate.getMinutes();
  let oSen = oDate.getSeconds();
  let localTime =
      oYear +
      &quot;-&quot; +
      addZero(oMonth) +
      &quot;-&quot; +
      addZero(oDay) +
      &quot; &quot; +
      addZero(oHour) +
      &quot;:&quot; +
      addZero(oMin) +
      &quot;:&quot; +
      addZero(oSen);
  return localTime;
&#125;

// 后面这个大佬的方法比较好
Date.prototype.Format = function(fmt) &#123;
    // author: meizz
    var o = &#123;
      &quot;M+&quot;: this.getMonth() + 1, // 月份
      &quot;d+&quot;: this.getDate(), // 日
      &quot;h+&quot;: this.getHours(), // 小时
      &quot;m+&quot;: this.getMinutes(), // 分
      &quot;s+&quot;: this.getSeconds(), // 秒
      &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), // 季度
      S: this.getMilliseconds() // 毫秒
    &#125;;
    if (/(y+)/.test(fmt))
      fmt = fmt.replace(
        RegExp.$1,
        (this.getFullYear() + &quot;&quot;).substr(
          4 - RegExp.$1.length
        )
      );
    for (var k in o)
      if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt))
        fmt = fmt.replace(
          RegExp.$1,
          RegExp.$1.length == 1
            ? o[k]
            : (&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)
        );
    return fmt;
  &#125;;
</code></pre>
]]></content>
      <categories>
        <category>方法</category>
      </categories>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title>休眠函数</title>
    <url>/2021/07/20/20210720-sleep/</url>
    <content><![CDATA[<p>休眠函数。</p>
<span id="more"></span>

<p>先写一个奇奇怪怪的休眠函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">millionSeconds</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() &lt; startTime + millionSeconds);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello world&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>然后是比较传统的<code>setTimeout</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span> (seconds) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">  &#125;,seconds)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">traffic_light</span>=(<span class="params">color,duration</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;traffic-light &#x27;</span>, color);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;,duration)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">main</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">traffic_light</span>(<span class="string">&#x27;red&#x27;</span>,<span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">traffic_light</span>(<span class="string">&#x27;yellow&#x27;</span>,<span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">traffic_light</span>(<span class="string">&#x27;green&#x27;</span>,<span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">main</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async await</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">wait</span>(<span class="params">time</span>)&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep2</span>(time);</span><br><span class="line">  <span class="title function_">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">wait</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">duration</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params">color, duration</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;traffic-light &#x27;</span>, color);</span><br><span class="line">	<span class="keyword">await</span> <span class="title function_">sleep</span>(duration);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">await</span> <span class="title function_">changeColor</span>(<span class="string">&#x27;red&#x27;</span>, <span class="number">2000</span>);</span><br><span class="line">		<span class="keyword">await</span> <span class="title function_">changeColor</span>(<span class="string">&#x27;yellow&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">		<span class="keyword">await</span> <span class="title function_">changeColor</span>(<span class="string">&#x27;green&#x27;</span>, <span class="number">3000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="variable language_">console</span>.<span class="property">log</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sleep</span> = (<span class="params">timeout</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, timeout)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">main</span> = <span class="keyword">async</span>(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">2000</span>);</span><br><span class="line">  <span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">3000</span>);</span><br><span class="line">  <span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>typescript+webpack从0构建项目</title>
    <url>/2021/07/29/20210729-webpack/</url>
    <content><![CDATA[<p>记录一下从 0 开始使用 typescript+webpack 搭建一个项目。</p>
<span id="more"></span>

<p>创建一个空目录，然后使用<code>npm init</code>，创建<code>package.json</code>。</p>
<p>安装<code>webpack</code>和<code>webpack-cli</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli -D</span><br></pre></td></tr></table></figure>

<p>安装成功之后，可以在<code>package.json</code>中看到对应的<code>webpack</code>版本。</p>
<p>然后创建<code>src</code>文件夹，创建一个<code>index.js</code>和一个<code>foo.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, log &#125; <span class="keyword">from</span> <span class="string">&#x27;./foo&#x27;</span>;</span><br><span class="line"><span class="title function_">log</span>(foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以使用<code>npx webpack</code>进行打包。</p>
<p><img src="https://dqtwdd.top/cdn/img/bundle.jpg" alt="bundle"></p>
<p>打包之后的结果。</p>
<p>然后创建一个<code>webpack.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 设置模式</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">// 指定构建入口文件</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 指定构建生成文件所在路径</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>, <span class="comment">// 指定构建生成的文件名</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后重新打包就可以看到配置已经生效了。</p>
<p>接下来使用<code>webpack-dev-server</code>进行本地开发。<code>npm install webpack-dev-server -D</code>。</p>
<p>需要注意的是安装之后，可能会因为<code>webpack-dev-server</code>和<code>webpack</code>/<code>webpack-cli</code>的版本冲突导致报错，今天（2021/07/29）安装的最新版：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;webpack&quot;</span>: <span class="string">&quot;^5.47.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^4.7.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^3.11.2&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个版本会报错，改为旧版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;webpack&quot;</span>: <span class="string">&quot;^5.2.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^3.3.12&quot;</span>,</span><br><span class="line">  <span class="string">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^3.11.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就 ok 啦。</p>
<p>然后在<code>./dist</code>新建<code>index.html</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// index.html // <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> //</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  //</span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    //</span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    //</span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    //</span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  //</span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    //</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    //</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  //</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://dqtwdd.top/cdn/img/webpack-dev-server.jpg" alt="webpack-dev-server" style="zoom:50%;" />

<p>接下来在项目中使用<code>typescript</code>。</p>
<p>安装<code>typescript</code>：<code>npm install typescript</code>。</p>
<p>然后用<code>tsc --init</code>命令初始化，创建<code>tsconfig.json</code>。</p>
<p>安装解析<code>ts</code>的<code>loader</code>：<code>npm install --save-dev ts-loader </code>。</p>
<p>安装完成后在<code>webpack.config.js</code>增加<code>rule</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 设置模式</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.ts&#x27;</span>, <span class="comment">// 指定构建入口文件</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 指定构建生成文件所在路径</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>, <span class="comment">// 指定构建生成的文件名</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123; <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, <span class="attr">loader</span>: <span class="string">&#x27;ts-loader&#x27;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将刚才创建的<code>index.js foo.js</code>文件拓展名改为<code>index.ts foo.ts</code>，然后就可以继续打包了。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2021/08/12/20210812-sort/</url>
    <content><![CDATA[<p>一直没有好好总结过排序算法，趁着这几天没事总结了一下排序算法。</p>
<span id="more"></span>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>遍历n次，每次都是从0开始</p>
<p>优化点：发现一次遍历没有任何改变立即结束遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bub</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> deepArr = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr));</span><br><span class="line">  <span class="keyword">let</span> loopNum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deepArr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> ifChange = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; deepArr.<span class="property">length</span> - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      loopNum += <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (deepArr[j] &gt; deepArr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = deepArr[j];</span><br><span class="line">        deepArr[j] = deepArr[j + <span class="number">1</span>];</span><br><span class="line">        deepArr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        ifChange = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ifChange) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;loopNum&#x27;</span>, loopNum);</span><br><span class="line">  <span class="keyword">return</span> deepArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>遍历n次，每次找到剩余的最小值，放到最前面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> deepArr = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tempMin = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (deepArr[j] &lt; deepArr[tempMin]) &#123;</span><br><span class="line">        tempMin = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deepArr[i] &gt; deepArr[tempMin]) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = deepArr[i];</span><br><span class="line">      deepArr[i] = deepArr[tempMin];</span><br><span class="line">      deepArr[tempMin] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> deepArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>外层循环遍历时，保证前面的数字是已经排序好的。</p>
<p>在使用while时，while的判断条件为：当前值小于pos上的值并且pos大于0。当不满足这个条件时，在pos后面插入当前值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> deepArr = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr));</span><br><span class="line">  <span class="keyword">let</span> resArr = [deepArr[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; deepArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> pos = resArr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &gt; <span class="number">0</span> &amp;&amp; deepArr[i] &lt; resArr[pos]) &#123;</span><br><span class="line">      pos -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    resArr.<span class="title function_">splice</span>(pos + <span class="number">1</span>, <span class="number">0</span>, deepArr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>选择一个基准数。</p>
<p>将小于基准数的放到左边的数组，将大于基准的放到右边的数组，然后递归将左边和右边的数组排序，最后将左边数组/中轴数/右边数组进行合并，就可以得到排序后的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> deepArr = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> basicNum = deepArr.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> left = [];</span><br><span class="line">  <span class="keyword">let</span> right = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deepArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (deepArr[i] &lt; basicNum) &#123;</span><br><span class="line">      left.<span class="title function_">push</span>(deepArr[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(deepArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">quickSort</span>(left).<span class="title function_">concat</span>(basicNum, <span class="title function_">quickSort</span>(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>董大宝的面试算法总结</title>
    <url>/2021/08/16/20210816-wifeInterview/</url>
    <content><![CDATA[<p>老婆面试的算法题，总结一下。</p>
<span id="more"></span>

<h3 id="1-实现一个千分位，扩展string的原型：这个可以有多种思路，不用反转。"><a href="#1-实现一个千分位，扩展string的原型：这个可以有多种思路，不用反转。" class="headerlink" title="1. 实现一个千分位，扩展string的原型：这个可以有多种思路，不用反转。"></a>1. 实现一个千分位，扩展string的原型：这个可以有多种思路，不用反转。</h3><p>本题考查点：</p>
<ol>
<li><p>原型上的this指向本身。</p>
</li>
<li><p>原型和原型链，在原型上拓展方法。</p>
</li>
<li><p>带有小数点时，要只从整数位开始加分号。</p>
</li>
</ol>
<p>核心思路：</p>
<ol>
<li>将字符串分为整数和小数两部分。</li>
<li>将整数反向遍历，遍历到序号是3的整数倍并且序号不为0时加一个’,’。需要注意的是反向遍历时可以写作 newStr = xxx+newStr（取代 newStr += xxx ），将反转的步骤就给省略了。</li>
<li>遍历完成后加上小数部分，返回。</li>
</ol>
<h4 id="1-1-使用toLocaleString方法。"><a href="#1-1-使用toLocaleString方法。" class="headerlink" title="1.1 使用toLocaleString方法。"></a>1.1 使用<code>toLocaleString</code>方法。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">thousands</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> * <span class="number">1</span> === <span class="title class_">NaN</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">NaN</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="variable language_">this</span> * <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> num.<span class="title function_">toLocaleString</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;12345678&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">thousands</span>()); <span class="comment">// &#x27;12,345,678&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-将字符串反转，加逗号后再次反转并返回"><a href="#1-2-将字符串反转，加逗号后再次反转并返回" class="headerlink" title="1.2 将字符串反转，加逗号后再次反转并返回"></a>1.2 将字符串反转，加逗号后再次反转并返回</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">thousands</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> * <span class="number">1</span> === <span class="title class_">NaN</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">NaN</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> reverseStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> intNum = <span class="variable language_">this</span>.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = intNum.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    reverseStr += intNum[i];</span><br><span class="line">    index += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (index % <span class="number">3</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      reverseStr += <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> resStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = reverseStr.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    resStr += reverseStr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  resStr += <span class="variable language_">this</span>.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] === <span class="literal">undefined</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;.&#x27;</span> + <span class="variable language_">this</span>.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> resStr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;12345678.635636&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">thousands</span>()); <span class="comment">// 12,345,678.635636</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-优化不反转，直接处理"><a href="#1-3-优化不反转，直接处理" class="headerlink" title="1.3 优化不反转，直接处理"></a>1.3 优化不反转，直接处理</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">thousands</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">let</span> intStr = str.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> newStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> reverseIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = intStr.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    newStr = intStr[i] + newStr;</span><br><span class="line">    reverseIndex += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (reverseIndex % <span class="number">3</span> === <span class="number">0</span> &amp;&amp; reverseIndex !== <span class="number">0</span>) &#123;</span><br><span class="line">      newStr = <span class="string">&#x27;,&#x27;</span> + newStr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newStr + (str.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] ? <span class="string">&#x27;.&#x27;</span> + str.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] : <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;12&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">thousands</span>()); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-正则"><a href="#1-4-正则" class="headerlink" title="1.4 正则"></a>1.4 正则</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">thousands</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="variable language_">this</span>.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="regexp">/\d+/</span>, <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num.<span class="title function_">replace</span>(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>, <span class="keyword">function</span> (<span class="params">$1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> $1 + <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;12345.678&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">thousands</span>()); <span class="comment">// 12,345.678</span></span><br></pre></td></tr></table></figure>

<h3 id="2-实现字符串的全排列"><a href="#2-实现字符串的全排列" class="headerlink" title="2. 实现字符串的全排列"></a>2. 实现字符串的全排列</h3><p>本题考查点：回溯算法。</p>
<p>回溯算法就相当于树的遍历，网上关于回溯的讲解有很多，贴一篇个人感觉比较好的：</p>
<p><a href="https://leetcode-cn.com/problems/permutations-ii/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-ki1h/">带你学透回溯算法！47. 全排列 II</a></p>
<p>回溯很简单，记住一串伪代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">backtracking</span>(<span class="params">参数</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">      	<span class="keyword">if</span> (跳过此循环条件) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="title function_">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一些稍微复杂的回溯问题，需要剪枝，就是要去除重复数据，去除重复数据有两种办法，一种是将走过的路径记录，另一种是遍历完成后将结果暴力去重。</p>
<h4 id="2-1-简单回溯"><a href="#2-1-简单回溯" class="headerlink" title="2.1 简单回溯"></a>2.1 简单回溯</h4><p>简单回溯问题包括：无重复字符串的全排列，无重复元素数组的全排列等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全排列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> currPath = [];</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="title function_">backtrack</span>(nums, []);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">nums, used</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currPath.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(currPath)));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      currPath.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">      used[i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">backtrack</span>(nums, used);</span><br><span class="line">      currPath.<span class="title function_">pop</span>();</span><br><span class="line">      used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2-回溯-amp-剪枝"><a href="#2-2-回溯-amp-剪枝" class="headerlink" title="2.2 回溯&amp;剪枝"></a>2.2 回溯&amp;剪枝</h4><p>回溯剪枝问题包括：包含重复字符的全排列，包含重复元素的数组全排列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用剪枝条件判断</span></span><br><span class="line"><span class="comment"> * used[i - 1] == true，说明同一树支nums[i - 1]使用过</span></span><br><span class="line"><span class="comment"> * used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line"><span class="comment"> * 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permuteUnique = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> path = [];</span><br><span class="line">  <span class="keyword">let</span> sortNums = nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="title function_">backtrack</span>(sortNums, []);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">nums, used</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(path)));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="comment">// 满足条件时返回</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (used[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="comment">// 使用过或满足剪枝条件时剪枝</span></span><br><span class="line">      path.<span class="title function_">push</span>(nums[i]); <span class="comment">// 做选择</span></span><br><span class="line">      used[i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">backtrack</span>(nums, used); <span class="comment">// 递归继续做选择</span></span><br><span class="line">      path.<span class="title function_">pop</span>(); <span class="comment">// 回溯</span></span><br><span class="line">      used[i] = <span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先全排列，得到结果后暴力去重</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> permuteUniqueWithSet = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> path = [];</span><br><span class="line">  <span class="title function_">backtrack</span>(nums, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(res)).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">sonItem</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> sonItem * <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">nums, used</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(path.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>))));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">      used[i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">backtrack</span>(nums, used);</span><br><span class="line">      path.<span class="title function_">pop</span>();</span><br><span class="line">      used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>pha工作流程</title>
    <url>/2021/08/30/20210830-pha/</url>
    <content><![CDATA[<p>记录一下 pha 的工作流程。</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ---on branch master ---</span></span><br><span class="line"><span class="comment">// 在master分枝上</span></span><br><span class="line">git checkout -b &lt;your <span class="keyword">new</span> branch&gt; <span class="comment">// 新建分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// —-on your branch—-</span></span><br><span class="line"><span class="comment">// 在你自己新建的分支开发，完成后进行后面操作：</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &lt;some desciption&gt;</span><br><span class="line">git push -u origin &lt;your branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送完成后执行arc命令</span></span><br><span class="line">arc diff master <span class="comment">//这个命令输入后应该会让你输入Summary(必填)/Reviewer(必填)/Surbscriber等信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入完成后 按 ctrl+x 退出并保存 等审批完成后执行下面命令</span></span><br><span class="line">arc land —-onto master <span class="comment">// 正常这样就能推送到master分支了。但是如果是两个人并行开发，在你开发期间有别人推送到master分支的话，就比较麻烦，后续总结出经验之后会更新。</span></span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<p>1.arc land 操作成功后会删除本地 git stash 的所有内容！！！所以切记 arc land 之前将 stash 的内容妥善保存，建议复制到本地。</p>
<p>2.arc land 操作将会删除你在本地的分支，并跳转到 maste 分支，所以建议将本地分支推送到远程保证代码不会丢失，可以定期清理远程分支。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ---on branch master---</span></span><br><span class="line">arc feature my-<span class="keyword">new</span>-feature <span class="comment">// arc命令，创建新分支。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---on your branch---</span></span><br><span class="line"><span class="comment">// 在你自己新建的分支开发，完成后进行后面操作：</span></span><br><span class="line"><span class="comment">// 在git add .之前，如果别人提交过的话，可以使用 git pll origin master合并本地代码和线上最新的代码。</span></span><br><span class="line">git add .</span><br><span class="line">arc diff</span><br><span class="line"><span class="comment">// arc diff 之后会出现下图的提示，让你输入commit信息，你也可以自己 git commit -m &quot;xxx&quot;之后再arc diff，这样就直接进入输入summary的环节了，不需要输入commit信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入完成后 按 ctrl+x 退出并保存 等审批完成后执行下面命令</span></span><br><span class="line">arc land —-onto master</span><br></pre></td></tr></table></figure>

<p><img src="https://dqtwdd.top/cdn/img/pha.gif" alt="pha"></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>加水印</title>
    <url>/2021/08/30/20210830-waterMark/</url>
    <content><![CDATA[<p>自己写的加水印小插件的思路。</p>
<span id="more"></span>

<p>之前组内大佬写了一个加水印的小工具，对原理比较好奇，所以自己尝试写了一下。</p>
<p>先附上一个最后的效果。</p>
<p><img src="https://dqtwdd.top/cdn/img/20210903154808.png" alt="end"></p>
<p>主要思路：</p>
<p>自己先思考一下，要把大象装冰箱<img src="http://ww4.sinaimg.cn/large/ceeb653ejw1fbif3twmh2g203c03c74e.gif" alt="bingxiang">，需要几步？</p>
<ol>
<li>打开冰箱</li>
<li>把大象塞进去</li>
<li>关上冰箱门</li>
</ol>
<p>装大象一样，经过简略的思考，想到其实加水印这个简单的问题也只需要三步：</p>
<ol>
<li>在页面创建时创建一个 dom 层。（<code>let dom = document.createElement(&#39;div&#39;)</code>）</li>
<li>将要设置为水印的文字/图片设置为 dom 背景。(<code>dom.style.backgroundColor = red</code>)</li>
<li>将 dom 挂载在需要打水印的节点上。(<code>document.body.appendChild(dom);</code>)</li>
</ol>
<p>So easy ～先写个小 demo：</p>
<p><img src="https://dqtwdd.top/cdn/img/20210903160850.png" alt="step1"></p>
<p><img src="http://ww1.sinaimg.cn/bmiddle/6af89bc8gw1f8q2elz9aqj205i045jr8.jpg" alt="nani">纳尼？我页面呢？稍一思考，哦～～背景颜色太深了，I know！设置个透明度！</p>
<p><img src="https://dqtwdd.top/cdn/img/20210903160207.png" alt="step2"></p>
<p>搞定收工！</p>
<p>等等！怎么按钮都点不了了？<img src="http://ww4.sinaimg.cn/bmiddle/005XSXmNgw1farkd1wk3hj305i05iaac.jpg" alt="not easy"></p>
<p>遮罩会挡住操作！这时就要出现一个非常重要的 css 属性：<code>pointer-events</code></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/pointer-events">pointer-events MDN</a></p>
<p>将水印层的 dom 设置为<code>pointer-events: none;</code>就行。这个问题就算是解决了。</p>
<p>此外，我们肯定不能将水印层设置成纯色，而是需要根据传入的图片和文字来配置。</p>
<p>图片还好说，直接配置<code>background-img</code>属性将水印图片设置为背景，然后设置<code>backgroundRepeat</code>为 repeat。</p>
<p>至于文字，我们可以使用<code>canvas</code>，将文字写在<code>canvas</code>之后将带有文字的画布作为图片输入，然后当作背景图片设置为水印层的背景图。</p>
<p>附上完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./watermark.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">waterMark</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> waterMarkDom = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  waterMarkDom.<span class="property">className</span> = <span class="string">&#x27;watermark&#x27;</span>;</span><br><span class="line">  waterMarkDom.<span class="title function_">setAttribute</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;waterMark&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  ctx.<span class="title function_">rotate</span>((<span class="number">20</span> * <span class="title class_">Math</span>.<span class="property">PI</span>) / <span class="number">180</span>);</span><br><span class="line">  ctx.<span class="property">font</span> = <span class="string">&#x27;30px Arial&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillText</span>(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">  <span class="keyword">let</span> tempSrc = canvas.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/png&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  img.<span class="property">src</span> = tempSrc;</span><br><span class="line"></span><br><span class="line">  waterMarkDom.<span class="property">style</span>.<span class="property">backgroundImage</span> = <span class="string">`URL(<span class="subst">$&#123;tempSrc&#125;</span>)`</span>; <span class="comment">//设置背景图的的地址</span></span><br><span class="line">  waterMarkDom.<span class="property">style</span>.<span class="property">backgroundRepeat</span> = <span class="string">&#x27;repeat&#x27;</span>; <span class="comment">//设置背景不平铺</span></span><br><span class="line">  <span class="comment">// waterMarkDom.style.backgroundPosition = &#x27;center&#x27;; //设置背景图的位置</span></span><br><span class="line">  waterMarkDom.<span class="property">style</span>.<span class="property">pointerEvents</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">  <span class="comment">// waterMarkDom.appendChild(img);</span></span><br><span class="line">  waterMarkDom.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;fixed&#x27;</span>;</span><br><span class="line">  waterMarkDom.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  waterMarkDom.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  waterMarkDom.<span class="property">style</span>.<span class="property">right</span> = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  waterMarkDom.<span class="property">style</span>.<span class="property">bottom</span> = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  waterMarkDom.<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&#x27;0.5&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> shadow = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> shadowDom = shadow.<span class="title function_">attachShadow</span>(&#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  shadowDom.<span class="title function_">append</span>(waterMarkDom);</span><br><span class="line"></span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(shadow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">drawBackgroundTxt</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> ctx = c.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  ctx.<span class="property">font</span> = <span class="string">&#x27;30px Arial&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillText</span>(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// waterMark.css</span></span><br><span class="line">.<span class="property">watermark</span> &#123;</span><br><span class="line">  <span class="attr">position</span>: fixed;</span><br><span class="line">  <span class="attr">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attr">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attr">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attr">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基本的功能就已经开发完毕了，然后继续思考一下有哪些优化点：</p>
<ol>
<li><p>水印文字的配置，包括但不限于字体/字号/文字倾斜度/颜色/透明度/粗细等等。</p>
</li>
<li><p>配置水印挂载的 dom。</p>
</li>
<li><p>是否将水印加密，加密方法。</p>
</li>
<li><p>文字在画布中的偏移量。</p>
</li>
<li><p>使用<code>canvas</code>的转换的图片是 base64，当使用 js 设置水印的背景属性之后，dom 会显示的非常臃肿，很不美观：</p>
<p><img src="https://dqtwdd.top/cdn/img/20210903170616.png" alt="dom"></p>
<p>可以配置使用<code>shadowDom</code>来改善这个情况：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM">shadowDom</a></p>
<p>使用<code>shadowDom</code>后：<img src="https://dqtwdd.top/cdn/img/20210903171332.png" alt="shadowDom"></p>
<p>这样看起来就美观很多了。</p>
</li>
<li><p>前端做水印一个最大的隐患就是安全性的问题，懂一点前端的人都知道可以打开控制台，通过修改 css 隐藏水印，这时我们可以通过使用<code>Mutation Observer API</code>监听 dom 的变化，在 dom 变化时让页面报错或者阻止页面重绘，比如：</p>
<p><img src="https://dqtwdd.top/cdn/img/mutation.gif" alt="mutation"></p>
<p>但是这个做法也不是完全安全的，可以通过禁止 js 执行或者隐藏元素等方法绕过。</p>
</li>
</ol>
<p>总之，前端加水印还是不太安全的，推荐还是后台来做，这个做法只能防止不懂技术的人。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2021/09/26/20210926-slidingWindow/</url>
    <content><![CDATA[<p>本文简单解释一下滑动窗口。</p>
<p>参考文档：<a href="https://juejin.cn/post/6854573218683387917#heading-1">你还在为 TCP 重传、滑动窗口、流量控制、拥塞控制发愁吗？</a></p>
<span id="more"></span>

<p>先看一个三次握手的动图：</p>
<p><img src="https://dqtwdd.top/cdn/img/tcp.awebp" alt="tcp"></p>
<p>先简单说一下这几个参数的意义：</p>
<p>SYN：同步序列编号（ Synchronize Sequence Numbers ）。</p>
<ul>
<li>是 TCP/IP 建立连接时使用的握手信号。</li>
<li>在客户机和 服务器 之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN+ACK 应答表示接收到了这个消息，最后客户机再以 ACK 消息响应。</li>
<li>这样在 客户机 和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</li>
</ul>
<p>ACK: 确认字符 (Acknowledge character）。</p>
<ul>
<li>在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。在 TCP/IP 协议中，如果接收方成功的接收到数据，那么会回复一个 ACK 数据。</li>
</ul>
<p>数据本身是有顺序的，tcp 链接的特点就是可靠。可靠，就指的是发送的数据每个都会被接受，并且是按顺序的，不会丢包，这时我们就会有一个疑问：</p>
<h3 id="如何保证数据传输的次序？"><a href="#如何保证数据传输的次序？" class="headerlink" title="如何保证数据传输的次序？"></a>如何保证数据传输的次序？</h3><p>简单的说就是主机 A 先发送一段数据，然后主机 B 收到之后返回一个 ACK（确认字符），然后主机 A 收到之后再发送下一段数据。</p>
<p>因为每次发送数据都需要接收的主机返回 ACK，这样虽然解决了丢包、出错、乱序等问题，但是这样也出现了新问题：吞吐量低。</p>
<p>正常数据传输的过程如下：</p>
<p><img src="https://dqtwdd.top/cdn/img/sendData.awebp" alt="sendData"></p>
<h3 id="如何提高吞吐量？"><a href="#如何提高吞吐量？" class="headerlink" title="如何提高吞吐量？"></a>如何提高吞吐量？</h3><p>提高吞吐量，就很自然的回到我们本文的重点：滑动窗口。</p>
<p><img src="https://dqtwdd.top/cdn/img/slidingWindow.awebp" alt="slidingWindow"></p>
<p>如上图，我们已经完成了 1/2/3 三段数据的传输，当前窗口处于 4-10，其中 4/5/6/7 已经发送，8/9/10 还未发送。</p>
<p>这个滑动窗口的大小是可以变化的，且滑动窗口的大小由服务端能接受的大小来控制。</p>
<p>当 4 号数据被接收并且返回确认字符之后，窗口就像后滑动一格，将 11 放入待发送队列。如下图：</p>
<p><img src="https://dqtwdd.top/cdn/img/slidingWindow1.awebp" alt="slidingWindow1"></p>
<p>正常情况的滑动窗口就是这样工作了，但是我们可以发现一个新的问题：</p>
<p>窗口的滑动是由窗口内第一个数据是否接收到确认字符来决定的，也就是说，5-11 这段窗口内 6-11 的数据全部发送完成，并且接收到确认字符，但是数据 5 发生了丢包或者确认字符丢失，整个窗口就滑不动了，数据传输陷入了瘫痪，这显然是我们不能接受的，该如何解决呢？</p>
<h3 id="滑动窗口的重传机制"><a href="#滑动窗口的重传机制" class="headerlink" title="滑动窗口的重传机制"></a>滑动窗口的重传机制</h3><ol>
<li><p>超时重传</p>
<p>超时重传的核心就是设置一个重传时间，一个数据发送后，一旦时间超过重传时间并且没有收到 ACK 返回，就立即重新发送请求。</p>
<p>如何配置重传时间也有其一套合理的算法，具体算法可以查看本文参考。</p>
</li>
<li><p>快速重传</p>
<p>快速重传就是将重传的标准由时间改为接收 ACK 的顺序。</p>
<p>比如，上图中 5-11 段的数据都已经发送，但是数据 5/7 的数据没有收到 ACK，但是后发送的 11 的数据都已经收到了 ACK，我们就可以直接重新发送 5/7 两段数据。</p>
</li>
<li><p>SACK（ Selective Acknowledgment 选择性确认）</p>
<p>SACK 就是在 TCP 头部选项里加一个 SACK 字段，将哪段数据收到哪段数据没收到数据跟随 ACK 返回数据发送方，这样发送方就知道该发送哪段数据。</p>
</li>
<li><p>D-SACK（Duplicate SACK 二重的选择性确认）</p>
<p>D-SACK 和 SACK 相比可以将重复接收的数据返回告诉发送端，让发送方知道是发出去的包丢了，还是接收方的 ACK 包丢了。可以知道是不是发送方的数据包被网络延迟了。等等。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3+vite2+ts项目搭建</title>
    <url>/2021/11/02/20211102-vite2+vue3+ts/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>使用viet cli脚手架搭建：    </p>
<p><code>yarn create @vitejs/app vite-ts --template vue-ts</code></p>
<p><code>yarn create vite study --template vue // 创建一个vite-vue项目</code></p>
<p>执行<code>yarn</code>安装依赖。</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h4><p>安装vue-router，需要注意，如果直接安装vue-router安装的是vue2.0版本适用的router，vue3.0需要的router需要使用下面命令：</p>
<p><code>yarn add vue-router@next</code></p>
<p>然后在src下创建router文件夹，创建router.ts</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouteRecordRaw</span>, createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">RouteRecordRaw</span>[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/Index.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/Login.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),</span><br><span class="line">  routes,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在<code>main.ts</code>中插入代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(router).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>记得在<code>app.vue</code>里面插入<code>&lt;router-view/&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;router-view /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: Avenir, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="使用tsx-配置路径别名"><a href="#使用tsx-配置路径别名" class="headerlink" title="使用tsx/配置路径别名"></a>使用tsx/配置路径别名</h3><p>使用tsx需要先安装插件<code>@vitejs/plugin-vue-jsx</code></p>
<p>在<code>vite.config.ts</code>中配置<code>resolve</code>选项可以配置别名</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> yarn add <span class="string">&#x27;@vitejs/plugin-vue-jsx&#x27;</span></span><br><span class="line"><span class="number">2.</span> 配置vite.<span class="property">config</span>.<span class="property">ts</span></span><br><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vueJsx <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue-jsx&#x27;</span> <span class="comment">// 添加这一句</span></span><br><span class="line"><span class="keyword">import</span> &#123; resolve &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>(), <span class="title function_">vueJsx</span>()],<span class="comment">// 添加这一句</span></span><br><span class="line">  <span class="comment">// 在vite.config.ts中添加下面代码可以配置路名别名</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>), <span class="comment">// 路径别名</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时，需要在’<code>tsconfig.ts</code>中配置<code>base</code>和<code>path</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,<span class="comment">// 添加这一句</span></span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;@/*&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;src/*&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;<span class="comment">// 添加这一句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vite.config.ts</code>中<code>__dirname</code>报错<code>Cannot find name &#39;__dirname&#39;</code></p>
<ol>
<li><p>修改<code>tsconfig.json</code> 文件</p>
<pre><code class="javascript">// tsconfig.json
&#123;
 &quot;compilerOptions&quot;: &#123;
  ...
  &quot;types&quot;: [
    &quot;node&quot;
  ]
  ...
  &#125;
&#125;
</code></pre>
</li>
<li><p>安装@types/node</p>
<p><code>npm install @types/node --save-dev</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3学习</title>
    <url>/2021/11/03/20211103-vue3/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="1-vue3-0-生命周期"><a href="#1-vue3-0-生命周期" class="headerlink" title="1.vue3.0 生命周期"></a>1.vue3.0 生命周期</h3><p><img src="https://dqtwdd.top/cdn/img/lifecycle.svg" alt="lifecycle"></p>
<p>setup 执行在 beforeCreate 之前。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始搭建组件库</title>
    <url>/2021/11/12/20211112-Do-UI/</url>
    <content><![CDATA[<p>感觉自己最近学习状态不太佳，所以想做点东西督促自己，每次做什么东西都会半途而费，总结起来就是目的性不太强。所以这次搭建组件库要从头到尾记录一下历程，包括思考的过程，为什么这么做，解决问题的方法，每日的目标，总体的目标。算是给自己立一个小小的 flag。</p>
<span id="more"></span>

<h3 id="1-技术选型"><a href="#1-技术选型" class="headerlink" title="1.技术选型"></a>1.技术选型</h3><p>为了拓展自己的知识面和提高自己的竞争力所以选择比较新的 vue3+ts+vite。</p>
<p>vue3 优点暂时不太明确，记一下，后面复习补上；</p>
<p>ts 是有必要的，可以解决很多类型引起的问题，但是没写过，需要学习一下。</p>
<p>vite 的原理不太懂，但是用过几次就会发现 vite 是真的快。</p>
<p>项目搭建大体用的就是之前文章写过的搭建过程。</p>
<h3 id="2-组件"><a href="#2-组件" class="headerlink" title="2.组件"></a>2.组件</h3><h4 id="2-1button"><a href="#2-1button" class="headerlink" title="2.1button"></a>2.1button</h4><p>参考 elementui 的 button 组件，button 组件的主要功能：</p>
<ol>
<li>根据 type 显示不同的按钮颜色；根据传入参数设置按钮的形状。</li>
<li>禁用功能。</li>
<li>增加按钮图标（通过 slot 方式插入按钮中间的内容）。</li>
<li>配置按钮尺寸。</li>
</ol>
<h4 id="2-2-icon"><a href="#2-2-icon" class="headerlink" title="2.2 icon"></a>2.2 icon</h4><p>通过传入 type 和 size 来控制显示 icon 的图标种类和大小。</p>
<h3 id="3-踩坑"><a href="#3-踩坑" class="headerlink" title="3.踩坑"></a>3.踩坑</h3><h4 id="3-1-打包时没有声明文件"><a href="#3-1-打包时没有声明文件" class="headerlink" title="3.1 打包时没有声明文件"></a>3.1 打包时没有声明文件</h4><p>目前的解决办法是可以在打包后的文件夹加一个<code>index.es.d.ts</code>的声明文档，文档的内容可以用<code>tsc --declaration xxx.ts</code>来生成一个。(图片太大，可以登录后查看：<a href="https://dqtwdd.top/cdn/img/tsx.gif">https://dqtwdd.top/cdn/img/tsx.gif</a>)</p>
<p>然后把这个<code>index.d.ts</code>在打包时候直接带到 dist 文件夹。</p>
<p><img src="http://g.recordit.co/2J1LxJyzNh.gif" alt="tsx"></p>
<h4 id="3-2-打包引入后报错找不到名称"><a href="#3-2-打包引入后报错找不到名称" class="headerlink" title="3.2 打包引入后报错找不到名称"></a>3.2 打包引入后报错找不到名称</h4><p>这个错误就很蠢，是由于命名规范导致的，情况就下面那么几种，我就好死不死的整了个最容易错的。我给组件命名<code>XButton</code>，按照规范，我引用组件应该写<code>&lt;x-button&gt;&lt;\x-button&gt;</code>，我却写的还是<code>&lt;XButton&gt;&lt;\XButton&gt;</code>，经过推断，vue 应该会把组件的第二个大写字母前面编译一个’-‘，所以会导致我的报错。</p>
<p>记住以后给<code>vue</code>组件命名，最好用<code>x-xxx</code>这种格式，就别出现大写字母就完了。</p>
<table>
<thead>
<tr>
<th>注册组件名</th>
<th>使用名</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>Mycom</td>
<td>Mycom</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>mycom</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>MyCom</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>myCom</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>MYCom</td>
<td>对</td>
</tr>
<tr>
<td>mycom</td>
<td>mycom</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>Mycom</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>MyCom</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>myCom</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>MYCom</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>mYCom</td>
<td>对</td>
</tr>
<tr>
<td>MyCom</td>
<td>MyCom</td>
<td>错误</td>
</tr>
<tr>
<td></td>
<td>Mycom</td>
<td>错误</td>
</tr>
<tr>
<td></td>
<td>mycom</td>
<td>错误</td>
</tr>
<tr>
<td></td>
<td>myCom</td>
<td>错误</td>
</tr>
<tr>
<td></td>
<td>My-Com</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>My-com</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>my-com</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>my-Com</td>
<td>对</td>
</tr>
<tr>
<td>My_Com</td>
<td>My_Com</td>
<td>错误</td>
</tr>
<tr>
<td></td>
<td>my_Com</td>
<td>错误</td>
</tr>
<tr>
<td></td>
<td>my_com</td>
<td>错误</td>
</tr>
<tr>
<td></td>
<td>My_com</td>
<td>错误</td>
</tr>
<tr>
<td></td>
<td>my_-com</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>My_-Com</td>
<td>对</td>
</tr>
<tr>
<td>My_com</td>
<td>my_com</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>my_Com</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>My_Com</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>My_com</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>my_com</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>my_Com</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>My_Com</td>
<td>对</td>
</tr>
<tr>
<td></td>
<td>My_com</td>
<td>对</td>
</tr>
</tbody></table>
<h3 id="4-功能脚本思路"><a href="#4-功能脚本思路" class="headerlink" title="4.功能脚本思路"></a>4.功能脚本思路</h3><h4 id="4-1-打包"><a href="#4-1-打包" class="headerlink" title="4.1 打包"></a>4.1 打包</h4><p>先贴一下当前打包的配置<code>vite.config.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> vueJsx <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue-jsx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; resolve &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>(), <span class="title function_">vueJsx</span>()],</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">dedupe</span>: [<span class="string">&#x27;vue&#x27;</span>],</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">postcss</span>: &#123;</span><br><span class="line">      <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;postcss-px-to-viewport&#x27;</span>)(&#123;</span><br><span class="line">          <span class="attr">viewportWidth</span>: <span class="number">1080</span>,</span><br><span class="line">          <span class="attr">viewportUnit</span>: <span class="string">&#x27;vw&#x27;</span>,</span><br><span class="line">          <span class="attr">minPixelValue</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">decimal</span>: <span class="number">3</span>,</span><br><span class="line">          <span class="attr">exclude</span>: <span class="regexp">/node_modules/i</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">lib</span>: &#123;</span><br><span class="line">      <span class="attr">entry</span>: <span class="string">&#x27;./src/componments/index.ts&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;XUI&#x27;</span>,</span><br><span class="line">      <span class="attr">fileName</span>: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">      <span class="attr">formats</span>: [<span class="string">&#x27;es&#x27;</span>, <span class="string">&#x27;umd&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">outDir</span>: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在打包时主要就是<code>build</code>里面的配置在生效，我需要做的有以下几件事：</p>
<ol>
<li>将 build 抽离出来，使用打包命令时才给<code>vite config</code>加上这些配置。</li>
<li>在打包后生成<code>package.json</code>文件，配置一下。</li>
</ol>
<p>看了大佬的代码之后，学到一个比较好的思想，就是把一些比较基础的功能抽离出来，单独抽成<code>base.config.js</code>，这样以后打包有什么拓展可以都把这个 base 配置直接引入就好了。</p>
<h3 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h3><h4 id="2021-11-12"><a href="#2021-11-12" class="headerlink" title="2021.11.12"></a>2021.11.12</h4><p>确定技术选型，写一个 button 组件。</p>
<p>大概明白了 props 的类型咋写。</p>
<h4 id="2021-11-15"><a href="#2021-11-15" class="headerlink" title="2021.11.15"></a>2021.11.15</h4><p>button 组件功能基本实现，整个过程思考了 props 如何传值，slot 如何插入值，各个功能用 sass 如何用最少的代码实现。下一步的任务是如何封装成组件。然后思考打包过程。</p>
<h4 id="2021-11-17"><a href="#2021-11-17" class="headerlink" title="2021.11.17"></a>2021.11.17</h4><p>有点蒙圈，遇到了两个问题，真的是，查都不知道怎么查，冷静。</p>
<p>现在应该做的是：</p>
<p>1.明确自己要做什么</p>
<p>要做的事情：</p>
<p>​ 1.解决声明文件问题。</p>
<p>​ 2.解决找不到文件的问题。</p>
<p>​ 3.看怎么打包才是更合理的方式，优化打包方案。 // 有方案 待实践</p>
<p>2.遇到的问题是什么</p>
<p>​ 1.不会写 typings</p>
<p>​ 2.不知道怎么打包 typings</p>
<p>问题解决，开心。</p>
<h4 id="2021-11-18"><a href="#2021-11-18" class="headerlink" title="2021.11.18"></a>2021.11.18</h4><p>思考一下接下来的方向和要做的事情：</p>
<ol>
<li><p>把工程化的功能，比如打包命令，和脚本单独放一个文件夹方便管理。</p>
</li>
<li><p>打包，可以把打包 配置/命令 单独封装一下。</p>
</li>
<li><p>写一个小脚本，可以一键生成组件文件夹，免去重复工作。</p>
</li>
<li><p>考虑一下文档生成的功能。</p>
</li>
</ol>
<p>目前就这几点目标，优先级从上到下挨个实现一下。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>工作相关记录</title>
    <url>/2021/11/18/20211118-work3/</url>
    <content><![CDATA[<p>此篇博客用来记录工作中遇到的的问题以及解决方案。</p>
<span id="more"></span>

<h4 id="1-axios发送raw格式的请求"><a href="#1-axios发送raw格式的请求" class="headerlink" title="1.axios发送raw格式的请求"></a>1.axios发送raw格式的请求</h4><p>请求中将headers进行如下配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">raw</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> baseurl = <span class="string">&quot;//dqtwdd.top&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">      <span class="attr">headers</span>: &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance.<span class="title function_">post</span>(</span><br><span class="line">      baseurl + <span class="string">&quot;/raw&quot;</span>,</span><br><span class="line">      params</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>params</code>需要传字符串但是后端不能有引号的话就用<code>replaceAll</code>方法直接把引号给过滤掉。</p>
<h3 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2.命名规范"></a>2.命名规范</h3><ol>
<li>变量 驼峰命名 比如： testQuery</li>
<li>Boolean类型 以<code>is</code>开头 比如：isShow isVisible</li>
<li>方法尽量以动词开头，尽量使用on和handle两个单词，其中onXx代表主动处理</li>
</ol>
<h3 id="3-编码解码"><a href="#3-编码解码" class="headerlink" title="3.编码解码"></a>3.编码解码</h3><h4 id="3-1url编码"><a href="#3-1url编码" class="headerlink" title="3.1url编码"></a>3.1url编码</h4><p>js中有三种URL编码的方法：</p>
<p><code>encodeURIComponent() </code>【推荐】 解码方法：<code>unencodeURIComponent()</code><br>使用场景：对url中的参数进行编码<br>不编码的字符： ~!*()</p>
<p><code>encodeURI()</code> 解码方法：<code>unencodeURI()</code><br>使用场景：对整个url进行编码<br>不编码的字符： ~!@#@{content}*()=:/,;?+’</p>
<p><code>escape()</code> 【不推荐】 解码方法：<code>unescape()</code><br>不编码的字符：@*/+<br>在用户提交的表单字段中，如果有空格，则会被转化为+字符，而服务器解析的时候则会认为+号代表空格。由于这个缺陷，应当尽量避免使用escape方法。</p>
<h4 id="3-2utf-8-utf-16"><a href="#3-2utf-8-utf-16" class="headerlink" title="3.2utf-8/utf-16"></a>3.2utf-8/utf-16</h4><p>用<code>\u</code>开头的是utf-8编码方式。可以使用<code>document.write()</code>来展示内容。</p>
<h3 id="4-位运算"><a href="#4-位运算" class="headerlink" title="4.位运算"></a>4.位运算</h3><p>位运算：在计算机内部，一切运算都最终转化为二进制运算，直接使用二进制执行小路最高，即位运算。</p>
<h4 id="4-1位与（-amp-）用于判断奇偶"><a href="#4-1位与（-amp-）用于判断奇偶" class="headerlink" title="4.1位与（&amp;）用于判断奇偶"></a>4.1位与（&amp;）用于判断奇偶</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 9和10二进制位与运算</span></span><br><span class="line"></span><br><span class="line">      <span class="number">1001</span></span><br><span class="line">    &amp; <span class="number">1010</span></span><br><span class="line">    -------</span><br><span class="line">      <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>由于奇数的二进制末尾位1，偶数为0，和1的位与运算后，分别为1和0，因此可以用来判断奇偶。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;n为奇数&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;n为偶数&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-位或（-）用于取整，用于判断大数字"><a href="#4-2-位或（-）用于取整，用于判断大数字" class="headerlink" title="4.2 位或（|）用于取整，用于判断大数字"></a>4.2 位或（|）用于取整，用于判断大数字</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 9和10二进制位或运算</span></span><br><span class="line"></span><br><span class="line">      <span class="number">1001</span></span><br><span class="line">    | <span class="number">1010</span></span><br><span class="line">    -------</span><br><span class="line">      <span class="number">1011</span></span><br></pre></td></tr></table></figure>

<p>整数与0的位或运算，都是本身。浮点数不支持位运算，过程中会自动转化为整数，利用这一点，可以将浮点数转化为整数（向下取整）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">15.22</span> | <span class="number">0</span>); <span class="comment">// 15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">15.99</span> | <span class="number">0</span>); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>超过 32 位的有符号整数的范围 <code>[−2^31, 2^(31 − 1)]</code>的数字，与<code>0</code>做位或运算可以用于判断是否超过范围。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1234</span>|<span class="number">0</span> <span class="comment">// 1234</span></span><br><span class="line"><span class="number">12345678901</span>|<span class="number">0</span> <span class="comment">// -539222987</span></span><br><span class="line"><span class="number">2147483648</span>|<span class="number">0</span> <span class="comment">// -2147483648</span></span><br><span class="line"><span class="number">2147483647</span>|<span class="number">0</span> <span class="comment">// 2147483647</span></span><br></pre></td></tr></table></figure>



<h4 id="4-3位非（-）用于string转数字"><a href="#4-3位非（-）用于string转数字" class="headerlink" title="4.3位非（~）用于string转数字"></a>4.3位非（~）用于string转数字</h4><p>按位非运算时，任何数字x的运算结果都是<code>-(x+1)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">~<span class="number">0</span>;  <span class="comment">// -1</span></span><br><span class="line">~-<span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line">~<span class="number">1</span>;  <span class="comment">// -2</span></span><br><span class="line">~-<span class="number">2</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>可以用两个按位非来将<code>string</code>转为数字。比用<code>srting * 1</code>这种方式高级一些。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">~~<span class="string">&#x27;1&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line">~~<span class="string">&#x27;-1&#x27;</span>; <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，这种方法会将带有小数的数字取整，并且大数会有问题。</p>
<h3 id="5-大数加法"><a href="#5-大数加法" class="headerlink" title="5.大数加法"></a>5.大数加法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumStrings</span>(<span class="params">a,b</span>)&#123; <span class="comment">// 参数a,b都是string格式</span></span><br><span class="line">  <span class="keyword">let</span> res=<span class="string">&#x27;&#x27;</span>, c=<span class="number">0</span>; <span class="comment">// 定义string格式结果 res,c作为进位(carry)</span></span><br><span class="line">  a = a.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// a分割为数组</span></span><br><span class="line">  b = b.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// b分割为数组</span></span><br><span class="line">  <span class="keyword">while</span> (a.<span class="property">length</span> || b.<span class="property">length</span> || c)&#123; <span class="comment">// 当a的长度大于0 或者 b的长度大于0 或 有进位的话 进行循环</span></span><br><span class="line">      c += ~~a.<span class="title function_">pop</span>() + ~~b.<span class="title function_">pop</span>(); <span class="comment">// 取a的最后一个 取b的最后一个 转为数字格式 ~~undefined 为0 c为两数相加的结果。</span></span><br><span class="line">      res = c % <span class="number">10</span> + res; <span class="comment">// c取余，以字符串的方式和前面的拼接到一起</span></span><br><span class="line">      c = c&gt;<span class="number">9</span>; <span class="comment">// c&gt;9的话记录进位,c&gt;9为true的话c=1，c&gt;9为false的话c=0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">replace</span>(<span class="regexp">/^0+/</span>,<span class="string">&#x27;&#x27;</span>); <span class="comment">// 过滤前面的0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-图片去除防盗链"><a href="#6-图片去除防盗链" class="headerlink" title="6. 图片去除防盗链"></a>6. 图片去除防盗链</h3><p>img 里面加 <code>referrerpolicy=&quot;no-referrer&quot;</code></p>
<h3 id="7-html-vue"><a href="#7-html-vue" class="headerlink" title="7.html-vue"></a>7.html-vue</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">class</span>=<span class="string">&quot;main-content&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/js/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>链表算法合集</title>
    <url>/2021/12/07/20211207-lists/</url>
    <content><![CDATA[<p>链表算法合集</p>
<span id="more"></span>

<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例 1：</p>
<p>输入：l1 = [1,2,4], l2 = [1,3,4]<br>输出：[1,1,2,3,4,4]</p>
<p>示例 2：</p>
<p>输入：l1 = [], l2 = []<br>输出：[]</p>
<p>示例 3：</p>
<p>输入：l1 = [], l2 = [0]<br>输出：[0]</p>
<p>首先明确一下链表，链表在js中的表现形式类似于对象，具体描述：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表的节点 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ListNode</span>(<span class="params">val, next</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">val</span> = (val===<span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">next</span> = (next===<span class="literal">undefined</span> ? <span class="literal">null</span> : next)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>每一个链表都是这样一个一个节点组合成的。我们假设一个链表<code>l1=[1,2,3,4]</code>，则可以表示为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(l1.<span class="property">val</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(l1.<span class="property">next</span>); <span class="comment">// obj</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(l1.<span class="property">next</span>.<span class="property">val</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>做题大概了解到这样就ok。</p>
<p>接下来本题解法的核心思路就是递归，如果<code>l1</code>的值比较小就拿<code>l1.next</code>的值和<code>l2</code>的当前值比较，如果<code>l2</code>的当前值比较小就拿<code>l1</code>的当前值和<code>l2.next</code>比较。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">list1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">list2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="keyword">function</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (l1 === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> l2</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.<span class="property">val</span> &lt; l2.<span class="property">val</span>) &#123;</span><br><span class="line">    l1.<span class="property">next</span> = <span class="title function_">mergeTwoLists</span>(l1.<span class="property">next</span>,l2)</span><br><span class="line">    <span class="comment">// 递归时的l1/l2相当于上一层的l1.next，所以直接返回</span></span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    l2.<span class="property">next</span> = <span class="title function_">mergeTwoLists</span>(l1,l2.<span class="property">next</span>)</span><br><span class="line">    <span class="keyword">return</span> l2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="环形链"><a href="#环形链" class="headerlink" title="环形链"></a>环形链</h3><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。 </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> hasCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">get</span>(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(head,<span class="literal">true</span>)</span><br><span class="line">            head = head.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h4><p>难度简单1464收藏分享切换为英文接收动态反馈</p>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>自定义评测：</strong></p>
<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>
<ul>
<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>
<li><code>listA</code> - 第一个链表</li>
<li><code>listB</code> - 第二个链表</li>
<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>
<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li><code>1 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>
</ul>
<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headA</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headB</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">while</span> (headA) &#123;</span><br><span class="line">        map.<span class="title function_">set</span>(headA,<span class="literal">true</span>)</span><br><span class="line">        headA = headA.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">get</span>(headB)) &#123;<span class="keyword">return</span> headB&#125;</span><br><span class="line">        headB = headB.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。 </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p>题解：本题的奥义，在于反复横跳。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = curr.<span class="property">next</span>;</span><br><span class="line">    curr.<span class="property">next</span> = pre;</span><br><span class="line">    pre = curr;</span><br><span class="line">    curr = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围<code>[1, 105]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(head.<span class="property">val</span>)</span><br><span class="line">        head = head.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === j || j-i===<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i+=<span class="number">1</span>;</span><br><span class="line">        j-=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<p>此题需要考虑一下大数相加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 菜菜的方法1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getNum</span>(<span class="params">li</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> (li) &#123;</span><br><span class="line">            res = li.<span class="property">val</span> + res</span><br><span class="line">            li = li.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> l1Num = <span class="title function_">getNum</span>(l1)</span><br><span class="line">    <span class="keyword">let</span> l2Num = <span class="title function_">getNum</span>(l2)</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a ,b</span>)&#123;</span><br><span class="line">   <span class="comment">//取两个数字的最大长度</span></span><br><span class="line">   <span class="keyword">let</span> maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(a.<span class="property">length</span>, b.<span class="property">length</span>);</span><br><span class="line">   <span class="comment">//用0去补齐长度</span></span><br><span class="line">    a = a.<span class="title function_">padStart</span>(maxLength , <span class="number">0</span>);<span class="comment">//&quot;0009007199254740991&quot;</span></span><br><span class="line">    b = b.<span class="title function_">padStart</span>(maxLength , <span class="number">0</span>);<span class="comment">//&quot;1234567899999999999&quot;</span></span><br><span class="line">    <span class="comment">//定义加法过程中需要用到的变量</span></span><br><span class="line">    <span class="keyword">let</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> f = <span class="number">0</span>;   <span class="comment">//&quot;进位&quot;</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=maxLength-<span class="number">1</span> ; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">        t = <span class="built_in">parseInt</span>(a[i]) + <span class="built_in">parseInt</span>(b[i]) + f;</span><br><span class="line">        f = <span class="title class_">Math</span>.<span class="title function_">floor</span>(t/<span class="number">10</span>);</span><br><span class="line">        sum = t%<span class="number">10</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f == <span class="number">1</span>)&#123;</span><br><span class="line">        sum = <span class="string">&quot;1&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title function_">add</span>(l1Num,l2Num)</span><br><span class="line">    <span class="keyword">let</span> resStr = res.<span class="title function_">toString</span>()</span><br><span class="line">    <span class="keyword">let</span> resLi = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> strLen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (strLen &lt; resStr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = &#123;&#125;</span><br><span class="line">        curr.<span class="property">next</span> = resLi</span><br><span class="line">        curr.<span class="property">val</span> = resStr[strLen]*<span class="number">1</span></span><br><span class="line">        resLi = curr</span><br><span class="line">        strLen++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resLi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 棒棒的方法2</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="keyword">function</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> c = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || c&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        c += (l1?l1.<span class="property">val</span>:<span class="number">0</span>) + (l2?l2.<span class="property">val</span>:<span class="number">0</span>) </span><br><span class="line">        res = c%<span class="number">10</span> + res</span><br><span class="line">        l1 = l1?l1.<span class="property">next</span>:<span class="literal">null</span></span><br><span class="line">        l2 = l2?l2.<span class="property">next</span>:<span class="literal">null</span></span><br><span class="line">        c = c&gt;<span class="number">9</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = res.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> resList = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (res.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = &#123;&#125; </span><br><span class="line">        curr.<span class="property">val</span> = res.<span class="title function_">shift</span>()</span><br><span class="line">        curr.<span class="property">next</span> = resList</span><br><span class="line">        resList = curr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resList</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树算法合集</title>
    <url>/2021/12/08/20211208-2tree/</url>
    <content><![CDATA[<p>二叉树算法合集</p>
<span id="more"></span>

<h3 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h3><p>中序遍历：左根右</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> inorder = <span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">    <span class="title function_">inorder</span>(root.<span class="property">left</span>)</span><br><span class="line">    res.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">    <span class="title function_">inorder</span>(root.<span class="property">right</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">inorder</span>(root)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h3><p>前序遍历：根左右</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> preorder = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">    res.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">    <span class="title function_">preorder</span>(root.<span class="property">left</span>)</span><br><span class="line">    <span class="title function_">preorder</span>(root.<span class="property">right</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">preorder</span>(root)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h3><p>后序遍历：左右根</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> postorder = <span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">    <span class="title function_">postorder</span>(root.<span class="property">left</span>)</span><br><span class="line">    <span class="title function_">postorder</span>(root.<span class="property">right</span>)</span><br><span class="line">    res.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">postorder</span>(root)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> leftNum = <span class="title function_">maxDepth</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="keyword">let</span> rightNum = <span class="title function_">maxDepth</span>(root.<span class="property">right</span>);</span><br><span class="line">  res = <span class="title class_">Math</span>.<span class="title function_">max</span>(leftNum,rightNum) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p>难度简单1649收藏分享切换为英文接收动态反馈</p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3 </span><br></pre></td></tr></table></figure>

<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> isSymmetric = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> compare = <span class="keyword">function</span> (<span class="params">p,q</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> p.<span class="property">val</span> === q.<span class="property">val</span> &amp;&amp; <span class="title function_">compare</span>(p.<span class="property">left</span>,q.<span class="property">right</span>) &amp;&amp; <span class="title function_">compare</span>(p.<span class="property">right</span>,q.<span class="property">left</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">compare</span>(root.<span class="property">left</span>,root.<span class="property">right</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h3><p>翻转一棵二叉树。</p>
<p><strong>示例：</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">let</span> leftTemp = root.<span class="property">left</span></span><br><span class="line">    root.<span class="property">left</span> = root.<span class="property">right</span></span><br><span class="line">    root.<span class="property">right</span> = leftTemp</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">left</span>) <span class="title function_">invertTree</span>(root.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">right</span>) <span class="title function_">invertTree</span>(root.<span class="property">right</span>) </span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>最小栈</title>
    <url>/2021/12/13/20211213-min-stack/</url>
    <content><![CDATA[<p>设计一个能返回最小值的栈</p>
<span id="more"></span>

<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li><code>push(x)</code> —— 将元素 x 推入栈中。</li>
<li><code>pop()</code> —— 删除栈顶的元素。</li>
<li><code>top()</code> —— 获取栈顶元素。</li>
<li><code>getMin()</code> —— 检索栈中的最小元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MinStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">minList</span> = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="variable language_">this</span>.<span class="property">minList</span>[<span class="variable language_">this</span>.<span class="property">minList</span>.<span class="property">length</span>-<span class="number">1</span>] || <span class="variable language_">this</span>.<span class="property">minList</span>[<span class="variable language_">this</span>.<span class="property">minList</span>.<span class="property">length</span>-<span class="number">1</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">minList</span>.<span class="title function_">push</span>(val)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">minList</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">minList</span>[<span class="variable language_">this</span>.<span class="property">minList</span>.<span class="property">length</span>-<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">push</span>(val)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">minList</span>.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span>-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMin</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">minList</span>[<span class="variable language_">this</span>.<span class="property">minList</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MinStack()</span></span><br><span class="line"><span class="comment"> * obj.push(val)</span></span><br><span class="line"><span class="comment"> * obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.getMin()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针算法合集</title>
    <url>/2021/12/21/20211221-double-pointer/</url>
    <content><![CDATA[<p>双指针算法合集。</p>
<span id="more"></span>

<h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h3><p>给你 <code>n</code> 个非负整数 <code>a1，a2，...，a``n</code>，每个数代表坐标中的一个点 <code>(i, ai)</code> 。在坐标内画 <code>n</code> 条垂直线，垂直线 <code>i</code> 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code> 。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明：</strong>你不能倾斜容器。 </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [4,3,2,1,4]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,2,1]</span><br><span class="line">输出：2 </span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= height[i] &lt;= 104</code></li>
</ul>
<p>从最两边往中间走，哪边比较小哪边往中间走，直到左右两边指针重合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">height</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> right = height.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (left !== right) &#123;</span><br><span class="line">    <span class="keyword">let</span> curr = (right - left) * <span class="title class_">Math</span>.<span class="title function_">min</span>(height[left],height[right])</span><br><span class="line">    <span class="keyword">if</span> (curr&gt;max) &#123;</span><br><span class="line">      max = curr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (height[left]&lt;height[right]) &#123;</span><br><span class="line">      left += <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.<span class="property">length</span></span><br><span class="line">  <span class="keyword">if</span> (len&lt;<span class="number">3</span>) <span class="keyword">return</span> [] <span class="comment">// 长度不足3个直接返回</span></span><br><span class="line">  nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;<span class="keyword">return</span> a-b&#125;) <span class="comment">// 排序一下</span></span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> L = i+<span class="number">1</span> <span class="comment">// 左指针</span></span><br><span class="line">    <span class="keyword">let</span> R = len-<span class="number">1</span> <span class="comment">// 右指针</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span> <span class="comment">// 排序后如果当前值大于0后面的一定比0大，直接跳出循环</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i-<span class="number">1</span>]) <span class="keyword">continue</span> <span class="comment">// 当前值如果之前有过的话直接跳过，去重</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123; <span class="comment">//当左指针右指针不重合时循环</span></span><br><span class="line">      <span class="keyword">let</span> <span class="variable constant_">SUM</span> = nums[i] + nums[L] + nums[R] <span class="comment">// 记和</span></span><br><span class="line">    	<span class="keyword">if</span> (<span class="variable constant_">SUM</span> === <span class="number">0</span>) &#123; <span class="comment">// 如果和为0时</span></span><br><span class="line">        res.<span class="title function_">push</span>([nums[i],nums[L],nums[R]]) <span class="comment">// 将答案push进答案数组</span></span><br><span class="line">        <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] === nums[L+<span class="number">1</span>]) L++ <span class="comment">// 当左指针的下一个和当前左指针的值相等，左指针右移，去重</span></span><br><span class="line">        <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] === nums[R-<span class="number">1</span>]) R-- <span class="comment">// 当右指针的前一个和当前右指针的值相等，右指针左移，去重</span></span><br><span class="line">        L++ <span class="comment">// 左指针移动</span></span><br><span class="line">        R-- <span class="comment">// 右指针移动</span></span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable constant_">SUM</span> &lt; <span class="number">0</span>) L++ <span class="comment">// 当和小于0时，说明总体小了，左指针右移</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable constant_">SUM</span> &gt; <span class="number">0</span>) R-- <span class="comment">// 当和大于0时，说明总体大了，右指针左移</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法合集</title>
    <url>/2021/12/23/20211223-back-track/</url>
    <content><![CDATA[<p>回溯算法合集。</p>
<span id="more"></span>

<h3 id="回溯算法模版"><a href="#回溯算法模版" class="headerlink" title="回溯算法模版"></a>回溯算法模版</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">backtrack</span> (list,used) &#123;</span><br><span class="line">  <span class="keyword">if</span> (判断保存结果条件) &#123;</span><br><span class="line">    保存结果</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (横向遍历) &#123;</span><br><span class="line">    <span class="keyword">if</span> (判断条件) &#123;剪枝&#125;</span><br><span class="line">    处理节点</span><br><span class="line">    <span class="title function_">backtrack</span>() <span class="comment">// 递归 深度遍历</span></span><br><span class="line">    回溯撤销处理结果</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= digits.length &lt;= 4</code></li>
<li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">digits</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> letterCombinations = <span class="keyword">function</span> (<span class="params">digits</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (digits.<span class="property">length</span> &lt; <span class="number">1</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> numLetterList = &#123;</span><br><span class="line">    <span class="number">2</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">    <span class="number">3</span>: [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>],</span><br><span class="line">    <span class="number">4</span>: [<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>],</span><br><span class="line">    <span class="number">5</span>: [<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>],</span><br><span class="line">    <span class="number">6</span>: [<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>],</span><br><span class="line">    <span class="number">7</span>: [<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>],</span><br><span class="line">    <span class="number">8</span>: [<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>],</span><br><span class="line">    <span class="number">9</span>: [<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">  resList = [];</span><br><span class="line">  digits = digits.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  digits.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    resList.<span class="title function_">push</span>(numLetterList[item]);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> path = [];</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">backTrack</span>(<span class="params">list, used</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">length</span> === resList.<span class="property">length</span>) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(path.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="regexp">/,/g</span>, <span class="string">&#x27;&#x27;</span>))));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (used &gt; i) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; list[i].<span class="property">length</span>; j++) &#123;</span><br><span class="line">        path.<span class="title function_">push</span>(list[i][j]);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="title function_">backTrack</span>(list, i);</span><br><span class="line">        i--;</span><br><span class="line">        path.<span class="title function_">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">backTrack</span>(resList, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span> (<span class="params">head, n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> start = head;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (head) &#123;</span><br><span class="line">    map.<span class="title function_">set</span>(index, head);</span><br><span class="line">    head = head.<span class="property">next</span>;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> pre = map.<span class="title function_">get</span>(index - n-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> next = map.<span class="title function_">get</span>(index - n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (pre&amp;&amp;next) &#123;</span><br><span class="line">      pre.<span class="property">next</span> = next</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next) &#123;</span><br><span class="line">      start = next</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre) &#123;</span><br><span class="line">      pre.<span class="property">next</span> = <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      start = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> start</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>养鱼笔记</title>
    <url>/2021/12/29/20211229-fish/</url>
    <content><![CDATA[<p>养鱼笔记</p>
<span id="more"></span>

<h3 id="1-大佬的干货"><a href="#1-大佬的干货" class="headerlink" title="1. 大佬的干货"></a>1. 大佬的干货</h3><p>1、合适的条件可生长至10厘米以上<br>2、根据花纹形态，常见品种有圆斑点、不规则斑点、大斑点、碎花斑点，少部分品种嘴巴无斑点，尾巴有花纹，眼睛有蓝或绿色<br>3、小的时候休息喜卷尾，多数时候沉在水底，有时也漂浮在水中<br>4、休息时、睡觉时整个身体会发黑，游动起来后恢复正常<br>5、后背有荧光绿色和偏暗淡的黄色，斑点黑色清晰，如果斑点变浅甚至模糊，预示状态不佳，有挂掉的可能<br>6、不吃饲料，可喂（冻）红虫，白蛤（花蛤浑水厉害），螺，小活虾，虾干，虾仁……<br>7、新环境中喜上下窜游，鱼友爱称“刷缸”<br>8、水温24~28度，含氧量丰富，可每周换部分水<br>9、加海盐，比较随意，首次多加一些，以后换水时根据换水量抓一把盐，光学盐度计比较精准，比重1.005到1.025根据体长逐量添加即可<br>10、能吃能拉，（肉类食物）水质易败坏，需要配备强大的过滤系统来保证水质稳定，建议滴流配滤材<br>11、对水质要求较高，水体尽可能大，这样水质更易稳定，建议40厘米以上长或方缸<br>12、离水后会鼓气成圆球，样子十分萌<br>13、易发生白点病、烂尾、缩鳃、内外寄，看情况治疗，或及时捞出隔离或换鱼即可<br>14、一定要加盖子，是跳高高手，离水20分钟内放入水中可活<br>15、可用珊瑚死石造景，同时增加水体碱性<br>16、过滤不强的，最好不要底沙，残渣残留严重，水质易坏<br>17、个别个体喜追逐或啃咬其他鱼，包括同类，鱼龙爱称“王者争霸”<br>18、不要总喂到撑，适当饿一天，如遇拖便，饿它一两天会好，如不好继续少喂加饿，直到好或挂掉换鱼<br>19、如果生病要用药，就要做好挂掉换鱼的准备<br>20、出现趴缸呼吸急促可能是腮生病或水质出现异常，尝试改善水质或等死换鱼<br>21、改善水质的常用办法：增大水体或加强过滤</p>
<h3 id="2-超白缸鉴定"><a href="#2-超白缸鉴定" class="headerlink" title="2. 超白缸鉴定"></a>2. 超白缸鉴定</h3><p>超白玻璃也叫低铁玻璃，以其无与伦比的通透性深得广大鱼友喜爱。尤其是在灯光下显示出来的水晶般的质感将鱼儿艳丽的色彩表现的非常到位，是草缸、海缸的不二之选。随着超白玻璃鱼缸的热卖，一些js利用小盆友对超白玻璃的性质盲区进行欺诈，以普通玻璃中透光较好的冒充超白销售。为了不让小盆友们上当受骗，我教大家一个最简单的超白玻璃鉴别方法，如下：拿一张带字的纸、报纸都可以，把有字的纸贴靠在鱼缸玻璃的横截面上，然后从对着的另一截面看，如果能清晰的看到纸上的字这就是超白，就是四米长的都可以看到。如果看到的只是一片绿或蓝，这肯定不是超白玻璃。</p>
<h3 id="3-水体计算、加盐"><a href="#3-水体计算、加盐" class="headerlink" title="3. 水体计算、加盐"></a>3. 水体计算、加盐</h3><p><strong>水体测量：</strong><br>首先是很多新人都在问的如何测量水体，如何加盐的问题。<br>水体测量其实很简单，以分米为单位，将鱼缸的长、宽内径（去掉玻璃厚度）及水位高度相乘，即可算出水体，即自己的缸有多少升水。如：本人艇缸为40cm方形缸，玻璃厚越5mm，水位约35cm，那么除去玻璃厚度后，水体约为：3.9X3.9X3.5 = 53.235L 。</p>
<p><strong>下盐、比重：</strong><br>然后是加盐问题，想要潜水艇出状态，必须加盐，因为潜水艇天生就是汽水鱼。不能使用食用盐,因为含有碘，从3元的海盐精到30元的观赏鱼专用盐我都用过，效果都还行，这里就直接建议3元的海盐精，性价比高。说到加盐就必须先说明一下比重概念，新手经常不明白老手说的1.008、1.010这些数字的含义，简单的说你可以将这个数字分成两部分：例如1.008分解成1和8，1.010分解成1和10，然后1.008理解成1升水含盐8克、1.010理解为1升水含盐10g。<br>了解了上述概念后，可依据下面的推荐比重加盐：<br>小艇长度2-4cm，比重1.005左右；<br>小艇长度4-8cm，比重1.010左右；<br>小艇长度8cm以上，比重1.015左右；</p>
<p>自己家小缸30*17*20 水位按15算，总共是7.65L左右，按照1.005算需要不到40g，可乐瓶盖大概6～7盖。</p>
<p>那么很多新人可能又会问，我没有比重计，无法知道我加了多少盐！这里提供一个粗略的加盐方法，用普通600ml的可乐瓶盖（当然不一定得是可乐），装满一瓶盖盐，稍微压实，齐平，大概是6-8g盐。</p>
<p>那么这里再用我的40方缸做个例子，上面已经算出了此缸水体大约为53升，如果按照1.008的比重加盐需要53*8 = 424g盐，我们加入的盐都不是纯盐，有一定杂质，所以应该加入的盐应大约应该为450g。（我是直接将一包500g包装的盐加完了，最后使用光学比重计测得比重在1.008多一点）<br>需要注意的一点是加盐时不能将盐直接加入缸中，应该使用另外的容器先将盐溶解，再缓慢倒入缸中。</p>
<p>硬度、PH值：<br>简单的说，小艇喜欢弱碱性硬水，PH范围7.5-9，如果没有专业设备这两个指标不用容易测量，但是我们可以通过底砂、石头、滤材来调整水的硬度及酸碱性。<br>首先是不推荐的底砂、石头、滤材：<br>1.水草，大多数水草会降低水的硬度和PH值，除非你的艇缸PH值较高，否则不要添加。<br>2.活性炭，理由同上。<br>3.黑金沙、水草泥，理由同上。<br>4.火山岩，理由同上。</p>
<p>推荐的底砂、石头、滤材：<br>1.菲律宾砂、贝壳沙、珊瑚砂，这些底砂都可以提高水的硬度和PH值。<br>2.珊瑚骨、青龙石作为造景不错。</p>
<p>如果你的艇缸出现下列情况，请考虑你的PH值是否符合潜水艇的要求：<br>1.有绿藻，出现绿水现象，PH偏低。<br>2.鱼缸内没有碱性物品，还放置了酸性物品。</p>
<p>原则上艇缸不推荐底砂，特别是对于新手，小艇能吃能拉，底砂会沉积便便和食物残渣影响水质。</p>
<p>温度、鱼缸要求：<br>潜水艇喜欢24度-28度的水温，水温不能高于34度，5cm以下的小艇需要每条10L左右的空间，饲养小艇不要使用圆形鱼缸。</p>
<h3 id="4-小艇开食、合理喂食、健康饮食"><a href="#4-小艇开食、合理喂食、健康饮食" class="headerlink" title="4.小艇开食、合理喂食、健康饮食"></a>4.小艇开食、合理喂食、健康饮食</h3><p>潜水艇一般情况下是不会吃任何饲料的，萌萌的潜水艇是吃荤的，小鱼、小虾、小螺、水生小虫都是他们的最爱。人吃的东西最好不要喂他们！吃荤的潜水艇消化系统并不算强大，吃得过多、不易消化、不干净的食物后，很容易引发肠炎、便秘等肠胃问题，这些问题处理不当很容易让潜水艇去陪马克思喝茶。</p>
<p>首先是开食问题：<br>有了良好的饲养环境，小艇们开始游来游去，下一步就是要让他们开始吃东西了，这里首要推荐的开口食物为冰冻红虫，喂前用容器将东红虫划开，用镊子或牙签将颜色鲜艳、饱满的红虫夹到缸中，切记不可将未化开的东红虫块扔进缸中或者将化开的红虫直接倒入缸中！第一次开食80%需要你将红虫夹到小艇嘴边，重复几次后，小艇就会主动吃落入缸中的红虫了。喂食几天之后，只要你靠近艇缸，小艇们就会围过来卖萌找你要吃的。</p>
<p>只要小艇们会围过来找你要吃的了，这时就可以喂一些其他食物，如虾干、虾皮、冻虾、小鱼等，期间也应该经常喂红虫，已达到营养均衡。以上食物需要注意的是，虾干喂之前应用热水泡开；冻虾由于一般块头都比较大，应该剪下适当大小，充分化开后喂食；活鱼活虾最好要过疫检后再喂！</p>
<p>合理饮食：<br>小艇的食物应该多样化，以上食物要经常交替喂食。<br>每次喂食应该注意不要喂得太多，8成饱就够了，差不多就是潜水艇肚子微微突起，如果你发现潜水艇的肚子都涨变形了！那就是喂得太多！潜水艇这货肠胃不行却是个十足的吃货，不吃到12分饱是不会停止在你面前卖萌要饭的，很多主人忍不住就喂多了，最后却是害了他们！<br>未吃完的食物残渣应该即使捞出来，以免污染水质。</p>
<h3 id="5-鉴定艇和怪"><a href="#5-鉴定艇和怪" class="headerlink" title="5.鉴定艇和怪"></a>5.鉴定艇和怪</h3><table>
<thead>
<tr>
<th>艇</th>
<th>怪</th>
</tr>
</thead>
<tbody><tr>
<td>尾巴有白白的，透明</td>
<td>尾巴有花纹</td>
</tr>
<tr>
<td>直背</td>
<td>驼背</td>
</tr>
<tr>
<td>嘴上有花纹</td>
<td>嘴上无花纹</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>潜水艇</tag>
      </tags>
  </entry>
  <entry>
    <title>项目优化</title>
    <url>/2022/02/17/20220217-pro/</url>
    <content><![CDATA[<p>手头的一个比较老的项目，打包极慢，用了分析工具之后发现问题还挺多，所以做了一些优化，在此记录一下。</p>
<span id="more"></span>

<p>优化前分析：</p>
<p><img src="https://dqtwdd.top/cdn/img/gongbu_beforeOpt.jpg" alt="beforeOpt"></p>
<p>优化前时间：</p>
<p><img src="https://dqtwdd.top/cdn/img/gongbu_time_before_build.jpg" alt="gongbu_time_before_build"></p>
<p>通过分析图可以很明显的看出来打包后的问题还是比较大的，首先很多文件里都打包了<code>echart</code>，这样打包出来有很多重复的文件，不太好，另外还有一个<code>region.js</code>也是被打包了多次，就从这两个方向入手。</p>
<p>在开始优化时，我首先想到的就是以前的经验使用<code>splitChunk</code>分割，可是配置了之后发现不生效，简单排查了一下，发现是由于项目比较老，使用的还是<code>webpack3</code>，而<code>splitChunk</code>是在<code>webpack4</code>才开始支持的。</p>
<p>然后查了<code>webpack3</code>的代码分割，发现使用的是<code>CommonsChunkPlugin</code>，从网上查了一下，简单配置之后发现不太对，仔细看了文档，发现这个插件主要是用来分割多入口的公共文件。</p>
<p>经过一系列调查之后发现一个比较简单的抽离方案，把<code>echart</code>直接放在<code>webpack.config</code>的<code>entry</code>中，然后<code>echart</code>就会被抽出来。变成这样：</p>
<p><img src="https://dqtwdd.top/cdn/img/after_echart_analyse.jpg" alt="after_echart_analyse"></p>
<p>时间：</p>
<p><img src="https://dqtwdd.top/cdn/img/after_echart_time.jpg" alt="after_echart_time"></p>
<p>可以看到，打包时间加快了 20s 左右，并且<code>echart</code>被打包到<code>vendor</code>中去了。</p>
<p>此外，我们看到很多 js 中引用了<code>region.js</code>，试了很多方法都没办法把这个 js 单独打包出来，然后我开始尝试用下面的方法来分析无法抽离的原因。</p>
<p>了模拟项目的情况，就自己搭建了一个小项目，专门模拟这个情况：</p>
<p>结构：</p>
<p><img src="https://dqtwdd.top/cdn/img/webpack_test.jpg" alt="webpack_test"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first.js</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./second&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; second &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;secondddddddddddddddddd&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./third&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; third &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;thirrrrrrrrrrrrrrrrrrrd&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// second.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; region &#125; <span class="keyword">from</span> <span class="string">&#x27;./common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> second = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;secondddddddddddddddddddddd&#x27;</span>,</span><br><span class="line">  <span class="attr">region</span>: region,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; second &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// third.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; region &#125; <span class="keyword">from</span> <span class="string">&#x27;./common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> third = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;thirrrrrrrrrrrrrrrrrrrrrrrrrrrrrrd&#x27;</span>,</span><br><span class="line">  <span class="attr">region</span>: region,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; third &#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://dqtwdd.top/cdn/img/test_analyse.jpg" alt="test_analyse"></p>
<p>可以看出来跟本项目的情况比较符合，所以可以下结论，打包出来的每一个 js 都是动态引入的 js 文件，而这些 js 都是用 import 引入了<code>common.js</code>，所以在打包时会直接把每个 js 中引入的<code>common.js</code>打包到 js 中。想到了一个最简单的解决办法，就是不在每个 js 中引入这个<code>common.js</code>，而是只引入一次，声明为全局变量，然后使用。</p>
<p>修改后的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; region &#125; <span class="keyword">from</span> <span class="string">&#x27;./common&#x27;</span>;</span><br><span class="line"><span class="comment">// import &#123; second &#125; from &#x27;./second&#x27;;</span></span><br><span class="line"><span class="comment">// import &#123; third &#125; from &#x27;./third&#x27;;</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./second&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; second &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;secondddddddddddddddddd&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./third&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; third &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;thirrrrrrrrrrrrrrrrrrrd&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">region</span> = region;</span><br><span class="line"></span><br><span class="line"><span class="comment">// second.js</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> second = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;secondddddddddddddddddddddd&#x27;</span>,</span><br><span class="line">  <span class="attr">region</span>: <span class="variable language_">window</span>.<span class="property">region</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; second &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// third.js</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> third = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;thirrrrrrrrrrrrrrrrrrrrrrrrrrrrrrd&#x27;</span>,</span><br><span class="line">  <span class="attr">region</span>: <span class="variable language_">window</span>.<span class="property">region</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; third &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到因为只引入了一次<code>common.js</code>，所以打包结果明显小了很多。</p>
<p><img src="https://dqtwdd.top/cdn/img/test_after.jpg" alt="test_after"></p>
<p>用同样的方法，对项目进行优化。</p>
<p>优化后结果：</p>
<p><img src="https://dqtwdd.top/cdn/img/gongbu_after_opt_anaylise.jpg" alt="gongbu_after_opt_anaylise"></p>
<p>优化后时间：</p>
<p><img src="https://dqtwdd.top/cdn/img/gongbu_after_opt_time.jpg" alt="gongbu_after_opt_time"></p>
<p>时间变化不大，但是打包后包的大小变小了 1M 多。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>http</title>
    <url>/2022/02/22/20220222-http/</url>
    <content><![CDATA[<p>本文记录一下对 http1.1 和 http2.0 差异的学习。</p>
<span id="more"></span>

<h3 id="1-http1-0"><a href="#1-http1-0" class="headerlink" title="1. http1.0"></a>1. http1.0</h3><p>http1.0 时代页面有多少 http 请求就需要经过多少次握手和挥手。流程如图：</p>
<p><img src="https://dqtwdd.top/cdn/img/hppt1.webp" alt="hppt1"></p>
<h3 id="2-http1-1"><a href="#2-http1-1" class="headerlink" title="2.http1.1"></a>2.http1.1</h3><p>Http1.1 的时代，http 新增了一个 tcp 长链接功能，这样每次访问页面只需要经历一次握手和挥手，期间可以多次发送请求：</p>
<p><img src="https://dqtwdd.top/cdn/img/hppt1.1.webp" alt="hppt1.1"></p>
<p>通过两张图的对比，可以发现 tcp 的长链接大大提高了传输效率，但是 http1 还有一个最大的问题：队头堵塞。</p>
<p>在 http1 中，http 请求必须等到上一个请求响应后，才能发送。如果某一个请求没有及时返回，那么后面的请求就会被堵塞住。</p>
<p>http1.1 对这一情况进行了 pipelining 优化：允许同时发送多个请求。</p>
<p><img src="https://dqtwdd.top/cdn/img/pipeliningCompare.webp" alt="pipeliningCompare"></p>
<p>虽然 pipelining 优化确实提高了效率，但是还是有其局限性：必须按照发送请求的顺序接收返回（FIFO），因为 http 请求和相应没有序号标识，无法将乱序的请求和相应关联起来，如果第一条发送的请求由于某些原因不能及时返回，那么后面发送请求的返回也会被堵塞住。</p>
<h3 id="3-http1-和-http2-差别"><a href="#3-http1-和-http2-差别" class="headerlink" title="3. http1 和 http2 差别"></a>3. http1 和 http2 差别</h3><ol>
<li><p>http1.1 采用的是明文协议；http2.0 采用的是二进制格式。</p>
<p>为什么用二进制？</p>
<p>基于文本解析的话，文本表现形式具有多样性，要考虑的情况就很多。</p>
<p>二进制只有 0 和 1 解析很快。</p>
<p><img src="https://dqtwdd.top/cdn/img/frame.webp" alt="frame"></p>
</li>
<li><p>http2 将每个 request 切割为更小的帧，有 header 帧有 body 帧，并且给同一个 request 的帧分配相同的 streamId，彻底解决了队头堵塞。</p>
<p><img src="https://dqtwdd.top/cdn/img/stream.webp" alt="stream"></p>
</li>
<li><p>http2 针对每一个域名只建立一个 tcp 链接，所有 http 请求都通过这个 TCP 链接完成。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>异常捕获</title>
    <url>/2022/02/28/20220228-error/</url>
    <content><![CDATA[<p>最近在看前端有关异常捕获相关的知识，总结一哈。</p>
<span id="more"></span>

<h3 id="1-错误类型"><a href="#1-错误类型" class="headerlink" title="1.错误类型"></a>1.错误类型</h3><h3 id="1-1-js-执行错误"><a href="#1-1-js-执行错误" class="headerlink" title="1.1 js 执行错误"></a>1.1 js 执行错误</h3><ol>
<li><p>SyntaxError 语法错误 在 IDE 编译时就会被发现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xx <span class="comment">//const xx = &#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TypeError 类型错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">undefined</span>;</span><br><span class="line">a.<span class="property">name</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ReferenceError 引用未声明的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unstated);</span><br></pre></td></tr></table></figure>
</li>
<li><p>RangeError 当一个值不在其所允许的范围或者集合中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line">a.<span class="property">length</span> = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="1-2-网络错误"><a href="#1-2-网络错误" class="headerlink" title="1.2 网络错误"></a>1.2 网络错误</h4><ol>
<li><p>ResourceError</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Image</span>().<span class="property">src</span> = <span class="string">&#x27;/remote/image/notdeinfed.png&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HttpError</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/remote/notdefined&#x27;</span>, &#123;&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-错误收集"><a href="#2-错误收集" class="headerlink" title="2. 错误收集"></a>2. 错误收集</h3><h4 id="2-1-try-catch"><a href="#2-1-try-catch" class="headerlink" title="2.1 try/catch"></a>2.1 try/catch</h4><p>个人理解，<code>try/catch</code>使用场景偏向于捕获一些可以预料的错误：</p>
<ol>
<li>coding 时感觉哪里容易出错，不想影响后面代码的编译时做一个保险。</li>
<li>对于一些比较容易出问题的场景（比如用户输入/浏览器新特性）有可能出错，提前做准备。</li>
</ol>
<h4 id="2-2-window-onerror"><a href="#2-2-window-onerror" class="headerlink" title="2.2 window.onerror"></a>2.2 window.onerror</h4><h4 id="2-3-window-addEventListener"><a href="#2-3-window-addEventListener" class="headerlink" title="2.3 window.addEventListener"></a>2.3 window.addEventListener</h4><p>后面两种捕获异常的方式更偏向于捕获一些意料不到的错误。</p>
<h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h3><p>搞一个这样的 html。</p>
<p>为什么要把每一个错误都单独写一个 script 标签呢？因为报错会阻止后面的代码运行，所以每一个都需要一个 script 标签，这样每一个报错都会出现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test page in http://test.com<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 图片加载错误（资源错误） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://yun.tuia.cn/image/ttttttttt.png&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>test error<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> xx; <span class="comment">// SyntaxError 语法错误</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> a = <span class="literal">undefined</span>;</span></span><br><span class="line"><span class="language-javascript">      a.<span class="property">name</span>; <span class="comment">// TypeError 类型错误</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferenceError 引用错误</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> c = [];</span></span><br><span class="line"><span class="language-javascript">      c.<span class="property">length</span> = -<span class="number">1</span>; <span class="comment">// RangeError 范围错误</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">fetch</span>(<span class="string">&#x27;https://tuia.cn/test&#x27;</span>); <span class="comment">//HttpError 本质是promise error</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> A = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">        A = <span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">0</span>); <span class="comment">// 异步错误</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://dqtwdd.top/cdn/img/AllErrorCompare.png" alt="AllErrorCompare"></p>
<p>好耶！七个错误一个不少。</p>
<p>然后我们分别用三种方式尝试一下错误捕获：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window.onerror捕获到异常：&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">      message,</span></span><br><span class="line"><span class="language-javascript">      source,</span></span><br><span class="line"><span class="language-javascript">      lineno,</span></span><br><span class="line"><span class="language-javascript">      colno,</span></span><br><span class="line"><span class="language-javascript">      error,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&#x27;error&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window.addEventListener error 捕获到异常：&#x27;</span>, error.<span class="property">message</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">  );</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&#x27;unhandledrejection&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;unhandledrejection捕获到异常：&#x27;</span>, e);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  );</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>window.onerror</code>：</p>
<p><img src="https://dqtwdd.top/cdn/img/windowOnError.png" alt="windowOnError"></p>
<p>可以看到 js 的执行错误都被捕获到了。但是<code>fetch</code>请求的错误和资源请求的错误捕获不到。</p>
<p><code>window.addEventListener( &#39;error&#39;,()=&gt;&#123;&#125;)</code>:</p>
<p><img src="https://dqtwdd.top/cdn/img/windowAddEventListenerError.png" alt="windowAddEventListenerError"></p>
<p>同样的，<code>window.addEventListener( &#39;error&#39;,()=&gt;&#123;&#125;)</code>可以捕获到所有 js 的执行错误，同时也可以捕获到图片的资源的错误。但是也无法捕获<code>fetch</code>的错误。</p>
<p>其实这两个方法都无法捕获的<code>fetch</code>错误本质其实是<code>promise</code>错误，<code>promise</code>本身没有对<code>reject</code>情况进行处理导致报错。</p>
<p>所以我们可以使用最后一个方法来捕获：<code>window.addEventListener(&#39;unhandledrejection&#39;,()=&gt;&#123;&#125;)</code>。</p>
<p><code>window.addEventListener(&#39;unhandledrejection&#39;,()=&gt;&#123;&#125;)</code>:</p>
<p>稍微修改一下示例，增加一个<code>promise</code>使例子更加生动：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test page in http://test.com<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 图片加载错误（资源错误） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://yun.tuia.cn/image/ttttttttt.png&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>test error<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;unhandledrejection&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;unhandledrejection捕获到异常：&#x27;</span>, e);</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> xx; <span class="comment">// SyntaxError 语法错误</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> a = <span class="literal">undefined</span>;</span></span><br><span class="line"><span class="language-javascript">      a.<span class="property">name</span>; <span class="comment">// TypeError 类型错误</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferenceError 引用错误</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> c = [];</span></span><br><span class="line"><span class="language-javascript">      c.<span class="property">length</span> = -<span class="number">1</span>; <span class="comment">// RangeError 范围错误</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">fetch</span>(<span class="string">&#x27;https://666.0.0.1.cn/test&#x27;</span>); <span class="comment">//HttpError 本质是promise error</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> A = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">        A = <span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">0</span>); <span class="comment">// 异步错误</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, rej</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">rej</span>(<span class="string">&#x27;rejecttttttttttttttttt&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>); <span class="comment">// promise错误</span></span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://dqtwdd.top/cdn/img/promiseError.png" alt="promiseError"></p>
<p>可以看见两个<code>promise</code>未处理的错误都被捕获到了。配合<code>window.addEventListener( &#39;error&#39;,()=&gt;&#123;&#125;)</code>可以捕获到所有异常。</p>
<p>来个捕获异常全家福：</p>
<p><img src="https://dqtwdd.top/cdn/img/AllErrorFetched.png" alt="AllErrorFetched"></p>
<p>然后就可以集中处理异常了。搞一个接口，可以把精确到哪一行报错的代码上传。</p>
<p>然后配置一下 wepack，在打包时将 sourcemap 打包，上传到服务器，可以实现监控前端异常。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>vim指令/linux指令/nginx指令</title>
    <url>/2022/03/22/20220322-vim/</url>
    <content><![CDATA[<p>搞服务器被vim整的欲仙欲死。记录一下。</p>
<span id="more"></span>

<ol>
<li>vim</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim [xxxx]</span><br><span class="line">ctrl + w</span><br><span class="line">:sp [filepath] // 垂直</span><br><span class="line">:vsp [filepath] // 水平</span><br><span class="line">:1,1s/^/<span class="comment">#/g // 注释</span></span><br><span class="line">v // 高亮</span><br><span class="line">y // 复制</span><br><span class="line">p // 黏贴</span><br><span class="line">u // 撤销</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>linux</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f [filename]</span><br><span class="line">find [filename]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>nginx</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br><span class="line">nginx -s reload</span><br><span class="line">nginx -s stop</span><br><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure>

<p>数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p      <span class="comment"># –h 主机名 –u 用户名 -P 端口号 –p密码，注意-p跟密码之间不能加空格其他可以加可以不加</span></span><br><span class="line"><span class="keyword">select</span> version();     <span class="comment"># 查看 mysql 服务版本</span></span><br><span class="line">show databases;       <span class="comment"># 查看所有数据库，注意最后有 s</span></span><br><span class="line"></span><br><span class="line">create database [库名]; <span class="comment"># 创建库</span></span><br><span class="line">use [库名];             <span class="comment"># 打开指定的库</span></span><br><span class="line"></span><br><span class="line">show tables;           <span class="comment"># 查看当前库的所有表        </span></span><br><span class="line">show tables from [库名];   <span class="comment"># 查看其他库的所有表               </span></span><br><span class="line">desc [表名];               <span class="comment"># 查看表结构   </span></span><br><span class="line"></span><br><span class="line">create table [表名] (      <span class="comment"># 创建表            </span></span><br><span class="line">    列名 列类型,</span><br><span class="line">    列名 列类型,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">drop database [库名];     <span class="comment"># 删除库  </span></span><br><span class="line">drop table [表名];        <span class="comment"># 删除表   </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>;                    <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure>

<p>数据库表结构：</p>
<p>article_id 自增长</p>
<p>aticle_title 文字</p>
<p>article_view_num 数量</p>
<p>article_last 最后一次访问时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 建表</span><br><span class="line">CREATE TABLE IF NOT EXISTS `blog`(</span><br><span class="line">   `article_id` INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">   `article_title` VARCHAR(100),</span><br><span class="line">   `visit_ip` VARCHAR(100),</span><br><span class="line">   `article_host` VARCHAR(100),</span><br><span class="line">   `article_last` VARCHAR(100),</span><br><span class="line">   PRIMARY KEY ( `article_id` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">// 插入数据</span><br><span class="line">INSERT INTO blog</span><br><span class="line">(article_title, article_page_view)</span><br><span class="line">VALUES</span><br><span class="line">(<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">// 增加字段</span><br><span class="line">ALTER TABLE blog ADD article_last DATETIME AFTER article_page_view;</span><br><span class="line">ALTER TABLE blog ADD article_host VARCHAR(100) BEFORE visit_time;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 删除</span><br><span class="line">DELETE FROM blog WHERE article_id=2;</span><br><span class="line"></span><br><span class="line">// 删除列</span><br><span class="line">ALTER TABLE view_log</span><br><span class="line">DROP COLUMN visit_tiem;</span><br><span class="line"></span><br><span class="line">TRUNCATE view_log;</span><br><span class="line"></span><br><span class="line">// 更新字段</span><br><span class="line">UPDATE blog SET article_page_view=article_page_view+1, article_last=<span class="string">&#x27;2022-02-22 22:22:22&#x27;</span> WHERE article_title = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line">// 修改字段类型</span><br><span class="line">ALTER TABLE blog MODIFY COLUMN article_last VARCHAR(100);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 查询表格所有数据</span><br><span class="line">SELECT * FROM blog;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>博客改版</title>
    <url>/2022/03/23/20220323-blog/</url>
    <content><![CDATA[<p>最近学了异常处理，学了nginx，学了koa，学了http2，然后想把自己的博客改改版把最近学的东西串一下。</p>
<span id="more"></span>

<h3 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h3><p>技术栈：hexo+koa+nginx+vue3+vite+element-plus+mysql</p>
<p>展示端页面不单独开发，直接使用hexo框架打包后的文件。</p>
<p>后端接口使用koa。</p>
<p>服务器使用nginx进行反向代理，实现https+http2 。</p>
<p>后台计划使用vue3+vite+element-plus简单搭一下。</p>
<p>服务器还没看，这个先往后放，先不入库，先把接口调通。</p>
<h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h3><h4 id="1-1-文章统计"><a href="#1-1-文章统计" class="headerlink" title="1.1 文章统计"></a>1.1 文章统计</h4><p>文章统计主要记录哪篇文章被点击过。</p>
<p>实现方案就是前端搞个sdk，文章标题应该有固定的class，通过这个或者访问文章里面的页面时候调一次接口。</p>
<h4 id="1-2-错误上报"><a href="#1-2-错误上报" class="headerlink" title="1.2 错误上报"></a>1.2 错误上报</h4><p> 也是搞个sdk，然后监听报错啥的。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2022/05/05/20220505-docker/</url>
    <content><![CDATA[<p>记录一下docker笔记。</p>
<span id="more"></span>

<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>两个重要概念：</p>
<p>容器Container：容器用来隔离镜像。</p>
<p>镜像Image：镜像是一个文件，用来创建容器。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>以守护进程的方式让容器在后台运行，在这您之 前可能使用的是pm2来守护进程</td>
</tr>
<tr>
<td>-it</td>
<td>这里是 -i和 -t的缩写</td>
</tr>
<tr>
<td>-i</td>
<td>告诉 Docker 容器保持标准输入流对容器开放,交互式操作即使容器没有终端连接</td>
</tr>
<tr>
<td>-t</td>
<td>终端。告诉 Docker为容器分配一个虚拟终端</td>
</tr>
<tr>
<td>–name xxx</td>
<td>将容器命名为 xxx，这样访问和操作容器等就不需要输入一大串的容器ID</td>
</tr>
<tr>
<td>–privileged</td>
<td>让容器的用户在容器内能获取完全root权限</td>
</tr>
<tr>
<td>-p 8081:8080</td>
<td>将容器的8080端口映射到宿主机的8081端口上这样我们访问本机的localhost:8081,就是访问到容器的8080端口因为容器都是独立运行互相隔离的，容器与容器各自的8080端口、容器跟主机各自的8080端口都不是一个东西，主机只有在这给端口做映射才能访问到容器端口</td>
</tr>
<tr>
<td>-v /Users/eric/my-repository/my-app-vue2:/app/vue</td>
<td>将主机的my-app-vue2目录(命令行这里只能写绝对路径哈)下的内容挂载到容器的目录/app/vue内，如果容器的指定目录有文件/文件夹，将被清空挂载后，容器修改 /app/vue目录的内容，也是在修改主机目录/Users/eric/my-repository/my-app-vue2内容</td>
</tr>
<tr>
<td>node:10.16.2</td>
<td>这里是指定nodejs，版本为10.16.2的镜像来创建容器如果不指定版本，会默认下载当前镜像的最新版本</td>
</tr>
<tr>
<td>/bin/bash -c “cd /app/vue2 &amp;&amp; node -v &amp;&amp; npm install &amp;&amp; npm run serve”</td>
<td>/bin/bash：是在让容器分配的虚拟终端以 bash 模式执行命令 -c “”cd /app/vue2 &amp;&amp; node -v &amp;&amp; npm install &amp;&amp; npm run serve：只能执行一条 shell 命令，需要多个命令按需用&amp;&amp;</td>
</tr>
</tbody></table>
<h3 id="2-例子"><a href="#2-例子" class="headerlink" title="2. 例子"></a>2. 例子</h3><ol>
<li><p>先来一个最基本的例子，体验一下docker：</p>
<ol>
<li><p>新建html文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello docker<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>新建 Dockerfile：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dockerfile</span></span><br><span class="line"><span class="variable constant_">FROM</span> nginx</span><br><span class="line"><span class="variable constant_">COPY</span> ./index.<span class="property">html</span> /usr/share/nginx/html/index.<span class="property">html</span></span><br><span class="line"><span class="variable constant_">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件结构</span></span><br><span class="line">hello-docker</span><br><span class="line">  |____index.<span class="property">html</span></span><br><span class="line">  |____Dockerfile</span><br><span class="line"></span><br><span class="line">cd docker/ # 进入刚刚的目录</span><br><span class="line">docker build ./ -t hello-<span class="attr">docker</span>:<span class="number">1.0</span><span class="number">.0</span> # 打包镜像</span><br></pre></td></tr></table></figure>

<p>不出意外，你应该能得到如下输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Sending</span> build context to <span class="title class_">Docker</span> daemon  <span class="number">3.</span>072kB</span><br><span class="line"><span class="title class_">Step</span> <span class="number">1</span>/<span class="number">3</span> : <span class="variable constant_">FROM</span> nginx</span><br><span class="line"> ---&gt; 5a3221f0137b</span><br><span class="line"><span class="title class_">Step</span> <span class="number">2</span>/<span class="number">3</span> : <span class="variable constant_">COPY</span> ./index.<span class="property">html</span> /usr/share/nginx/html/index.<span class="property">html</span></span><br><span class="line"> ---&gt; 1c433edd5891</span><br><span class="line"><span class="title class_">Step</span> <span class="number">3</span>/<span class="number">3</span> : <span class="variable constant_">EXPOSE</span> <span class="number">80</span></span><br><span class="line"> ---&gt; <span class="title class_">Running</span> <span class="keyword">in</span> c2ff9ec2e945</span><br><span class="line"><span class="title class_">Removing</span> intermediate container c2ff9ec2e945</span><br><span class="line"> ---&gt; f6a472c1b0a0</span><br><span class="line"><span class="title class_">Successfully</span> built f6a472c1b0a0</span><br><span class="line"><span class="title class_">Successfully</span> tagged hello-<span class="attr">docker</span>:<span class="number">1.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="4">
<li><p>运行容器：</p>
<p>之前的步骤只是通过Dockerfile创建一个镜像。接下来需要根据镜像创建容器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker container create -p <span class="number">2333</span>:<span class="number">80</span> hello-<span class="attr">docker</span>:<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">docker container start xxx # xxx 为上一条命令运行得到的结果</span><br></pre></td></tr></table></figure>

<p><code>docker create</code> 是创建一个容器但是不启动</p>
<p><code>docker start</code>启动一个或多个容器</p>
<p>以上两个命令可以合并成一个：</p>
<p><code>docker run</code>创建一个容器并启动</p>
</li>
</ol>
<ol start="5">
<li><p>进入容器内部：</p>
<p>容器运行后，可以使用如下命令进入容器内部：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker container exec -it xxx /bin/bash # xxx 为容器<span class="variable constant_">ID</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>来一个前端启动项目比较完整的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn create vite docker-study --template vue <span class="comment">// 创建一个vite-vue项目</span></span><br><span class="line">cd docker-study</span><br><span class="line"><span class="title class_">Mkfile</span> <span class="title class_">Dockerfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dockerfile</span></span><br><span class="line"><span class="variable constant_">FROM</span> <span class="attr">node</span>:<span class="number">16.16</span><span class="number">.0</span>-slim  <span class="comment">// 指定模版</span></span><br><span class="line"><span class="variable constant_">COPY</span> . ./demo <span class="comment">// 将当前文件夹拷贝到docker中</span></span><br><span class="line"><span class="variable constant_">WORKDIR</span> /demo <span class="comment">// 指定docker中的工作路径</span></span><br><span class="line">run yarn <span class="comment">// 安装依赖</span></span><br><span class="line"><span class="variable constant_">CMD</span> yarn dev --host <span class="comment">// 启动项目 不加host可能导致映射端口失败</span></span><br><span class="line"></span><br><span class="line">docker container run -p <span class="number">3000</span>:<span class="number">5173</span> vue-demo <span class="comment">// 然后本地就可以看咯</span></span><br></pre></td></tr></table></figure>




</li>
</ol>
<p>修改dns<code>$ vim $PREFIX/etc/resolv.conf</code></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript</title>
    <url>/2022/06/10/20220610-typescript/</url>
    <content><![CDATA[<p>Typescript学习笔记。</p>
<span id="more"></span>

<h3 id="1-基础类型"><a href="#1-基础类型" class="headerlink" title="1. 基础类型"></a>1. 基础类型</h3><h4 id="1-1基础类型"><a href="#1-1基础类型" class="headerlink" title="1.1基础类型"></a>1.1基础类型</h4><p>基础类型可以直接用<code>:</code>连接。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: boolean = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: string = <span class="string">&quot;bob&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-数组"><a href="#1-2-数组" class="headerlink" title="1.2 数组"></a>1.2 数组</h4><p>数组可以有两种方法定义。第一种是在元素类型后面接<code>[]</code>，表示由此类型元素组成一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>:number[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>第二种方式是实用数组泛型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>:<span class="title class_">Array</span>&lt;number&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="1-3-元组"><a href="#1-3-元组" class="headerlink" title="1.3 元组"></a>1.3 元组</h3><p>元组表示允许一个已知元素数量和类型的数组。各元素的类型不必相同。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:[string,number];</span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>,<span class="number">1</span>] <span class="comment">// ok</span></span><br><span class="line">x = [<span class="number">1</span>,<span class="string">&#x27;hello&#x27;</span>] <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-any"><a href="#1-4-any" class="headerlink" title="1.4 any"></a>1.4 any</h4><p>啥类型都行。尽量少用。</p>
<h4 id="1-5-Void"><a href="#1-5-Void" class="headerlink" title="1.5 Void"></a>1.5 Void</h4><p>void类型像是与any类型相反。它表示没有任何类型。当一个函数没有任何返回时，可以使用<code>void</code>作为返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params"></span>):<span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is an error&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-Object"><a href="#1-6-Object" class="headerlink" title="1.6 Object"></a>1.6 Object</h4><p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p>
<p>使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的API。例如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">o: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(<span class="number">42</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="string">&quot;string&quot;</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">false</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p>接口就是把要定义的type进行一个封装。例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">print</span> (<span class="attr">param</span>:&#123;<span class="attr">label</span>:<span class="built_in">string</span>&#125;) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(param.<span class="property">lable</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">label</span>:<span class="string">&#x27;size&#x27;</span>,<span class="attr">size</span>:<span class="number">10</span>&#125;</span><br><span class="line"><span class="title function_">print</span>(obj);</span><br><span class="line"><span class="comment">// 上面的例子用接口封装</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Param</span> &#123;</span><br><span class="line">  <span class="attr">label</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span> (<span class="attr">param</span>:<span class="title class_">Param</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(param.<span class="property">lable</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">label</span>:<span class="string">&#x27;size&#x27;</span>,<span class="attr">size</span>:<span class="number">10</span>&#125;</span><br><span class="line"><span class="title function_">print</span>(obj);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-可选属性"><a href="#2-2-可选属性" class="headerlink" title="2.2 可选属性"></a>2.2 可选属性</h4><p>可选属性是对一些可能存在可能不存在的值进行type限定。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Bag</span> &#123;</span><br><span class="line">  color?:<span class="built_in">string</span>;</span><br><span class="line">  book?:<span class="built_in">string</span>;</span><br><span class="line">  pen?:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createBag</span> (<span class="attr">bag</span>:<span class="title class_">Bag</span>):&#123;<span class="attr">color</span>:<span class="built_in">string</span>;<span class="attr">size</span>:<span class="built_in">number</span>&#125;&#123;</span><br><span class="line">  <span class="keyword">let</span> newBag = &#123;<span class="attr">color</span>:<span class="string">&#x27;white&#x27;</span>,<span class="attr">size</span>:<span class="string">&#x27;big&#x27;</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (bag.<span class="property">color</span>) &#123;</span><br><span class="line">    newBag.<span class="property">color</span> = bag.<span class="property">color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newBag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myBag = <span class="title function_">createBag</span>(&#123;<span class="attr">color</span>:<span class="string">&#x27;black&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>没加<code>?</code>的接口中的属性必须存在，不然就会报错。</p>
<p>如果赋值接口不存在的值，ts也会报错，但是也能运行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> test = reactive&lt;&#123;color?:<span class="built_in">string</span>;<span class="attr">book</span>:<span class="built_in">string</span>;<span class="attr">pen</span>:<span class="built_in">number</span>&#125;&gt;(&#123; <span class="attr">book</span>: <span class="string">&#x27;hello&#x27;</span> &#125;) </span><br><span class="line"><span class="comment">// 类型“&#123; book: string; &#125;”的参数不能赋给类型“&#123; color?: string | undefined; book: string; pen: number; &#125;”的参数。</span></span><br><span class="line"><span class="comment">// 类型&quot;&#123; book: string; &#125;&quot;中缺少属性 &quot;pen&quot;，但类型 &quot;&#123; color?: string | undefined; book: string; pen: number; &#125;&quot; 中需要该属性。ts(2345)</span></span><br><span class="line"><span class="keyword">const</span> test = reactive&lt;&#123;color?:<span class="built_in">string</span>;<span class="attr">book</span>:<span class="built_in">string</span>;pen?:<span class="built_in">number</span>&#125;&gt;(&#123; <span class="attr">book</span>: <span class="string">&#x27;hello&#x27;</span> &#125;) <span class="comment">// ok</span></span><br><span class="line">test.<span class="property">test</span> = <span class="string">&#x27;hah&#x27;</span> </span><br><span class="line"><span class="comment">// 类型“&#123; color?: string | undefined; book: string; pen: number; &#125;”上不存在属性“test”。ts(2339)</span></span><br></pre></td></tr></table></figure>

<p>如果可能添加额外的属性，有三种方法。</p>
<ol>
<li>赋值给另一个变量</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> test &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">book</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">pen</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">color</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">book</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">pen</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">test</span>: <span class="string">&#x27;hello&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> test = reactive&lt;test&gt;(a)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>断言</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> test &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">book</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">pen</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = reactive&lt;test&gt;(&#123; <span class="attr">color</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">book</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">pen</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">test</span>: <span class="string">&#x27;hello&#x27;</span> &#125; <span class="keyword">as</span> test)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>索引签名</li>
</ol>
<p>需要注意的是，索引签名也会约束已经定义的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> test &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">book</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">pen</span>: <span class="built_in">string</span></span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = reactive&lt;test&gt;(&#123; <span class="attr">color</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">book</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">pen</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">test</span>: <span class="string">&#x27;hello&#x27;</span> &#125;) <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> test &#123;</span><br><span class="line">  <span class="attr">pen</span>: <span class="built_in">number</span></span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = reactive&lt;test&gt;(&#123; <span class="attr">pen</span>: <span class="number">1</span>, <span class="attr">test</span>: <span class="string">&#x27;hello&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// 类型“&#123; pen: number; test: string; &#125;”的参数不能赋给类型“test”的参数。</span></span><br><span class="line"><span class="comment">// 属性“pen”与索引签名不兼容。</span></span><br><span class="line"><span class="comment">// 不能将类型“number”分配给类型“string”。ts(2345)</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-只读属性"><a href="#2-3-只读属性" class="headerlink" title="2.3 只读属性"></a>2.3 只读属性</h4><p>使一些对象属性只能在对象刚创建时修改其值。可以在属性名县使用<code>readonly</code>来指定只读属性：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p1</span>: <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line">p1.<span class="property">x</span> = <span class="number">5</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>最简单判断该用<code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用<code>readonly</code>。</p>
<h4 id="2-4-implements和extends"><a href="#2-4-implements和extends" class="headerlink" title="2.4 implements和extends"></a>2.4 implements和extends</h4><p>个人感觉，理解这两个作用的最简单的方式就是从字面理解。</p>
<p>implements 实现 就是 类 根据 接口/类 来实现具体的内容。</p>
<p>extends 继承 就是 接口/类 继承 （接口，类）/（类） 的本身属性。</p>
<p>原因是，类在构建过程中会自行创建一个类对应的接口，可以理解为接口是类的子集。</p>
<p>基于这个理解，我们可以得到下面的表：</p>
<table>
<thead>
<tr>
<th></th>
<th>interface</th>
<th>class</th>
</tr>
</thead>
<tbody><tr>
<td>interface</td>
<td>extends</td>
<td>extends</td>
</tr>
<tr>
<td>class</td>
<td>implements</td>
<td>implements/extends</td>
</tr>
</tbody></table>
<p><img src="https://dqtwdd.top/cdn/img/implements.jpg" alt="implements"></p>
<h3 id="3-class"><a href="#3-class" class="headerlink" title="3. class"></a>3. class</h3><p>关于类，看了一些资料，感觉比较好的一个说法是：</p>
<p>不要为了oop而使用class，大多数时候，函数式编程都可以解决我们的问题。学好 工厂函数/闭包 才是关键。</p>
<p>来一个简单的小例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">talk</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I am &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">green</span>:<span class="title class_">Person</span>;</span><br><span class="line">green = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Green&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(green.<span class="title function_">talk</span>()); <span class="comment">// I am Green</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有一个小问题，关于this指向</span></span><br><span class="line"><span class="keyword">let</span> test = &#123;&#125;</span><br><span class="line">test.<span class="property">func</span> = green.<span class="property">talk</span>;</span><br><span class="line">test.<span class="title function_">func</span>() <span class="comment">// &#x27;I am undefined&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案1 显式调用bind</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">talk</span> = <span class="variable language_">this</span>.<span class="property">talk</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">talk</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I am &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解决方案2 箭头函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  talk = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I am &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">talk</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&#x27;I am &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解决方案3 工厂函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Person</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">talk</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am &#x27;</span> + name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h3><p>为函数定义类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>):<span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选参数和默认参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">first:<span class="string">&#x27;bob&#x27;</span>,lastNmae?:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">first:<span class="built_in">string</span>,args:<span class="built_in">string</span>[]</span>)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5. 泛型"></a>5. 泛型</h3><p>泛型用来捕获用户传入的类型，之后我们就可以使用这个类型。</p>
<p>来一个简单的小例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> genericity&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">par</span>: T</span><br><span class="line">  	<span class="attr">test</span>: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> genericityTest = reactive&lt;genericity&lt;<span class="built_in">number</span>&gt;&gt;(&#123; <span class="attr">par</span>: <span class="number">1</span>, <span class="attr">test</span>: <span class="number">2</span> &#125;) <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> genericityTest = reactive&lt;genericity&lt;<span class="built_in">string</span>&gt;&gt;(&#123; <span class="attr">par</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">test</span>: <span class="string">&#x27;&#x27;</span> &#125;) <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> genericityTest = reactive&lt;genericity&lt;<span class="built_in">number</span>&gt;&gt;(&#123; <span class="attr">par</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">test</span>: <span class="number">2</span> &#125;) <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数泛型</span></span><br><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2022/06/16/20220616-algorithm/</url>
    <content><![CDATA[<p>总结一下面试准备的算法和所用时间。</p>
<span id="more"></span>

<h3 id="1-岛屿问题"><a href="#1-岛屿问题" class="headerlink" title="1. 岛屿问题"></a>1. <a href="https://leetcode.cn/problems/number-of-islands/">岛屿问题</a></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">character[][]</span>&#125; <span class="variable">grid</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> * time:2022/06/16-16:47</span></span><br><span class="line"><span class="comment"> * total:30min</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">character[][]</span>&#125; <span class="variable">grid</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> * time:2022/06/16-16:47</span></span><br><span class="line"><span class="comment"> * total:30min</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numIslands = <span class="keyword">function</span> (<span class="params">grid</span>) &#123;</span><br><span class="line">  <span class="comment">// 淹没</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">submerged</span>(<span class="params">i, j</span>) &#123;</span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (grid[i + <span class="number">1</span>] &amp;&amp; grid[i + <span class="number">1</span>][j] === <span class="string">&#x27;1&#x27;</span>) <span class="title function_">submerged</span>(i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">if</span> (grid[i - <span class="number">1</span>] &amp;&amp; grid[i - <span class="number">1</span>][j] === <span class="string">&#x27;1&#x27;</span>) <span class="title function_">submerged</span>(i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j + <span class="number">1</span>] === <span class="string">&#x27;1&#x27;</span>) <span class="title function_">submerged</span>(i, j + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j - <span class="number">1</span>] === <span class="string">&#x27;1&#x27;</span>) <span class="title function_">submerged</span>(i, j - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        res += <span class="number">1</span>;</span><br><span class="line">        <span class="title function_">submerged</span>(i, j);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;grid:&#x27;</span>, grid);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-最长回文子串"><a href="#2-最长回文子串" class="headerlink" title="2. 最长回文子串"></a>2. <a href="https://leetcode.cn/problems/longest-palindromic-substring/submissions/">最长回文子串</a></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> getMax = <span class="keyword">function</span> (<span class="params">s, l, r</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="property">length</span> &amp;&amp; s[l] === s[r]) &#123;</span><br><span class="line">      l--;</span><br><span class="line">      r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">slice</span>(l + <span class="number">1</span>, r);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="title function_">getMax</span>(s, i, i);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="title function_">getMax</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line">    res = a.<span class="property">length</span> &gt; res.<span class="property">length</span> ? a : res;</span><br><span class="line">    res = b.<span class="property">length</span> &gt; res.<span class="property">length</span> ? b : res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-接雨水"><a href="#3-接雨水" class="headerlink" title="3. 接雨水"></a>3. <a href="https://leetcode.cn/problems/trapping-rain-water">接雨水</a></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心思想 中心扩散。找到最低点，然后根据最低点算出当前水坑水的体积，然后再找下一个水坑</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">height</span></span></span><br><span class="line"><span class="comment"> * time:2022/06/17 10:13 gg</span></span><br><span class="line"><span class="comment"> * time:2022/06/17 11:05 中心扩散 15:20完成 我是菜逼</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> trap = <span class="keyword">function</span> (<span class="params">height</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (height.<span class="property">length</span> &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getWater</span>(<span class="params">mid</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> l = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> r = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> lM = l;</span><br><span class="line">    <span class="keyword">let</span> rM = r;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; height.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (height[lM] &gt;= height[rM]) &#123;</span><br><span class="line">        r++;</span><br><span class="line">        rM = height[r] &gt; height[rM] ? r : rM;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l--;</span><br><span class="line">        lM = height[l] &gt; height[lM] ? l : lM;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(height[rM], height[lM]);</span><br><span class="line">    <span class="keyword">let</span> tempRes = min * (rM - <span class="number">1</span> - lM);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = lM + <span class="number">1</span>; i &lt; rM; i++) &#123;</span><br><span class="line">      tempRes -= height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">res</span>: tempRes,</span><br><span class="line">      <span class="attr">r</span>: rM,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="comment">// 从最低点中心扩散取水</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; height.<span class="property">length</span> - <span class="number">1</span>; ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (height[i - <span class="number">1</span>] &gt;= height[i] &amp;&amp; height[i + <span class="number">1</span>] &gt;= height[i]) &#123;</span><br><span class="line">      <span class="keyword">let</span> funcRes = <span class="title function_">getWater</span>(i);</span><br><span class="line">      res += funcRes.<span class="property">res</span>;</span><br><span class="line">      i = funcRes.<span class="property">r</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// 找最低点</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-生成括号"><a href="#4-生成括号" class="headerlink" title="4.生成括号"></a>4.<a href="https://leetcode.cn/problems/generate-parentheses/submissions/">生成括号</a></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * time:2020-06-17 16:23 回溯</span></span><br><span class="line"><span class="comment"> * 10min 我是小天才</span></span><br><span class="line"><span class="comment"> * 回溯需要注意的就是两点：</span></span><br><span class="line"><span class="comment"> * 1.停止条件</span></span><br><span class="line"><span class="comment"> * 2.继续进行的条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">l, r, s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> === <span class="number">2</span> * n) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(s);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; <span class="number">0</span>) <span class="title function_">dfs</span>(l - <span class="number">1</span>, r, s + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) <span class="title function_">dfs</span>(l, r - <span class="number">1</span>, s + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">dfs</span>(n, n, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generateParenthesis</span>(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<h3 id="5-爬楼梯"><a href="#5-爬楼梯" class="headerlink" title="5. 爬楼梯"></a>5. <a href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * time:2022-06-17 16:36</span></span><br><span class="line"><span class="comment"> * 16:48 12min</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 这道题应该动态规划和回溯都能做，本次尝试用回溯做。</span></span><br><span class="line"><span class="comment"> * 还是两个注意点：</span></span><br><span class="line"><span class="comment"> * 1.终止条件</span></span><br><span class="line"><span class="comment"> * 2.进行条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">stairs, gone</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stairs === <span class="number">0</span>) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(gone);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stairs &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="title function_">go</span>(stairs - <span class="number">1</span>, gone + <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">      <span class="title function_">go</span>(stairs - <span class="number">2</span>, gone + <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">go</span>(stairs - <span class="number">1</span>, gone + <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">go</span>(n, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> res.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">climbStairs</span>(<span class="number">35</span>)); <span class="comment">// 14930352 虽然很慢，但是确实对了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * time:2022-06-17 16:49</span></span><br><span class="line"><span class="comment"> * 回溯太变态了，耗时极长，因此用动态规划再做一遍</span></span><br><span class="line"><span class="comment"> * 动态规划思路：</span></span><br><span class="line"><span class="comment"> * 后面的跟前面的有关系，先找这个关系，一般都是 a = a-1 + a-2这种。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>] + res[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res[n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">climbStairs</span>(<span class="number">35</span>)); <span class="comment">// 14930352</span></span><br></pre></td></tr></table></figure>

<p>然后举一反三搞了一个暴力破解密码的小脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力破解六位密码;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">force</span>(<span class="params">pos</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> passDic = [</span><br><span class="line">    <span class="string">&#x27;q&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;t&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;u&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;i&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;o&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;g&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;j&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;k&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;l&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;z&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;v&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;n&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;5&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;6&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;7&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getPass</span>(<span class="params">left, str</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// console.log(str);</span></span><br><span class="line">      res.<span class="title function_">push</span>(str);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; passDic.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">getPass</span>(left - <span class="number">1</span>, str + passDic[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getPass</span>(pos, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> timeStart = <span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(timeStart);</span><br><span class="line"><span class="keyword">let</span> passList = <span class="title function_">force</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> timeEnd = <span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(timeEnd.<span class="title function_">toString</span>() * <span class="number">1</span> - timeStart.<span class="title function_">toString</span>() * <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="6-买卖股票的最佳时机"><a href="#6-买卖股票的最佳时机" class="headerlink" title="6. 买卖股票的最佳时机"></a>6. <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * time: 16:45:00 26min</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 最弱智的双层遍历</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span> (<span class="params">prices</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> curr = prices[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; prices.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prices[j] &lt;= prices[i]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">let</span> profit = prices[j] - prices[i];</span><br><span class="line">      res = profit &gt; res ? profit : res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxProfit</span>([<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>]));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 剪枝</span></span><br><span class="line"><span class="comment"> * 如果当前值小于最小买入值直接继续</span></span><br><span class="line"><span class="comment"> * 如果当前值小于买入值直接继续</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span> (<span class="params">prices</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> minBuy = prices[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> curr = prices[i];</span><br><span class="line">    <span class="keyword">if</span> (curr &gt; minBuy) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; prices.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prices[j] &lt;= prices[i]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">let</span> profit = prices[j] - prices[i];</span><br><span class="line">      <span class="keyword">if</span> (profit &gt; res) &#123;</span><br><span class="line">        minBuy = curr;</span><br><span class="line">        res = profit;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxProfit</span>([<span class="number">1</span>, <span class="number">2</span>]));</span><br><span class="line"><span class="comment">// 最好的办法</span></span><br><span class="line"><span class="comment">// 如果当前值小于最小值 直接赋给最小值 然后继续</span></span><br><span class="line"><span class="comment">// 如果不大于最小值，算利润，取比较高的利润</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span> (<span class="params">prices</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> min = prices[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &lt; min) &#123;</span><br><span class="line">      min = prices[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      maxProfit = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxProfit, prices[i] - min);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxProfit</span>([<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure>

<h3 id="7-最大子数组和-连续子数组的最大和"><a href="#7-最大子数组和-连续子数组的最大和" class="headerlink" title="7.最大子数组和 / 连续子数组的最大和"></a>7.<a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a> / <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">连续子数组的最大和</a></h3><p>这两道题解法基本一致。</p>
<p>动态规划的步骤：</p>
<ol>
<li>穷举（举出部分结果，寻找dp[i]和dp[i-1]的规律）</li>
<li>确定边界（就是找特殊的例子，相当于剪支）</li>
<li>找出转移态方程（寻找dp[i]和dp[i-1]的关系）</li>
<li>求解</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * time:2022-07-01 15:56 16:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// dp[i+1] = Math.max(dp[i]+nums[i+1],nums[i+1])</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="property">length</span> === <span class="number">0</span> ? <span class="number">0</span> : nums[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> max = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> dp = [nums[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">    dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i], max);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nums = [-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span>]; <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">maxSubArray</span>(nums));</span><br></pre></td></tr></table></figure>

<h3 id="8-跳跃游戏-II"><a href="#8-跳跃游戏-II" class="headerlink" title="8. 跳跃游戏 II"></a>8. <a href="https://leetcode.cn/problems/jump-game-ii/">跳跃游戏 II</a></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> * time:14:00</span></span><br><span class="line"><span class="comment"> * 通过审题得出转移态方程</span></span><br><span class="line"><span class="comment"> * dp[i] = dp[i-1] + nums[i]</span></span><br><span class="line"><span class="comment"> * 需要注意的是不一定直接跳到最后一个台阶，可能跳的更远，所以需要记录一下中间的部分。防止有empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> jump = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="property">length</span> === <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dp = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt;= i + nums[i]; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dp[j] &amp;&amp; dp[i]) &#123;</span><br><span class="line">        dp[j] = <span class="title class_">Math</span>.<span class="title function_">min</span>(dp[j], dp[i] + <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          dp[j] = dp[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[nums.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-斐波那契数列"><a href="#9-斐波那契数列" class="headerlink" title="9.斐波那契数列"></a>9.<a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">斐波那契数列</a></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最简单的动态规划注意下取模就行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> * time:11:08</span></span><br><span class="line"><span class="comment"> * dp[n] = dp[n-1]+dp[n-2]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fib = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> dp = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> dp[n];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    dp[i] = ((dp[i] % <span class="number">1000000007</span>) + <span class="number">1000000007</span>) % <span class="number">1000000007</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">81</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-打家劫舍"><a href="#9-打家劫舍" class="headerlink" title="9.打家劫舍"></a>9.<a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * time:14:25 15min</span></span><br><span class="line"><span class="comment"> * 打家劫舍的dp模型还是比较简单的</span></span><br><span class="line"><span class="comment"> * dp[i] = Math.max(dp[i-2],dp[i-3]) + nums[i]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">2</span>) <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">3</span>) <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>] + nums[<span class="number">2</span>], nums[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> dp = [</span><br><span class="line">    nums[<span class="number">0</span>],</span><br><span class="line">    <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]),</span><br><span class="line">    <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>] + nums[<span class="number">2</span>], nums[<span class="number">1</span>]),</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">let</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(...dp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">2</span>], dp[i - <span class="number">3</span>]) + nums[i];</span><br><span class="line">    <span class="keyword">if</span> (dp[i] &gt; max) max = dp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> nums = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">rob</span>(nums));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>项目总结</title>
    <url>/2022/06/16/20220616-project/</url>
    <content><![CDATA[<p>总结一下手里的项目。</p>
<span id="more"></span>

<p>工布：用来做AB分桶实验。</p>
<ol>
<li>简单的说就是根据一定指标（地域/机型/浏览习惯）将用户随机分组。</li>
<li>在上线某些功能或者上某些推荐策略时，对部分相同标签用户随机分组，然后进行观察。</li>
<li>根据观察结果决定是调整策略还是继续放量。</li>
</ol>
<p>以此达到尽量平稳的上线的目的。</p>
<p>智能媒体平台：用来划分优质内容。</p>
<p>新媒体传播大部分内容是从别的媒体平台获取的。</p>
<p>用爬虫爬来的各个平台的内容可能良莠不齐，所以需要筛选，通过对内容打标签划分出优质内容，然后从优质内容中选内容进行曝光。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>手机linux服务器</title>
    <url>/2022/03/23/20221013-phoneLinux/</url>
    <content><![CDATA[<p>旧安卓手机改造服务器。</p>
<span id="more"></span>

<h3 id="1-流程"><a href="#1-流程" class="headerlink" title="1. 流程"></a>1. 流程</h3><ol>
<li><p>手机安装 <a href="https://f-droid.org/">f-droid</a></p>
</li>
<li><p>f-droid 安装 temux</p>
</li>
<li><p>temux操作</p>
<ol>
<li><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/termux/">切换源</a></p>
<p><code>termux-change-repo</code></p>
</li>
<li><p>更新包</p>
<p><code>apt update</code></p>
<p><code>pkg update</code></p>
<p><code>apt upgrade</code></p>
</li>
<li><p>安装ssh</p>
<p><code>apt install openssh</code></p>
<p><code>pkg install termux-auth</code></p>
</li>
<li><p>获取用户名</p>
<p><code>whoami  // 如：a0_a62</code></p>
</li>
<li><p>设置密码</p>
<p><code>passwd</code></p>
</li>
<li><p>查看本机局域网ip in中的是</p>
<p><code>ifconfig</code></p>
</li>
<li><p>手机启动ssh服务 </p>
<p><code>sshd</code></p>
</li>
</ol>
</li>
</ol>
<h3 id="2-坑"><a href="#2-坑" class="headerlink" title="2. 坑"></a>2. 坑</h3><ol>
<li><p>git clone 报错 library “libssl.so.1.1” not found</p>
<p>解决链接：<a href="https://blog.csdn.net/qq_42560204/article/details/125670804">csdn</a></p>
<p>解决方法：</p>
<ol>
<li><p>安装openssl1.1<br>先搜索 <code>pkg search openssl1.1</code><br>可以看到有一个openssl1.1-tool的package，对它进行安装<code>pkg install openssl1.1-tool</code> </p>
<p>已经安装openssh跳过这步</p>
</li>
<li><p>搜索libssl.so.1.1<br>可以pwd先看下自己的目录 一般来说都安装到了/data/data/com.termux/files下</p>
<p><code>find /data/data/com.termux/files -name &#39;libssl.so.*&#39;</code></p>
</li>
<li><p>添加环境变量<br><code>echo &quot;export LD_LIBRARY_PATH=/data/data/com.termux/files/usr/lib/openssl-1.1&quot; &gt;&gt; ~/.bashrc</code><br>使当前shell生效</p>
<p><code>export LD_LIBRARY_PATH=/data/data/com.termux/files/usr/lib/openssl-1.1</code></p>
</li>
<li><p>再次检验命令 ————成功</p>
</li>
</ol>
</li>
<li><p>修改linux文件</p>
<p><code>vim $PREFIX/etc/resolv.conf</code></p>
</li>
</ol>
<h3 id="3-Termux启用ftp功能"><a href="#3-Termux启用ftp功能" class="headerlink" title="3. Termux启用ftp功能"></a>3. Termux启用ftp功能</h3><p>openssh自带sftp-server。</p>
<p>连接方法:Filezilla —&gt; 新建链接 —&gt; 选择sftp协议 —&gt; 询问用户名和密码 (whoami和对应的密码)</p>
<p>注意端口选择8022，即可连接sftp服务，亲测可删写服务器内容，简单极致，无需安装和启动pure-ftpd软件。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>试智力题</title>
    <url>/2022/10/19/20221019-iq/</url>
    <content><![CDATA[<h1 id="常见面试智力题总结"><a href="#常见面试智力题总结" class="headerlink" title="常见面试智力题总结"></a>常见面试智力题总结</h1><p>本部分主要是笔者在练习常见面试智力题所做的笔记，如果出现错误，希望大家指出！</p>
<h2 id="常见智力题"><a href="#常见智力题" class="headerlink" title="常见智力题"></a>常见智力题</h2><ol>
<li><p>时针与分针夹角度数问题？</p>
<p>分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当时间为 m 点 n 分时，其时针与分针夹角的度数为多少？</span><br><span class="line"></span><br><span class="line">我们可以这样考虑，分针每走一格为 6 度，分针每走一格对应的时针会走 0.5 度。</span><br><span class="line"></span><br><span class="line">时针每走一格为 30 度。</span><br><span class="line"></span><br><span class="line">因此，时针走过的度数为 m * 30 + n * 0.5，分针走过的度数为 n * 6。</span><br><span class="line"></span><br><span class="line">因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|;</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|;</span><br></pre></td></tr></table></figure>

<p>详细资料参考：<br><a href="https://blog.csdn.net/prstaxy/article/details/22210829">《面试智力题 — 时针与分针夹角度数问题》</a></p>
</li>
<li><p>用 3 升，5 升杯子怎么量出 4 升水？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）将 5 升杯子装满水，然后倒入 3 升杯子中，之后 5 升杯子还剩 2 升水。</span><br><span class="line"></span><br><span class="line">（2）将 3 升杯子的水倒出，然后将 5 升杯子中的 2 升水倒入 3 升杯子中。</span><br><span class="line"></span><br><span class="line">（3）将 5 升杯子装满水，然后向 3 升杯子中倒水，直到 3 升杯子装满为止，此时 5 升杯子中就还剩 4 升水。</span><br></pre></td></tr></table></figure>
</li>
<li><p>四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于浑浊的每片药片比正常药片都多出了一克，因此我认为可以通过控制药片的数量来实现判断。</span><br><span class="line"></span><br><span class="line">（1）首先将每个药罐进行编号，分别标记为 1、2、3、4 号药罐。</span><br><span class="line"></span><br><span class="line">（2）然后从 1 号药罐中取出 1 片药片，从 2 号药罐中取出 2 片药片，从 3 号药罐中取出 3 片药片，从 4 号药罐中取出 4</span><br><span class="line">    片药片。</span><br><span class="line"></span><br><span class="line">（3）将 10 片药片使用天平称重，药片的重量比正常重量多出几克，就是哪一号药罐的问题。</span><br></pre></td></tr></table></figure>
</li>
<li><p>四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1<br>我只能翻两张牌，我翻哪两张？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我认为证明 a 的反面一定是 1 的充要条件为 a 的反面为 1，并且 2 的反面不能为 a，因此应该翻 a 和 2 两张牌。</span><br></pre></td></tr></table></figure>
</li>
<li><p>赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我认为一共至少需要 7 次才能选出最快的三匹马。</span><br><span class="line"></span><br><span class="line">（1）首先，我们将 25 匹马分为 5 组，每组进行比赛，选出每组最快的三匹马，其余的马由于已经不可能成为前三了，因此可以直</span><br><span class="line">    接淘汰掉，那么我们现在还剩下了 15 匹马。</span><br><span class="line"></span><br><span class="line">（2）然后我们将 5 组中的第一名来进行一轮比赛，最终的结果能够确定最快的马一定是第一名，四五名的马以及它们对应组的其余</span><br><span class="line">    马就可以淘汰掉了，因为它们已经没有进入前三的机会了。并且第二名那一组的第三名和第三组的第二第三名都可以淘汰掉了，</span><br><span class="line">    它们也没有进入前三的机会了。因此我们最终剩下了第一名那一组的二三名和第二名那一组的一二名，以及第三名一共 5 匹马，</span><br><span class="line">    它们都有竞争最快第二第三的机会。</span><br><span class="line"></span><br><span class="line">（3）最后一次对最后的 5 匹马进行比赛，选择最快的一二名作为最终结果的二三名，因此就能够通过 7 次比较，选择出最快的马。</span><br></pre></td></tr></table></figure>
</li>
<li><p>五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A 问了其他人，发现每个人的握手次数都<br>不同，那么 A 的配偶握手了几次？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）由于每个人不能和自己的配偶握手，并且最多只能和他人握手一次，因此一个人最多能握 8 次手。</span><br><span class="line"></span><br><span class="line">（2）因为 A 问了除自己配偶的其他人，每个人的握手次数都不同。因此一共有九种握手的情况，由于一个人最多只能握 8 次手，因</span><br><span class="line">    此握手的情况分别为 0、1、2、3、4、5、6、7、8 这九种情况。</span><br><span class="line"></span><br><span class="line">（3）我们首先分析握了 8 次手的人，由于他和除了自己配偶的每一个人都握了一次手，因此其他人的握手次数都不为 0，因此只有</span><br><span class="line">    他的配偶握手次数为0，由此我们可以知道握手次数为 8 的人和握手次数为 0 的人是配偶。</span><br><span class="line"></span><br><span class="line">（4）我们再来分析握了 7 次手的人，他和除了握了 0 次手以外的人都握了一次手，由于握了 8 次手的人和其余人也都握了一次手</span><br><span class="line">    ，因此其他人的握手次数至少为 2 ，因此只有他的配偶的握手次数才能为 1。由此我们可以知道握手次数为 7 的人和握手次数</span><br><span class="line">    为 1 的人是配偶。</span><br><span class="line"></span><br><span class="line">（5）依次可以类推，握手次数为 6 的人和握手次数为 2 的人为配偶，握手次数为 5 的人和握手次数为 3 的人为配偶。</span><br><span class="line"></span><br><span class="line">（6）最终剩下了握手次数为 4 的人，按照规律我们可以得知他的配偶的握手次数也为4。</span><br><span class="line"></span><br><span class="line">（7）由于 A 和其他人的握手次数都不同，因此我们可以得知握手次数为 4 的人就是 A。因此他的配偶的握手次数为 4 。</span><br></pre></td></tr></table></figure>
</li>
<li><p>你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）先走到离起点 20 公里的地方，然后放下 20 公里的油在这，然后返回起点加油。</span><br><span class="line"></span><br><span class="line">（2）当第二次到达这时，车还剩 40 公里的油，加上上一次放在这的 20 公里的油，一共就有 60 公里的油，能够走完剩下的路</span><br><span class="line">    程。</span><br></pre></td></tr></table></figure>
</li>
<li><p>烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一共需要三根绳子，假设分别为 1、2、3 号绳子，每个绳子一共有 A、B 两端。</span><br><span class="line"></span><br><span class="line">（1）首先点燃 1 号绳子的 A、B 两端，然后点燃 2 号绳子的 A 端。</span><br><span class="line"></span><br><span class="line">（2）当 1 号绳子燃尽时，此时过去了半小时，然后同时点燃 2 号绳子的 B 端。</span><br><span class="line"></span><br><span class="line">（3）当 2 号绳子燃尽时，此时又过去了 15 分钟，然后同时点燃 3 号绳子的 A、B 两端。</span><br><span class="line"></span><br><span class="line">（4）当 3 号绳子燃尽时，又过去了半小时，以此一共加起来过去了一个小时十五分钟。</span><br></pre></td></tr></table></figure>
</li>
<li><p>有 7 克、2 克砝码各一个，天平一只，如何只用这些物品三次将 140 克的盐分成 50、90 克各一份？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1） 第一次用 7 克砝码和 2 克砝码称取 9 克盐。</span><br><span class="line"></span><br><span class="line">（2） 第二次再用第一次称取的盐和砝码称取 16 克盐。</span><br><span class="line"></span><br><span class="line">（3） 第三次再用前两次称取的盐和砝码称取 25 克盐，这样就总共称取了 50 克盐，剩下的就是 90 克。</span><br></pre></td></tr></table></figure>
</li>
<li><p>有一辆火车以每小时 15 公里的速度离开洛杉矶直奔纽约，另一辆火车以第   小时 20 公里的速度从纽约开往洛杉矶。如果<br>有一只鸟，以外 30 公里每小时的速度和   两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回<br>的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于小鸟一直都在飞，直到两车相遇时才停下来。因此小鸟飞行的时间为两车相遇的时间，由于两车是相向而行，因此</span><br><span class="line">两车相遇的时间为总路程除以两车的速度之和，然后再用飞行的时间去乘以小鸟的速度，就能够得出小鸟飞行的距离。</span><br></pre></td></tr></table></figure>
</li>
<li><p>你有两个罐子，50 个红色弹球，50 个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最<br>大的选中机会？在你的计划中，得到红球的准确几率是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个罐子里放一个红球，第二个罐子里放剩余的球，这样概率接近75%，这是概率最大的方法</span><br></pre></td></tr></table></figure>
</li>
<li><p>假设你有 8 个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找<br>出这个较重的球？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最少两次可以称出。</span><br><span class="line"></span><br><span class="line">首先将 8 个球分为 3 组，其中两组为 3 个球，一组为 2 个球。</span><br><span class="line"></span><br><span class="line">第一次将两组三个的球进行比较，如果两边相等，则说明重的球在最后一组里。第二次将最后一组的球进行比较即可。如</span><br><span class="line">果两边不等，则说明重的球在较重的一边，第二次只需从这一组中随机取两球出来比较即可判断。</span><br></pre></td></tr></table></figure>
</li>
<li><p>在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一<br>盏灯？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）首先打开一盏灯 10 分钟，然后打开第二盏。</span><br><span class="line">（2）进入房间，看看那盏灯亮，摸摸那盏灯热，热的是第一个开关打开的，亮的是第二个开关打开的，而剩下的就是第三个开关打开</span><br><span class="line">    的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心<br>将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将每一对袜子分开，一人拿一只袜子，因为袜子不分左右脚的，因此最后每个人都能取回白袜和黑袜两对。</span><br></pre></td></tr></table></figure>
</li>
<li><p>有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说<br>筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从混合标签里取出一个水果，取出的是什么水果，就写上相应的标签。</span><br><span class="line"></span><br><span class="line">对应水果标签的筐的标签改为另一种水果。</span><br><span class="line"></span><br><span class="line">另一种水果标签的框改为混合。</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个班级 60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）首先确定最多的一种情况，就是 60% 喜欢足球的人同时也喜欢篮球和排球，此时为三种球都喜欢的人的最大比例。</span><br><span class="line"></span><br><span class="line">（2）然后确定最小的一种情况，根据题目可以知道有 40%的人不喜欢足球，30%的人不喜欢篮球，20%的人不喜欢排球，因此有最多</span><br><span class="line">    90% 的人三种球中有一种球不喜欢，因此三种球都喜欢的人的最小比例为 10%。</span><br><span class="line"></span><br><span class="line">因此三种球都喜欢的人占比为 10%-60%</span><br></pre></td></tr></table></figure>
</li>
<li><p>五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">五只鸡五天能下五个蛋，平均下来五只鸡每天能下一个蛋，因此五只鸡一百天就能够下一百个蛋。</span><br></pre></td></tr></table></figure>

<p>更多的智力题可以参考：<br><a href="https://blog.csdn.net/hilyoo/article/details/4445858">《经典面试智力题 200+题和解答》</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>工具</title>
    <url>/2022/10/19/20221019-tool/</url>
    <content><![CDATA[<h2 id="常用工具知识总结"><a href="#常用工具知识总结" class="headerlink" title="常用工具知识总结"></a>常用工具知识总结</h2><p>本部分主要是笔者关于常用工具所做的笔记，如果出现错误，希望大家指出！</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#git">GIT</a><ul>
<li><a href="#1-git-%E4%B8%8E-svn-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C">1. git 与 svn 的区别在哪里？</a></li>
<li><a href="#2-%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84-git-%E5%91%BD%E4%BB%A4">2. 经常使用的 git 命令？</a></li>
<li><a href="#3-git-pull-%E5%92%8C-git-fetch-%E7%9A%84%E5%8C%BA%E5%88%AB">3. git pull 和 git fetch 的区别</a></li>
<li><a href="#4-git-rebase-%E5%92%8C-git-merge-%E7%9A%84%E5%8C%BA%E5%88%AB">4. git rebase 和 git merge 的区别</a></li>
</ul>
</li>
</ul>
<h3 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h3><h4 id="1-git-与-svn-的区别在哪里？"><a href="#1-git-与-svn-的区别在哪里？" class="headerlink" title="1. git 与 svn 的区别在哪里？"></a>1. git 与 svn 的区别在哪里？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git 和 svn 最大的区别在于 git 是分布式的，而 svn 是集中式的。因此我们不能再离线的情况下使用 svn。如果服务器</span><br><span class="line">出现问题，我们就没有办法使用 svn 来提交我们的代码。</span><br><span class="line"></span><br><span class="line">svn 中的分支是整个版本库的复制的一份完整目录，而 git 的分支是指针指向某次提交，因此 git 的分支创建更加开销更小</span><br><span class="line">并且分支上的变化不会影响到其他人。svn 的分支变化会影响到所有的人。</span><br><span class="line"></span><br><span class="line">svn 的指令相对于 git 来说要简单一些，比 git 更容易上手。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83">《常见工作流比较》</a><br><a href="https://juejin.im/post/5bd95bf4f265da392c5307eb">《对比 Git 与 SVN，这篇讲的很易懂》</a><br><a href="https://blog.csdn.net/github_33304260/article/details/80171456">《GIT 与 SVN 世纪大战》</a><br><a href="https://www.jianshu.com/p/e8ad60710017">《Git 学习小记之分支原理》</a></p>
<h4 id="2-经常使用的-git-命令？"><a href="#2-经常使用的-git-命令？" class="headerlink" title="2. 经常使用的 git 命令？"></a>2. 经常使用的 git 命令？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init                     // 新建 git 代码库</span><br><span class="line">git add                      // 添加指定文件到暂存区</span><br><span class="line">git rm                       // 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">git commit -m [message]      // 提交暂存区到仓库区</span><br><span class="line">git branch                   // 列出所有分支</span><br><span class="line">git checkout -b [branch]     // 新建一个分支，并切换到该分支</span><br><span class="line">git status                   // 显示有变更的文件</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">《常用 Git 命令清单》</a></p>
<h4 id="3-git-pull-和-git-fetch-的区别"><a href="#3-git-pull-和-git-fetch-的区别" class="headerlink" title="3. git pull 和 git fetch 的区别"></a>3. git pull 和 git fetch 的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。</span><br><span class="line"></span><br><span class="line">git pull 会将远程仓库的变化下载下来，并和当前分支合并。</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/weixin_41975655/article/details/82887273">《详解 git pull 和 git fetch 的区别》</a></p>
<h4 id="4-git-rebase-和-git-merge-的区别"><a href="#4-git-rebase-和-git-merge-的区别" class="headerlink" title="4. git rebase 和 git merge 的区别"></a>4. git rebase 和 git merge 的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge 和 git rebase 都是用于分支合并，关键在 commit 记录的处理上不同。</span><br><span class="line"></span><br><span class="line">git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会</span><br><span class="line">保留之前每个分支的 commit 历史。</span><br><span class="line"></span><br><span class="line">git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后</span><br><span class="line">将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记</span><br><span class="line">录了。</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/f23f72251abc">《git rebase 和 git merge 的区别》</a><br><a href="https://blog.csdn.net/liuxiaoheng1992/article/details/79108233">《git merge 与 git rebase 的区别》</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备-webpack/xss/其他</title>
    <url>/2022/11/21/20221121-interview-other/</url>
    <content><![CDATA[<p>记录工作中想到的面试应该会的问题。</p>
<span id="more"></span>

<h2 id="4-webpack-相关知识"><a href="#4-webpack-相关知识" class="headerlink" title="4.webpack 相关知识"></a>4.webpack 相关知识</h2><h3 id="4-1-webpack-与-glup-区别"><a href="#4-1-webpack-与-glup-区别" class="headerlink" title="4.1 webpack 与 glup 区别"></a>4.1 webpack 与 glup 区别</h3><p>webpack 是一个模块化打包工具，他可以将各种格式的文件通过 loader（加载器）和 plugin（插件）对资源进行处理，打包成符合环境部署的前端资源。webpack 强调的是模块化打包。<br>webpack is a module bundle.</p>
<p>loader : sass-loader、svg-sprite-loader 等</p>
<p>pugin : DllPlugin DllReferencePlugin speed-measure-webpack-plugin webpack-bundle-analyzer</p>
<p>glup 强调的是前端开发的工作流程，我们可以通过配置一系列的 task（比如压缩文件合并，雪碧图，版本控制等）然后定义执行顺序，然后让 glup 执行这些 task，从而构建整个项目。glup 强调的是开发流程。<br>glup is a task Runner.</p>
<h3 id="4-2-webpack-原理"><a href="#4-2-webpack-原理" class="headerlink" title="4.2 webpack 原理"></a>4.2 webpack 原理</h3><p>webpack 打包原理：当 webpack 处理程序时，会根据文件间的依赖关系对其进行静态分析，根据依赖关系递归的构建一个依赖关系图（dependency graph），然后将这些模块按照指定的规则生成静态资源，其中包含应用程序需要的每个模块，然后将这些模块打包程一个或多个 bundle。</p>
<h2 id="5-XSS"><a href="#5-XSS" class="headerlink" title="5. XSS"></a>5. XSS</h2><h2 id="6-数据结构"><a href="#6-数据结构" class="headerlink" title="6.数据结构"></a>6.数据结构</h2><h3 id="6-1-二叉树"><a href="#6-1-二叉树" class="headerlink" title="6.1 二叉树"></a>6.1 二叉树</h3><p>二叉树是一种典型的树状结构，有根、左子树和子右子树。</p>
<p>前序遍历 根左右 中序遍历 左根右 后序遍历 左右根</p>
<p>只要有第一个，就一直找第一个。</p>
<p>下图中 前序：ABCDEGF 中序：CBEGDFA 后序：CGEFDBA</p>
<p><img src="https://dqtwdd.top/cdn/img/BinaryTree.png" alt="BinaryTree"></p>
<h3 id="6-2-链表"><a href="#6-2-链表" class="headerlink" title="6.2 链表"></a>6.2 链表</h3><p>链表的就是用一组任意储存单元来储存线性表的数据结构，每一个节点对象储存着它本身的值和他指向的下一个节点的地址。</p>
<p>链表分 线性链表，双向链表，环形链表。</p>
<h2 id="7-算法"><a href="#7-算法" class="headerlink" title="7. 算法"></a>7. 算法</h2><h3 id="7-1-数组扁平化"><a href="#7-1-数组扁平化" class="headerlink" title="7.1 数组扁平化"></a>7.1 数组扁平化</h3><h3 id="7-2-动态规划"><a href="#7-2-动态规划" class="headerlink" title="7.2 动态规划"></a>7.2 动态规划</h3><h3 id="7-3-获取地址栏中所有参数"><a href="#7-3-获取地址栏中所有参数" class="headerlink" title="7.3 获取地址栏中所有参数"></a>7.3 获取地址栏中所有参数</h3><h2 id="8-有哪些项目优化方法"><a href="#8-有哪些项目优化方法" class="headerlink" title="8. 有哪些项目优化方法"></a>8. 有哪些项目优化方法</h2><h3 id="8-1-加快-HTML-页面加载速度"><a href="#8-1-加快-HTML-页面加载速度" class="headerlink" title="8.1 加快 HTML 页面加载速度"></a>8.1 加快 HTML 页面加载速度</h3><ol>
<li><p>页面减肥</p>
<ul>
<li>删除不必要的空格、注释。</li>
<li>将 inline 的 script 和 css 移到外部文件。</li>
</ul>
</li>
<li><p>减少文件数量</p>
<ul>
<li>减少页面上引用的文件数量可以减少 HTTP 链接数。</li>
<li>许多 JavaScript、CSS 文件可以合并最好合并。</li>
</ul>
</li>
<li><p>减少域名查询</p>
<p>DNS 查询和解析也是消耗时间的，所以要减少对外部 JavaScript、CSS 图片等资源的引用，不同域名的使用越少越好。</p>
</li>
<li><p>缓冲重用数据</p>
<ul>
<li>对重复使用的数据进行缓存</li>
</ul>
</li>
<li><p>优化页面元素的加载顺序</p>
<ul>
<li>首先加兹安页面最初显示的内容与之相关的 JavaScript 和 CSS</li>
<li>然后加载 HTML 相关的东西，像什么不是最初显示相关的图片，视频等很肥的资源就最后加加载。</li>
</ul>
</li>
<li><p>指定图像和 table 的大小</p>
<p>如果浏览器可以立即决定图像或者 table 的大小，那么他就可以马上显示而不需要重新做一些布局安排工作。这不仅加快了页面显示，也预防了页面完成加载后布局的一些不当的改变。</p>
</li>
</ol>
<h2 id="9-工作中遇到的兼容性问题"><a href="#9-工作中遇到的兼容性问题" class="headerlink" title="9. 工作中遇到的兼容性问题"></a>9. 工作中遇到的兼容性问题</h2><h2 id="10-浏览器相关"><a href="#10-浏览器相关" class="headerlink" title="10. 浏览器相关"></a>10. 浏览器相关</h2><h3 id="10-1-浏览器缓存机制"><a href="#10-1-浏览器缓存机制" class="headerlink" title="10.1 浏览器缓存机制"></a>10.1 浏览器缓存机制</h3>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>轮询问题</title>
    <url>/2023/02/21/20230221-axios/</url>
    <content><![CDATA[<p>今天遇到了一个问题：</p>
<p>一个页面轮询请求接口，根据返回展示数据，轮询的时间比较短，一般在5s左右，我使用了setinterval就出现了以下问题：</p>
<ol>
<li>第一个请求的结果5秒还没返回，发送了第二次请求。</li>
<li>第一个请求发出之后，切换了tab（更改了请求的参数），发出了第二次请求，然后第一次返回的数据覆盖了第二次的数据，导致展示不正常。</li>
</ol>
<p>思考了一下，解决方案如下：</p>
<ol>
<li>轮询的方法用setTimeout代替setinterval，在接口返回数据之后再调用第二次。</li>
<li>更改请求参数发出新请求之后，取消上一次的请求，以最后一次的结果为准</li>
</ol>
<span id="more"></span>

<p>根据以上的结论，对接口进行了封装，然后写了轮询的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口封装</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRequestKey</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; method, url, params, data &#125; = config;</span><br><span class="line">  <span class="comment">// axios中取消请求及阻止重复请求的方法</span></span><br><span class="line">  <span class="comment">// 参数相同时阻止重复请求：</span></span><br><span class="line">  <span class="comment">// return [method, url, JSON.stringify(params), JSON.stringify(data)].join(&quot;&amp;&quot;);</span></span><br><span class="line">  <span class="comment">// 请求方法相同，参数不同时阻止重复请求</span></span><br><span class="line">  <span class="keyword">return</span> [method, url].<span class="title function_">join</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 添加请求信息 **/</span></span><br><span class="line"><span class="keyword">let</span> pendingRequest = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addPendingRequest</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// console.log(config.url)</span></span><br><span class="line">  <span class="keyword">let</span> requestKey = <span class="title function_">getRequestKey</span>(config);</span><br><span class="line">  config.<span class="property">cancelToken</span> =</span><br><span class="line">    config.<span class="property">cancelToken</span> ||</span><br><span class="line">    <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="function"><span class="params">cancel</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!pendingRequest.<span class="title function_">has</span>(requestKey)) &#123;</span><br><span class="line">        pendingRequest.<span class="title function_">set</span>(requestKey, cancel);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 取消重复请求 **/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removePendingRequest</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> requestKey = <span class="title function_">getRequestKey</span>(config);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (pendingRequest.<span class="title function_">has</span>(requestKey)) &#123;</span><br><span class="line">    <span class="comment">// 如果是重复的请求，则执行对应的cancel函数</span></span><br><span class="line">    <span class="keyword">let</span> cancel = pendingRequest.<span class="title function_">get</span>(requestKey);</span><br><span class="line">    <span class="title function_">cancel</span>(requestKey);</span><br><span class="line">    <span class="comment">// 将前一次重复的请求移除</span></span><br><span class="line">    pendingRequest.<span class="title function_">delete</span>(requestKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="title function_">removePendingRequest</span>(config);</span><br><span class="line">    <span class="title function_">addPendingRequest</span>(config);</span><br><span class="line">    <span class="comment">// 请求头添加token</span></span><br><span class="line">    <span class="keyword">var</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      config.<span class="property">headers</span>.<span class="property">Authorization</span> = token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">removePendingRequest</span>(res.<span class="property">config</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">removePendingRequest</span>(err.<span class="property">config</span> || &#123;&#125;);</span><br><span class="line">    <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(err)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;被取消的重复请求：&quot;</span> + err.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">function,obj,callBack,boolean</span>&#125; requestInterface,params,cb,isForce</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">object</span>&#125; <span class="variable">promiseRes</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> timer = &#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">rollPoling</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  requestInterface,</span></span><br><span class="line"><span class="params">  params,</span></span><br><span class="line"><span class="params">  cb,</span></span><br><span class="line"><span class="params">  isForce = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">  time = <span class="number">5000</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> funcName = requestInterface.<span class="property">name</span>;</span><br><span class="line">  <span class="keyword">if</span> (!timer[funcName]) &#123;</span><br><span class="line">    timer[funcName] = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isForce &amp;&amp; timer[funcName]) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer[funcName]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">singleQuery</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">requestInterface</span>(params);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      <span class="title function_">cb</span>(res);</span><br><span class="line">      timer[funcName] = <span class="built_in">setTimeout</span>(singleQuery, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">singleQuery</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>熟练使⽤webpack、rollup、vite等构建⼯具，熟悉⼯程搭建和优化</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序分享总结</title>
    <url>/2023/02/27/20230227-miniProgram/</url>
    <content><![CDATA[<h1 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h1><h2 id="1-什么是小程序"><a href="#1-什么是小程序" class="headerlink" title="1. 什么是小程序"></a>1. 什么是小程序</h2><p>小程序是一个不需要下载和安装的应用。</p>
<h2 id="2-App-小程序-H5对比"><a href="#2-App-小程序-H5对比" class="headerlink" title="2. App/小程序/H5对比"></a>2. App/小程序/H5对比</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>【APP】 <ol>
<li>运行速度快，体验好。 </li>
<li>可使用底层的设备功能，如摄像头、方向传感器、重力传感器、拨号、GPS、语音、短信、蓝牙等； </li>
<li>在界面设计、功能设计、操作逻辑等方面，更容易做到流畅性、用户体验好。且留存率高，用户一旦下载，相较于其他两端，留存的可能性大。</li>
<li>精准，超强用户黏性。一旦主动下载了APP，便是基于本身APP的内容有兴趣，同时APP会一直待在用户手机里，APP端便有了不断向用户传播信息，达到唤醒沉睡用户的机会。 </li>
</ol>
</li>
<li>【小程序】 <ol>
<li>背靠微博的流量；使得小程序更易获客，降低获客成本（附近小程序功能），同时可借助微博的社交网络引发爆发性传播，“在巨人肩膀搭积木”。 </li>
<li>连接线上与线下；推动线下用户习惯的养成，小程序相比APP更容易达成线上线下场景的连接与互动。 </li>
<li>无需下载，即用即走，体验度接近原生，用户体验好。该概念是小程序一上线就开始打的战略，可做APP的整体嫁接，也可做简洁版功能的承载体，这一特点使得能代替许多APP。 </li>
<li>相对于开发app开发成本低、体验接近原生。 </li>
</ol>
</li>
<li>【H5】 <ol>
<li>跨平台性（同时兼容PC端、移动端、Windows、Linux、Android与ios） </li>
<li>开发周期短，维护成本较低，可快速迭代。 </li>
<li>开发相对较容易，对浏览器适配简单，简单易发布，直接上传即可，无需审核。</li>
</ol>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>【APP】 <ol>
<li>开发周期长，费用多，不同的操作系统（Android与ios）需要独立开发，且维护起来也比较麻烦。</li>
<li>获客成本高，用户使用需要下载。 </li>
<li>更新需要上架审核，Android需在各大应用市场，ios需在App store上进行上架审核，受制于各大应用商店的规范中，上架后用户需重新更新安装。 </li>
</ol>
</li>
<li>【小程序】 <ol>
<li>用户留存困难，在小程序中留存的概念弱。该缺点也正是由于“即用即走”的特点，导致留存困难。 </li>
<li>受制于微博管控，功能的开发取决于微博的赋能</li>
</ol>
</li>
<li>【H5】<ol>
<li>用户体验差，每次打开页面，需要重新加载； </li>
<li>加载速度慢，若是在网络情况差的情况下，网页可能加载需要长久的时间； </li>
<li>仅能使用部分设备底层的功能，蓝牙、短信、摄像头、麦克风等功能无法使用，造成开发功能局限。</li>
</ol>
</li>
</ul>
<h2 id="3-小程序原理"><a href="#3-小程序原理" class="headerlink" title="3. 小程序原理"></a>3. 小程序原理</h2><p>微信小程序的框架包含两部分<strong>View视图层</strong>、<strong>App Service逻辑层</strong>。</p>
<p><strong>View层</strong>用来渲染页面结构；<strong>AppService层</strong>用来逻辑处理、数据请求、接口调用。</p>
<p>它们在两个进程里运行。 视图层和逻辑层通过系统层的JSBridage进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1148531/6faxo6p80s.jpeg?imageView2/2/w/1620" alt="小程序架构图"></p>
<h2 id="4-拓展—快应用"><a href="#4-拓展—快应用" class="headerlink" title="4. 拓展—快应用"></a>4. 拓展—快应用</h2><p>快应用是各大手机厂商基于硬件平台共同推出的新型应用生态。用户无需下载安装，即点即用，享受原生应用的性能体验。</p>
<p>加入厂商：华为、小米、OPPO、vivo、中兴、金立、联想、魅族、努比亚…</p>
<p><img src="https://pic3.zhimg.com/80/v2-d968f43c32c65555c5e1ba355395f606_720w.webp" alt="快应用对比"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>web-worker</title>
    <url>/2023/03/20/20230320-web-worker/</url>
    <content><![CDATA[<p>关于web-worker的学习总结。</p>
<span id="more"></span>

<p>浏览器是单线程的，所以在进行大量的计算或者大量数据的渲染时会发生页面卡顿，使用webworker可以很好的解决这一问题。</p>
<p><strong><a href="https://juejin.cn/post/7137728629986820126">看这里</a></strong></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>简洁的log</title>
    <url>/2024/05/06/20240506-autolog/</url>
    <content><![CDATA[<p> 简洁的log</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cssStr = <span class="string">`#autolog&#123;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;pointer-events:none;width:100vw;height:100vh;position:fixed;left:0;top:0;z-index:9999999;cursor:pointer;transition:0.2s&#125;#autolog span&#123;pointer-events:auto;width:max-content;animation:fadein 0.4s;animation-delay:0s;border-radius:6px;padding:10px 20px;box-shadow:0 0 10px 6px rgba(0,0,0,0.1);margin:4px;transition:0.2s;z-index:9999999;font-size:14px;display:flex;align-items:center;justify-content:center;gap:4px;height:max-content&#125;#autolog span.hide&#123;opacity:0;pointer-events:none;transform:translateY(-10px);height:0;padding:0;margin:0&#125;.autolog-warn&#123;background-color:#fffaec;color:#e29505&#125;.autolog-error&#123;background-color:#fde7e7;color:#d93025&#125;.autolog-info&#123;background-color:#e6f7ff;color:#0e6eb8&#125;.autolog-success&#123;background-color:#e9f7e7;color:#1a9e2c&#125;.autolog-&#123;background-color:#fafafa;color:#333&#125;@keyframes fadein&#123;0%&#123;opacity:0;transform:translateY(-10px)&#125;100%&#123;opacity:1;transform:translateY(0)&#125;&#125;`</span>;</span><br><span class="line"><span class="keyword">const</span> svgIcons = &#123;</span><br><span class="line">  <span class="attr">warn</span>: <span class="string">`&lt;svg t=&quot;1713405237257&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;2387&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;16&quot; height=&quot;16&quot;&gt;&lt;path d=&quot;M934.4 770.133333L605.866667 181.333333C586.666667 147.2 550.4 128 512 128c-38.4 0-74.666667 21.333333-93.866667 53.333333L89.6 770.133333c-19.2 34.133333-19.2 76.8 0 110.933334S145.066667 938.666667 183.466667 938.666667h657.066666c38.4 0 74.666667-21.333333 93.866667-57.6 19.2-34.133333 19.2-76.8 0-110.933334z m-55.466667 81.066667c-8.533333 14.933333-23.466667 23.466667-38.4 23.466667H183.466667c-14.933333 0-29.866667-8.533333-38.4-23.466667-8.533333-14.933333-8.533333-34.133333 0-49.066667L473.6 213.333333c8.533333-12.8 23.466667-21.333333 38.4-21.333333s29.866667 8.533333 38.4 21.333333l328.533333 588.8c8.533333 14.933333 8.533333 32 0 49.066667z&quot; fill=&quot;#e29505&quot; p-id=&quot;2388&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M512 746.666667m-42.666667 0a42.666667 42.666667 0 1 0 85.333334 0 42.666667 42.666667 0 1 0-85.333334 0Z&quot; fill=&quot;#e29505&quot; p-id=&quot;2389&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M512 629.333333c17.066667 0 32-14.933333 32-32v-192c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v192c0 17.066667 14.933333 32 32 32z&quot; fill=&quot;#e29505&quot; p-id=&quot;2390&quot;&gt;&lt;/path&gt;&lt;/svg&gt;`</span>,</span><br><span class="line">  <span class="attr">error</span>: <span class="string">`&lt;svg t=&quot;1713405212725&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;1744&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;16&quot; height=&quot;16&quot;&gt;&lt;path d=&quot;M512 74.666667C270.933333 74.666667 74.666667 270.933333 74.666667 512S270.933333 949.333333 512 949.333333 949.333333 753.066667 949.333333 512 753.066667 74.666667 512 74.666667z m0 810.666666c-204.8 0-373.333333-168.533333-373.333333-373.333333S307.2 138.666667 512 138.666667 885.333333 307.2 885.333333 512 716.8 885.333333 512 885.333333z&quot; fill=&quot;#d93025&quot; p-id=&quot;1745&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M657.066667 360.533333c-12.8-12.8-32-12.8-44.8 0l-102.4 102.4-102.4-102.4c-12.8-12.8-32-12.8-44.8 0-12.8 12.8-12.8 32 0 44.8l102.4 102.4-102.4 102.4c-12.8 12.8-12.8 32 0 44.8 6.4 6.4 14.933333 8.533333 23.466666 8.533334s17.066667-2.133333 23.466667-8.533334l102.4-102.4 102.4 102.4c6.4 6.4 14.933333 8.533333 23.466667 8.533334s17.066667-2.133333 23.466666-8.533334c12.8-12.8 12.8-32 0-44.8l-106.666666-100.266666 102.4-102.4c12.8-12.8 12.8-34.133333 0-46.933334z&quot; fill=&quot;#d93025&quot; p-id=&quot;1746&quot;&gt;&lt;/path&gt;&lt;/svg&gt;`</span>,</span><br><span class="line">  <span class="attr">info</span>: <span class="string">`&lt;svg t=&quot;1713405208589&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;1582&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;16&quot; height=&quot;16&quot;&gt;&lt;path d=&quot;M853.333333 138.666667H170.666667c-40.533333 0-74.666667 34.133333-74.666667 74.666666v512c0 40.533333 34.133333 74.666667 74.666667 74.666667h151.466666V917.333333c0 12.8 8.533333 25.6 19.2 29.866667 4.266667 2.133333 8.533333 2.133333 12.8 2.133333 8.533333 0 17.066667-4.266667 23.466667-10.666666l136.533333-138.666667H853.333333c40.533333 0 74.666667-34.133333 74.666667-74.666667V213.333333c0-40.533333-34.133333-74.666667-74.666667-74.666666z m10.666667 586.666666c0 6.4-4.266667 10.666667-10.666667 10.666667H501.333333c-8.533333 0-17.066667 4.266667-23.466666 10.666667l-89.6 93.866666V768c0-17.066667-14.933333-32-32-32H170.666667c-6.4 0-10.666667-4.266667-10.666667-10.666667V213.333333c0-6.4 4.266667-10.666667 10.666667-10.666666h682.666666c6.4 0 10.666667 4.266667 10.666667 10.666666v512z&quot; fill=&quot;#0e6eb8&quot; p-id=&quot;1583&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M512 490.666667H298.666667c-17.066667 0-32 14.933333-32 32S281.6 554.666667 298.666667 554.666667h213.333333c17.066667 0 32-14.933333 32-32S529.066667 490.666667 512 490.666667zM672 341.333333H298.666667c-17.066667 0-32 14.933333-32 32S281.6 405.333333 298.666667 405.333333h373.333333c17.066667 0 32-14.933333 32-32s-14.933333-32-32-32z&quot; fill=&quot;#0e6eb8&quot; p-id=&quot;1584&quot;&gt;&lt;/path&gt;&lt;/svg&gt;`</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="string">`&lt;svg t=&quot;1713405224326&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;2225&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;16&quot; height=&quot;16&quot;&gt;&lt;path d=&quot;M512 74.666667C270.933333 74.666667 74.666667 270.933333 74.666667 512S270.933333 949.333333 512 949.333333 949.333333 753.066667 949.333333 512 753.066667 74.666667 512 74.666667z m0 810.666666c-204.8 0-373.333333-168.533333-373.333333-373.333333S307.2 138.666667 512 138.666667 885.333333 307.2 885.333333 512 716.8 885.333333 512 885.333333z&quot; fill=&quot;#1a9e2c&quot; p-id=&quot;2226&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M701.866667 381.866667L448 637.866667 322.133333 512c-12.8-12.8-32-12.8-44.8 0-12.8 12.8-12.8 32 0 44.8l149.333334 149.333333c6.4 6.4 14.933333 8.533333 23.466666 8.533334s17.066667-2.133333 23.466667-8.533334l277.333333-277.333333c12.8-12.8 12.8-32 0-44.8-14.933333-12.8-36.266667-12.8-49.066666-2.133333z&quot; fill=&quot;#1a9e2c&quot; p-id=&quot;2227&quot;&gt;&lt;/path&gt;&lt;/svg&gt;`</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> autolog = &#123;</span><br><span class="line">  <span class="title function_">log</span>(<span class="params">text, type = <span class="string">&quot;&quot;</span>, time = <span class="number">2500</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      time = type;</span><br><span class="line">      type = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mainEl = <span class="title function_">getMainElement</span>();</span><br><span class="line">    <span class="keyword">let</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>);</span><br><span class="line">    el.<span class="property">className</span> = <span class="string">`autolog-<span class="subst">$&#123;type&#125;</span>`</span>;</span><br><span class="line">    el.<span class="property">innerHTML</span> = svgIcons[type] + text;</span><br><span class="line">    mainEl.<span class="title function_">appendChild</span>(el);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      el.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;hide&quot;</span>);</span><br><span class="line">    &#125;, time - <span class="number">500</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      mainEl.<span class="title function_">removeChild</span>(el);</span><br><span class="line">      el = <span class="literal">null</span>;</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMainElement</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> mainEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#autolog&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!mainEl) &#123;</span><br><span class="line">    mainEl = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    mainEl.<span class="property">id</span> = <span class="string">&quot;autolog&quot;</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(mainEl);</span><br><span class="line">    <span class="keyword">let</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">    style.<span class="property">innerHTML</span> = cssStr;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">insertBefore</span>(style, <span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">firstChild</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mainEl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> autolog;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>工作相关记录</title>
    <url>/2020/09/19/20201019-work/</url>
    <content><![CDATA[<p>此篇博客用来记录工作中遇到的的问题以及解决方案。</p>
<span id="more"></span>

<h3 id="0-Important"><a href="#0-Important" class="headerlink" title="0.Important!!!!!!!!!"></a>0.Important!!!!!!!!!</h3><h4 id="1-能用基础属性解决的布局问题尽量不要使用-flex-等方式。可能会有奇奇怪怪的兼容性问题！！！"><a href="#1-能用基础属性解决的布局问题尽量不要使用-flex-等方式。可能会有奇奇怪怪的兼容性问题！！！" class="headerlink" title="1.能用基础属性解决的布局问题尽量不要使用 flex 等方式。可能会有奇奇怪怪的兼容性问题！！！"></a>1.能用基础属性解决的布局问题尽量不要使用 flex 等方式。可能会有奇奇怪怪的兼容性问题！！！</h4><h4 id="2-Object-prototype-toString-apply-param"><a href="#2-Object-prototype-toString-apply-param" class="headerlink" title="2. Object.prototype.toString.apply(param) "></a>2. <code>Object.prototype.toString.apply(param) </code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>([<span class="number">1</span>,<span class="number">2</span>])    <span class="comment">//&quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="string">&#x27;str&#x27;</span>)    <span class="comment">//&quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="number">1</span>)        <span class="comment">//&quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="title class_">NaN</span>)        <span class="comment">//&quot;[object Number]&quot; NaN是Number类型！</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="literal">null</span>)     <span class="comment">//&quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>()         <span class="comment">//&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)      <span class="comment">//&quot;[object Function]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="literal">true</span>)     <span class="comment">//&quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="keyword">new</span> <span class="title class_">Object</span>())     <span class="comment">//&quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p>  切记！使用类似 <code>document.referrer.split(&#39;#&#39;)[0]</code> 这种方法的时候一定一定一定一定要判断 <code>document.referrer</code> 有没有 <code>split</code> 方法,里面有没有 <code>#</code>, <code>document.referrer.split(&#39;#&#39;)</code>有没有 <code>[0]</code></p>
<p>此时<code>Object.prototype.toString.apply()</code>是个好方法，可以直接得到属性！！！优秀！！</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 hideSrcebusList[flag][srcebus].includes(companyNo) 要判断</span></span><br><span class="line"><span class="comment">// hideSrcebusList[flag]是否存在， hideSrcebusList[flag][srcebus]是否存在</span></span><br><span class="line"><span class="keyword">if</span> (!hideSrcebusList[flag] || !hideSrcebusList[flag][srcebus]) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> (hideSrcebusList[flag][srcebus].<span class="title function_">includes</span>(companyNo)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-attrs"><a href="#1-attrs" class="headerlink" title="1. $attrs"></a>1. <code>$attrs</code></h3><p>官方释意：<br>包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用。</p>
<p><code>$attrs</code>用于父子组件传值（或者子孙组件等）时子组件可以通过<code>$attrs</code>可以访问父组件传过来的所有属性。</p>
<p>需要注意的是如果父组件所传属性如果已经在子组件<code>props</code>中声明过的话，该属性不会出现在<code>$attrs</code>中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是父组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">test</span> <span class="attr">name</span>=<span class="string">&quot;tom&quot;</span> <span class="attr">:age</span>=<span class="string">&quot;12&quot;</span> <span class="attr">:id</span>=<span class="string">&quot;12345&quot;</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">test</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">template</span>: <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="language-javascript"><span class="language-xml">      &lt;div&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="language-javascript"><span class="language-xml">        &lt;p&gt;我是子组件&lt;/p&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="language-javascript"><span class="language-xml">        &lt;test2 v-bind=&quot;$attrs&quot; s1=&quot;sss&quot; s2=&quot;sss&quot; /&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="language-javascript"><span class="language-xml">      &lt;/div&gt;`</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">props</span>: [<span class="string">&quot;name&quot;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// [Important]</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$attrs</span>); <span class="comment">// &#123;age: 12, id: 12345&#125;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">test2</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">template</span>: <span class="string">`&lt;p&gt;我是孙子组件&lt;/p&gt;`</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">props</span>: [<span class="string">&quot;age&quot;</span>, <span class="string">&quot;s1&quot;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// [Important]</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$attrs</span>); <span class="comment">// &#123;s2: &quot;sss&quot;, id: 12345&#125;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-inheritAttrs"><a href="#2-inheritAttrs" class="headerlink" title="2.inheritAttrs"></a>2.<code>inheritAttrs</code></h3><p>如果你不希望组件的根元素继承特性，你可以在组件的选项中设置 inheritAttrs: false。</p>
<p><a href="https://www.cnblogs.com/luyuefeng/p/11106172.html">参考</a></p>
<h3 id="3-关于-tree-shaking"><a href="#3-关于-tree-shaking" class="headerlink" title="3. 关于 tree-shaking"></a>3. 关于 tree-shaking</h3><p><a href="https://juejin.im/post/6844903544756109319">参考</a></p>
<h3 id="4-全屏组件返回"><a href="#4-全屏组件返回" class="headerlink" title="4. 全屏组件返回"></a>4. 全屏组件返回</h3><p>今天遇到一个有趣的功能，有些 <code>.vue</code> 需要全屏使用，但是在手机中点击返回时会不但会关闭组件，而且会返回之前的页面。</p>
<p>主要要实现的功能就是返回时只关闭组件，不返回上一个页面。</p>
<p>使用到的功能为 <code>pushState</code> ，思路就是打开页面时使用 <code>window.history.pushState(null,null,&#39;#&#39;)</code> 在浏览器的地址中添加一个。如果点击返回，返回时在地址往前走一个，同时关闭组件；然后再选中的关闭中加上 <code>window.history.go(-1)</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;SelectBranch_main cell_main&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.native</span>=<span class="string">&quot;showPop&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;showBranch&quot;</span> <span class="attr">v-fixed</span> <span class="attr">class</span>=<span class="string">&quot;SelectBranch_main_content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;selectBranch&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  data () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">showBranch</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  mounted () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 监听 popstate事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="variable language_">this</span>.<span class="property">popstate</span>, <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  beforeDestroy () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 移除popstate事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="variable language_">this</span>.<span class="property">popstate</span>, <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">async</span> getInfo () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">storeList</span> = (<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">$url</span>.<span class="property">getAvailableInstitutions</span>, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">params</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">serviceType</span>: <span class="variable language_">this</span>.<span class="property">model</span>.<span class="property">serviceType</span>, <span class="attr">provinceId</span>: <span class="variable language_">this</span>.<span class="property">model</span>.<span class="property">provinceId</span>, <span class="attr">cityId</span>: <span class="variable language_">this</span>.<span class="property">model</span>.<span class="property">cityId</span>, <span class="attr">institutionId</span>: <span class="variable language_">this</span>.<span class="property">model</span>.<span class="property">institutionId</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;)).<span class="property">info</span>.<span class="property">list</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    popstate () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">showBranch</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 关团]弹窗</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">showBranch</span> = !<span class="variable language_">this</span>.<span class="property">showBranch</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 打开组件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    showPop () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="title function_">getInfo</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">showBranch</span> = <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">pushState</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 确定</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    selectBranch (item) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">showBranch</span> = <span class="literal">false</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">go</span>(-<span class="number">1</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>参考资料：<a href="https://www.cnblogs.com/wyx-remove-love/p/wyx-20190510-1.html">CSDN 博客</a></p>
<h3 id="5-防抖"><a href="#5-防抖" class="headerlink" title="5. 防抖"></a>5. 防抖</h3><p>函数防抖有专门的 debounce，但是有些情况需要所有请求时都要有防抖，防止请求短时间内多次触发。</p>
<p>传统防抖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防止抖动</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait, immediate</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">const</span> immediates = immediate || <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">const</span> later = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (!immediates) fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> call = immediates &amp;&amp; !timeout;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    <span class="keyword">if</span> (call) <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(later, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止抖动less版</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">debounceLess</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求封装防抖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正在进行中的请求列表</span></span><br><span class="line"><span class="keyword">let</span> reqList = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻止重复请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">array</span>&#125; <span class="variable">reqList</span> - 请求缓存列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">url</span> - 当前请求地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">function</span>&#125; <span class="variable">cancel</span> - 请求中断函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">errorMessage</span> - 请求中断时需要显示的错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> stopRepeatRequest = <span class="keyword">function</span> (<span class="params">reqList, url, cancel, errorMessage</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> errorMsg = errorMessage || <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reqList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (reqList[i] === url) &#123;</span><br><span class="line">      <span class="title function_">cancel</span>(errorMsg);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  reqList.<span class="title function_">push</span>(url);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许某个请求可以继续进行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">array</span>&#125; reqList 全部请求列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; url 请求地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> allowRequest = <span class="keyword">function</span> (<span class="params">reqList, url</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reqList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (reqList[i] === url) &#123;</span><br><span class="line">      reqList.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> service = axios.<span class="title function_">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cancel;</span><br><span class="line">    <span class="comment">// 设置cancelToken对象</span></span><br><span class="line">    config.<span class="property">cancelToken</span> = <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">      cancel = c;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 阻止重复请求。当上个请求未完成时，相同的请求不会进行</span></span><br><span class="line">    <span class="title function_">stopRepeatRequest</span>(reqList, config.<span class="property">url</span>, cancel, <span class="string">`<span class="subst">$&#123;config.url&#125;</span> 请求被中断`</span>);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 增加延迟，相同请求不得在短时间内重复发送</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">allowRequest</span>(reqList, response.<span class="property">config</span>.<span class="property">url</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// ...请求成功后的后续操作</span></span><br><span class="line">    <span class="comment">// successHandler(response)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(thrown)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(thrown.<span class="property">message</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 增加延迟，相同请求不得在短时间内重复发送</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">allowRequest</span>(reqList, error.<span class="property">config</span>.<span class="property">url</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...请求失败后的后续操作</span></span><br><span class="line">    <span class="comment">// errorHandler(error)</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>参考资料：<a href="https://blog.csdn.net/qq_32615575/article/details/105712068">CSDN 博客</a></p>
<h3 id="6-nvm-安装后-npm-命令找不到"><a href="#6-nvm-安装后-npm-命令找不到" class="headerlink" title="6. nvm 安装后 npm 命令找不到"></a>6. nvm 安装后 npm 命令找不到</h3><p>切换到最新版本后使用<code>npm install npm@latest -g</code>安装</p>
<h3 id="7-某些机型设置-1px-线条不显示-（scaleY-0-5-）"><a href="#7-某些机型设置-1px-线条不显示-（scaleY-0-5-）" class="headerlink" title="7. 某些机型设置 1px 线条不显示 （scaleY(0.5)）"></a>7. 某些机型设置 1px 线条不显示 （scaleY(0.5)）</h3><p>将缩放属性写在行内<code>&lt;div style=&quot;transform: scaleY(0.5);&quot; class=&quot;border_one&quot;&gt;&lt;/div&gt;</code></p>
<h3 id="8-插入图片页面抖动"><a href="#8-插入图片页面抖动" class="headerlink" title="8. 插入图片页面抖动"></a>8. 插入图片页面抖动</h3><p>overflow:hidden;<br>height:0;<br>padding-bottom:<em>; // 其中</em>处填 图片的高宽百分比=高/宽*100%<br>核心思想就是使用 padding 将撑开宽高，类似骨架屏的效果。</p>
<h3 id="9-下划线"><a href="#9-下划线" class="headerlink" title="9. 下划线"></a>9. 下划线</h3><p>搞出来一个信纸下划线效果，核心思想是使用 <code>background</code> 属性结合 <code>linear-gradient</code> 线性渐变，实际上整个背景色就是 y 方向 repeat 的横条，只不过显示文字的地方的透明度是 0，线的部分透明度为 1。要注意设置 <code>line-height</code> 和 <code>background-size</code> 的 <code>height</code> 一致，这样才能保证下划线在文字下方。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;letter_txt&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;under_line&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！您好！</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// css</span></span><br><span class="line"> .<span class="property">letter_txt</span> &#123;</span><br><span class="line">    line-<span class="attr">height</span>: 50px;</span><br><span class="line">    .<span class="property">under_line</span> &#123;</span><br><span class="line">      text-<span class="attr">indent</span>: 2em;</span><br><span class="line">      text-<span class="attr">align</span>: left;</span><br><span class="line">      <span class="attr">background</span>: linear-<span class="title function_">gradient</span>(</span><br><span class="line">          <span class="title function_">rgba</span>(<span class="attr">$color</span>: #<span class="number">000000</span>, <span class="attr">$alpha</span>: <span class="number">0</span>),</span><br><span class="line">          <span class="title function_">rgba</span>(<span class="attr">$color</span>: #<span class="number">000000</span>, <span class="attr">$alpha</span>: <span class="number">0</span>) <span class="number">95</span>%,</span><br><span class="line">          <span class="title function_">rgba</span>(<span class="attr">$color</span>: #dca287, <span class="attr">$alpha</span>: <span class="number">0.35</span>) <span class="number">96</span>%,</span><br><span class="line">          <span class="title function_">rgba</span>(<span class="attr">$color</span>: #dca287, <span class="attr">$alpha</span>: <span class="number">0.35</span>)</span><br><span class="line">        )</span><br><span class="line">        repeat-y;</span><br><span class="line">      background-<span class="attr">size</span>: <span class="number">100</span>% 50px;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-时间比较"><a href="#10-时间比较" class="headerlink" title="10. 时间比较"></a>10. 时间比较</h3><p>工作中遇到两个日期比较的情况，这时可以在创建 <code>date</code> 对象时传入时间参数，需要注意的是 <code>Month</code> 要 -1，新创建的 <code>date</code> 对象的时间是当前时间，所以要比较的时候可以使用 <code>setTime</code> 把时间设置成一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @params</span></span><br><span class="line"><span class="comment">// @bookingDetail 获取的时间 格式为 YYYY-MM-DD HH:MM:MM</span></span><br><span class="line"><span class="keyword">const</span> year = <span class="variable language_">this</span>.<span class="property">bookingDetail</span>.<span class="property">dateTime</span>.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>] * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> month = <span class="variable language_">this</span>.<span class="property">bookingDetail</span>.<span class="property">dateTime</span>.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>] * <span class="number">1</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> day = <span class="variable language_">this</span>.<span class="property">bookingDetail</span>.<span class="property">dateTime</span>.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>] * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> dateGet = <span class="keyword">new</span> <span class="title class_">Date</span>(year, month, day);</span><br><span class="line"><span class="keyword">const</span> dateNow = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">dateGet.<span class="title function_">setHours</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">dateNow.<span class="title function_">setHours</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 然后 dateGet和dateNow就可以用&lt;&gt;=比较了</span></span><br></pre></td></tr></table></figure>

<h3 id="11-url-拼汉字"><a href="#11-url-拼汉字" class="headerlink" title="11. url 拼汉字"></a>11. url 拼汉字</h3><p>某些情况下参数中拼汉字时会报错（比如微信分享参数直接写汉字就会报错），这时就需要对文字做转码。</p>
<p>第一次转码使用 <code>encodeURIComponent</code> 和 <code>decodeURIComponent</code> 进行 url 编码，将汉字转换为 url 编码，但是 url 编码含有 <code>%</code> 还是可能报错，所以需要转码两次。</p>
<p>第二次转码使用团队的大手子了解到的两个方法 <code>atob</code> <code>btoa</code> 转为 base64 或者 base64 转回去。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b64Encode</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">btoa</span>(<span class="built_in">encodeURIComponent</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b64Decode</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(<span class="title function_">atob</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> strChinaBase64 = <span class="title function_">b64Encode</span>(<span class="string">&quot;你好&quot;</span>); <span class="comment">// &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">b64Decode</span>(strChinaBase64)); <span class="comment">// &quot;你好&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="12-Chrome-调试技巧"><a href="#12-Chrome-调试技巧" class="headerlink" title="12. Chrome 调试技巧"></a>12. Chrome 调试技巧</h3><p>1.copy()</p>
<p>在移动端 <code>v-console</code> 好多东西复制不了 有好办法啦。</p>
<p>可以使用 <code>copy()</code> 全局方法复制几乎任何东西哦。</p>
<p>2.使用 Command</p>
<p>在 Chrome 的调试打开的情况下 按下 <code>[ Ctrl] + [Shift] + [P]</code></p>
<p>截屏 输入 <code>screen</code> 找到 <code>Capture full size screenshot</code></p>
<p>3.修改 layout</p>
<p>输入 <code>layout</code> ，你会看到 2 到 3 个可供选择的项(这里不再显示你已经激活的选项)：</p>
<p>使用横向面板布局<br>使用纵向面板布局<br>使用自动面板布局</p>
<p>4.修改主题</p>
<p>输入 <code>theme</code> 可以修改主题</p>
<p>5.console</p>
<p><code>console.log(&#123;a,b,c&#125;)</code> 可以直接打印键值对 省去输入字符串的烦恼</p>
<p><code>console.dir(div)</code> 可以打印 dom 节点的方法等参数</p>
<h3 id="13-项目优化技巧"><a href="#13-项目优化技巧" class="headerlink" title="13. 项目优化技巧"></a>13. 项目优化技巧</h3><p>1.图片压缩 图片无损压缩可以将图片缩小约 75%的体积。</p>
<p>2.路由懒加载 在路由中一次性将所有 vue 文件引入会导致将所有文件打包在一个 js 中，在访问单页面时打包后的 js 文件利用率很低，同时会导致首页白屏时间很长，使用路由懒加载可以将各个页面的 vue 文件分开打包，在访问该页面时才去加载对应的 js 文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./views/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;./views/Login.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Role</span> <span class="keyword">from</span> <span class="string">&#x27;./views/system/Role.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">User</span> <span class="keyword">from</span> <span class="string">&#x27;./views/system/User.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./views/Home.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Login</span> = (<span class="params"></span>) =&gt; <span class="title function_">import</span>(<span class="params"><span class="string">&#x27;./views/Login.vue&#x27;</span></span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/Login&#x27;</span>, <span class="comment">// 微信-小知识</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">Login</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/Login&#x27;</span>, <span class="comment">// 微信-小知识</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;Login&quot; */</span> <span class="string">&#x27;./views/Login.vue&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.提高首屏加载速度</p>
<p>首先 webpack 打包时会根据 <code>entry</code> 文件生成 bundlejs，然后在模板 html 中引入，所以，为了加快首屏加载速度可以将一些首屏没有使用到的模块拿出来，在需要引用的位置引用。</p>
<h3 id="13-webpack-相关-更详细的内容单开了一篇博客，可以去那里看哦"><a href="#13-webpack-相关-更详细的内容单开了一篇博客，可以去那里看哦" class="headerlink" title="13. webpack 相关(更详细的内容单开了一篇博客，可以去那里看哦)"></a>13. webpack 相关(更详细的内容单开了一篇博客，可以去那里看哦)</h3><h4 id="1-chunk-bundle"><a href="#1-chunk-bundle" class="headerlink" title="1.chunk bundle"></a>1.chunk bundle</h4><p>chunk：webpack 配置中，每一个入口文件，以及入口文件里所有引入的文件的集合，就是一个 chunk。</p>
<p>bundle：bundle 是打包之后，打包出来的文件。</p>
<p>参考资料：<a href="https://www.cnblogs.com/skychx/p/webpack-module-chunk-bundle.html">webpack 中，module，chunk 和 bundle 的区别是什么？</a></p>
<h4 id="2-压缩工具"><a href="#2-压缩工具" class="headerlink" title="2.压缩工具"></a>2.压缩工具</h4><p>uglifyjs-webpack-plugin 传统老牌的压缩插件，缺点是不支持 es6。</p>
<p>terser-webpack-plugin 推荐使用。</p>
<h4 id="3-打包时间插件"><a href="#3-打包时间插件" class="headerlink" title="3.打包时间插件"></a>3.打包时间插件</h4><p>speed-measure-webpack-plugin</p>
<h3 id="14-webpack-打包优化之-splitChunk"><a href="#14-webpack-打包优化之-splitChunk" class="headerlink" title="14. webpack 打包优化之 splitChunk"></a>14. webpack 打包优化之 splitChunk</h3><p>SplitChunks 插件配置选项：</p>
<ul>
<li><p>chunks 选项，决定要提取那些模块。</p>
<ul>
<li><p>默认是 async：只提取异步加载的模块出来打包到一个文件中。</p>
</li>
<li><p>异步加载的模块：通过 import(‘xxx’)或 require([‘xxx’],() =&gt;{})加载的模块。</p>
</li>
<li><p>initial：提取同步加载和异步加载模块，如果 xxx 在项目中异步加载了，也同步加载了，那么 xxx 这个模块会被提取两次，分别打包到不同的文件中。</p>
<ul>
<li>同步加载的模块：通过 import xxx 或 require(‘xxx’)加载的模块。</li>
</ul>
</li>
<li><p>all：不管异步加载还是同步加载的模块都提取出来，打包到一个文件中。</p>
</li>
</ul>
</li>
<li><p>minSize 选项：规定被提取的模块在压缩前的大小最小值，单位为字节，默认为 30000，只有超过了 30000 字节才会被提取。</p>
</li>
<li><p>maxSize 选项：把提取出来的模块打包生成的文件大小不能超过 maxSize 值，如果超过了，要对其进行分割并打包生成新的文件。单位为字节，默认为 0，表示不限制大小。</p>
</li>
<li><p>minChunks 选项：表示要被提取的模块最小被引用次数，引用次数超过或等于 minChunks 值，才能被提取。</p>
</li>
<li><p>maxAsyncRequests 选项：最大的按需(异步)加载次数，默认为 6。</p>
</li>
<li><p>maxInitialRequests 选项：打包后的入口文件加载时，还能同时加载 js 文件的数量（包括入口文件），默认为 4。</p>
</li>
<li><p>先说一下优先级 maxInitialRequests / maxAsyncRequests &lt; maxSize&lt; minSize。<br>automaticNameDelimiter 选项：打包生成的 js 文件名的分割符，默认为~。<br>name 选项：打包生成 js 文件的名称。</p>
</li>
<li><p>cacheGroups 选项，核心重点，配置提取模块的方案。里面每一项代表一个提取模块的方案。下面是 cacheGroups 每项中特有的选项，其余选项和外面一致，若 cacheGroups 每项中有，就按配置的，没有就使用外面配置的。</p>
<ul>
<li>test 选项：用来匹配要提取的模块的资源路径或名称。值是正则或函数。<br>priority 选项：方案的优先级，值越大表示提取模块时优先采用此方案。默认值为 0。</li>
<li>reuseExistingChunk 选项：true/false。为 true 时，如果当前要提取的模块，在已经在打包生成的 js 文件中存在，则将重用该模块，而不是把当前要提取的模块打包生成新的 js 文件。</li>
<li>enforce 选项：true/false。为 true 时，忽略 minSize，minChunks，maxAsyncRequests 和 maxInitialRequests 外面选项</li>
</ul>
</li>
</ul>
<p>核心嘛，就是配置 <code>cacheGroups</code> 来根据自己的需求来分割打包代码块。</p>
<p>先贴一份配置可视化分析打包后的文件的插件的 demo</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm install webpack-bundle-analyzer --save-dev</span><br><span class="line"><span class="comment">// vue.config.js中引入</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BundleAnalyzerPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).<span class="property">BundleAnalyzerPlugin</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="attr">configureWebpack</span>:<span class="function"><span class="params">config</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">plugins</span>:[</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>()</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vuecli3 中 splitChunk 的默认配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">          <span class="attr">chunks</span>: <span class="string">&quot;async&quot;</span>,</span><br><span class="line">          <span class="attr">minSize</span>: <span class="number">30000</span>,</span><br><span class="line">          <span class="attr">maxSize</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">minChunks</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">maxAsyncRequests</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="attr">maxInitialRequests</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="attr">automaticNameDelimiter</span>: <span class="string">&quot;~&quot;</span>,</span><br><span class="line">          <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">            <span class="attr">vendors</span>: &#123;</span><br><span class="line">              <span class="attr">name</span>: <span class="string">`chunk-vendors`</span>,</span><br><span class="line">              <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">              <span class="attr">priority</span>: -<span class="number">10</span>,</span><br><span class="line">              <span class="attr">chunks</span>: <span class="string">&quot;initial&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">common</span>: &#123;</span><br><span class="line">              <span class="attr">name</span>: <span class="string">`chunk-common`</span>,</span><br><span class="line">              <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="attr">priority</span>: -<span class="number">20</span>,</span><br><span class="line">              <span class="attr">chunks</span>: <span class="string">&quot;initial&quot;</span>,</span><br><span class="line">              <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>贴一个自己项目的实验结果。</p>
<p>项目结构</p>
<p><img src="https://s3.ax1x.com/2020/12/16/rlszlt.png" alt="项目结构"></p>
<p>按照默认配置打包后的可视化解析图：</p>
<p><img src="https://s3.ax1x.com/2020/12/16/rlyQ7F.md.png" alt="before"></p>
<p>配置之后的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="attr">configureWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">      <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">        <span class="attr">chunks</span>: <span class="string">&quot;async&quot;</span>,</span><br><span class="line">        <span class="attr">minSize</span>: <span class="number">30000</span>,</span><br><span class="line">        <span class="attr">maxSize</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">minChunks</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">maxAsyncRequests</span>: <span class="number">6</span>,</span><br><span class="line">        <span class="attr">maxInitialRequests</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">automaticNameDelimiter</span>: <span class="string">&quot;~&quot;</span>,</span><br><span class="line">        <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">          <span class="attr">vendors</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;chunk-vendors&quot;</span>,</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">            <span class="attr">priority</span>: -<span class="number">10</span>,</span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">mixIn</span>: &#123;</span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;mixIn&quot;</span>,</span><br><span class="line">            <span class="attr">test</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./src/views/medicineType/typeMixin&quot;</span>),</span><br><span class="line">            <span class="attr">priority</span>: <span class="number">0</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>()],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配置之后打包完的可视化：</p>
<p><img src="https://s3.ax1x.com/2020/12/16/rly73n.md.png" alt="after"></p>
<p>可以看到变小了 20 多 K，并且把 mixin 给抽离出来单独打包了。</p>
<h3 id="15-查看-1rem-px"><a href="#15-查看-1rem-px" class="headerlink" title="15. 查看 1rem=?px"></a>15. 查看 1rem=?px</h3><p>查看：<code>window.getComputedStyle(document.documentElement)[&quot;fontSize&quot;]</code></p>
<p>设置：<code>document.documentElement.style.fontSize</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据设备设置根font-size,配合px2rem可以直接写px</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取屏幕的宽度</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getWdith</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> myWidth = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span>.<span class="property">innerWidth</span> === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// Non-IE</span></span><br><span class="line">        myWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">documentElement</span> &amp;&amp;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// IE 6+ in &#x27;standards compliant mode&#x27;</span></span><br><span class="line">        myWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span> &amp;&amp; <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>) &#123;</span><br><span class="line">        <span class="comment">// IE 4 compatible</span></span><br><span class="line">        myWidth = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">parseInt</span>(myWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> screenWidth = screen.<span class="property">width</span> &gt; <span class="title function_">getWdith</span>() ? <span class="title function_">getWdith</span>() : screen.<span class="property">width</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (screenWidth &gt;= <span class="number">414</span>) &#123;</span><br><span class="line">      screenWidth = <span class="number">414</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span> = screenWidth / (<span class="number">750</span> / <span class="number">40</span>) + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reSize</span>();</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reSize</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  postcss.js</span></span><br><span class="line"><span class="keyword">const</span> pxtorem = <span class="built_in">require</span>(<span class="string">&quot;postcss-pxtorem&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">&#123; file &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> rootValue;</span><br><span class="line">  <span class="comment">// 配置使引入的组件不被影响</span></span><br><span class="line">  <span class="keyword">if</span> (file &amp;&amp; file.<span class="property">dirname</span> &amp;&amp; file.<span class="property">dirname</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;vant&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    rootValue = <span class="number">20</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rootValue = <span class="number">40</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="title function_">pxtorem</span>(&#123;</span><br><span class="line">        <span class="attr">rootValue</span>: rootValue,</span><br><span class="line">        <span class="attr">propList</span>: [<span class="string">&quot;*&quot;</span>],</span><br><span class="line">        <span class="attr">minPixelValue</span>: <span class="number">2</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="16-npm-install-–save-、–save-dev-、-D、-S-区别"><a href="#16-npm-install-–save-、–save-dev-、-D、-S-区别" class="headerlink" title="16.npm install –save 、–save-dev 、-D、-S 区别"></a>16.npm install –save 、–save-dev 、-D、-S 区别</h3><p>npm install 和 npm i 是一样<br>–save 和 -S 是一样<br>–save-dev 和 -D 是一样的</p>
<p>区别:<br>npm install 在安装 npm 包时，有两种命令参数可以把它们的信息写入 package.json 文件，一个是 npm install–save 另一个是 npm install –save-dev，他们表面上的区别是–save 会把依赖包名称添加到 package.json 文件 dependencies 键下，–save-dev 则添加到 package.json 文件 devDependencies 键下，譬如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;vue&quot;</span>: <span class="string">&quot;^2.2.1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;babel-core&quot;</span>: <span class="string">&quot;^6.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-loader&quot;</span>: <span class="string">&quot;^6.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-preset-latest&quot;</span>: <span class="string">&quot;^6.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cross-env&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;css-loader&quot;</span>: <span class="string">&quot;^0.25.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;file-loader&quot;</span>: <span class="string">&quot;^0.9.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;vue-loader&quot;</span>: <span class="string">&quot;^11.1.4&quot;</span>,</span><br><span class="line">    <span class="string">&quot;vue-template-compiler&quot;</span>: <span class="string">&quot;^2.2.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack&quot;</span>: <span class="string">&quot;^2.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^2.2.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>不过这只是它们的表面区别。它们真正的区别是，npm 自己的文档说 dependencies 是运行时依赖，devDependencies 是开发时的依赖。即 devDependencies 下列出的模块，是我们开发时用的，比如 我们安装 js 的压缩包 gulp-uglify 时，我们采用的是 “npm install –save-dev gulp-uglify ”命令安装，因为我们在发布后用不到它，而只是在我们开发才用到它。</p>
<p>举例：<br>像 jQuery 库或者 Angular 框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了，这是 dependencies。而写 ES6 代码，需要 babel 转换成 es5，转换完成后，我们只需要转换后的代码，上线的时候，直接把转换后的代码部署上线，不需要 bebal 了，上线了不需要，这就是 devDependencies。<br>而如果用了 jQuery，由于发布之后还是依赖 jQuery，所以是 dependencies。</p>
<p>总结：<br>-S, –save 安装包信息将加入到 dependencies（生产阶段的依赖,也就是项目运行时的依赖，就是程序上线后仍然需要依赖）</p>
<p>-D, –save-dev 安装包信息将加入到 devDependencies（开发阶段的依赖，就是我们在开发过程中需要的依赖，只在开发阶段起作业的）</p>
<p>补充：<br>正常使用 npm install 时，会下载 dependencies 和 devDependencies 中的模块，当使用 npm install –production 或者注明 NODE_ENV 变量值为 production 时，只会下载 dependencies 中的模块。</p>
<h3 id="17-使用not选择器"><a href="#17-使用not选择器" class="headerlink" title="17.使用not选择器"></a>17.使用not选择器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&amp;:<span class="title function_">not</span>(<span class="params">:last-child</span>) &#123;</span><br><span class="line">   margin-<span class="attr">bottom</span>: 70px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父级非最后一个。</span></span><br></pre></td></tr></table></figure>

<h3 id="18-input弹出软键盘弹起遮挡"><a href="#18-input弹出软键盘弹起遮挡" class="headerlink" title="18.input弹出软键盘弹起遮挡"></a>18.input弹出软键盘弹起遮挡</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> hrt = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollHeight</span>; <span class="comment">//获取当前可视区域的高度存到hrt变量</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;key_keep_out&quot;</span>).<span class="property">style</span>.<span class="property">height</span> = hrt + <span class="string">&quot;px&quot;</span>; <span class="comment">//把获取到的高度赋值给根div</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 在页面加载完成后将可视区域的高度赋给最外层容器div。</span></span><br></pre></td></tr></table></figure>

<h3 id="19-获取地址中的参数"><a href="#19-获取地址中的参数" class="headerlink" title="19.获取地址中的参数"></a>19.获取地址中的参数</h3><p>获取query可以使用三种方式：</p>
<ol>
<li><p><code>location. search: &quot; ?query=1&#39;</code>，然后分割。</p>
</li>
<li><p>使用 <code>URLSearchParams </code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> searchParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(location.<span class="property">hash</span>.<span class="title function_">split</span>(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">const</span> staffNumber = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;staffNumber&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> partyId = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;partyId&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> busys = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;busys&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cusId = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;cusId&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>this.$route.query</code></p>
<p>比如 <code> http://localhost:8081/#/?staffNo=3_1_01000012&amp;token=lka1f3sd1f3a1h35fd3a1</code> </p>
<p>获取： <code>this.$route.query.staffNo</code></p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>: <span class="string">&quot;http: //localhost:4200/landing?query=1#2&quot;</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">host</span>: <span class="string">&quot;localhost :4200&quot;</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>: <span class="string">&quot; ?query=1&#x27;</span></span><br><span class="line"><span class="string">window.location.pathname: &quot;</span>/landing<span class="string">&quot;</span></span><br><span class="line"><span class="string">window.location.hash: &quot;</span>#<span class="number">2</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">window.location.hostname: &quot;</span>localhost<span class="string">&quot;</span></span><br><span class="line"><span class="string">window.location.origin: &quot;</span><span class="attr">http</span>:<span class="comment">//localhost:4200&quot;</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">port</span>:<span class="string">&quot;4200&quot;</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">protocol</span>: <span class="string">&quot;http:</span></span><br></pre></td></tr></table></figure>

<p><em>有#后面是hash 没#后面是search</em></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备-html</title>
    <url>/2022/11/21/20221121-interview-html/</url>
    <content><![CDATA[<p>记录工作中想到的面试应该会的问题。</p>
<span id="more"></span>

<h2 id="1-HTML-CSS"><a href="#1-HTML-CSS" class="headerlink" title="1. HTML + CSS"></a>1. HTML + CSS</h2><h3 id="1-1-HTTP-状态码及其含义"><a href="#1-1-HTTP-状态码及其含义" class="headerlink" title="1.1 HTTP 状态码及其含义"></a>1.1 HTTP 状态码及其含义</h3><ul>
<li>1XX：信息状态码<ul>
<li>100 Continue 继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>
</ul>
</li>
<li>2XX：成功状态码<ul>
<li>200 OK 正常返回信息</li>
<li>201 Created 请求成功并且服务器创建了新的资源</li>
<li>202 Accepted 服务器已接受请求，但尚未处理</li>
</ul>
</li>
<li>3XX：重定向<ul>
<li>301 Moved Permanently 请求的网页已永久移动到新位置。</li>
<li>302 Found 临时性重定向。</li>
<li>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。</li>
<li>304 Not Modified 自从上次请求后，请求的网页未修改过。</li>
</ul>
</li>
<li>4XX：客户端错误<ul>
<li>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>
<li>401 Unauthorized 请求未授权。</li>
<li>403 Forbidden 禁止访问。</li>
<li>404 Not Found 找不到如何与 URI 相匹配的资源。</li>
</ul>
</li>
<li>5XX: 服务器错误<ul>
<li>500 Internal Server Error 最常见的服务器端错误。</li>
<li>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li>
</ul>
</li>
</ul>
<h3 id="1-2-如何进行网站性能优化"><a href="#1-2-如何进行网站性能优化" class="headerlink" title="1.2 如何进行网站性能优化"></a>1.2 如何进行网站性能优化</h3><ol>
<li>页面懒加载。</li>
<li>使用 webpack 插件（terser-webpack-plugin），在打包时删除冗余代码 。</li>
<li>使用<strong>SplitChunks</strong> 手动将一些复用性高的文件抽离出来。</li>
<li>使用 CDN。</li>
<li>将较大的图片进行无损压缩。</li>
</ol>
<h3 id="1-3-H5-新增的特性-只列出了常用的几个"><a href="#1-3-H5-新增的特性-只列出了常用的几个" class="headerlink" title="1.3 H5 新增的特性(只列出了常用的几个)"></a>1.3 H5 新增的特性(只列出了常用的几个)</h3><ol>
<li><p>新增语义化标签 <code>header nav footer section</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;header&gt; :头部标签</span><br><span class="line">&lt;nav&gt; : 导航标签</span><br><span class="line">&lt;footer&gt; :尾部标签</span><br><span class="line">&lt;section&gt; :块级标签</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增多媒体标签 <code>audio video </code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;audio src=<span class="string">&quot;MP3.mp3&quot;</span> controls=<span class="string">&quot;controls&quot;</span>&gt;您的浏览器不支持<span class="title class_">Audio</span>元素&lt;/audio&gt;</span><br><span class="line"></span><br><span class="line">video元素要设定好长宽和src属性就可以了：</span><br><span class="line"></span><br><span class="line">&lt;video width=<span class="string">&quot;750&quot;</span> height=<span class="string">&quot;400&quot;</span> src=<span class="string">&quot;time.mp4&quot;</span>&gt;&lt;/video&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增绘图功能 <code> canvas svg</code></p>
</li>
</ol>
<h3 id="1-4-lt-DOCTYPE-HTML-gt-的作用"><a href="#1-4-lt-DOCTYPE-HTML-gt-的作用" class="headerlink" title="1.4  &lt;!DOCTYPE HTML&gt;的作用"></a>1.4 <code> &lt;!DOCTYPE HTML&gt;</code>的作用</h3><p>声明文档类型为 HTML</p>
<h3 id="1-5-cookies，sessionStorage-和-localStorage-的区别"><a href="#1-5-cookies，sessionStorage-和-localStorage-的区别" class="headerlink" title="1.5 cookies，sessionStorage 和 localStorage 的区别"></a>1.5 cookies，sessionStorage 和 localStorage 的区别</h3><ul>
<li>cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），一般用来携带</li>
<li>cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递</li>
<li>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存</li>
<li>存储大小：<ul>
<li>cookie 数据大小不能超过 4k</li>
<li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大</li>
</ul>
</li>
<li>有效时间：<ul>
<li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>
<li>sessionStorage 数据在当前浏览器窗口关闭后自动删除</li>
<li>cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
</li>
</ul>
<h3 id="1-6-iframe"><a href="#1-6-iframe" class="headerlink" title="1.6 iframe"></a>1.6 iframe</h3><p>iframes 提供了一个简单的方式把一个网站的内容嵌入到另一个网站中。</p>
<p>缺点：</p>
<ul>
<li>iframe 会阻塞主页面的 Onload 事件</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于 SEO</li>
</ul>
<h3 id="1-7-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？"><a href="#1-7-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？" class="headerlink" title="1.7 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？"></a>1.7 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？</h3><ul>
<li>行内元素有：a b span img input select strong</li>
<li>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p</li>
<li>空元素：<code>&lt;br&gt; </code></li>
<li>行内元素不可以设置宽高，不独占一行</li>
<li>块级元素可以设置宽高，独占一行</li>
</ul>
<h3 id="1-8-display-none-与-visibility-hidden-的区别"><a href="#1-8-display-none-与-visibility-hidden-的区别" class="headerlink" title="1.8 display: none;与 visibility: hidden;的区别"></a>1.8 display: none;与 visibility: hidden;的区别</h3><ul>
<li><p>联系：它们都能让元素不可见</p>
</li>
<li><p>Vue 的<code>v-show</code>相当于<code>display: none</code> 而 <code>v-if</code>是不在 dom 中渲染该节点</p>
</li>
<li><p>区别：</p>
</li>
<li><ul>
<li>display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li>
<li>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了 hidden，通过设置 visibility: visible;可以让子孙节点显式</li>
<li>修改常规流中元素的 display 通常会造成文档重排。修改 visibility 属性只会造成本元素的重绘。</li>
<li>读屏器不会读取 display: none;元素内容；会读取 visibility: hidden;元素内容</li>
</ul>
</li>
</ul>
<h3 id="1-9-清除浮动"><a href="#1-9-清除浮动" class="headerlink" title="1.9 清除浮动"></a>1.9 清除浮动</h3><p>清除浮动的几种方式，各自的优缺点</p>
<ul>
<li><p>使用空标签清除浮动 clear:both（缺点，增加无意义的标签）</p>
</li>
<li><p>使用 overflow:auto（使用 zoom:1 用于兼容 IE，缺点：内部宽高超过父级 div 时，会出现滚动条）</p>
</li>
<li><p>用 afert 伪元素清除浮动(IE8 以上和非 IE 浏览器才支持。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// dom</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.main &#123; border:20px solid blueviolet; &#125; .main::after &#123; content:&quot;&quot;;</span><br><span class="line">display:table; /*采用此方法可以有效避免浏览器兼容问题*/ clear:both; &#125; .box &#123;</span><br><span class="line">width: 100px; height: 100px; &#125; .blue&#123; background-color: blue; float: left; &#125;</span><br><span class="line">//css</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-10-css3-有哪些新特性"><a href="#1-10-css3-有哪些新特性" class="headerlink" title="1.10 css3 有哪些新特性"></a>1.10 css3 有哪些新特性</h3><ul>
<li><p>新增各种 css 选择器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪元素选择器</span></span><br><span class="line">::before ::after ::first-line ::first-letter ::section</span><br><span class="line"><span class="comment">// 伪类选择器</span></span><br><span class="line">.<span class="property">list</span>&gt;<span class="attr">li</span>:first-child     选中第一个子元素</span><br><span class="line">.<span class="property">list</span>&gt;<span class="attr">li</span>:last-child     选中最后一个子元素</span><br><span class="line">.<span class="property">list</span>&gt;<span class="attr">li</span>:nth-<span class="title function_">child</span>(n)  选中第五个子元素</span><br><span class="line">.<span class="property">list</span>&gt;<span class="attr">li</span>:nth-<span class="title function_">child</span>(odd)  选中偶数行</span><br><span class="line">.<span class="property">list</span>&gt;<span class="attr">li</span>:nth-<span class="title function_">child</span>(even)  选中奇数行</span><br><span class="line">.<span class="property">list</span>&gt;<span class="attr">li</span>:nth-<span class="title function_">child</span>(<span class="number">2n</span>)  支持数学表达式，选中偶数行</span><br><span class="line">.<span class="property">list</span>&gt;:nth-<span class="keyword">of</span>-<span class="title function_">type</span>(<span class="number">1</span>)  选择类型匹配的，选中的是第五个li,跳过ul中其他类型</span><br></pre></td></tr></table></figure>

<p><strong>ps 一个坑：伪类选择器，比如<code>last-child </code>或者<code>last-of-type</code> 的意思是，既要是最后一个，还得是指定的类型</strong></p>
<p><a href="https://blog.csdn.net/Dorothy1224/article/details/95206594">示例链接</a></p>
</li>
<li><p>flex 布局</p>
</li>
<li><p>圆角 <code>border-radius</code></p>
</li>
<li><p>阴影和反射<code>shadow</code></p>
</li>
<li><p>文字特效<code>text-shadow</code></p>
</li>
<li><p>线性渐变<code>linear-gradient(#fff2d9, #fff2d9 50%, #f9e7b9 51%, #f9e7b9)</code></p>
</li>
<li><p>旋转<code>transform</code> 包含<code>scale (缩放) rotate (旋转) skew (倾斜)</code></p>
</li>
<li><p>媒体查询<code>@media only screen and (min-width: 1200px) &#123;&#125;</code></p>
</li>
<li><p>过度<code>transition</code></p>
</li>
<li><p>动画<code>animation</code></p>
</li>
</ul>
<h3 id="1-11-display-有哪些值？说明他们的作用"><a href="#1-11-display-有哪些值？说明他们的作用" class="headerlink" title="1.11 display 有哪些值？说明他们的作用"></a>1.11 display 有哪些值？说明他们的作用</h3><ul>
<li>block 象块类型元素一样显示。</li>
<li>inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。</li>
<li>list-item 象块类型元素一样显示，并添加样式列表标记。</li>
<li>table 此元素会作为块级表格来显示</li>
<li>inherit 规定应该从父元素继承 display 属性的值</li>
</ul>
<h3 id="1-12-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？"><a href="#1-12-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="1.12 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？"></a>1.12 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h3><p>有两种， IE 盒子模型、W3C 盒子模型；内容(content)、填充(padding)、边框(border)、边界(margin) ；</p>
<ul>
<li>盒模型(box-sizing:content-box): width/height 为 content 的宽高。</li>
<li>怪异模型(box-sizing:border-box)：width/height 为 content + padding + border 的宽高。</li>
</ul>
<h3 id="1-13-position-的值，-relative-和-absolute-定位原点是"><a href="#1-13-position-的值，-relative-和-absolute-定位原点是" class="headerlink" title="1.13 position 的值， relative 和 absolute 定位原点是"></a>1.13 position 的值， relative 和 absolute 定位原点是</h3><ul>
<li>absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</li>
<li>fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。</li>
<li>relative：生成相对定位的元素，相对于其正常位置进行定位。</li>
<li>static 默认值。没有定位，元素出现在正常的流中。</li>
<li>inherit 规定从父元素继承 position 属性的值。</li>
</ul>
<h3 id="1-14-display-inline-block-出现缝隙解决方案"><a href="#1-14-display-inline-block-出现缝隙解决方案" class="headerlink" title="1.14 display:inline-block 出现缝隙解决方案"></a>1.14 display:inline-block 出现缝隙解决方案</h3><ul>
<li>使用 margin 负值（大概-5px）</li>
<li>使用 font-size:0</li>
</ul>
<h3 id="1-15-从输入网址，到页面展示，浏览器做了什么"><a href="#1-15-从输入网址，到页面展示，浏览器做了什么" class="headerlink" title="1.15 从输入网址，到页面展示，浏览器做了什么"></a>1.15 从输入网址，到页面展示，浏览器做了什么</h3><ol>
<li>DNS 解析 ip 地址。</li>
<li>三次握手建立 Tcp 链接。</li>
<li>发送 Http 请求。</li>
<li>服务器处理请求。</li>
<li>服务器返回响应结果。</li>
<li>关闭 Tcp 链接。</li>
<li>浏览器解析 HTML。</li>
<li>浏览器布局渲染页面。</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000012092552">细说浏览器输入 URL 后发生了什么</a></p>
<h3 id="1-16-请求头的作用"><a href="#1-16-请求头的作用" class="headerlink" title="1.16 请求头的作用"></a>1.16 请求头的作用</h3><p>请求头主要用来携带客户端向服务器发送请求的一些描述，比如 http 协议类型，客户端所接受的编码方式，发送内容的长度等；某些用户信息也携带在请求头中，比如说 cookie，token 等；还携带了 referer 信息。</p>
<p>referer 信息代表当前请求的源头，可以用来防止盗链，防止恶意请求。</p>
<p>响应头主要用来携带服务器返回的 content 的一些描述，比如编码类型，内容长度等。</p>
<h3 id="1-17-同源策略"><a href="#1-17-同源策略" class="headerlink" title="1.17 同源策略"></a>1.17 同源策略</h3><p>浏览器中的<strong>协议、域名、端口号</strong>相同则属于同源。</p>
<p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。</p>
<p>什么要有同源策略：主要是为了保护用户的网络安全。禁止对不同源的 DOM 进行访问，禁止向不同源的服务器发起 HTTP 请求。</p>
<h3 id="1-18-几种常用-css-布局"><a href="#1-18-几种常用-css-布局" class="headerlink" title="1.18 几种常用 css 布局"></a>1.18 几种常用 css 布局</h3><h4 id="1-18-1-居中"><a href="#1-18-1-居中" class="headerlink" title="1.18.1 居中"></a>1.18.1 居中</h4><ul>
<li><p>文字居中</p>
<ul>
<li><p>垂直居中</p>
<ol>
<li>为文字添加相等的 padding-top 和 padding-bottom</li>
<li>单行文字且不会换行展示使<code>line-height</code>与容器<code>height</code>相等</li>
</ol>
</li>
<li><p>水平居中</p>
<p>设置<code>text-aligin:center</code></p>
</li>
</ul>
</li>
<li><p><code>dom</code>居中</p>
<ol>
<li><p>绝对定位配合<code>transform</code>居中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>flex</code>布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h4 id="1-18-2-两栏布局"><a href="#1-18-2-两栏布局" class="headerlink" title="1.18.2 两栏布局"></a>1.18.2 两栏布局</h4><ol>
<li><p>BFC 实现两栏布局</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左边左边左边左边左边左边左边左边左边左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">    右边右边右边右边右边右边右边右边右边右边右边右边右边右边右边右边右边</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--css--&gt;</span></span><br><span class="line">.container &#123; width:100%; &#125; .left &#123;</span><br><span class="line"><span class="comment">&lt;!--!important--&gt;</span></span><br><span class="line">float:left;</span><br><span class="line"><span class="comment">&lt;!--!important--&gt;</span></span><br><span class="line">width:100px; background-color: red; &#125; .right &#123;</span><br><span class="line"><span class="comment">&lt;!--!important--&gt;</span></span><br><span class="line">overflow:hidden;</span><br><span class="line"><span class="comment">&lt;!--!important--&gt;</span></span><br><span class="line">background-color: blue; min-height:100vh; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>flex 实现两栏布局</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左边左边左边左边左边左边左边左边左边左边<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">    右边右边右边右边右边右边右边右边右边右边右边右边右边右边右边右边右边</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--css--&gt;</span></span><br><span class="line">.container &#123; width:100%;</span><br><span class="line"><span class="comment">&lt;!--!important--&gt;</span></span><br><span class="line">display:flex;</span><br><span class="line"><span class="comment">&lt;!--!important--&gt;</span></span><br><span class="line">&#125; .left &#123; width:100px; background-color: red; &#125; .right &#123;</span><br><span class="line"><span class="comment">&lt;!--!important--&gt;</span></span><br><span class="line">flex:1;</span><br><span class="line"><span class="comment">&lt;!--!important--&gt;</span></span><br><span class="line">background-color: blue; &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="1-19-BFC（Block-Formatting-Context-块格式化上下文）"><a href="#1-19-BFC（Block-Formatting-Context-块格式化上下文）" class="headerlink" title="1.19 BFC（Block-Formatting-Context 块格式化上下文）"></a>1.19 BFC（Block-Formatting-Context 块格式化上下文）</h3><ul>
<li><p>作用：</p>
<ol>
<li><p>解决外边距合并问题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- CSS --&gt;</span></span><br><span class="line">.container &#123; position: absolute; border: 5px solid lightcoral; &#125; .box &#123;</span><br><span class="line">width:100px; height:100px; padding:100px; &#125; .red &#123; background-color:red; &#125;</span><br><span class="line">.blue &#123; background-color:blue; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://dqtwdd.top/cdn/img/OuterMargin.jpg" alt="OuterMargin"></p>
<p>以上代码实际展示出来是这个样子的，可以很明显的看出来了两个块之间的间距只有 100px，使用 BFC 的解决办法就是在两个块外层加一个 BFC 的容器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bfc&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bfc&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- CSS --&gt;</span></span><br><span class="line">.container &#123; position: absolute; border: 5px solid lightcoral; &#125; .bfc &#123;</span><br><span class="line">overflow:hidden &#125; .box &#123; width:100px; height:100px; &#125; .red &#123;</span><br><span class="line">background-color:red; &#125; .blue &#123; background-color:blue; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://dqtwdd.top/cdn/img/OuterMarginAfterBFC.jpg" alt="OuterMarginAfterBFC"></p>
</li>
<li><p>解决 float 导致的高度塌陷问题，清除浮动。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- CSS --&gt;</span></span><br><span class="line">.container &#123; border: 5px solid lightcoral; width: 100%; &#125; .box &#123; width:</span><br><span class="line">100px; height: 100px; &#125; .red &#123; background-color: red; float: left; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://dqtwdd.top/cdn/img/Float.jpg" alt="Float"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- CSS --&gt;</span></span><br><span class="line">.container &#123; overflow: hidden; border: 5px solid lightcoral; width: 100%; &#125;</span><br><span class="line">.box &#123; width: 100px; height: 100px; &#125; .red &#123; background-color: red; float:</span><br><span class="line">left; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://dqtwdd.top/cdn/img/FloatAfterBFC.jpg" alt="FloatAfterBFC"></p>
</li>
<li><p>用来布局（比如经典的两栏布局）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- CSS --&gt;</span></span><br><span class="line">.container &#123; width: 100%; &#125; .left &#123; float:left; min-height:100vh;</span><br><span class="line">background-color: red; &#125; .right &#123; background-color: blue; min-height:100vh;</span><br><span class="line">overflow: hidden; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://dqtwdd.top/cdn/img/TwoLayout.jpg" alt="TwoLayout"></p>
</li>
</ol>
</li>
<li><p>形成 BFC 的条件</p>
<ol>
<li>浮动元素，float 除 none 以外的值；</li>
<li>绝对定位元素，position（absolute，fixed）；</li>
<li>display 为以下其中之一的值 inline-blocks，table-cells，table-captions；</li>
<li>overflow 除了 visible 以外的值（hidden，auto，scroll）</li>
</ol>
</li>
</ul>
<h3 id="1-20-实现一个三角形-css"><a href="#1-20-实现一个三角形-css" class="headerlink" title="1.20 实现一个三角形 css"></a>1.20 实现一个三角形 css</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top-color</span>: ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-21-tcp-udp"><a href="#1-21-tcp-udp" class="headerlink" title="1.21 tcp/udp"></a>1.21 tcp/udp</h3><ul>
<li><p>tcp 全称 传输控制协议。是一种面向连接的，可靠的，基于字节流的传输通信协议。</p>
<p>tcp 链接过程需要经过三次握手：</p>
<ol>
<li>我要发请求了，ok 吗？（客户端向服务端发送请求报文段，客户端进入 SYN_SEND（请求链接）状态）</li>
<li>ok！我准备好了，发吧！（服务端收到连接请求报文段后，如果同意链接，则发送一个应答，同时客户端进入 SYN_RECEIVE（准备接收）状态）</li>
<li>ok，我也准备好了，这就发。（客户端收到链接同意的应答后，还要向服务器发送一个确认报文，发送完成后，客户端进入 ESTABLISHED（已连接）状态，服务端接收到请求后也进入 ESTABLISHED 状态，此时连接建立成功）</li>
</ol>
<p>然后就开始了。第三次握手是为了防止出现失效的链接请求报文被服务端接受的情况。</p>
<p>断开链接过程需要经过四次握手：</p>
<ol>
<li>我没啥要发的了，可以断开链接吗？（客户端进入 FIN_WAIT_1 状态）</li>
<li>我看看啊，要是没有了我告诉你。（此时，服务端进入 CLOSE_WAIT 状态，服务端已经不再接受客户端发送的数据，但是仍然可以发送数据给客户端，客户端手收到后进入 FIN_WAIT_2 状态）</li>
<li>（如果有没发完的继续发送，发送完成后）我没啥发的了，你也断开吧。（此时，服务端进入 LAST_ACK 状态，等客户端发送 ACK 确认连接后就关闭链接）</li>
<li>好的，我也断开了。（此时客户端进入 TIME_WAIT 状态，在一段时间内没收到 B 的重发请求的话，就进入 CLOSED 状态，此条信息发送的就是 ACK 链接，B 收到确认应答后，就进入 CLOSED 状态）</li>
</ol>
<p>TCP 特点：</p>
<ul>
<li>面向连接 是指发送数据之前必须在两端建立链接。</li>
<li>仅支持单播传输 每条 TCP 传输只能有两个端点，只能进行点对点的数据传输，不支持多播和广播的传输方式。</li>
<li>面向字节流 TCP 不像 UDP 一样以一个一个报文独立的传输，而是在不保留报文边界的情况下以字节流方式进行传输。</li>
<li>可靠传输 TCP 为了保证报文传输的可靠，给每一个包一个需要，同时序号也保证了传输到接受端实体包的按序接受，然后接收端对已经接收到的字节发挥一个相应的确认（ACK），如果发送端实体在合理往返延时内未收到确认，那么就会将对应的数据进行重新传送。</li>
</ul>
</li>
<li><p>UDP 全称用户数据报协议，是一种无连接协议。UDP 具有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，报文发送后，是无法得知是否完整到达的。</p>
</li>
</ul>
<p>应用场景：文件传输等。</p>
<p>UDP 特点：</p>
<ul>
<li>面向无连接。 不需要进行连接，想发数据就开始发送。</li>
<li>有单播，多播，广播的功能 UDP 不只支持一对一的传输方式，还支持一对多，多对多，多对一的方式。</li>
<li>UDP 是面向报文的。</li>
<li>不可靠 不知道是否接受，是否有丢包。</li>
</ul>
<p>应用场景：电话会议，视频等。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td align="left">是否连接</td>
<td align="left">无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td align="left">是否可靠</td>
<td align="left">不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td align="left">连接对象个数</td>
<td align="left">支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td align="left">传输方式</td>
<td align="left">面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td align="left">首部开销</td>
<td align="left">首部开销小，仅 8 字节</td>
<td>首部最小 20 字节，最大 60 字节</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">适用于实时应用（IP 电话、视频会议、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<h3 id="1-22-html-加载顺序"><a href="#1-22-html-加载顺序" class="headerlink" title="1.22 html 加载顺序"></a>1.22 html 加载顺序</h3><ul>
<li>下载的顺序就是从上到下，渲染的顺序也是从上到下，下载和渲染时同时进行的。</li>
<li>在渲染到页面的某一部分时，其上面所有部分都已经下载完成（并不是说所有相关联的元素都已经下载完）</li>
<li>如果遇到语义解释性的标签嵌入文件（Js 脚本，Css 样式），那么此时浏览器的下载过程会启用单独的链接进行下载。</li>
<li>样式表在下载完成后，将和以前下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（含以前已经渲染的）重新进行渲染。</li>
<li>Js、Css 中如果有重定义，后定义的函数将覆盖前定义的函数。</li>
</ul>
<p>html：贯穿整个页面；</p>
<p>css（三种声明方式）：</p>
<ol>
<li>外联样式表：在 head 标签中，使用 link 标签的 href 属性来引用后缀名为.css 的 css 样式文件。</li>
<li>内联样式表：在 head 标签下的 style 标签，选择器+样式声明。</li>
<li>外部样式表：在标签的 style 属性中添加 css 样式声明。</li>
</ol>
<p>JavaScript：在<code>&lt;script&gt;</code>标签中，可以在 head 标签汇总，也可以在 body 标签中。</p>
<p>运行顺序：从上到下运行。</p>
<p>先解析 head 标签中的代码：</p>
<p>head 标签会包含一些引用外部文件的代码，从开始运行就会下载这些被引用的文件。</p>
<p>当遇到<code>&lt;script&gt;</code>标签时，浏览器会暂停解析（下载不会暂停），将控制权交给 JavaScript 引擎（解释器）。</p>
<p>如果<code>&lt;script&gt;</code>标签引用了外部脚本，就下载该脚本，否则就直接执行，执行完成后将控制权交给浏览器渲染引擎。</p>
<p>当 head 中代码解析完毕，会开始解析 body 中的代码：</p>
<p>如果 head 中引用的外部文件没有下载完，将会继续下载。</p>
<p>此时如果遇到 body 标签中的<code>&lt;script&gt;</code>，同样会将控制权交给 JavaScript 引擎来解析 JavaScript。</p>
<p>解析完毕后将控制权交还给浏览器渲染引擎</p>
<p>当 body 中的代码全部执行完毕，并且整个页面的 css 样式加载完毕后，css 会重新渲染整个页面的 html。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备-vue</title>
    <url>/2022/11/21/20221121-interview-vue/</url>
    <content><![CDATA[<p>记录工作中想到的面试应该会的问题。</p>
<span id="more"></span>

<h2 id="3-Vue"><a href="#3-Vue" class="headerlink" title="3.Vue"></a>3.Vue</h2><h3 id="3-1-前端如何解决跨域问题"><a href="#3-1-前端如何解决跨域问题" class="headerlink" title="3.1 前端如何解决跨域问题"></a>3.1 前端如何解决跨域问题</h3><p>跨域的几种方式：</p>
<ol>
<li>JSONP 跨域。</li>
<li>CORS 跨域。</li>
<li>Websocket 跨域。</li>
</ol>
<p>一般跨域是后端配置的。</p>
<p>前端在测试时可以在<code>vue.config.js</code>中配置代理，可以在本地调用接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> isDev = process.<span class="property">env</span>.<span class="property">VUE_APP_ENV</span> === <span class="string">&#x27;development&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">  <span class="attr">productionSourceMap</span>: isDev,</span><br><span class="line">  <span class="attr">pages</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;https://sspuat.taikang.com&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-MVVM"><a href="#3-2-MVVM" class="headerlink" title="3.2 MVVM"></a>3.2 MVVM</h3><p>MVVM 与 MVC 的最大区别是：<strong>MVVM 实现了 View 和 Model 的自动同步</strong>，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变。</p>
<p>MVVM 解决了：</p>
<ol>
<li>MVC 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验的问题。</li>
<li>每次 Module 更新数据需要用户手动更新 View 的问题。</li>
</ol>
<h3 id="3-3-vue-双向绑定原理"><a href="#3-3-vue-双向绑定原理" class="headerlink" title="3.3 vue 双向绑定原理"></a>3.3 vue 双向绑定原理</h3><p>原理：vue 是使用<strong>数据劫持</strong>结合<strong>订阅-发布模式</strong>实现双向绑定的。通过<code>Object.defineProperty()</code>方法劫持数据对象的<code>get()</code>和<code>set()</code>方法，可以理解为，在<code>get()</code>中执行的就是订阅过程，在<code>set()</code>中执行的就是发布过程。\</p>
<p>订阅发布模式和观察者模式</p>
<p><img src="https://dqtwdd.top/cdn/img/Publish-Observer.png" alt="两种开发模式"></p>
<ul>
<li><p>订阅-发布模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一家猎人工会</span></span><br><span class="line"><span class="comment">//主要功能包括任务发布大厅(topics)，以及订阅任务(subscribe)，发布任务(publish)</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">HunterUnion</span> = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;hunt&#x27;</span>,</span><br><span class="line">  <span class="attr">topics</span>: <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>),</span><br><span class="line">  <span class="attr">subscribe</span>: <span class="keyword">function</span> (<span class="params">topic, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">topics</span>[topic]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">topics</span>[topic] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">topics</span>[topic].<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">publish</span>: <span class="keyword">function</span> (<span class="params">topic, money</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">topics</span>[topic]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">topics</span>[topic]) &#123;</span><br><span class="line">      <span class="title function_">fn</span>(money);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个猎人类</span></span><br><span class="line"><span class="comment">//包括姓名，级别</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Hunter</span>(<span class="params">name, level</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">level</span> = level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//猎人可在猎人工会发布订阅任务</span></span><br><span class="line"><span class="title class_">Hunter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">subscribe</span> = <span class="keyword">function</span> (<span class="params">topic, fn</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">level</span> + <span class="string">&#x27;猎人&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;订阅了狩猎&#x27;</span> + topic + <span class="string">&#x27;的任务&#x27;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="title class_">HunterUnion</span>.<span class="title function_">subscribe</span>(topic, fn);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Hunter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">publish</span> = <span class="keyword">function</span> (<span class="params">topic, money</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">level</span> + <span class="string">&#x27;猎人&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;发布了狩猎&#x27;</span> + topic + <span class="string">&#x27;的任务&#x27;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="title class_">HunterUnion</span>.<span class="title function_">publish</span>(topic, money);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//猎人工会走来了几个猎人</span></span><br><span class="line"><span class="keyword">let</span> hunterMing = <span class="keyword">new</span> <span class="title class_">Hunter</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;黄金&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterJin = <span class="keyword">new</span> <span class="title class_">Hunter</span>(<span class="string">&#x27;小金&#x27;</span>, <span class="string">&#x27;白银&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterZhang = <span class="keyword">new</span> <span class="title class_">Hunter</span>(<span class="string">&#x27;小张&#x27;</span>, <span class="string">&#x27;黄金&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterPeter = <span class="keyword">new</span> <span class="title class_">Hunter</span>(<span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;青铜&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//小明，小金，小张分别订阅了狩猎tiger的任务</span></span><br><span class="line">hunterMing.<span class="title function_">subscribe</span>(<span class="string">&#x27;tiger&#x27;</span>, <span class="keyword">function</span> (<span class="params">money</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;小明表示：&#x27;</span> + (money &gt; <span class="number">200</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;不&#x27;</span>) + <span class="string">&#x27;接取任务&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">hunterJin.<span class="title function_">subscribe</span>(<span class="string">&#x27;tiger&#x27;</span>, <span class="keyword">function</span> (<span class="params">money</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;小金表示：接取任务&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">hunterZhang.<span class="title function_">subscribe</span>(<span class="string">&#x27;tiger&#x27;</span>, <span class="keyword">function</span> (<span class="params">money</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;小张表示：接取任务&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//Peter订阅了狩猎sheep的任务</span></span><br><span class="line">hunterPeter.<span class="title function_">subscribe</span>(<span class="string">&#x27;sheep&#x27;</span>, <span class="keyword">function</span> (<span class="params">money</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Peter表示：接取任务&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Peter发布了狩猎tiger的任务</span></span><br><span class="line">hunterPeter.<span class="title function_">publish</span>(<span class="string">&#x27;tiger&#x27;</span>, <span class="number">198</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//猎人们发布(发布者)或订阅(观察者/订阅者)任务都是通过猎人工会(调度中心)关联起来的，他们没有直接的交流。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>观察者模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有一家猎人工会，其中每个猎人都具有发布任务(publish)，订阅任务(subscribe)的功能</span></span><br><span class="line"><span class="comment">//他们都有一个订阅列表来记录谁订阅了自己</span></span><br><span class="line"><span class="comment">//定义一个猎人类</span></span><br><span class="line"><span class="comment">//包括姓名，级别，订阅列表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Hunter</span>(<span class="params">name, level</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">level</span> = level;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">list</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Hunter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">publish</span> = <span class="keyword">function</span> (<span class="params">money</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">level</span> + <span class="string">&#x27;猎人&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;寻求帮助&#x27;</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item, index</span>) &#123;</span><br><span class="line">    <span class="title function_">item</span>(money);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Hunter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">subscribe</span> = <span class="keyword">function</span> (<span class="params">targrt, fn</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">level</span> + <span class="string">&#x27;猎人&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;订阅了&#x27;</span> + targrt.<span class="property">name</span>);</span><br><span class="line">  targrt.<span class="property">list</span>.<span class="title function_">push</span>(fn);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//猎人工会走来了几个猎人</span></span><br><span class="line"><span class="keyword">let</span> hunterMing = <span class="keyword">new</span> <span class="title class_">Hunter</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;黄金&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterJin = <span class="keyword">new</span> <span class="title class_">Hunter</span>(<span class="string">&#x27;小金&#x27;</span>, <span class="string">&#x27;白银&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterZhang = <span class="keyword">new</span> <span class="title class_">Hunter</span>(<span class="string">&#x27;小张&#x27;</span>, <span class="string">&#x27;黄金&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> hunterPeter = <span class="keyword">new</span> <span class="title class_">Hunter</span>(<span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;青铜&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Peter等级较低，可能需要帮助，所以小明，小金，小张都订阅了Peter</span></span><br><span class="line">hunterMing.<span class="title function_">subscribe</span>(hunterPeter, <span class="keyword">function</span> (<span class="params">money</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">&#x27;小明表示：&#x27;</span> + (money &gt; <span class="number">200</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;暂时很忙，不能&#x27;</span>) + <span class="string">&#x27;给予帮助&#x27;</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">hunterJin.<span class="title function_">subscribe</span>(hunterPeter, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;小金表示：给予帮助&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">hunterZhang.<span class="title function_">subscribe</span>(hunterPeter, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;小金表示：给予帮助&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Peter遇到困难，赏金198寻求帮助</span></span><br><span class="line">hunterPeter.<span class="title function_">publish</span>(<span class="number">198</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//猎人们(观察者)关联他们感兴趣的猎人(目标对象)，如Peter，当Peter有困难时，会自动通知给他们（观察者）</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>二者的区别在于，观察者模式相当于是观察者实例直接订阅发布者的实例，发布者在发布后直接通知观察者。而订阅发布模式相当与有一个调度中心，发布者只将任务发布到调度中心，订阅者的信息也是直接保存在调度中心中，由调度中心发出指令。</p>
<h3 id="3-4-vue-为什么无法监听数组-对象的变化"><a href="#3-4-vue-为什么无法监听数组-对象的变化" class="headerlink" title="3.4 vue 为什么无法监听数组/对象的变化"></a>3.4 vue 为什么无法监听数组/对象的变化</h3><p>vue2 使用的<code>Object.definePropertype</code>方法是通过对<code>data</code>进行递归遍历实现的对数据进行监控的，如果有一个很大的数组或者对象，遍历+递归的方式进行监听会非常的损耗性能，所以作者出于性能考虑，并没有对数组和对象进行深度监控，这就导致了在 vue 中某些情况下无法监听到数组和对象的改变。</p>
<ul>
<li><p>vue 能监听数组改变的情况：</p>
<ol>
<li>通过<strong>赋值形式</strong>改变的数组<code>let arr = [] arr = [1,2,3]</code></li>
<li>通过<code>splice</code>方法改变的数组 <code>let arr = [1,2,3] arr.splice(0,1)</code></li>
<li>通过<code>push</code>方法改变的数组<code>let arr = [1] arr.push(2)</code></li>
</ol>
</li>
<li><p>vue 无法监听的情况：</p>
<ul>
<li><p>数组</p>
<ol>
<li>使用索引直接改变数组的某个值<code>let arr = [1,2,3] arr[0] = 3</code></li>
<li>直接改变数组长度<code>let arr = [1,2,3,4] arr.length = 2</code></li>
</ol>
</li>
<li><p>对象</p>
<ol>
<li>vue 中只有在 data 中声明的对象属性是响应式的，后添加的都不是响应的。</li>
<li>在方法中对 data 中的对象进行增加，删除，改变，无法被 vue 监听到。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// data</span></span><br><span class="line">data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">obj</span>:&#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;王大宝&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>:<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">obj</span>.<span class="property">sex</span> = <span class="string">&#x27;princess&#x27;</span> <span class="comment">// 非响应</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">age</span> <span class="comment">// 非响应</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">obj</span>.<span class="property">age</span> = <span class="number">0</span> <span class="comment">// 响应，因为在data中声明了age</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">obj</span>.<span class="property">sex</span> = <span class="string">&#x27;girl&#x27;</span> <span class="comment">// 非响应，因为是在方法中添加的sex属性</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>无法监听情况的解决方案</p>
<ul>
<li><p>数组</p>
<ol>
<li>使用<code>Vue.set()</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(arr, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [3,2,3,4]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>利用临时变量传参<code>let a = [1,2,3,4] let b = [...a] b[0] = 10 a = b</code> 注意，临时变量一定要是深拷贝出来的，重新开辟内存，不然不生效的。</p>
</li>
<li><p>使用<code>split()</code>方法对数组进行增加或删除。</p>
</li>
</ol>
</li>
<li><p>对象</p>
<ol>
<li>使用<code>vue.set</code></li>
<li>使用临时变量传参，同样的，临时变量一定要深拷贝出来，重新开辟内存。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>vue3 中使用了<code>proxy</code>方法代替了<code>Object.difinePropertype</code>，<code>Object.difinePropertype</code>方法的局限性在于它只能对单例属性进行监听，而<code>proxy</code>属性相当于对对象架设一层拦截，对目标对象的所有访问，都必须通过这层拦截，使用这个方法可以解决使用<code>Object.difinePropertype</code>所带来的的性能损耗问题，<code>proxy</code>的缺点是这个方法是 ES6 的方法，对旧的浏览器的支持不太好，所以在 vue2 中没有使用这种方法。</p>
<h3 id="3-5-vue-生命周期"><a href="#3-5-vue-生命周期" class="headerlink" title="3.5 vue 生命周期"></a>3.5 vue 生命周期</h3><p><img src="https://dqtwdd.top/cdn/img/LifeRound.png" alt="LifeRound"></p>
<h4 id="3-5-1-vue-生命周期"><a href="#3-5-1-vue-生命周期" class="headerlink" title="3.5.1 vue 生命周期"></a>3.5.1 vue 生命周期</h4><ol>
<li><code>beforeCreated()</code><br>在实例初始化，完成创建之前调用</li>
<li><code>created()</code><br>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</li>
<li><code>beforeMount()</code><br>在挂载开始之前被调用。 相关的 render 函数首次被调用。</li>
<li><code>mounted()</code><br>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</li>
<li><code>beforeUpdate()</code><br>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li>
<li><code>updated()</code><br>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<br>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。<br>该钩子在服务器端渲染期间不被调用。</li>
<li><code>beforeDestroy()</code><br>实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li><code>destroyed()</code><br>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</li>
</ol>
<h4 id="3-5-2-activated与deactivated"><a href="#3-5-2-activated与deactivated" class="headerlink" title="3.5.2 activated与deactivated"></a>3.5.2 <code>activated</code>与<code>deactivated</code></h4><p>页面第一次进入，钩子的触发顺序<code>created -&gt; mounted -&gt; activated</code>，退出时触发<code>deactivated</code>。当再次进入（前进或者后退）时，只触发<code>activated</code>。</p>
<p>事件挂载的方法等，只执行一次的放在<code>mounted</code>中；组件每次进去执行的方法放在 <code>activated</code> 中， <code>activated</code> 中的不管是否需要缓存多会执行。</p>
<p>所以当页面设置了<code>keepalive</code>的时候，要想对页面数据进行更改，则可在<code>activated</code>中调用组件中相关的方法。调用方式和<code>mounted</code>一样。</p>
<h4 id="3-5-3-父子组件生命周期调用顺序"><a href="#3-5-3-父子组件生命周期调用顺序" class="headerlink" title="3.5.3 父子组件生命周期调用顺序"></a>3.5.3 父子组件生命周期调用顺序</h4><ul>
<li><p>加载渲染过程 { } { ( ) ( ) }</p>
<p><code>父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</code></p>
</li>
<li><p>子组件更新过程 { ( ) }</p>
<p><code>父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated</code></p>
</li>
<li><p>父组件更新过程 { }</p>
<p><code>父beforeUpdate -&gt; 父updated</code></p>
</li>
<li><p>销毁过程 { ( ) }</p>
<p><code>父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed</code></p>
</li>
</ul>
<p>练习：祖父 -&gt; 父 -&gt; 子</p>
<ul>
<li>加载渲染过程 { } { [ ] [ ( ) ( ) ] }</li>
<li>子更新过程 { [ ( ) ] }</li>
<li>销毁过程 { [ ( ) ] }</li>
</ul>
<h3 id="3-6-filter、computed-和-watch"><a href="#3-6-filter、computed-和-watch" class="headerlink" title="3.6 filter、computed 和 watch"></a>3.6 filter、computed 和 watch</h3><ul>
<li>watch 监控现有的属性,computed 通过现有的属性计算出一个新的属性。</li>
<li>watch 不会缓存数据，每次打开页面都会重新加载一次。</li>
<li>computed 会缓存数据，所以 computed 的性能比 watch 更好一些。</li>
</ul>
<h4 id="3-6-1-filter"><a href="#3-6-1-filter" class="headerlink" title="3.6.1 filter"></a>3.6.1 filter</h4><p>filter 无缓存，调用频率高，因此比较适合在格式化输出的场景，主要在模板渲染时使用，主要作用是在数据展示之前对数据进行处理，让展示的数据符合我们的需求。filter 支持链式调用。</p>
<p>比如：将要展示的字段全部小写/大写；把要展示的数字四舍五入/保留两位小数等；为字段添加单位等等。</p>
<p>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;&#123; item.age | ageFilter &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  filters: &#123;</span><br><span class="line">    ageFilter: function (item) &#123;</span><br><span class="line">      return item + &#x27;岁&#x27;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-6-2-computed"><a href="#3-6-2-computed" class="headerlink" title="3.6.2 computed"></a>3.6.2 computed</h4><p>computed 属性具有缓存能力，在组件内普适性更强，因此适用于复杂的数据转换、统计等场景。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">      &lt;div @click=&quot;addAge&quot; v-for=&quot;(item, index) in listComputed&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123; item.age | ageFilter &#125;&#125;</span><br><span class="line">        &#123;&#123; item.age | ageFilter &#125;&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    listComputed: function () &#123;</span><br><span class="line">      let newArr = this.list.filter((item) =&gt; &#123;</span><br><span class="line">        return item.age &gt; 3;</span><br><span class="line">      &#125;);</span><br><span class="line">      return newArr;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-6-3-watch"><a href="#3-6-3-watch" class="headerlink" title="3.6.3 watch"></a>3.6.3 watch</h4><p>watch 主要用于监听某个 vue 中定义的属性， 一旦属性发生了改变就去自动调用对应的方法 。</p>
<h3 id="3-7-路由守卫"><a href="#3-7-路由守卫" class="headerlink" title="3.7 路由守卫"></a>3.7 路由守卫</h3><h4 id="3-7-1-全局守卫"><a href="#3-7-1-全局守卫" class="headerlink" title="3.7.1 全局守卫"></a>3.7.1 全局守卫</h4><p>全局守卫包含<strong>beforeEach、beforeResolve、afterEach</strong>。</p>
<p><code>beforeResolve</code>在<code>afterEach</code>之前调用。</p>
<p><code>afterEach</code>在进入路由后调用。</p>
<p>全局守卫定义在<code>router.js</code>中，路由中的每一个组件都会通过全局守卫。可以用于权限判断等：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">name</span> !== <span class="string">&#x27;Login&#x27;</span> &amp;&amp; !isAuthenticated) <span class="title function_">next</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span> &#125;)</span><br><span class="line">  <span class="keyword">else</span> <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 以上代码实现了在所有页面进入之前判断是否有登录权限，如果没有直接跳转登录页。</span></span><br></pre></td></tr></table></figure>

<h4 id="3-7-2-组件内守卫"><a href="#3-7-2-组件内守卫" class="headerlink" title="3.7.2 组件内守卫"></a>3.7.2 组件内守卫</h4><p>组件内守卫包含<strong>beforeRouterEnter、beforeRouteUpdate 、beforeRouterLeave</strong>。</p>
<p>组件内守卫就是定义在组件内部的守卫，可以在<code>componments</code>中定义使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>beforeRouteUpdate </code>在路由跳转，但是该组件被复用时调用 (2.2+) 。</p>
<p><code>beforeRouterLeave</code>通常在用户即将离开某个页面时，用来提醒用户之前的操作不会被保存。</p>
<h4 id="3-7-3-独享守卫"><a href="#3-7-3-独享守卫" class="headerlink" title="3.7.3 独享守卫"></a>3.7.3 独享守卫</h4><p>独享守卫只有<strong>beforeEnter</strong>。</p>
<p>独享守卫写在<code>router</code>的路由对象中，为跳转某个路由独享的守卫：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/foo&#x27;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>独享守卫和路由内守卫的主要区别在于组件内守卫在多个路由使用同一组件时都会调用，独享守卫只在进入某个路由时才会调用。</p>
<p>路由守卫调用顺序：</p>
<ol>
<li>调用<strong>路由内守卫</strong>离开页面的<code>beforeRouterLeave</code></li>
<li>调用<strong>全局守卫</strong><code>beforeEach</code></li>
<li>如果新进入的路由组件复用的话，调用<strong>路由内守卫</strong><code>beforeRouterUpdate</code></li>
<li>调用<strong>独享守卫</strong><code>beforeEnter</code></li>
<li>调用<strong>路由内守卫</strong><code>beforeRouterEnter</code></li>
<li>调用<strong>全局守卫</strong><code>beforeResolve</code></li>
<li>调用<strong>全局守卫</strong><code>afterEach</code></li>
</ol>
<h3 id="3-8-VueX"><a href="#3-8-VueX" class="headerlink" title="3.8 VueX"></a>3.8 VueX</h3><h4 id="3-8-1-知识点"><a href="#3-8-1-知识点" class="headerlink" title="3.8.1 知识点"></a>3.8.1 知识点</h4><p>VueX 拥有五个属性，分别是：<code>state getter mutation action module</code></p>
<ul>
<li><p><code>state</code></p>
<p><code>state</code>可以理解为 VueX 的仓库，所有需要全局状态管理的数据都存放在<code>state</code>中，在组件中读取<code>state</code>值的方法有两种，一种是使用<code>getter</code>，另一种是使用 VueX 的<code>mapState</code>方法。使用<code>mapState</code>的优势在于，在某个组件中需要一次性使用大量 VueX 中的数据时，我们可以直接通过这种映射的方式把所有需要的属性都取过来，而不用一个一个去取。</p>
</li>
<li><p><code>getter</code></p>
<p>可以理解为 VueX 中的计算属性，它是 VueX 对外暴露的接口，可以将<code>state</code>中的值经过处理后返回。</p>
</li>
<li><p><code>mutation</code></p>
<p>VueX 中有两种改变<code>store</code>中的值，一种是使用<code>this.$store.state.xxxx = &#39;xxx&#39;</code>来改变（这种方法改变<code>state</code>中的值 dom 中可能不会同步更新），另一种是使用<code>mutation</code>改变，一般来说，VueX 中的值不允许直接改变，只能使用<code>mutation</code>中的方法改变<code>state</code>中的值，这样可以方便追踪数据流向，使用方法为在组件的方法中调用<code>this.$store.commit(&#39;xxx&#39;)</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">daughter</span>: <span class="string">&quot;王一一&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">father</span>: <span class="string">&quot;栋栋&quot;</span>,</span><br><span class="line">    <span class="attr">mother</span>: <span class="string">&quot;董菜菜&quot;</span>,</span><br><span class="line">    <span class="attr">toys</span>: [<span class="string">&quot;小飞机&quot;</span>, <span class="string">&quot;非洲鼓&quot;</span>, <span class="string">&quot;小钢琴&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">getAge</span>: <span class="keyword">function</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">age</span> + <span class="string">&quot;岁&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">addAge</span>(<span class="params">state, addNum = <span class="number">1</span></span>) &#123;</span><br><span class="line">      state.<span class="property">age</span> += addNum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">      <span class="title function_">yearGone</span>(<span class="params">content, year = <span class="number">1</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;马上要执行+1啦&quot;</span>);</span><br><span class="line">        content.<span class="title function_">commit</span>(<span class="string">&quot;addAge&quot;</span>, year);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;+1完成啦&quot;</span>);</span><br><span class="line">        resolve;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.vue</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;print&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">computed</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ...<span class="title function_">mapState</span>([<span class="string">&quot;daughter&quot;</span>, <span class="string">&quot;age&quot;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ...<span class="title function_">mapActions</span>([<span class="string">&quot;yearGone&quot;</span>]),</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">print</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&quot;addAge&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">printAsync</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="title function_">yearGone</span>(<span class="number">2</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;actionsssssssssssss执行完啦！&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// printAsync : 马上要执行+1啦 +1完成啦 actionsssssssssssss执行完啦!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>action</code></p>
<p><code>action</code>的主要魅力在于<code>action</code>支持异步，在某些情况下，我们需要确定<code>mutation</code>改变<code>state</code>中的值之后再进行下一步操作，这时就需要用到<code>actions</code>。</p>
</li>
<li><p><code>module</code></p>
<p>在项目开发过程中，随着功能的增加，一个<code>VueX</code>里面储存的变量可能变得非常多，此外，如果多人开发一个项目，在项目开发时可能会出现<code>state mutation getters actions</code>重名的现象，这时，我们就用到了<code>module</code>。</p>
<p>首先要说的是，<code>module</code>可以将<code>VueX</code>分解成多个<code>store</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"><span class="keyword">const</span> father = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">fatherName</span>: <span class="string">&#x27;栋栋&#x27;</span>,</span><br><span class="line">    <span class="attr">fatherAge</span>: <span class="number">27</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">getFatherAge</span>: <span class="keyword">function</span> (<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;爸爸&#x27;</span> + state.<span class="property">age</span> + <span class="string">&#x27;岁&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">fatherAddAge</span>(<span class="params">state, addNum = <span class="number">1</span></span>) &#123;</span><br><span class="line">      state.<span class="property">age</span> += addNum;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mother = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;雨雨&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">26</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;妈妈&#x27;</span> + state.<span class="property">age</span> + <span class="string">&#x27;岁&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">addAge</span>(<span class="params">state, addNum = <span class="number">1</span></span>) &#123;</span><br><span class="line">      state.<span class="property">age</span> += addNum;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> daughter = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;一一&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">getAge</span>: <span class="keyword">function</span> (<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;大闺女&#x27;</span> + state.<span class="property">age</span> + <span class="string">&#x27;岁&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">addAge</span>(<span class="params">state, addNum = <span class="number">1</span></span>) &#123;</span><br><span class="line">      state.<span class="property">age</span> += addNum;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    father,</span><br><span class="line">    mother,</span><br><span class="line">    daughter,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>state</code>可以使用<code>this.$store.father.fatherName this.$store.mother.name this.$store.daughter.name</code>来获取。<code>father</code>定义的属性和另外两个都不一样，所以可以在组件中直接通过<code>this.$store.commit(&#39;fatherAddAge&#39;) this.$store.getters.getFatherAge</code>来触发<code>father</code>中的方法，<code>mother</code>和<code>daughter</code>定义的属性是重复的，这时最好为<code>modules</code>添加<code>namespaced </code>属性，来区分各个包的方法，方法为<code>this.$store.commit(&#39;mother/addAge&#39;) this.$store.commit(&#39;daughter/addAge&#39;) this.$store.getters[&quot;mother/getAge&quot;] this.$store.getters[&quot;daughter/getAge&quot;]</code>。</p>
</li>
<li><p>辅助函数 （<code>mapState mapGetters mapActions mapMutations</code>）</p>
<p><code> mapState mapGetters</code>写在<code>computed</code>中，<code> mapActions mapMutations</code>写在<code>method</code>中，都是相当于把要调用的值/方法直接映射在组件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapState, mapGetters, mapActions, mapMutations &#125; from &#x27;vuex&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      viewsCount: &#x27;views&#x27;,</span><br><span class="line">    &#125;),</span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">      todosALise: &#x27;getToDo&#x27;, // getToDo 不是字符串，对应的是getter里面的一个方法名字 然后将这个方法名字重新取一个别名 todosALise</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      totalAlise: &#x27;clickTotal&#x27;, // clickTotal 是mutation 里的方法，totalAlise是重新定义的一个别名方法，本组件直接调用这个方法</span><br><span class="line">    &#125;),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      blogAdd: &#x27;blogAdd&#x27;, // 第一个blogAdd是定义的一个函数别名称，挂载在到this(vue)实例上，后面一个blogAdd 才是actions里面函数方法名称</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-8-2-常见面试题"><a href="#3-8-2-常见面试题" class="headerlink" title="3.8.2 常见面试题"></a>3.8.2 常见面试题</h4><ol>
<li><p>vuex 有哪几种属性？</p>
<p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p>
</li>
<li><p>vuex 的 State 特性是？</p>
<ol>
<li>Vuex 就是一个仓库，仓库里面放了很多对象。其中 state 就是数据源存放地，对应于与一般 Vue 对象里面的 data</li>
<li>state 里面存放的数据是响应式的，Vue 组件从 store 中读取数据，若是 store 中的数据发生改变，依赖这个数据的组件也会发生更新 三、它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</li>
</ol>
</li>
<li><p>vuex 的 Getter 特性是？</p>
<ol>
<li>getters 可以对 State 进行计算操作，它就是 Store 的计算属性</li>
<li>虽然在组件内也可以做计算属性，但是 getters 可以在多组件之间复用</li>
<li>如果一个状态只在一个组件内使用，是可以不用 getters</li>
</ol>
</li>
<li><p>vuex 的 Mutation 特性是？</p>
<p>Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作</p>
</li>
<li><p>Vue.js 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 actions 中？</p>
<ol>
<li>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 vuex 的 state 里。</li>
<li>如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入 action 里，方便复用，并包装成 promise 返回，在调用处用 async await 处理返回的数据。如果不要复用这个请求，那么直接写在 vue 文件里很方便。</li>
</ol>
</li>
<li><p>不用 Vuex 会带来什么问题？</p>
<ol>
<li>可维护性会下降，你要想修改数据，你得维护三个地方</li>
<li>可读性会下降，因为一个组件里的数据，你根本就看不出来是从哪来的</li>
<li>增加耦合，大量的上传派发，会让耦合性大大的增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背。 但兄弟组件有大量通信的，建议一定要用，不管大项目和小项目，因为这样会省很多事</li>
</ol>
</li>
</ol>
<h3 id="3-9-如何实现一个-vue-插件"><a href="#3-9-如何实现一个-vue-插件" class="headerlink" title="3.9 如何实现一个 vue 插件"></a>3.9 如何实现一个 vue 插件</h3><h3 id="3-10-vue-router-原理"><a href="#3-10-vue-router-原理" class="headerlink" title="3.10 vue-router 原理"></a>3.10 vue-router 原理</h3><p>首先，从在浏览器地址栏输入地址到返回页面经历以下几个步骤：</p>
<ol>
<li>dns 解析服务器地址。</li>
<li>三次握手简历 tcp 链接。</li>
<li>发送 http 请求到服务端。</li>
<li>服务器处理 http 请求。</li>
<li>服务器返回请求结果。</li>
<li>关闭 tcp 链接。</li>
<li>浏览器解析返回结果。</li>
<li>浏览器布局渲染页面。</li>
</ol>
<ul>
<li>后端路由 后端路由相当于每一次改变地址（path）之后都会重新经历上面的流程，都重新去获取页面资源并渲染页面。</li>
<li>前端路由 前端路由，特别是现在一般使用的单页面应用框架，一般只需要第一次请求页面信息，然后都是在同一个 html 中渲染不同的内容。在路由改变时，是由框架的 js 监听地址的变化，然后通过 js 给变页面内容。主要是以下一个步骤：<ol>
<li>输入 url</li>
<li>js 解析地址</li>
<li>找到地址对应的页面</li>
<li>行页面的 js</li>
<li>渲染页面</li>
</ol>
</li>
</ul>
<p>此外前端路由也可以分为两种模式，一种是 hash 模式，一种是 history 模式；两种模式最大的区别在于 history 模式的可读性更好，更美观。在使用 history 模式时需要后台设置，将所有路由默认重定向到根页面，不然就会出现 404 错误。</p>
<h3 id="3-11-vue-keep-alive-原理"><a href="#3-11-vue-keep-alive-原理" class="headerlink" title="3.11 vue keep-alive 原理"></a>3.11 vue keep-alive 原理</h3><p>首先，keep-alive 是一个抽象组件，它本身不会渲染 dom 元素，也不会出现在父组件链中，使用 keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们。</p>
<h3 id="3-12-vue-directive-自定义指令"><a href="#3-12-vue-directive-自定义指令" class="headerlink" title="3.12 vue directive (自定义指令)"></a>3.12 vue directive (自定义指令)</h3><p>自定义指令是用来操作 DOM 的，尽管 Vue 推崇数据驱动识图的理念，但并非所有的情况都适合数据驱动。自定义指定就是一种有效的补充和扩展，不紧可以用于定义任何 dom 的操作，并且是复用的。</p>
<p>vue 指令的钩子函数</p>
<ul>
<li>bind：只调用一次，指令第一次绑定到元素时调用，这里可以进行一次性的初始化设置。</li>
<li>inserted：被绑定的元素插入父节点时调用（保证父节点存在，但不一定已被插入文档中）。</li>
<li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。</li>
<li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li>
<li>unbind：调用一次，指令与元素解绑时调用。</li>
</ul>
<p>钩子函数的参数：</p>
<ul>
<li>el：指令绑定的元素，可以用来直接操作 dom。</li>
<li>binding：一个对象，包含以下 property：<ul>
<li>name：指令名，不包括 v-前缀</li>
<li>value：指令的绑定值，例如：v-my-directive=”1+1”中，绑定值为 2。</li>
<li>expression：字符串形式的指令表达式。例如 v-my-directive=”1+1”中，指令表达式为”1+1”</li>
<li>arg：传给指令的参数，可选，例如：v-my-directive:foo 中，参数为”foo”。</li>
<li>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为{foo:true,bar:true}。</li>
</ul>
</li>
<li>vnode：vue 编译生成的虚拟节点。</li>
<li>oldVNode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li>
</ul>
<h3 id="3-13-vue3相关"><a href="#3-13-vue3相关" class="headerlink" title="3.13 vue3相关"></a>3.13 vue3相关</h3><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>题目列表</title>
    <url>/2021/12/24/20211224-question-list/</url>
    <content><![CDATA[<p>力扣各种类型题目出现频率。</p>
<span id="more"></span>

<h3 id="全站题目出现频率Top200"><a href="#全站题目出现频率Top200" class="headerlink" title="全站题目出现频率Top200"></a>全站题目出现频率Top200</h3><table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">题目</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/two-sum">1. 两数之和</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/binary-search">704. 二分查找</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/add-two-numbers">2. 两数相加</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/reverse-integer">7. 整数反转</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays">4. 寻找两个正序数组的中位数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">剑指 Offer 09. 用两个栈实现队列</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">3. 无重复字符的最长子串</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-palindromic-substring">5. 最长回文子串</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/trapping-rain-water">42. 接雨水</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-common-prefix">14. 最长公共前缀</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/contains-duplicate">217. 存在重复元素</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/generate-parentheses">22. 括号生成</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/3sum">15. 三数之和</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/combine-two-tables">175. 组合两个表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/valid-parentheses">20. 有效的括号</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/climbing-stairs">70. 爬楼梯</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/merge-sorted-array">88. 合并两个有序数组</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/regular-expression-matching">10. 正则表达式匹配</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal">102. 二叉树的层序遍历</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/merge-intervals">56. 合并区间</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group">25. K 个一组翻转链表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/container-with-most-water">11. 盛最多水的容器</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/candy">135. 分发糖果</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/lru-cache">146. LRU 缓存机制</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">121. 买卖股票的最佳时机</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">剑指 Offer 03. 数组中重复的数字</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum">124. 二叉树中的最大路径和</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof">剑指 Offer 24. 反转链表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">21. 合并两个有序链表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/first-missing-positive">41. 缺失的第一个正数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/3sum-closest">16. 最接近的三数之和</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array">215. 数组中的第K个最大元素</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/second-highest-salary">176. 第二高的薪水</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/roman-to-integer">13. 罗马数字转整数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/number-of-islands">200. 岛屿数量</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof">剑指 Offer 38. 字符串的排列</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/reorder-list">143. 重排链表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/valid-triangle-number">611. 有效三角形的个数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/edit-distance">72. 编辑距离</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence">128. 最长连续序列</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">剑指 Offer 11. 旋转数组的最小数字</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/reverse-linked-list">206. 反转链表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/maximum-subarray">53. 最大子数组和</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/restore-ip-addresses">93. 复原 IP 地址</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/move-zeroes">283. 移动零</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/lru-cache-lcci">面试题 16.25. LRU 缓存</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof">剑指 Offer 42. 连续子数组的最大和</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/permutations">46. 全排列</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/add-strings">415. 字符串相加</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">剑指 Offer 22. 链表中倒数第k个节点</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/is-unique-lcci">面试题 01.01. 判定字符是否唯一</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/sort-an-array">912. 排序数组</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/multiply-strings">43. 字符串相乘</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/compare-version-numbers">165. 比较版本号</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/single-number">136. 只出现一次的数字</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/decode-string">394. 字符串解码</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">560. 和为 K 的子数组</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">23. 合并K个升序链表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/first-bad-version">278. 第一个错误的版本</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/palindrome-number">9. 回文数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/spiral-matrix">54. 螺旋矩阵</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/zigzag-conversion">6. Z 字形变换</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/max-submatrix-lcci">面试题 17.24. 最大子矩阵</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/next-permutation">31. 下一个排列</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof">剑指 Offer 51. 数组中的逆序对</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii">92. 反转链表 II</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/the-skyline-problem">218. 天际线问题</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/combination-sum">39. 组合总和</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/nth-highest-salary">177. 第N高的薪水</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/smallest-k-lcci">面试题 17.14. 最小K个数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">剑指 Offer 10- I. 斐波那契数列</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/jump-game-ii">45. 跳跃游戏 II</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof">剑指 Offer 62. 圆圈中最后剩下的数字</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/daily-temperatures">739. 每日温度</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/maximum-product-subarray">152. 乘积最大子数组</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/n-queens">51. N 皇后</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">26. 删除有序数组中的重复项</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/house-robber">198. 打家劫舍</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram">84. 柱状图中最大的矩形</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal">103. 二叉树的锯齿形层序遍历</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/string-to-integer-atoi">8. 字符串转换整数 (atoi)</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/minimum-path-sum">64. 最小路径和</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/sqrtx">69. Sqrt(x)</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/rotate-array">189. 轮转数组</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof">剑指 Offer 06. 从尾到头打印链表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/invert-binary-tree">226. 翻转二叉树</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/department-top-three-salaries">185. 部门工资前三高的所有员工</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">剑指 Offer 13. 机器人的运动范围</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">剑指 Offer 04. 二维数组中的查找</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number">17. 电话号码的字母组合</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array">33. 搜索旋转排序数组</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/consecutive-numbers">180. 连续出现的数字</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/spiral-matrix-ii">59. 螺旋矩阵 II</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">300. 最长递增子序列</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/word-break">139. 单词拆分</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof">剑指 Offer 26. 树的子结构</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof">剑指 Offer 29. 顺时针打印矩阵</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/maximal-square">221. 最大正方形</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi">LCP 07. 传递信息</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-valid-parentheses">32. 最长有效括号</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/remove-element">27. 移除元素</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/sliding-window-maximum">239. 滑动窗口最大值</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">104. 二叉树的最大深度</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/boats-to-save-people">881. 救生艇</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/bus-routes">815. 公交路线</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/powx-n">50. Pow(x, n)</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array">34. 在排序数组中查找元素的第一个和最后一个位置</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/coin-change">322. 零钱兑换</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/4sum">18. 四数之和</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/integer-to-roman">12. 整数转罗马数字</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">236. 二叉树的最近公共祖先</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/search-insert-position">35. 搜索插入位置</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof">剑指 Offer 05. 替换空格</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof">剑指 Offer 25. 合并两个排序的链表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof">剑指 Offer 46. 把数字翻译成字符串</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays">349. 两个数组的交集</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence">673. 最长递增子序列的个数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/palindrome-linked-list">234. 回文链表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/unique-binary-search-trees">96. 不同的二叉搜索树</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/validate-binary-search-tree">98. 验证二叉搜索树</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof">剑指 Offer 48. 最长不含重复字符的子字符串</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal">106. 从中序与后序遍历序列构造二叉树</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/rotate-image">48. 旋转图像</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/valid-sudoku">36. 有效的数独</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/text-justification">68. 文本左右对齐</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/gas-station">134. 加油站</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">309. 最佳买卖股票时机含冷冻期</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/implement-strstr">28. 实现 strStr()</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">105. 从前序与中序遍历序列构造二叉树</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/top-k-frequent-elements">347. 前 K 个高频元素</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/divide-two-integers">29. 两数相除</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/rectangle-area">223. 矩形面积</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/24-game">679. 24 点游戏</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/linked-list-cycle">141. 环形链表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/permutations-ii">47. 全排列 II</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/integer-break">343. 整数拆分</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii">557. 反转字符串中的单词 III</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/pascals-triangle">118. 杨辉三角</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii">350. 两个数组的交集 II</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/subsets">78. 子集</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/sort-list">148. 排序链表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal">145. 二叉树的后序遍历</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/largest-number">179. 最大数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/min-stack">155. 最小栈</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/repeated-dna-sequences">187. 重复的DNA序列</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers">181. 超过经理收入的员工</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/find-peak-element">162. 寻找峰值</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/house-robber-iii">337. 打家劫舍 III</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/jump-game">55. 跳跃游戏</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/minimum-window-substring">76. 最小覆盖子串</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof">剑指 Offer 45. 把数组排成最小的数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer">138. 复制带随机指针的链表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof">剑指 Offer 40. 最小的k个数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii">82. 删除排序链表中的重复元素 II</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/valid-parenthesis-string">678. 有效的括号字符串</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-common-subsequence">1143. 最长公共子序列</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings">583. 两个字符串的删除操作</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/sorted-merge-lcci">面试题 10.01. 合并排序的数组</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/symmetric-tree">101. 对称二叉树</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/simplify-path">71. 简化路径</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/max-area-of-island">695. 岛屿的最大面积</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">剑指 Offer 10- II. 青蛙跳台阶问题</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree">543. 二叉树的直径</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element">1838. 最高频元素的频数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum">416. 分割等和子集</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/unique-paths">62. 不同路径</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/print-in-order">1114. 按序打印</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii">240. 搜索二维矩阵 II</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/course-schedule">207. 课程表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted">167. 两数之和 II - 输入有序数组</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">142. 环形链表 II</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order">440. 字典序的第K小数字</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/avoid-flood-in-the-city">1488. 避免洪水泛滥</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/combination-sum-ii">40. 组合总和 II</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/majority-element">169. 多数元素</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/number-of-digit-one">233. 数字 1 的个数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency">451. 根据字符出现频率排序</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/dungeon-game">174. 地下城游戏</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/duplicate-emails">182. 查找重复的电子邮箱</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/decode-ways">91. 解码方法</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view">199. 二叉树的右视图</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof">剑指 Offer 50. 第一个只出现一次的字符</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/assign-cookies">455. 分发饼干</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii">407. 接雨水 II</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string">434. 字符串中的单词数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/single-number-iii">260. 只出现一次的数字 III</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/sum-of-left-leaves">404. 左叶子之和</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof">剑指 Offer 36. 二叉搜索树与双向链表</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/path-sum">112. 路径总和</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/combination-sum-iii">216. 组合总和 III</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii">123. 买卖股票的最佳时机 III</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/merge-two-binary-trees">617. 合并二叉树</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/basic-calculator-ii">227. 基本计算器 II</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/find-median-from-data-stream">295. 数据流的中位数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/remove-duplicate-letters">316. 去除重复字母</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci">面试题 01.07. 旋转矩阵</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/perfect-squares">279. 完全平方数</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array">977. 有序数组的平方</a></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/task-scheduler">621. 任务调度器</a></td>
</tr>
</tbody></table>
<h3 id="动态规划-出现频率top50"><a href="#动态规划-出现频率top50" class="headerlink" title="动态规划  出现频率top50"></a>动态规划  出现频率top50</h3><table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">题目</th>
<th align="left">通过率</th>
<th align="left">难度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ok</td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></td>
<td align="left">35.9%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left">Ok</td>
<td align="left"><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></td>
<td align="left">59.0%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left">ok</td>
<td align="left"><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></td>
<td align="left">77.3%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left">ok</td>
<td align="left"><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></td>
<td align="left">53.3%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></td>
<td align="left">31.6%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left">ok</td>
<td align="left"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></td>
<td align="left">57.4%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></td>
<td align="left">44.6%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></td>
<td align="left">61.5%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left">ok</td>
<td align="left"><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></td>
<td align="left">55.3%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left">ok</td>
<td align="left"><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></td>
<td align="left">60.6%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">面试题 17.24. 最大子矩阵</a></td>
<td align="left">52.2%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left">ok</td>
<td align="left"><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a></td>
<td align="left">43.5%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left">ok</td>
<td align="left"><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></td>
<td align="left">36.1%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></td>
<td align="left">42.3%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left">ok</td>
<td align="left"><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></td>
<td align="left">52.1%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></td>
<td align="left">68.9%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></td>
<td align="left">52.8%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></td>
<td align="left">52.2%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></td>
<td align="left">52.0%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></td>
<td align="left">47.9%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/">LCP 07. 传递信息</a></td>
<td align="left">76.7%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></td>
<td align="left">35.7%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></td>
<td align="left">44.8%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></td>
<td align="left">70.0%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></td>
<td align="left">53.1%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a></td>
<td align="left">43.6%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></td>
<td align="left">61.6%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分</a></td>
<td align="left">61.0%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></td>
<td align="left">73.7%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></td>
<td align="left">43.4%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></td>
<td align="left">60.7%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></td>
<td align="left">44.7%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></td>
<td align="left">38.6%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></td>
<td align="left">62.7%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></td>
<td align="left">63.8%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></td>
<td align="left">66.5%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></td>
<td align="left">51.0%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/dungeon-game/">174. 地下城游戏</a></td>
<td align="left">48.0%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/number-of-digit-one/">233. 数字 1 的个数</a></td>
<td align="left">47.7%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></td>
<td align="left">31.3%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></td>
<td align="left">54.1%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></td>
<td align="left">63.6%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></td>
<td align="left">65.8%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></td>
<td align="left">66.4%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></td>
<td align="left">56.9%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/beautiful-arrangement/">526. 优美的排列</a></td>
<td align="left">73.5%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/integer-replacement/">397. 整数替换</a></td>
<td align="left">43.2%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></td>
<td align="left">65.1%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></td>
<td align="left">43.4%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></td>
<td align="left">67.1%</td>
<td align="left">简单</td>
</tr>
</tbody></table>
<h3 id="回溯-Top25"><a href="#回溯-Top25" class="headerlink" title="回溯 Top25"></a>回溯 Top25</h3><table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">题目</th>
<th align="left">通过率</th>
<th align="left">难度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></td>
<td align="left">77.3%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></td>
<td align="left">58.0%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原 IP 地址</a></td>
<td align="left">54.7%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></td>
<td align="left">78.4%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></td>
<td align="left">72.7%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></td>
<td align="left">73.8%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></td>
<td align="left">57.5%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></td>
<td align="left">64.1%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/24-game/">679. 24 点游戏</a></td>
<td align="left">54.0%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></td>
<td align="left">80.2%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></td>
<td align="left">61.6%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></td>
<td align="left">73.6%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></td>
<td align="left">76.9%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/beautiful-arrangement/">526. 优美的排列</a></td>
<td align="left">73.5%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></td>
<td align="left">70.7%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a></td>
<td align="left">67.1%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></td>
<td align="left">54.8%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></td>
<td align="left">58.0%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></td>
<td align="left">45.3%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a></td>
<td align="left">44.9%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></td>
<td align="left">49.2%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a></td>
<td align="left">72.3%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></td>
<td align="left">46.0%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/bracket-lcci/">面试题 08.09. 括号</a></td>
<td align="left">81.6%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></td>
<td align="left">62.8%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/gray-code/">89. 格雷编码</a></td>
<td align="left">71.3%</td>
<td align="left">中等</td>
</tr>
</tbody></table>
<h3 id="双指针-Top50"><a href="#双指针-Top50" class="headerlink" title="双指针 Top50"></a>双指针 Top50</h3><table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">题目</th>
<th align="left">通过率</th>
<th align="left">难度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></td>
<td align="left">59.0%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></td>
<td align="left">34.1%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></td>
<td align="left">51.9%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></td>
<td align="left">62.3%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a></td>
<td align="left">45.8%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/valid-triangle-number/">611. 有效三角形的个数</a></td>
<td align="left">53.3%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></td>
<td align="left">62.6%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></td>
<td align="left">64.0%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></td>
<td align="left">79.9%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/compare-version-numbers/">165. 比较版本号</a></td>
<td align="left">52.1%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></td>
<td align="left">37.3%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></td>
<td align="left">53.7%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></td>
<td align="left">75.0%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/rotate-array/">189. 轮转数组</a></td>
<td align="left">44.7%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></td>
<td align="left">43.3%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></td>
<td align="left">59.6%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/boats-to-save-people/">881. 救生艇</a></td>
<td align="left">53.8%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></td>
<td align="left">39.5%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></td>
<td align="left">73.9%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></td>
<td align="left">50.2%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></td>
<td align="left">40.3%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></td>
<td align="left">51.3%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a></td>
<td align="left">74.3%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></td>
<td align="left">66.6%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></td>
<td align="left">55.2%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></td>
<td align="left">53.2%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/">面试题 10.01. 合并排序的数组</a></td>
<td align="left">55.6%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></td>
<td align="left">58.7%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></td>
<td align="left">55.5%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">295. 数据流的中位数</a></td>
<td align="left">52.3%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></td>
<td align="left">70.2%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></td>
<td align="left">43.4%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/compress-string-lcci/">面试题 01.06. 字符串压缩</a></td>
<td align="left">47.1%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/reverse-string/">344. 反转字符串</a></td>
<td align="left">77.4%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/happy-number/">202. 快乐数</a></td>
<td align="left">62.1%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></td>
<td align="left">76.3%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串</a></td>
<td align="left">47.1%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></td>
<td align="left">40.6%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/meeting-rooms-ii/">253. 会议室 II</a><img src="https://static.leetcode-cn.com/cn-mono-assets/production/assets/plus.31398c34.svg" alt="plus"></td>
<td align="left">50.5%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></td>
<td align="left">65.2%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/">1877. 数组中最大数对和的最小值</a></td>
<td align="left">81.8%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/string-compression/">443. 压缩字符串</a></td>
<td align="left">47.7%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></td>
<td align="left">70.9%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></td>
<td align="left">59.9%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">345. 反转字符串中的元音字母</a></td>
<td align="left">54.0%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></td>
<td align="left">64.5%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">80. 删除有序数组中的重复项 II</a></td>
<td align="left">61.8%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></td>
<td align="left">61.8%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a></td>
<td align="left">49.6%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-string-chain/">1048. 最长字符串链</a></td>
<td align="left">46.4%</td>
<td align="left">中等</td>
</tr>
</tbody></table>
<h3 id="记忆化搜索-Top10"><a href="#记忆化搜索-Top10" class="headerlink" title="记忆化搜索 Top10"></a>记忆化搜索 Top10</h3><table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">题目</th>
<th align="left">通过率</th>
<th align="left">难度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></td>
<td align="left">53.3%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></td>
<td align="left">36.1%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></td>
<td align="left">52.0%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></td>
<td align="left">44.7%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/integer-replacement/">397. 整数替换</a></td>
<td align="left">43.2%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></td>
<td align="left">67.1%</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/zuma-game/">488. 祖玛游戏</a></td>
<td align="left">52.6%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a></td>
<td align="left">44.9%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级</a></td>
<td align="left">73.5%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></td>
<td align="left">49.0%</td>
<td align="left">困难</td>
</tr>
</tbody></table>
<h3 id="滑动窗口-Top10"><a href="#滑动窗口-Top10" class="headerlink" title="滑动窗口 Top10"></a>滑动窗口 Top10</h3><table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">题目</th>
<th align="left">通过率</th>
<th align="left">难度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></td>
<td align="left">38.3%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></td>
<td align="left">49.7%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></td>
<td align="left">46.5%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></td>
<td align="left">52.3%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></td>
<td align="left">43.0%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">1838. 最高频元素的频数</a></td>
<td align="left">42.9%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></td>
<td align="left">43.4%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></td>
<td align="left">47.7%</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></td>
<td align="left">44.5%</td>
<td align="left">困难</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></td>
<td align="left">56.5%</td>
<td align="left">中等</td>
</tr>
</tbody></table>
<h3 id="位运算-Top10"><a href="#位运算-Top10" class="headerlink" title="位运算  Top10"></a>位运算  Top10</h3><table>
<thead>
<tr>
<th>状态</th>
<th>题目</th>
<th>通过率</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/is-unique-lcci/">面试题 01.01. 判定字符是否唯一</a></td>
<td>71.7%</td>
<td>简单</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></td>
<td>71.9%</td>
<td>简单</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/divide-two-integers/">29. 两数相除</a></td>
<td>22.0%</td>
<td>中等</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></td>
<td>52.3%</td>
<td>中等</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></td>
<td>80.2%</td>
<td>中等</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></td>
<td>74.0%</td>
<td>中等</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/beautiful-arrangement/">526. 优美的排列</a></td>
<td>73.5%</td>
<td>中等</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></td>
<td>69.7%</td>
<td>中等</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和</a></td>
<td>61.3%</td>
<td>中等</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/integer-replacement/">397. 整数替换</a></td>
<td>43.2%</td>
<td>中等</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/add-binary/">67. 二进制求和</a></td>
<td>54.1%</td>
<td>简单</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></td>
<td>44.8%</td>
<td>简单</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/">847. 访问所有节点的最短路径</a></td>
<td>67.9%</td>
<td>困难</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/xoh6Oh/">剑指 Offer II 001. 整数除法</a></td>
<td>20.8%</td>
<td>简单</td>
</tr>
<tr>
<td></td>
<td><a href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a></td>
<td>44.9%</td>
<td>中等</td>
</tr>
</tbody></table>
<p>贪心算法需要看</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>题目列表</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统</title>
    <url>/2022/10/19/20221019-pc/</url>
    <content><![CDATA[<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><p>本部分主要是笔者在学习现代操作系统和一些相关面试题所做的笔记，如果出现错误，希望大家指出！</p>
<h2 id="现代操作系统阅读笔记"><a href="#现代操作系统阅读笔记" class="headerlink" title="现代操作系统阅读笔记"></a>现代操作系统阅读笔记</h2><h3 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h3><h4 id="1-操作系统定义"><a href="#1-操作系统定义" class="headerlink" title="1. 操作系统定义"></a>1. 操作系统定义</h4><p>操作系统是运行在内核态的软件，它执行两个基本上独立的任务。</p>
<ul>
<li>隐藏计算机底层硬件的实现，为用户及应用程序提供一个资源集的清晰抽象。</li>
<li>管理计算机硬件资源。</li>
</ul>
<p>任何操作系统的核心是它可处理的系统调用集。这些系统调用集真实地说明了操作系统做的工作。</p>
<h4 id="2-计算机运行模式"><a href="#2-计算机运行模式" class="headerlink" title="2. 计算机运行模式"></a>2. 计算机运行模式</h4><p>多数计算机有两种运行模式：内核态和用户态。</p>
<p>软件中最基础的部分是操作系统，它运行在内核态。这内核态模式下，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在用户态下，在用户态下，只能使用机器指令中的一个子集。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-1.png" alt="计算机运行模式"></p>
<h4 id="3-shell-与-GUI"><a href="#3-shell-与-GUI" class="headerlink" title="3. shell 与 GUI"></a>3. shell 与 GUI</h4><p>用户与之交互的程序，基于文本的通常称为 shell，而基于图标的则称为图形用户界面（GUI）。</p>
<p>它们并不是操作系统的一部分，它们是运行在用户态最低层次的用户接口程序</p>
<h4 id="4-对于抽象的理解"><a href="#4-对于抽象的理解" class="headerlink" title="4. 对于抽象的理解"></a>4. 对于抽象的理解</h4><p>现代计算机系统中，大量使用了抽象这一概念。抽象是管理复杂性的一个关键。好的抽象可以把一个几乎不可能管理的任务划分为两个可管理的部分。其中第一部分是有关抽象的定义和实现，第二部分是随时用这些抽象解决问题。</p>
<p>以抽象的角度看操作系统，它的任务就是创建好的抽象，并实现和管理它所创建的抽象。</p>
<h4 id="5-多路复用资源方式"><a href="#5-多路复用资源方式" class="headerlink" title="5. 多路复用资源方式"></a>5. 多路复用资源方式</h4><p>在时间上复用：当一种资源在时间上复用时，不同的程序或用户轮流使用它。</p>
<p>在空间上复用：每个客户得到资源的一部分。</p>
<h4 id="6-I-O-设备的结构"><a href="#6-I-O-设备的结构" class="headerlink" title="6. I/O 设备的结构"></a>6. I/O 设备的结构</h4><p>I/O 设备一般包括两个部分：设备控制器和设备本身。控制器插在电路板上的一块芯片或一组芯片，这块电路板物理地控制芯片，它从操作系统接收命令。</p>
<p>控制器的任务是为操作系统提供一个简单的接口。每类设备控制器是不同的，所以需要不同的软件进行控制。专门与控制器对话，发出命令并接收响应的软件，称为设备驱动程序。为了使用设备驱动程序，必须要把设备驱动程序装入到操作系统中，这样它可在核心态中运行。</p>
<p>每个设备控制器都有少量的用于通信的寄存器，所有的寄存器的集合构成了 I/O 空间。</p>
<h4 id="7-IDE-概念"><a href="#7-IDE-概念" class="headerlink" title="7. IDE 概念"></a>7. IDE 概念</h4><p>IDE 表示集成驱动电子设备，是许多计算机的磁盘标准。</p>
<h4 id="8-实现输入输出的三种方式"><a href="#8-实现输入输出的三种方式" class="headerlink" title="8. 实现输入输出的三种方式"></a>8. 实现输入输出的三种方式</h4><p>第一种方式，用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序的过程调用。然后设备驱动程序启动 I/O 并在一个连续不断的循环中检查该设备，看该设备是否完成了工作。当 I/O 结束后，设备驱动程序把数据送到指定的地方（若有此需要），并返回。然后操作系统将控制返回给调用者。这种方式称为忙等待（busy waiting），其缺点是要占据 CPU ，CPU 一直轮询设备直到对应的 I/O 操作完成。</p>
<p>第二种方式，设备驱动程序启动设备并且让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备的操作完毕时，它发出一个中断通知操作完成。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-2.png" alt="终端实例"></p>
<p>第三种方式，为 I/O 使用一种特殊的直接存储器访问（Direct Memory Access，DMA）芯片，它可以控制在内存和某些控制器之间的位流，而无须持续的 CPU 干预。</p>
<h4 id="9-CMOS-存储器"><a href="#9-CMOS-存储器" class="headerlink" title="9. CMOS 存储器"></a>9. CMOS 存储器</h4><p>CMOS 存储器是易失性的。许多计算机利用 CMOS 存储器保持当前时间和日期。 CMOS 存储器和递增时间的时钟电路有一块小电池驱动，所以，即使计算机没有上电，时间也可以正确地更新。</p>
<h4 id="10-USB-概念"><a href="#10-USB-概念" class="headerlink" title="10. USB 概念"></a>10. USB 概念</h4><p>USB 是通用串行总线，是用来将所有的慢速 I/O 设备，诸如键盘和鼠标，与计算机相连。USB 是一种集中式总线，其根设备每 1ms 轮询一次 I/O 设备，看是否有消息收发。所有的 USB 设备共享一个 USB 设备驱动器，于是就不需要为新的 USB 设备安装新的设备驱动器了。</p>
<h4 id="11-即插即用概念"><a href="#11-即插即用概念" class="headerlink" title="11. 即插即用概念"></a>11. 即插即用概念</h4><p>在一般的计算机工作环境下，操作系统必须了解有些什么外部设备连接到计算机上，并对它们进行配置。这种需求导致了 Intel 和微软设计了一种名为即插即用的 I/O 系统。</p>
<p>在即插即用之前，每块 I/O 卡有一个固定的中断请求级别和用于其 I/O 寄存器的固定地址。即插即用所做的工作是，系统自动地收集有关 I/O 设备的信息，集中赋予 I/O 地址，然后通知每块卡所用的数值。</p>
<h4 id="12-计算机的启动"><a href="#12-计算机的启动" class="headerlink" title="12. 计算机的启动"></a>12. 计算机的启动</h4><p>Pentium 的简要启动过程如下。在每个 Pentium 上有一块母板。在母板上有一个称为基本输入输出系统（Basic Input Output System，BIOS）的程序。在 BIOS 内有底层 I/O 软件，包括读键盘、写屏幕、进行磁盘 I/O 以及其他过程。现在这个程序存放在一块闪速 RAM 中，它是非可易失性的，但是在发现 BIOS 中有错时可以通过操作系统对它进行更新。</p>
<p>简要过程如下：</p>
<ol>
<li>BIOS 开始运行。它首先检查计算机设备的状态信息是否正常。</li>
<li>扫描并记录总线所连设备。</li>
<li>依次搜索启动设备，导入操作系统。</li>
<li>操作系统询问 BIOS ，获得配置信息，获取所有设备的驱动程序并调入内核。</li>
<li>初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登录程序或 GUI。</li>
</ol>
<h4 id="13-操作系统分类"><a href="#13-操作系统分类" class="headerlink" title="13. 操作系统分类"></a>13. 操作系统分类</h4><p>大型机操作系统、服务器操作系统、多处理器操作系统、个人计算机操作系统、掌上计算机操作系统、嵌入式操作系统、传感器节点操作系统、实时操作系统、智能卡操作系统</p>
<h4 id="14-实时操作系统的基本概念"><a href="#14-实时操作系统的基本概念" class="headerlink" title="14. 实时操作系统的基本概念"></a>14. 实时操作系统的基本概念</h4><p>实时操作系统的特征是将时间作为关键参数。通常分为硬实时操作系统和软实时操作系统。</p>
<p>在硬实时操作系统中，某个规定的动作必须绝对地在规定的时刻（或规定的时间范围）发生。</p>
<p>在软实时操作系统中，偶尔违反最终时限是不希望的，但可以接受，并且不会引起任何实时性的损害。</p>
<h4 id="15-UID"><a href="#15-UID" class="headerlink" title="15. UID"></a>15. UID</h4><p>系统管理器授权每个进程使用一个给定的 UID 标识。每个被启动的进程都有一个启动该进程的用户 UID 。子进程与父进程拥有一样 UID。用户可以是某个组的成员，每个组也有一个 GID 标识。</p>
<h4 id="16-文件路径"><a href="#16-文件路径" class="headerlink" title="16. 文件路径"></a>16. 文件路径</h4><p>在 UNIX 中，绝对路径名包含了从根目录到该文件的所有目录清单，它们之间用正斜线 <code>/</code> 隔开。最开始的正斜线标识这是从根目录开始的绝对路径。</p>
<p>在 MS-DOS 和 Windows 中，用反斜线 <code>\</code> 作为分隔符。</p>
<h4 id="17-文件系统安装"><a href="#17-文件系统安装" class="headerlink" title="17. 文件系统安装"></a>17. 文件系统安装</h4><p>UNIX 一个重要概念是安装文件系统。几乎所有的个人计算机都有一个或多个光盘驱动器，可以插入 CD-ROM 和 DV D。它们几乎都有 USB 接口，可以插入 USB 存储棒（实际是固态磁盘驱动器）。为了提供一个出色的方式处理可移动介质，UNIX 允许把在 CD-ROM 或 DVD 上的文件系统接入到主文件树上。 mount 系统调用允许把在 CD-ROM 上的文件系统连接到程序所希望的根文件系统上。</p>
<h4 id="18-特殊文件"><a href="#18-特殊文件" class="headerlink" title="18. 特殊文件"></a>18. 特殊文件</h4><p>提供特殊文件是为了使 I/O 设备看起来像文件一般。这样，就像使用系统调用读写文件一样，I/O 设备也可通过同样的系统调用进行读写。</p>
<p>有两类特殊文件：块特殊文件和字符特殊文件。</p>
<p>块特殊文件指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读第 4 块，程序可以直接访问设备的第 4 块而不必考虑存放该文件的文件系统结构。</p>
<p>字符特殊文件用于打印机、调制解调器和其他接收或输出字符流的设备。按照惯例，特殊文件保存在 /dev 目录中。例如，/dev/lp 是打印机。</p>
<h4 id="19-文件保护"><a href="#19-文件保护" class="headerlink" title="19. 文件保护"></a>19. 文件保护</h4><p>UNIX 操作系统通过对每个文件赋予一个 9 位的二进制保护代码，对 UNIX 中的文件实现保护。该保护代码有三个 3 位字段，一个用于所有者，一个用于所有者同组（用户被系统管理员划分成组）中的其他成员，而另一个用于其他人。每个字段中有一位用于读访问，一位用于写访问，一位用于执行访问。这些位就是知名的 rwx 位。</p>
<h4 id="20-系统调用概念"><a href="#20-系统调用概念" class="headerlink" title="20. 系统调用概念"></a>20. 系统调用概念</h4><p>如果一个进程正在用户态中运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据，那么它就必须执行一个陷阱或系统调用指令，将控制转移到操作系统。操作系统接着通过参数检查，找出所需要的调用进程。然后，它执行系统调用，并把控制返回给在系统调用后面跟随着的指令。在某种意义上，进行系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进入内核，而过程调用则不能。</p>
<h4 id="21-POSIX"><a href="#21-POSIX" class="headerlink" title="21. POSIX"></a>21. POSIX</h4><p>UNIX 有很多不兼容的版本，从而导致了混乱。为了能使编写的程序能够在任何版本的 UNIX 系统运行，IEEE 提出了一个 UNIX 标准，称为 POSIX，目前大多数 UNIX 版本都支持他。 POSIX 标准定义了凡是 UNIX 必须支持的小型系统调用接口。</p>
<h4 id="22-Windows-Win32-API"><a href="#22-Windows-Win32-API" class="headerlink" title="22. Windows Win32 API"></a>22. Windows Win32 API</h4><p>Windows 和 UNIX 的主要差别在于编程方式。一个 UNIX 程序包括做各种处理的代码以及从事完成特定服务的系统调用。相反，一个 Windows 程序通常是一个事件驱动程序。其中主程序等待某些事件发生，然后调用一个过程处理该事件。</p>
<p>在 UNIX 中，系统调用（如 read）和系统调用所使用的库过程（如 read）之间几乎是一一对应的关系。换句话说，对于每个系统调用，差不多就涉及一个被调用的库过程。</p>
<p>在 Windows 中，情况就大不相同了。首先，库调用和实际的系统调用是几乎不对应的。微软定义了一套过程，称为应用编程接口（Application Program Interface，Win32 API），程序员用这套过程获得操作系统的服务。</p>
<p>Win32 并不是非常统一的或有一致的接口。其主要原因是由于 Win32 需要与早期的在 Windows 3.x 中使用的 16 位接口向后兼容。</p>
<p>Windows 中没有类似 UNIX 中的进程层次，所以不存在父进程和子进程的概念。在进程创建之后，创建者和被创建者是平等的。</p>
<h4 id="23-操作系统结构"><a href="#23-操作系统结构" class="headerlink" title="23. 操作系统结构"></a>23. 操作系统结构</h4><p>单体结构、层次式结构、微内核、客户机-服务器模式、虚拟机、外核、</p>
<h4 id="24-微内核的概念"><a href="#24-微内核的概念" class="headerlink" title="24. 微内核的概念"></a>24. 微内核的概念</h4><p>在微内核设计背后的思想是，为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有其中一个模块——微内核——运行在内核态上，其余的模块，由于功能相对弱些，则作为普通用户进程运行。特别地，由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使得整个系统死机。</p>
<h4 id="25-机制与策略分离原则"><a href="#25-机制与策略分离原则" class="headerlink" title="25. 机制与策略分离原则"></a>25. 机制与策略分离原则</h4><p>策略指的是做什么，机制指的是怎么做。例如一个比较简单的调度算法是，对每个进程赋予一个优先级，并让内核执行在具有最高优先级进程中可以运行的某个进程。这里，机制（在内核中）就是寻找最高优先级的进程并运行之。而策略（赋予进程以优先级）可以由用户态中的进程完成。在这个方式中，机制和策略是分离的，从而使系统内核变得更小。</p>
<h4 id="26-make-程序"><a href="#26-make-程序" class="headerlink" title="26. make 程序"></a>26. make 程序</h4><p>在 UNIX 系统中，有个名为 make 的程序（其大量的变体如 gmake、pmake 等），它读入 Makefile ，该 Makefile 说明哪个文件与哪个文件相关。make 的作用是，在构建操作系统二进制码时，检查此刻需要哪个目标文件，而且对于每个文件，检查自从上次目标文件创建之后，是否有任何它依赖（代码和头文件）的文件已经被修改了。如果有，目标文件需要重新编译。在大型项目中，创建 Makefile 是一件容易出错的工作，所以出现了一些工具使该工作能够自动完成。</p>
<h3 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h3><h4 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h4><h4 id="1-进程模型"><a href="#1-进程模型" class="headerlink" title="1. 进程模型"></a>1. 进程模型</h4><p>在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。</p>
<p>由于 CPU 在各进程之间来回快速切换，所以每个进程执行其运算的速度是不确定的。而且当同一进程再次运行时，其运算速度通常也不可再现。所以，在对进程编程时决不能对时序做任何确定的假设。</p>
<h4 id="2-进程的创建"><a href="#2-进程的创建" class="headerlink" title="2. 进程的创建"></a>2. 进程的创建</h4><p>有 4 种主要事件导致进程的创建：</p>
<ul>
<li><p><strong>系统初始化</strong></p>
<blockquote>
<p>启动操作系统时，通常会创建若干个进程。其中有些是前台进程，也就是同用户（人类）交互并且替他们完成工作的那些进程。其他的是后台进程，这些进程与特定的用户没有关系，相反，却具有某些专门的功能。停留在后台处理诸如电子邮件、Web 页面、新闻、打印之类活动的进程称为守护进程</p>
</blockquote>
</li>
<li><p><strong>执行了正在运行的进程所调用的进程创建系统调用</strong></p>
<blockquote>
<p>一个正在运行的进程经常发出系统调用，以便创建一个或多个新进程协助其工作。在所要从事的工作可以容易地划分成若干相关的但没有相互作用的进程时，创建新的进程就特别有效果。</p>
</blockquote>
</li>
<li><p><strong>用户请求创建一个新进程</strong></p>
<blockquote>
<p>在交互式系统中，键入一个命令或者点（双）击一个图标就可以启动一个程序。这两个动作中的任何一个都会开始一个新的进程，并在其中运行所选择的程序。</p>
</blockquote>
</li>
<li><p><strong>一个批处理作业的初始化</strong></p>
<blockquote>
<p>最后一种创建进程的情形仅在大型机的批处理系统中应用。用户在这种系统中（可能是远程地）提交批处理作业。在操作系统认为有资源可运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。</p>
</blockquote>
</li>
</ul>
<p>在 UNIX 系统中，只有一个系统调用可以用来创建新进程：fork。在调用了 fork 后，这两个进程（父进程和子进程）拥有相同的存储映像、同样的环境字符串和同样的打开文件。</p>
<p>在 Windows 中，一个 Win32 函数调用 CreateProcess 既处理进程的创建，也负责把正确的程序装入新的进程。</p>
<p>在 UNIX 和 Windows 中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。</p>
<h4 id="3-进程的终止"><a href="#3-进程的终止" class="headerlink" title="3. 进程的终止"></a>3. 进程的终止</h4><p>进程在创建之后，它开始运行，完成其工作。但永恒是不存在的，进程也一样。迟早这个新的进程会终止，通常由下列条件引起：</p>
<ul>
<li><p><strong>正常退出（自愿的）</strong></p>
<blockquote>
<p>多数进程是由于完成了它们的工作而终止。在 UNIX 中该调用是 exit，而在 Windows 中，相关的调用是 ExitProcess 。</p>
</blockquote>
</li>
<li><p><strong>出错退出（自愿的）</strong></p>
<blockquote>
<p>进程终止的第二个原因是进程发现了严重错误。</p>
</blockquote>
</li>
<li><p><strong>严重错误（非自愿）</strong></p>
<blockquote>
<p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所致。</p>
</blockquote>
</li>
<li><p><strong>被其他进程杀死（非自愿）</strong></p>
<blockquote>
<p>第四种终止进程的原因是，某个进程执行一个系统调用通知操作系统杀死某个其他进程。在 UNIX 中，这个系统调用是 kill 。在 Win32 中对应的函数是 TerminateProcess 。</p>
</blockquote>
</li>
</ul>
<h4 id="4-进程的层次结构"><a href="#4-进程的层次结构" class="headerlink" title="4. 进程的层次结构"></a>4. 进程的层次结构</h4><p>某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。</p>
<p>在 UNIX 中，进程和它的所有子女以及后裔共同组成一个进程组。</p>
<p>在 Windows 中没有进程层次的概念，所有的进程都是地位相同的。惟一类似于进程层次的暗示是在创建进程的时侯，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。但是，它有权把这个令牌传送给某个其他进程，这样就不存在进程层次了。</p>
<h4 id="5-UNIX-启动时的初始化"><a href="#5-UNIX-启动时的初始化" class="headerlink" title="5. UNIX 启动时的初始化"></a>5. UNIX 启动时的初始化</h4><p>一个称为 init 的特殊进程出现在启动映像中。当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录。如果有一个用户登录成功，该登录进程就执行一个 shell 准备接收命令。所接收的这些命令会启动更多的进程，以此类推。这样，在整个系统中，所有的进程都属于以 init 为根的一棵树。</p>
<h4 id="6-进程的状态"><a href="#6-进程的状态" class="headerlink" title="6. 进程的状态"></a>6. 进程的状态</h4><p>进程存在三种状态：</p>
<ul>
<li>运行态（该时刻进程实际占用 CPU）。</li>
<li>就绪态（可运行，但因为其他进程正在运行而暂时停止）。</li>
<li>阻塞态（除非某种外部事件发生，否则进程不能运行）。</li>
</ul>
<p>状态间的转化关系为</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-3.png" alt="进程间状态转换"></p>
<h4 id="7-进程的实现"><a href="#7-进程的实现" class="headerlink" title="7. 进程的实现"></a>7. 进程的实现</h4><p>为了实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表。每个进程占用一个进程表项。（也可称为进程控制块。）该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。</p>
<h4 id="8-多道程序设计模型"><a href="#8-多道程序设计模型" class="headerlink" title="8. 多道程序设计模型"></a>8. 多道程序设计模型</h4><p>采用多道程序设计可以提高 CPU 的利用率。从概率的角度来看 CPU 的利用率。假设一个进程等待 I/O 操作的时间与其停留在内存中时间的比为 p。当内存中同时有 n 个进程时，则所有 n 个进程都在等待 I/O（此时 CPU 空转）的概率是 pⁿ 。CPU 的利用率由下面的公式给出：</p>
<blockquote>
<p>CPU 利用率 = 1-pⁿ</p>
</blockquote>
<h4 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h4><h4 id="1-线程的使用原因"><a href="#1-线程的使用原因" class="headerlink" title="1. 线程的使用原因"></a>1. 线程的使用原因</h4><p>人们需要多线程的主要原因是，在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。</p>
<p>第二个关于需要多线程的理由是，由于线程比进程更轻量级，所以它们比进程更容易（即更快）创建，也更容易撤销。在许多系统中，创建一个线程较创建一个进程要快 10 ～ 100 倍。</p>
<p>需要多线程的第三个原因涉及性能方面的讨论。若多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。</p>
<h4 id="2-线程模型"><a href="#2-线程模型" class="headerlink" title="2. 线程模型"></a>2. 线程模型</h4><p>进程拥有一个执行的线程，通常简写为线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。尽管线程必须在某个进程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。进程用于把资源集中到一起，而线程则是在 CPU 上被调度执行的实体。</p>
<p>线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。</p>
<h4 id="3-在用户空间中实现线程"><a href="#3-在用户空间中实现线程" class="headerlink" title="3. 在用户空间中实现线程"></a>3. 在用户空间中实现线程</h4><p>把整个线程包放在用户空间中，内核对线程包一无所知。从内核角度考虑，就是按正常的方式管理，即单线程进程。线程在一个运行时系统的顶部运行，这个运行时系统是一个管理线程的过程的集合。我们已经见过其中的四个过程：pthread_create ，pthread_exit ，pthread_join 和 pthread_yield 。不过，一般还会有更多的过程。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-4.png" alt="用户线程实现"></p>
<p>在用户空间管理线程时，每个进程需要有其专用的线程表，用来跟踪该进程中的线程。这些表和内核中的进程表类似。该线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样。</p>
<p><strong>优点</strong></p>
<ol>
<li><p>用户级线程包可以在不支持线程的操作系统上实现。</p>
</li>
<li><p>线程的切换可以在几条指令内完成。进行类似于这样的线程切换至少比陷入内核要快一个数量级（或许更多）。</p>
</li>
<li><p>保存线程状态的过程和调度程序都只是本地过程，所以启动它们比进行内核调用效率更高。另一方面，不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。</p>
</li>
<li><p>它允许每个进程有自己定制的调度算法。</p>
</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><p>第一个问题是如何实现阻塞系统调用。假设在还没有任何击键之前，一个线程读取键盘。让该线程实际进行该系统调用是不可接受的，因为这会停止所有的线程。</p>
</li>
<li><p>页面故障问题。如果有一个线程引起页面故障，内核由于甚至不知道有线程存在，通常会把整个进程阻塞直到磁盘 I/O 完成为止，尽管其他的线程是可以运行的。</p>
</li>
<li><p>如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃 CPU 。</p>
</li>
<li><p>通常在经常发生线程阻塞的应用中才希望使用多个线程。对于那些基本上是 CPU 密集型而且极少有阻塞的应用程序而言，没有很大的意义。</p>
</li>
</ol>
<h4 id="4-在内核中实现线程"><a href="#4-在内核中实现线程" class="headerlink" title="4. 在内核中实现线程"></a>4. 在内核中实现线程</h4><p>在内核中实现线程时，内核中有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。内核的线程表保存了每个线程的寄存器、状态和其他信息。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-5.png" alt="内核线程实现"></p>
<p>所有能够阻塞线程的调用都以系统调用的形式实现，这与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程（若有一个就绪线程）或者运行另一个进程中的线程。而在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的 CPU （或者没有可运行的线程存在了）为止。</p>
<h4 id="5-混合实现"><a href="#5-混合实现" class="headerlink" title="5. 混合实现"></a>5. 混合实现</h4><p>人们已经研究了各种试图将用户级线程的优点和内核级线程的优点结合起来的方法。一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-6.png" alt="混合线程实现"></p>
<p>采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。如同在没有多线程能力操作系统中某个进程中的用户级线程一样，可以创建、撤销和调度这些用户级线程。在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合。</p>
<h4 id="6-调度程序激活机制"><a href="#6-调度程序激活机制" class="headerlink" title="6. 调度程序激活机制"></a>6. 调度程序激活机制</h4><p>调度程序激活工作的目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。</p>
<p>使该机制工作的基本思路是，当内核了解到一个线程被阻塞之后，内核通知该进程的运行时系统，。内核通过在一个已知的起始地址启动运行时系统，从而发出了通知，这个机制称为上行调用。一旦如此激活，运行时系统就重新调度其线程。</p>
<p><strong>调度程序激活机制的一个目标是作为上行调用的信赖基础，这是一种违反分层次系统内在结构的概念。</strong></p>
<h4 id="7-弹出式线程"><a href="#7-弹出式线程" class="headerlink" title="7. 弹出式线程"></a>7. 弹出式线程</h4><p>一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程。</p>
<p>弹出式线程的关键好处是，由于这种线程相当新，没有历史这样，就有可能快速创建这类线程。对该新线程指定所要处理的消息。使用弹出式线程的结果是，消息到达与处理开始之间的时间非常短。</p>
<h4 id="三、-进程间通信"><a href="#三、-进程间通信" class="headerlink" title="三、 进程间通信"></a>三、 进程间通信</h4><p>进程间通信需要关注的三个问题：</p>
<ol>
<li><p>一个进程如何把信息传递给另一个。</p>
</li>
<li><p>如何确保两个或更多的进程在关键活动中不会出现交叉。</p>
</li>
<li><p>正确的顺序。</p>
</li>
</ol>
<h4 id="1-竞争条件"><a href="#1-竞争条件" class="headerlink" title="1. 竞争条件"></a>1. 竞争条件</h4><p>两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件。</p>
<h4 id="2-临界区"><a href="#2-临界区" class="headerlink" title="2. 临界区"></a>2. 临界区</h4><p>在某些时候进程可能需要访问共享内存或共享文件，或执行另外一些会导致竞争的操作。我们把对共享内存进行访问的程序片段称作临界区域或临界区。如果我们能够适当地安排，使得两个进程不可能同时处于临界区中，就能够避免竞争条件。</p>
<p>对于保证使用共享数据的并发进程能够正确和高效地进行协作，一个好的解决方案，需要满足以下 4 个条件：</p>
<ul>
<li>任何两个进程不能同时处于其临界区。</li>
<li>不应对 CPU 的速度和数量做任何假设。</li>
<li>临界区外运行的进程不得阻塞其他进程。</li>
<li>不得使进程无限期等待进入临界区。</li>
</ul>
<h4 id="3-忙等待的互斥"><a href="#3-忙等待的互斥" class="headerlink" title="3. 忙等待的互斥"></a>3. 忙等待的互斥</h4><h5 id="（1）-屏蔽中断"><a href="#（1）-屏蔽中断" class="headerlink" title="（1） 屏蔽中断"></a>（1） 屏蔽中断</h5><p>在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。屏蔽中断后，时钟中断也被屏蔽。CPU 只有发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断之后 CPU 将不会被切换到其他进程。于是，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不必担心其他进程介入。</p>
<p><strong>缺点：</strong></p>
<ol>
<li>若一个进程屏蔽中断后不再打开中断，整个系统可能会因此终止。</li>
<li>如果系统是多处理器（有两个或可能更多的处理器），则屏蔽中断仅仅对执行 disable 指令的那个 CPU 有效。其他 CPU 仍将继续运行，并可以访问共享内存。</li>
</ol>
<p>但是对内核来说，当它在更新变量或列表的几条指令期间将中断屏蔽是很方便的。</p>
<p>所以结论是：屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。</p>
<h5 id="（2）-锁变量"><a href="#（2）-锁变量" class="headerlink" title="（2） 锁变量"></a>（2） 锁变量</h5><p>设想有一个共享（锁）变量，其初始值为 0。当一个进程想进入其临界区时，它首先测试这把锁。如果该锁的值为 0，则该进程将其设置为 1 并进入临界区。若这把锁的值已经为 1，则该进程将等待直到其值变为 0。于是，0 就表示临界区内没有进程，1 表示已经有某个进程进入临界区。</p>
<p><strong>缺点：锁变量的读写不是原子操作，可能被其他进程中断</strong></p>
<p>假设一个进程读出锁变量的值并发现它为 0，而恰好在它将其值设置为 1 之前，另一个进程被调度运行，将该锁变量设置为 1。当第一个进程再次能运行时，它同样也将该锁设置为 1，则此时同时有两个进程进入临界区中。</p>
<h5 id="（3）严格轮换法"><a href="#（3）严格轮换法" class="headerlink" title="（3）严格轮换法"></a>（3）严格轮换法</h5><p>定义一个整型变量 turn ，初始值为 0，用于记录轮到哪个进程进入临界区，并检查或更新共享内存。开始时，进程 0 检查 turn ，发现其值为 0，于是进入临界区。进程 1 也发现其值为 0，所以在一个等待循环中不停地测试 turn ，看其值何时变为 1。连续测试一个变量直到某个值出现为止，称为忙等待。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-7.png" alt="严格轮换法"></p>
<p>只有在有理由认为等待时间是非常短的情形下，才使用忙等待。用于忙等待的锁，称为自旋锁（spin lock）。</p>
<p><strong>缺点：</strong></p>
<ol>
<li><p>采用忙等待的方式，会浪费 CPU 时间。</p>
</li>
<li><p>该方案要求两个进程严格地轮流进入它们的临界区，会造成一个临界区外运行的进程阻塞其他进程的情况。</p>
</li>
</ol>
<h5 id="（4）Peterson-解法"><a href="#（4）Peterson-解法" class="headerlink" title="（4）Peterson 解法"></a>（4）Peterson 解法</h5><p>在使用共享变量（即进入其临界区）之前，各个进程使用其进程号 0 或 1 作为参数来调用 enter_region 。该调用在需要时将使进程等待，直到能安全地进入临界区。在完成对共享变量的操作之后，进程将调用 leave_region ，表示操作已完成，若其他的进程希望进入临界区，则现在就可以进入。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-8.png" alt="Peterson 解法"></p>
<h5 id="（5）TSL-指令"><a href="#（5）TSL-指令" class="headerlink" title="（5）TSL 指令"></a>（5）TSL 指令</h5><p>TSL 指令是硬件支持的一种方案，称为测试并加锁，它将一个内存字 lock 读到寄存器 RX 中，然后在该内存地址上存一个非零值。</p>
<p>读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字。执行 TSL 指令的 CPU 将锁住内存总线，以禁止其他 CPU 在本指令结束之前访问内存。因此不会出现前面第二种方法锁变量的问题。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-9.png" alt="TSL 指令"></p>
<p>为了使用 TSL 指令，要使用一个共享变量 lock 来协调对共享内存的访问。当 lock 为 0 时，任何进程都可以使用 TSL 指令将其设置为 1，并读写共享内存。当操作结束时，进程用一条普通的 move 指令将 lock 的值重新设置为 0。</p>
<p>一个可替代 TSL 的指令是 XCHG ，它原子性地交换了两个位置的内容，它本质上与 TSL 的解决办法一样。所有的 Intel x86 CPU 在低层同步中使用 XCHG 指令。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-10.png" alt="XCHG 指令"></p>
<p><strong>缺点：</strong></p>
<ol>
<li>采用忙等待的方式，会浪费 CPU 时间。</li>
</ol>
<h4 id="4-睡眠与唤醒"><a href="#4-睡眠与唤醒" class="headerlink" title="4. 睡眠与唤醒"></a>4. 睡眠与唤醒</h4><p>Peterson 解法和 TSL 或 XCHG 解法都是正确的，但它们都有忙等待的缺点。这种方法不仅浪费了 CPU 时间，而且还可能引起预想不到的结果。</p>
<p>我们可以使用睡眠与唤醒的机制，使它们在无法进入临界区时将阻塞，而不是忙等待。</p>
<p>最简单的是 sleep 和 wakeup 。 sleep 是一个将引起调用进程阻塞的系统调用，即被挂起，直到另外一个进程将其唤醒。wakeup 调用有一个参数，即要被唤醒的进程。</p>
<p><strong>缺点：</strong></p>
<p>参考生产者-消费者问题，发给一个（尚）未睡眠进程的 wakeup 信号会出现丢失，从而出现生产者和消费者同时睡眠的情况。</p>
<p>一种快速的弥补方法是修改规则，加上一个唤醒等待位。当一个 wakeup 信号发送给一个清醒的进程信号时，将该位置 1。随后，当该进程要睡眠时，如果唤醒等待位为 1，则将该位清除，而该进程仍然保持清醒。但原则上讲，这并没有从根本上解决问题。</p>
<h4 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5. 信号量"></a>5. 信号量</h4><p>信号量是一个整型变量用来累计唤醒次数，供以后使用。一个信号量的取值可以为 0（表示没有保存下来的唤醒操作）或者为正值（表示有一个或多个唤醒操作）。</p>
<p>对信号量一共有两种操作：down 和 up （分别为一般化后的 sleep 和 wakeup ）。</p>
<p>对一信号量执行 down 操作，则是检查其值是否大于 0。若该值大于 0，则将其值减 1（即用掉一个保存的唤醒信号）并继续；若该值为 0，则进程将睡眠，而且此时 down 操作并未结束。</p>
<p>对一信号量执行 up 操作，会对信号量的值增 1。如果一个或多个进程在该信号量上睡眠，信号量的值仍旧是 0，但在其上睡眠的进程会被唤醒一个。</p>
<p>检查数值、修改变量值以及可能发生的睡眠和唤醒操作均作为一个单一的、不可分割的原子操作完成。所谓原子操作，是指一组相关联的操作要么都不间断地执行，要么都不执行。</p>
<h4 id="6-互斥量"><a href="#6-互斥量" class="headerlink" title="6. 互斥量"></a>6. 互斥量</h4><p>如果不需要信号量的计数能力，有时可以使用信号量的一个简化版本，称为互斥量（mutex）。互斥量仅仅适用于管理共享资源或一小段代码。由于互斥量在实现时既容易又有效，这使得互斥量在实现用户空间线程包时非常有用。</p>
<p>互斥量是一个可以处于两态之一的变量：解锁和加锁。当一个线程（或进程）需要访问临界区时，它调用 mutex_lock 。如果该互斥量当前是解锁的（即临界区可用），此调用成功，调用线程可以自由进入该临界区。另一方面，如果该互斥量已经加锁，调用线程被阻塞，直到在临界区中的线程完成并调用 mutex_unlock 。如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-11.png" alt="互斥量"></p>
<p>enter_region 和 mutex_lock 的代码很相似，但有一个关键的区别。</p>
<p>当 enter_region 进入临界区失败时，它始终重复测试锁（忙等待）。实际上，由于时钟超时的作用，会调度其他进程运行。这样迟早拥有锁的进程会进入运行并释放锁。</p>
<p>在（用户）线程中，情形有所不同，因为没有时钟停止运行时间过长的线程。结果是通过忙等待的方式来试图获得锁的线程将永远循环下去，决不会得到锁，因为这个运行的线程不会让其他线程运行从而释放锁。因此当 mutex_lock 取锁失败时，它调用 thread_yield 将 CPU 放弃给另一个线程。这样，就没有忙等待。在该线程下次运行时，它再一次对锁进行测试。</p>
<h4 id="7-条件变量"><a href="#7-条件变量" class="headerlink" title="7. 条件变量"></a>7. 条件变量</h4><p>条件变量允许线程由于一些未达到的条件而阻塞。</p>
<p>与条件变量相关的最重要的两个操作是 pthread_cond_wait 和 pthread_cond_signal 。前者阻塞调用线程直到另一其他线程向它发信号（使用后一个调用）。</p>
<p>条件变量（不像信号量）不会存在内存中。如果将一个信号量传递给一个没有线程在等待的条件变量，那么这个信号就会丢失。</p>
<h4 id="8-管程"><a href="#8-管程" class="headerlink" title="8. 管程"></a>8. 管程</h4><p>管程是一种高级同步原语，管程有一个很重要的特性，即任一时刻管程中只能有一个活跃进程，这一特性使管程能有效地完成互斥。</p>
<p>当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果</p>
<p>管程提供了一种实现互斥的简便途径，通过临界区互斥的自动化，管程比信号量更容易保证并行编程的正确性。</p>
<h4 id="9-消息传递"><a href="#9-消息传递" class="headerlink" title="9. 消息传递"></a>9. 消息传递</h4><p>这种进程间通信的方法使用两条原语 send 和 receive ，它们像信号量而不像管程，是系统调用而不是语言成分。</p>
<p>前一个调用向一个给定的目标发送一条消息，后一个调用从一个给定的源（或者是任意源，如果接收者不介意的话）接收一条消息。如果没有消息可用，则接收者可能被阻塞，直到一条消息到达，或者，带着一个错误码立即返回。</p>
<h4 id="10-屏障"><a href="#10-屏障" class="headerlink" title="10. 屏障"></a>10. 屏障</h4><p>在有些应用中划分了若干阶段，并且规定，除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段。可以通过在每个阶段的结尾安置屏障来实现这种行为。当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏障为止。</p>
<h4 id="四、调度"><a href="#四、调度" class="headerlink" title="四、调度"></a>四、调度</h4><p>当计算机系统是多道程序设计系统时，通常就会有多个进程或线程同时竞争 CPU。只要有两个或更多的进程处于就绪状态，这种情形就会发生。如果只有一个 CPU 可用，那么就必须选择下一个要运行的进程。在操作系统中，完成选择工作的这一部分称为调度程序，该程序使用的算法称为调度算法。</p>
<h4 id="1-何时调度"><a href="#1-何时调度" class="headerlink" title="1. 何时调度"></a>1. 何时调度</h4><ol>
<li><p>在创建一个新进程之后，需要决定是运行父进程还是运行子进程。</p>
</li>
<li><p>在一个进程退出时必须做出调度决策。</p>
</li>
<li><p>当一个进程阻塞在 I/O 和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。</p>
</li>
<li><p>第四，在一个 I/O 中断发生时，必须做出调度决策。</p>
</li>
</ol>
<h4 id="2-调度算法分类"><a href="#2-调度算法分类" class="headerlink" title="2. 调度算法分类"></a>2. 调度算法分类</h4><ol>
<li>批处理。</li>
<li>交互式。</li>
<li>实时。</li>
</ol>
<h4 id="3-调度算法的目标"><a href="#3-调度算法的目标" class="headerlink" title="3. 调度算法的目标"></a>3. 调度算法的目标</h4><p>为了设计调度算法，有必要考虑什么是一个好的调度算法。某些目标取决于环境（批处理、交互式或实时），但是还有一些目标是适用于所有情形的。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-12.png" alt="调度算法的目标"></p>
<h4 id="4-批处理系统中的调度"><a href="#4-批处理系统中的调度" class="headerlink" title="4. 批处理系统中的调度"></a>4. 批处理系统中的调度</h4><h5 id="（1）先来先服务"><a href="#（1）先来先服务" class="headerlink" title="（1）先来先服务"></a>（1）先来先服务</h5><p>在所有调度算法中，最简单的是非抢占式的先来先服务算法。使用该算法，进程按照它们请求 CPU 的顺序使用 CPU 。</p>
<p><strong>优点：</strong></p>
<p>这个算法的主要优点是易于理解并且便于在程序中运用。</p>
<p><strong>缺点：</strong></p>
<p>平均等待时间过长。</p>
<h5 id="（2）最短作业优先"><a href="#（2）最短作业优先" class="headerlink" title="（2）最短作业优先"></a>（2）最短作业优先</h5><p>当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短作业优先算法。</p>
<p>只有在所有的作业都可同时运行的情形下，最短作业优先算法才是最优化的。</p>
<h5 id="（3）最短剩余时间优先"><a href="#（3）最短剩余时间优先" class="headerlink" title="（3）最短剩余时间优先"></a>（3）最短剩余时间优先</h5><p>最短作业优先的抢占式版本是最短剩余时间优先算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。</p>
<h4 id="5-交互式系统中的调度"><a href="#5-交互式系统中的调度" class="headerlink" title="5. 交互式系统中的调度"></a>5. 交互式系统中的调度</h4><h5 id="（1）轮转调度"><a href="#（1）轮转调度" class="headerlink" title="（1）轮转调度"></a>（1）轮转调度</h5><p>一种最古老、最简单、最公平且使用最广的算法是轮转调度。每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行。如果在时间片结束时该进程还在运行，则将剥夺 CPU 并分配给另一个进程。如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。</p>
<p>需要注意的是，时间片设得太短会导致过多的进程切换，降低了 CPU 效率；而设得太长又可能引起对短的交互请求的响应时间变长。将时间片设为 20ms ～ 50 ms 通常是一个比较合理的折中。</p>
<h4 id="（2）优先级调度"><a href="#（2）优先级调度" class="headerlink" title="（2）优先级调度"></a>（2）优先级调度</h4><p>每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行。为了防止高优先级进程无休止地运行下去，调度程序可以在每个时钟滴答（即每个时钟中断）降低当前进程的优先级。如果这个动作导致该进程的优先级低于次高优先级的进程，则进行进程切换。</p>
<h4 id="（3）多级队列"><a href="#（3）多级队列" class="headerlink" title="（3）多级队列"></a>（3）多级队列</h4><p>将一组进程按优先级分成若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用其他调度方式。</p>
<h4 id="（4）最短进程优先"><a href="#（4）最短进程优先" class="headerlink" title="（4）最短进程优先"></a>（4）最短进程优先</h4><p>对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，所以如果能够把它用于交互进程，那将是非常好的。</p>
<h4 id="（5）保证调度"><a href="#（5）保证调度" class="headerlink" title="（5）保证调度"></a>（5）保证调度</h4><p>向用户作出明确的性能保证，然后去实现它。</p>
<p>一种很实际并很容易实现的保证是：若用户工作时有 n 个用户登录，则用户将获得 CPU 处理能力的 1/n 。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。看上去足够公平了。</p>
<h4 id="（6）彩票调度"><a href="#（6）彩票调度" class="headerlink" title="（6）彩票调度"></a>（6）彩票调度</h4><p>向进程提供各种系统资源（如 CPU 时间）的彩票。一旦需要做出一项调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源。在应用到 CPU 调度时，系统可以掌握每秒钟 50 次的一种彩票，作为奖励每个获奖者可以得到 20 ms 的 CPU 时间。</p>
<h4 id="（7）公平分享调度"><a href="#（7）公平分享调度" class="headerlink" title="（7）公平分享调度"></a>（7）公平分享调度</h4><p>到现在为止，我们假设被调度的都是各个进程自身，并不关注其所有者是谁。</p>
<p>为了避免这种情形，某些系统在调度处理之前考虑谁拥有进程这一因素。在这种模式中，每个用户分配到 CPU 时间的一部分，而调度程序以一种强制的方式选择进程。这样，如果两个用户都得到获得 50% CPU 时间的保证，那么无论一个用户有多少进程存在，每个用户都会得到应有的 CPU 份额。</p>
<h4 id="6-策略和机制"><a href="#6-策略和机制" class="headerlink" title="6. 策略和机制"></a>6. 策略和机制</h4><p>我们讨论的调度算法中没有一个算法从用户进程接收有关的调度决策信息，这就导致了调度程序很少能够做出最优的选择。</p>
<p>解决问题的方法是将调度机制与调度策略分离，也就是将调度算法以某种形式参数化，而参数可以由用户进程填写。</p>
<p>在这里，调度机制位于内核，而调度策略则由用户进程决定。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备-js</title>
    <url>/2022/11/21/20221121-interview-js/</url>
    <content><![CDATA[<p>记录工作中想到的面试应该会的问题。</p>
<span id="more"></span>

<h2 id="2-JS-基础和-ES6-相关知识"><a href="#2-JS-基础和-ES6-相关知识" class="headerlink" title="2.JS 基础和 ES6 相关知识"></a>2.JS 基础和 ES6 相关知识</h2><h3 id="2-1-闭包"><a href="#2-1-闭包" class="headerlink" title="2.1 闭包"></a>2.1 闭包</h3><ul>
<li><p>闭包是指有权访问另外一个函数作用域中的变量的函数</p>
</li>
<li><p>闭包的特性：</p>
<ul>
<li>函数内再嵌套函数</li>
<li>内部函数可以引用外层的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
</li>
<li><p>说说你对闭包的理解</p>
<ul>
<li>使用闭包主要是为了设计私有的方法和变量。</li>
<li>闭包的优点是可以避免全局变量的污染。</li>
<li>缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</li>
</ul>
</li>
<li><p>闭包的使用场景</p>
<ul>
<li><p>防抖、节流函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防抖</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait, immediate</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">const</span> immediates = immediate || <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">const</span> later = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (!immediates) fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> call = immediates &amp;&amp; !timeout;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    <span class="keyword">if</span> (call) <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(later, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">b, c</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b, c);</span><br><span class="line">  <span class="keyword">return</span> b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> de = <span class="title function_">debounce</span>(a, <span class="number">3</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">de</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="keyword">return</span>;</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="2-2-内存泄漏"><a href="#2-2-内存泄漏" class="headerlink" title="2.2 内存泄漏"></a>2.2 内存泄漏</h3><ul>
<li><p>概念</p>
<p>当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p>
</li>
<li><p>造成内存泄露的原因：</p>
<ul>
<li>意外的全局变量(在函数内部没有使用 var 进行声明的变量)</li>
<li>console.log</li>
<li>闭包</li>
<li>对象的循环引用</li>
<li>未清除的计时器</li>
<li>DOM 泄露(获取到 DOM 节点之后，将 DOM 节点删除，但是没有手动释放变量，拿对应的 DOM 节点在变量中还可以访问到，就会造成泄露)</li>
</ul>
</li>
<li><p>例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DOM泄露</span></span><br><span class="line"><span class="comment">//这段代码会导致内存泄露</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">  el.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(el.<span class="property">id</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法为</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> id = el.<span class="property">id</span>; <span class="comment">//解除循环引用</span></span><br><span class="line">  el.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(id);</span><br><span class="line">  &#125;;</span><br><span class="line">  el = <span class="literal">null</span>; <span class="comment">// 将闭包引用的外部函数中活动对象清除</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 闭包导致的内存泄漏</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    sum++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(sum);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">fn1 = <span class="title function_">fn</span>();</span><br><span class="line"><span class="title function_">fn1</span>(); <span class="comment">//1</span></span><br><span class="line"><span class="title function_">fn1</span>(); <span class="comment">//2</span></span><br><span class="line"><span class="title function_">fn1</span>(); <span class="comment">//3</span></span><br><span class="line"><span class="comment">// 这之前，如果fn1一直存在，闭包中的sum就一直不会被内存回收，就造成了内存泄露</span></span><br><span class="line">fn1 = <span class="literal">null</span>; <span class="comment">// fn1的引用fn被手动释放了 这样就被回收了</span></span><br><span class="line">fn1 = <span class="title function_">fn</span>(); <span class="comment">//num再次归零</span></span><br><span class="line"><span class="title function_">fn1</span>(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-3-事件循环机制—–宏任务（macrotask-）和微任务（microtask-）"><a href="#2-3-事件循环机制—–宏任务（macrotask-）和微任务（microtask-）" class="headerlink" title="2.3 事件循环机制—–宏任务（macrotask ）和微任务（microtask ）"></a>2.3 事件循环机制—–宏任务（macrotask ）和微任务（microtask ）</h3><p><strong>下面的重点，只在 node 版本 11 之前有体现！！！！！</strong></p>
<p>**在 node 11 版本中，node 下 Event Loop 已经与浏览器趋于相同。<br>在 node 11 版本中，node 下 Event Loop 已经与浏览器趋于相同。<br>在 node 11 版本中，node 下 Event Loop 已经与浏览器趋于相同。 **</p>
<p><strong>重点来啦：</strong>node 环境和浏览器环境对于微任务和宏任务的执行顺序是不一样的，主要体现在：</p>
<ul>
<li>node 环境中，微任务是事件循环的各个阶段之间执行。</li>
<li>浏览器环境中，微任务在事件循环的宏任务执行完成后执行。</li>
</ul>
<p><img src="https://dqtwdd.top/cdn/img/EventLoop.png" alt="EventLoop"></p>
<p>来一个挺经典的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 浏览器 timer1 promise1 timer2 promise2</span></span><br><span class="line"><span class="comment">// node  timer1 timer2 promise1 promise2</span></span><br></pre></td></tr></table></figure>

<p>可以看到以上代码在浏览器中和在 node 环境中的执行结果是不同的，具体用两张动图说明下原因：</p>
<p><img src="https://dqtwdd.top/cdn/img/Browser.gif" alt="Browser"></p>
<p><img src="https://dqtwdd.top/cdn/img/Node.gif" alt="Node"></p>
<ul>
<li><p>macrotask 和 microtask 表示异步任务的两种分类。</p>
<p>在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。</p>
</li>
<li><p>宏任务</p>
<table>
<thead>
<tr>
<th>#</th>
<th>浏览器</th>
<th>Node</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>setInterval</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>setImmediate</td>
<td>x</td>
<td>√</td>
</tr>
<tr>
<td>requestAnimationFrame</td>
<td>√</td>
<td>x</td>
</tr>
</tbody></table>
</li>
<li><p>微任务</p>
<table>
<thead>
<tr>
<th>#</th>
<th>浏览器</th>
<th>Node</th>
</tr>
</thead>
<tbody><tr>
<td>process.nextTick</td>
<td>x</td>
<td>√</td>
</tr>
<tr>
<td>MutationObserver</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>Promise.then catch finally</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主线程直接执行</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="comment">//丢到宏事件队列中</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//微事件1</span></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//主线程直接执行</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//微事件2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//丢到宏事件队列中</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;12&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 打印结果：1 7 6 8 2 4 3 5 9 11 10 12</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-call、apply-和-bind"><a href="#2-4-call、apply-和-bind" class="headerlink" title="2.4 call、apply 和 bind"></a>2.4 call、apply 和 bind</h3><ul>
<li><p>相同点</p>
</li>
<li><p>都改变了 this 的指向</p>
</li>
<li><p>区别</p>
<ul>
<li><p>call/apply 返回的是函数执行的结果，bind 返回的是函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">personInit</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">getInfo</span>: <span class="keyword">function</span> (<span class="params">nameParam, ageParam</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="string">&#x27; &#x27;</span>, <span class="variable language_">this</span>.<span class="property">age</span>, <span class="string">&#x27; &#x27;</span>, nameParam, <span class="string">&#x27; &#x27;</span>, ageParam);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  person.<span class="property">name</span> = name;</span><br><span class="line">  person.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> father = <span class="keyword">new</span> <span class="title function_">personInit</span>(<span class="string">&#x27;小王&#x27;</span>, <span class="number">28</span>);</span><br><span class="line"><span class="keyword">let</span> daughter = <span class="keyword">new</span> <span class="title function_">personInit</span>(<span class="string">&#x27;小小王&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">daughter.<span class="title function_">getInfo</span>(); <span class="comment">// &#x27;小小王&#x27; 2</span></span><br><span class="line">daughter.<span class="property">getInfo</span>.<span class="title function_">apply</span>(father); <span class="comment">// &#x27;小王&#x27; 28</span></span><br><span class="line">daughter.<span class="property">getInfo</span>.<span class="title function_">bind</span>(father)(); <span class="comment">// &#x27;小王&#x27; 28</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>call、bind 传递第二个参数时可以直接传入，用’,’隔开，apply 传入第二个参数时必须传入[]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">daughter.<span class="property">getInfo</span>.<span class="title function_">call</span>(father, <span class="string">&#x27;小董&#x27;</span>, <span class="number">27</span>); <span class="comment">// 小王   28   小董   27</span></span><br><span class="line">daughter.<span class="property">getInfo</span>.<span class="title function_">apply</span>(father, [<span class="string">&#x27;小董&#x27;</span>, <span class="number">27</span>]); <span class="comment">// 小王   28   小董   27</span></span><br><span class="line">daughter.<span class="property">getInfo</span>.<span class="title function_">bind</span>(father, <span class="string">&#x27;小董&#x27;</span>, <span class="number">27</span>)(); <span class="comment">// 小王   28   小董   27</span></span><br><span class="line">daughter.<span class="property">getInfo</span>.<span class="title function_">bind</span>(father, [<span class="string">&#x27;小董&#x27;</span>, <span class="number">27</span>])(); <span class="comment">// 小王   28   [&quot;小董&quot;, 27]  undefined</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="2-5-原型与原型链"><a href="#2-5-原型与原型链" class="headerlink" title="2.5 原型与原型链"></a>2.5 原型与原型链</h3><p>提一个方法：instanceof</p>
<p>语法：<code>object instanceof constructor</code></p>
<p>作用： <code>instanceof</code> 运算符用来检测 <code>constructor.prototype </code>是否存在于参数 <code>object</code> 的原型链上。</p>
<ul>
<li><p>原型</p>
<ul>
<li><p>定义</p>
<p><strong>每一个 javascript 对象(除 null 外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。</strong></p>
<p><strong>原型是一个</strong> <strong><em>对象</em></strong>。</p>
<ul>
<li><p>Function =&gt; prototype</p>
<p>Js 中每个函数都有一个 prototype 属性，这个属性指向函数的<strong>原型</strong> <strong><em>对象</em></strong>。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">personInit</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">personInit.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;小王&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title function_">personInit</span>();</span><br><span class="line">person.<span class="property">name</span>; <span class="comment">// &#x27;小王&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Object =&gt; __proto__</p>
<p>是每个对象(除 null 外)都会有的属性，叫做__proto__，这个属性会指向该对象的<strong>原型</strong> <strong><em>对象</em></strong>。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">personInit</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title function_">personInit</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://dqtwdd.top/cdn/img/Object.png" alt="Object"></p>
<p> Object 的 __proto__和 Function 的 prototype 都指向原型对象。</p>
<ul>
<li><p>constructor</p>
<p>每个原型都有一个 constructor 属性，指向该关联的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">__proto__</span> == <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://dqtwdd.top/cdn/img/Constructor.png" alt="Constructor"></p>
</li>
</ul>
<p><img src="https://dqtwdd.top/cdn/img/ProtoOfProto.png" alt="ProtoOfProto"></p>
<p>Object 的 __proto__ 和 Function 的 prototype 都指向原型对象，修改原型对象参数时，原型对象的构造函数构造出来的对象也会改变。</p>
<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">name</span> = <span class="string">&#x27;小王&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, a.<span class="property">name</span>); <span class="comment">// 小王</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>原型链</p>
<ul>
<li><p>概念</p>
<p>每个函数都有一个 prototype 属性，每个函数构造出来的实例都有一个__proto__ 属性，他们都指向构造函数的原型对象，对应的，构造函数的原型对象也有自己的__proto__属性，指向自己的原型，这就是原型链。</p>
<p><img src="https://dqtwdd.top/cdn/img/ProtoChain.png" alt="ProtoChain"></p>
<p><img src="https://dqtwdd.top/cdn/img/proto.png" alt="proto"></p>
<p>从上面的图片不难看出，Person 和 Object 这个两个构造函数都是 Object.prototype 的儿子。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-6-继承"><a href="#2-6-继承" class="headerlink" title="2.6 继承"></a>2.6 继承</h3><p>继承就是让子类继承父类的属性。</p>
<p>类是什么，类是对象的抽象（我觉得也是对象）。</p>
<p>继承有六种，分别是 原型链继承，构造继承，实例继承，拷贝继承，组合继承，寄生组合继承。</p>
<p>我们先构造一个父构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name || <span class="string">&#x27;姓名&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age || <span class="number">999</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实验一下，构造一个实例</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Wdd</span> = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小王&#x27;</span>, <span class="number">27</span>);</span><br><span class="line"><span class="title class_">Wdd</span>.<span class="title function_">getName</span>(); <span class="comment">// &#x27;小王&#x27;</span></span><br><span class="line"><span class="title class_">Wdd</span>.<span class="title function_">getAge</span>(); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-1-原型链继承"><a href="#2-6-1-原型链继承" class="headerlink" title="2.6.1 原型链继承"></a>2.6.1 原型链继承</h4><ul>
<li>定义：将父类的实例作为子类的原型 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Black</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">skin</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;R&amp;B&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Black</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> black = <span class="keyword">new</span> <span class="title class_">Black</span>(); <span class="comment">// 可以看见，创建子类的实例时，无法向父类的构造函数传参。</span></span><br><span class="line">black.<span class="title function_">getName</span>(); <span class="comment">// &#x27;姓名&#x27;</span></span><br><span class="line">black.<span class="title function_">getAge</span>(); <span class="comment">// &#x27;999&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(black.<span class="property">skin</span>); <span class="comment">//&#x27;black&#x27;</span></span><br><span class="line">black.<span class="title function_">hobby</span>(); <span class="comment">// &#x27;R&amp;B&#x27;</span></span><br><span class="line">black <span class="keyword">instanceof</span> <span class="title class_">Black</span>; <span class="comment">// true</span></span><br><span class="line">black <span class="keyword">instanceof</span> <span class="title class_">Person</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>可以看见 Black 的实例 black 继承了所有来自于父类的的属性。</p>
<ul>
<li>特点<ul>
<li>简单，容易实现。</li>
<li>原型对象的改变能影响所有后代实例。</li>
</ul>
</li>
<li>缺点<ul>
<li>无法实现多继承。子类的构造函数只能继承一个父类的属性。</li>
<li>创建子类的实例时，无法向父类的构造函数传参。</li>
<li>来自原型对象的所有属性被所有后代实例共享。</li>
</ul>
</li>
</ul>
<h4 id="2-6-2-构造继承"><a href="#2-6-2-构造继承" class="headerlink" title="2.6.2 构造继承"></a>2.6.2 构造继承</h4><ul>
<li><p>定义：改变父类构造函数的 this 指向，使子类获得父类所有的属性和方法。</p>
<p>区别于拷贝继承的是，构造继承只让子类获取了父类的属性和方法，没有继承父类原型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Black</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">skin</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;R&amp;B&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> black = <span class="keyword">new</span> <span class="title class_">Black</span>(<span class="string">&#x27;James&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">black.<span class="title function_">getName</span>(); <span class="comment">// &#x27;James&#x27;</span></span><br><span class="line">black.<span class="title function_">getAge</span>(); <span class="comment">// Uncaught TypeError: black.getAge is not a function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(black); <span class="comment">//&#x27;black&#x27;</span></span><br><span class="line">black.<span class="title function_">hobby</span>(); <span class="comment">// &#x27;R&amp;B&#x27;</span></span><br><span class="line">black <span class="keyword">instanceof</span> <span class="title class_">Black</span>; <span class="comment">// true</span></span><br><span class="line">black <span class="keyword">instanceof</span> <span class="title class_">Person</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特点</p>
<ul>
<li>可以在子类创建时使用父类构造函数传递参数</li>
<li>可以实现多继承</li>
<li>子类的实例就是子类的实例，不是父类的实例。</li>
<li>父类构造函数原型的改变不会影响子类。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>父类原型上的的属性和方法不会继承。</li>
<li>无法实现多级集成：比如 祖父类=》父类 使用的是原型链继承，那么父类可以使用祖父的所有属性和方法，子类=》父类使用构造继承的话 子类是无法使用祖父类的方法和属性的。每一个子类如果想要使用祖父类和父类的话需要分别进行。</li>
</ul>
</li>
</ul>
<h4 id="2-6-3-实例继承（寄生继承）"><a href="#2-6-3-实例继承（寄生继承）" class="headerlink" title="2.6.3 实例继承（寄生继承）"></a>2.6.3 实例继承（寄生继承）</h4><ul>
<li><p>定义：使用父类构造函数创建实例，为实例添加新特性后，作为子类实例返回。</p>
<p>这个就很神奇，就如同它的名字一样，通过子类构造函数创造的实例却不是子类的实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Black</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">  instance.<span class="property">skin</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">  instance.<span class="property">hobby</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;R&amp;B&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> black = <span class="keyword">new</span> <span class="title class_">Black</span>();</span><br><span class="line">black.<span class="title function_">getName</span>(); <span class="comment">// &#x27;James&#x27;</span></span><br><span class="line">black.<span class="title function_">getAge</span>(); <span class="comment">// Uncaught TypeError: black.getAge is not a function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(black); <span class="comment">//&#x27;black&#x27;</span></span><br><span class="line">black.<span class="title function_">hobby</span>(); <span class="comment">// &#x27;R&amp;B&#x27;</span></span><br><span class="line">black <span class="keyword">instanceof</span> <span class="title class_">Black</span>; <span class="comment">// false</span></span><br><span class="line">black <span class="keyword">instanceof</span> <span class="title class_">Person</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特点</p>
<ul>
<li>创建的实例时父类的实例，不是子类的实例。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>不支持多继承。</li>
</ul>
</li>
</ul>
<h4 id="2-6-4-拷贝继承"><a href="#2-6-4-拷贝继承" class="headerlink" title="2.6.4 拷贝继承"></a>2.6.4 拷贝继承</h4><ul>
<li><p>定义：创建父类的实例后，遍历父级实例，将父级实例原型上的方法赋给子类构造函数的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Black</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> instance) &#123;</span><br><span class="line">    <span class="title class_">Black</span>.<span class="property"><span class="keyword">prototype</span></span>[key] = instance[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">skin</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;R&amp;B&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> black = <span class="keyword">new</span> <span class="title class_">Black</span>();</span><br><span class="line">black.<span class="title function_">getName</span>(); <span class="comment">// &#x27;姓名&#x27;</span></span><br><span class="line">black.<span class="title function_">getAge</span>(); <span class="comment">// &#x27;999&#x27;</span></span><br><span class="line">black.<span class="title function_">hobby</span>(); <span class="comment">// &#x27;R&amp;B&#x27;</span></span><br><span class="line">black <span class="keyword">instanceof</span> <span class="title class_">Black</span>; <span class="comment">// true</span></span><br><span class="line">black <span class="keyword">instanceof</span> <span class="title class_">Person</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特点</p>
<ul>
<li>支持多继承。</li>
<li>可以继承父类的原型方法，但是不是父类的实例。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>执行效率低（因为需要遍历拷贝父类的每一条属性）。</li>
<li>无法复制不可遍历属性。</li>
</ul>
</li>
</ul>
<h4 id="2-6-5-组合继承"><a href="#2-6-5-组合继承" class="headerlink" title="2.6.5 组合继承"></a>2.6.5 组合继承</h4><ul>
<li><p>定义：组合继承即组合了原型链继承和构造继承，使子类即可以向父类构造函数传递参数，又可以能继承父类原型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Black</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">skin</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;R&amp;B&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Black</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Black</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Black</span>; <span class="comment">// 修改子类原型构造函数</span></span><br><span class="line"><span class="comment">// 子类原型的构造函数不影响子类创建实例，但是我们一般会修正子类原型的构造函数使其指向本身。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = <span class="keyword">new</span> <span class="title class_">Black</span>(<span class="string">&#x27;Jone&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">black.<span class="title function_">getName</span>(); <span class="comment">// &#x27;Jone&#x27;</span></span><br><span class="line">black.<span class="title function_">getAge</span>(); <span class="comment">// &#x27;5&#x27;</span></span><br><span class="line">black.<span class="title function_">hobby</span>(); <span class="comment">// &#x27;R&amp;B&#x27;</span></span><br><span class="line">black <span class="keyword">instanceof</span> <span class="title class_">Black</span>; <span class="comment">// true</span></span><br><span class="line">black <span class="keyword">instanceof</span> <span class="title class_">Person</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特点</p>
<ul>
<li>子类即可以向父类构造函数传递参数，又可以能继承父类原型的属性和方法。</li>
<li>既是子类实例，又是父类实例。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>调用了两次父类的构造函数，创建了两次父类的实例。</li>
</ul>
</li>
</ul>
<h4 id="2-6-6-寄生组合继承"><a href="#2-6-6-寄生组合继承" class="headerlink" title="2.6.6 寄生组合继承"></a>2.6.6 寄生组合继承</h4><ul>
<li><p>定义：使用构造继承使子类可以使用父类的属性和方法，通过继承方法创建一个父类构造函数的副本使子类的原型指向这个副本，以此访问父类的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Black</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">skin</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;R&amp;B&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inherit</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line">  <span class="comment">//在new inheritFn 的时候将构造函数指向子类</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inheritFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">constructor</span> = subType;</span><br><span class="line">  &#125;</span><br><span class="line">  inheritFn.<span class="property"><span class="keyword">prototype</span></span> = superType.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="comment">//将子类的原型指向父类原型的一个副本</span></span><br><span class="line">  subType.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">inheritFn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inherit</span>(<span class="title class_">Black</span>, <span class="title class_">Person</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = <span class="keyword">new</span> <span class="title class_">Black</span>(<span class="string">&#x27;Jone&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">black.<span class="title function_">getName</span>(); <span class="comment">// &#x27;Jone&#x27;</span></span><br><span class="line">black.<span class="title function_">getAge</span>(); <span class="comment">// &#x27;5&#x27;</span></span><br><span class="line">black.<span class="title function_">hobby</span>(); <span class="comment">// &#x27;R&amp;B&#x27;</span></span><br><span class="line">black <span class="keyword">instanceof</span> <span class="title class_">Black</span>; <span class="comment">// true</span></span><br><span class="line">black <span class="keyword">instanceof</span> <span class="title class_">Person</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特点</p>
<ul>
<li>可以实现多继承，但是原型只能指向一个父类的原型。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>实现比较麻烦。</li>
</ul>
</li>
</ul>
<h3 id="2-7-深拷贝、浅拷贝"><a href="#2-7-深拷贝、浅拷贝" class="headerlink" title="2.7 深拷贝、浅拷贝"></a>2.7 深拷贝、浅拷贝</h3><h4 id="2-7-1-基本数据类型：number-string-boolean-undefined-null-object"><a href="#2-7-1-基本数据类型：number-string-boolean-undefined-null-object" class="headerlink" title="2.7.1 基本数据类型：number string boolean undefined null object"></a>2.7.1 基本数据类型：number string boolean undefined null object</h4><ul>
<li>简单数据类型：number string boolean undefined null</li>
<li>复杂数据类型：object</li>
</ul>
<p>简单数据类型存放在<strong>栈</strong>中，负责数据类型存放在<strong>堆</strong>中。</p>
<p>复杂数据类型赋值时会指向同一个内存地址（既浅拷贝）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> objAncestor = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;ancestor&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">999</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> objGeneration = objAncestor;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objGeneration.<span class="property">name</span>); <span class="comment">// &#x27;ancestor&#x27;</span></span><br><span class="line">objAncestor.<span class="property">name</span> = <span class="string">&#x27;son&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objGeneration.<span class="property">name</span>); <span class="comment">// &#x27;son&#x27;</span></span><br></pre></td></tr></table></figure>

<p>简单数据类型就没有这样的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">a = <span class="number">11</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">// 11 10</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-2-typeof-与-instanceof"><a href="#2-7-2-typeof-与-instanceof" class="headerlink" title="2.7.2 typeof 与 instanceof"></a>2.7.2 typeof 与 instanceof</h4><ul>
<li><p>typeof 主要用于判断简单数据类型，只能返回 <code>&#39;number&#39; &#39;boolean&#39; &#39;string&#39; &#39;null&#39; &#39;undefined&#39; &#39;object&#39;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;&#x27;</span>; <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// &#x27;object&#x27; 历史遗留问题</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> undefinded; <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">//&#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>instanceof 可以判断是否为某个构造函数的实例，但是对简单数据类型的判断不准确</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Object</span>  <span class="comment">//true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span>  <span class="comment">//true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>  <span class="comment">//true</span></span><br><span class="line">/\d/ <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>  <span class="comment">//true</span></span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>  <span class="comment">//true</span></span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>  <span class="comment">//false</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比较好的办法是使用<code>Object.prototype.toString.apply()</code>来判断数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">//&quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="string">&#x27;str&#x27;</span>); <span class="comment">//&quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="number">1</span>); <span class="comment">//&quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="literal">null</span>); <span class="comment">//&quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(); <span class="comment">//&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;); <span class="comment">//&quot;[object Function]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="literal">true</span>); <span class="comment">//&quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">//&quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-7-3-深拷贝"><a href="#2-7-3-深拷贝" class="headerlink" title="2.7.3 深拷贝"></a>2.7.3 深拷贝</h4><ul>
<li><code>Object.assign()</code>方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。 此方法可以实现对象内部第一层简单数据类型的深拷贝。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: &#123; <span class="attr">d</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a); <span class="comment">// 参数中 &#123;&#125; 开辟了新的内存空间，将a中的简单数据类型拷过去了</span></span><br><span class="line">a.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line">a.<span class="property">c</span>.<span class="property">d</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// &#123;a:2,b:2,c:&#123;d:2&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// &#123;a:1,b:2,c:&#123;d:2&#125;&#125; 可以看见第一层还是ok的，第二层不行。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>JSON.stringify</code>和<code>JSON.parse</code>实现深拷贝：JSON.stringify 把对象转成字符串，再用 JSON.parse 把字符串转成新的对象；</p>
<p>这个方法的缺点是只能实现转换成 Json 格式的才能用这种方式，如果源中含有 function 的这种方式是拷贝不过去的。</p>
<p>不过这种方式工作中一般的情况都可以应付了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1：</span></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: &#123; <span class="attr">d</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(source));</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">clone</span>(a);</span><br><span class="line">a.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line">a.<span class="property">c</span>.<span class="property">d</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// &#123;a:2,b:2,c:&#123;d:2&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// &#123;a:1,b:2，c:&#123;d:1&#125;&#125;</span></span><br><span class="line"><span class="comment">// 例2：</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is a Function&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(source));</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">clone</span>(a);</span><br><span class="line">a.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line">a.<span class="property">c</span>.<span class="property">d</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// &#123;a:1,b:2,c:function()&#123;console.log(&#x27;this is a Function&#x27;)&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// &#123;a:1,b:2&#125; 可以看见c直接蒸发了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>递归实现深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is a Function&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newObj;</span><br><span class="line">  <span class="keyword">if</span> (source !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> source === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    newObj =</span><br><span class="line">      <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(source) === <span class="string">&#x27;[object Array]&#x27;</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">      newObj[key] = <span class="title function_">deepClone</span>(source[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newObj = source;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">deepClone</span>(a);</span><br><span class="line">a.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line">a.<span class="property">c</span>.<span class="property">d</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// &#123;a:2,b:2,c:&#123;d:2&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// &#123;a:1,b:2，c:&#123;d:1&#125;&#125;</span></span><br><span class="line">a.<span class="property">c</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is not a Function&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a.<span class="title function_">c</span>(); <span class="comment">// &#x27;this is not a Function&#x27;</span></span><br><span class="line">b.<span class="title function_">c</span>(); <span class="comment">// &#x27;this is a Function&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>附带一个自己做题时遇到的小问题：<a href="https://dqtwdd.gitee.io/2020/08/12/20200812-mergeArr/">一道简单小题引发的思考</a></p>
<h3 id="2-8-new-关键字做了什么"><a href="#2-8-new-关键字做了什么" class="headerlink" title="2.8 new 关键字做了什么"></a>2.8 new 关键字做了什么</h3><ol>
<li>创建一个新对象。</li>
<li>将新对象的<em>proto</em>指向构造函数的 prototype 对象。</li>
<li>将构造函数的作用域赋值给新对象 （也就是 this 指向新对象）。</li>
<li>执行构造函数中的代码（为这个新对象添加属性）。</li>
<li>返回新的对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> people = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">==========================================</span><br><span class="line"><span class="keyword">let</span> people = &#123;&#125;</span><br><span class="line">people.<span class="property">__proto__</span> = <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">call</span>(people)</span><br><span class="line"><span class="keyword">return</span> people</span><br></pre></td></tr></table></figure>

<h3 id="2-9-0-1-0-2-为什么不等于-0-3"><a href="#2-9-0-1-0-2-为什么不等于-0-3" class="headerlink" title="2.9 0.1 + 0.2 为什么不等于 0.3"></a>2.9 0.1 + 0.2 为什么不等于 0.3</h3><p>因为 Js 采用的是<strong>64 位双精度浮点数</strong>编码，所以会有精度问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span>; <span class="comment">// 0.30000000000000004  (15个0)</span></span><br><span class="line"><span class="number">0.7</span> * <span class="number">180</span>; <span class="comment">// 125.99999999998</span></span><br><span class="line"><span class="number">1000000000000000128</span> === <span class="number">1000000000000000129</span>; <span class="comment">//true  (15个0)</span></span><br></pre></td></tr></table></figure>

<p>解决方案：小数计算时将小数转换成整数进行计算后再恢复成小数。</p>
<h3 id="2-10-事件捕获和事件冒泡"><a href="#2-10-事件捕获和事件冒泡" class="headerlink" title="2.10 事件捕获和事件冒泡"></a>2.10 事件捕获和事件冒泡</h3><p>事件流程处理分为三个阶段：</p>
<ol>
<li>事件捕获</li>
<li>事件目标</li>
<li>事件冒泡</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addEventListener，他有一个参数，为true就是捕获阶段，为false就是冒泡阶段，默认为false</span></span><br><span class="line">&lt;div id=<span class="string">&quot;box1&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;;</span><br><span class="line"><span class="comment">// js 结构</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box1&#x27;</span>).<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box1事件捕获阶段&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box1&#x27;</span>).<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box1事件冒泡阶段&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box2&#x27;</span>).<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box2事件捕获阶段&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box2&#x27;</span>).<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box2事件冒泡阶段&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box3&#x27;</span>).<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box3事件捕获阶段&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box3&#x27;</span>).<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box3事件冒泡阶段&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 控制台打印</span></span><br><span class="line">box1事件捕获阶段;</span><br><span class="line">box2事件捕获阶段;</span><br><span class="line">box3事件捕获阶段;</span><br><span class="line">box3事件冒泡阶段;</span><br><span class="line">box2事件冒泡阶段;</span><br><span class="line">box1事件冒泡阶段;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件捕获：点击一个 dom 后，事件会从文档的根节点流向目标节点，触发事件捕获（也就是<code>addEventListener true </code>时监听到的事件。）</li>
<li>事件目标：当事件到达目标节点后，就会触发目标节点所绑定的事件。然后会开始逆向回流，直到文档的最外层。</li>
<li>事件冒泡：目标节点绑定的事件触发后，并不会终止，而是会向文档的外层冒泡，依次触发外层 dom 所绑定的事件。</li>
</ul>
<p>事件委托就是基于这个原理，当一个列表中有很多项时，我们可以不用为每一项绑定一个<code>@click</code>事件，而是可以直接在父节点绑定一个事件，传入<code>e</code>，然后对目标节点进行判断后做出回应：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//html</span></span><br><span class="line">&lt;table @click=<span class="string">&quot;edit&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    ...</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">:data-id</span>=<span class="string">&quot;item.id&quot;</span> <span class="attr">title</span>=<span class="string">&quot;eidt&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//js</span></span><br><span class="line">edit (event)&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.<span class="property">target</span>.<span class="property">title</span> == <span class="string">&quot;edit&quot;</span>)&#123; <span class="comment">//如果点击到了edit</span></span><br><span class="line">        <span class="keyword">let</span> id = evenr.<span class="property">target</span>.<span class="property">dataset</span>.<span class="property">id</span>;</span><br><span class="line">        <span class="comment">//拿着id参数执行着相关的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**无法在捕获阶段阻止事件冒泡！ **</p>
<p>vue 中可以使用修饰符来<code>@click.prevent</code> 阻止默认事件，使用<code> @click.stop</code>阻止事件冒泡。</p>
<h3 id="2-11-ajax-原理"><a href="#2-11-ajax-原理" class="headerlink" title="2.11 ajax 原理"></a>2.11 ajax 原理</h3><p><strong>ajax：</strong> 既 <em>Asynchronous JavaScript and XML</em> 异步的 Javascript 和 XML。</p>
<p>ajax 不是一种新技术，而是以下几种技术的组合：</p>
<ol>
<li>使用<strong>HTML</strong>和<strong>Css</strong>进行展示。</li>
<li>使用<strong>Dom</strong>模型来交互和显示。</li>
<li>使用<strong>XMLHttpRequest</strong>来请求。</li>
<li>使用<strong>JavaScript</strong>来绑定和调用。</li>
</ol>
<p>通过下图可以看出，以前的页面发送请求时是返回整个页面的信息，使用 Ajax 之后可以极大的降低网络请求传输的数据大小。</p>
<p><img src="https://dqtwdd.top/cdn/img/AjaxPrinciple.png" alt="ajax原理"></p>
<h3 id="2-12-前端模块化"><a href="#2-12-前端模块化" class="headerlink" title="2.12 前端模块化"></a>2.12 前端模块化</h3><ul>
<li><p>Node 采用 CommonJS 规范</p>
<ul>
<li>使用<code>module.exports</code>和<code>require()</code>配对</li>
<li>特点：<ol>
<li>每一个文件就是一个模块。</li>
<li>每个模块有自己的作用域。</li>
<li>每个模块内部的变量，方法，都是私有的，只能通过 exports 属性访问。</li>
</ol>
</li>
</ul>
<p>看着眼熟不眼熟，面向对象啊！感觉每个 module 就是一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">x</span> = x;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">addX</span> = addX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(example.<span class="property">x</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(example.<span class="title function_">addX</span>(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 模块规范</p>
<ul>
<li>使用<code>export</code>和<code>import</code>配对。</li>
<li>特点：<ul>
<li><code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br></pre></td></tr></table></figure>

<p>// 报错<br>function f() {}<br>export f;</p>
<p>// 正确<br>export function f() {};</p>
<p>// 正确<br>function f() {}<br>export {f};</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 2.13 ES6</span><br><span class="line"></span><br><span class="line">#### 2.13.1 async await</span><br><span class="line"></span><br><span class="line">- `async`是 Generator 函数的语法糖。</span><br><span class="line">- `async`可以将异步函数改写为同步形式。</span><br><span class="line">- `await` 后面跟一个函数。</span><br><span class="line">- `async`函数返回一个 Promise 对象，可以使用`then`方法添加回调函数。</span><br><span class="line">- 只有在 `async`内部函数执行完成后，函数才会继续往后执行。</span><br><span class="line">- `await`后面如果是一个 Promise，会等待返回`resolve`或者`reject`之后再继续执行。</span><br><span class="line">- `await`后面如果是一个普通函数，会立即执行。</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">function fn1() &#123;</span><br><span class="line">console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">function fn2() &#123;</span><br><span class="line">console.log(2);</span><br><span class="line">setTimeout(fn1, 10);</span><br><span class="line">console.log(3);</span><br><span class="line">&#125;</span><br><span class="line">function fn3() &#123;</span><br><span class="line">return new Promise(function (resolve) &#123;</span><br><span class="line">  console.log(&#x27;4&#x27;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">  console.log(&#x27;5&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function fn4() &#123;</span><br><span class="line">let res = await fn3();</span><br><span class="line">fn1();</span><br><span class="line">fn2();</span><br><span class="line">&#125;</span><br><span class="line">async function fn5() &#123;</span><br><span class="line">let res = await fn2();</span><br><span class="line">fn1();</span><br><span class="line">fn2();</span><br><span class="line">&#125;</span><br><span class="line">fn4(); // 4 5 1 2 3 1</span><br><span class="line">fn5(); //2 3 1 2 3 1 1</span><br></pre></td></tr></table></figure>

<h4 id="2-13-2-set-map"><a href="#2-13-2-set-map" class="headerlink" title="2.13.2 set map"></a>2.13.2 set map</h4><ol>
<li><p>set</p>
<ul>
<li><code>set</code> 类似于数组，与数组不同的是它内部的每个值都是唯一的。</li>
<li><code>set</code>本身是一个构造函数，可以通过<code>new</code>关键字创建<code>set</code>对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> s.<span class="title function_">add</span>(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">[...set];</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">items.<span class="property">size</span>; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>set</code>的属性</p>
<ul>
<li><code>Set.prototype.size</code>用于查看<code>set</code>的总成员数，类似<code>Array.prototype.length</code></li>
<li><code>Set.prototype.constructor</code>用于查看<code>set</code>的构造函数。</li>
</ul>
</li>
<li><p><code>set</code>的方法</p>
<ul>
<li><p><code>Set.prototype.has</code>用于查看<code>set</code>是否含有某个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">set.<span class="title function_">has</span>(<span class="number">1</span>); <span class="comment">//true</span></span><br><span class="line">set.<span class="title function_">has</span>(<span class="string">&#x27;1&#x27;</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Set.prototype.add</code>用于向<code>set</code>添加新元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set]); <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">9</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set]); <span class="comment">// [1,2,3,4,5,6,9]</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set]); <span class="comment">// [1,2,3,4,5,6,9]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Set.prototype.delete用于</code>set`删除元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set]); <span class="comment">// [1,2,3,4,5,6,9]</span></span><br><span class="line">set.<span class="title function_">delete</span>(<span class="number">9</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set]); <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line">set.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set]); <span class="comment">// [2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Set.prototype.clear</code>用于清除<code>set</code>所有元素。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>map</code></p>
<ul>
<li><p><code>map</code>类似于对象，与对象不同的是，传统的对象的<code>key</code>只能是 String，而<code>map</code>的<code>key</code>可以是任意类型（<code>Object Array String ... </code>）。</p>
</li>
<li><p><code>map</code>的属性</p>
<p><code>size</code>属性返回 Map 结构的成员总数。</p>
</li>
<li><p><code>map</code>的方法</p>
<ul>
<li><code>Map.prototype.set(key, value)</code>： <code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</li>
<li><code> Map.prototype.has(key)</code>： <code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li><code>Map.prototype.get(key)</code>：<code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</li>
<li><code> Map.prototype.delete(key)</code> ： <code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</li>
<li><code>Map.prototype.clear()：</code>： <code>clear</code>方法清除所有成员，没有返回值。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-13-3-let-和-const"><a href="#2-13-3-let-和-const" class="headerlink" title="2.13.3 let 和 const"></a>2.13.3 let 和 const</h4><p>先看一道经典的面试题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>以前啊，把这道题想简单了，以为知识简单的考<code>let</code>和<code>var</code>的区别，昨天跟小伙伴讨论的时候才意识到这道题考到了块级作用域和宏任务。现在把这道题改变一下，然后剖析一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;print&#x27;</span>,i)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">print1 print2 print3 print4 print5 print6 print7 print8 print9 <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>结合后面提到的宏任务，我们可以分析，每一次执行循环的时候，都是先执行了一遍<code>console.log(&#39;print&#39;,i)</code>，然后把<code>setTimeout</code>的内容拿出来，放到宏任务的队列里面，由于<code>var</code>没有块级作用域，在执行完<code>for</code>循环后此时<code>i</code>的值为 10，然后再执行宏任务，打印 10 次 10。</p>
<p>而将<code>var</code>改为<code>let</code>之后，由于块级作用域的作用，每一次<code>for</code>的<code>i</code>不会互相影响， 所以打印结果就变成了<code>print1 print2 print3 print4 print5 print6 print7 print8 print9 1 2 3 4 5 6 7 8 9</code></p>
<h3 id="2-14-常用的array-string方法"><a href="#2-14-常用的array-string方法" class="headerlink" title="2.14 常用的array string方法"></a>2.14 常用的<code>array string</code>方法</h3><ul>
<li><code>array</code><ol>
<li><code>Array.splice()</code> 截取数组中的一段，并返回新数组。</li>
<li><code>Array.concat()</code> 连接连个新数组。</li>
<li><code>Array.push()</code> 向数组最后添加一个元素。</li>
<li><code>Array.pop()</code> 删除并返回数组的最后一个元素。</li>
<li><code>Array.reverse()</code> 将数组倒叙排列。</li>
<li><code>Array.forEach()</code> 对数组中的每一个元素执行一遍函数，无返回值，更改原数组。</li>
<li><code>Array.every()</code> 检查数组中的每个元素是否都符合条件。</li>
<li><code>Array.map()</code> 对数组中的每一个元素执行一遍函数，返回一个新数组，不改变原数组。</li>
<li><code>Array.includes()</code> 查看数组是否包含某个元素。</li>
<li><code>Array.findIndex()</code> 查找数组中某个元素的索引。</li>
<li><code>Array.shift()</code> 从删除并返回一个元素。</li>
<li><code>Array.toString()</code> 将两个数组连接成一个新数组。</li>
<li><code>Array.sort()</code> 将数组排序。</li>
<li><code>Array.split()</code>从数组中添加或者删除元素。</li>
</ol>
</li>
<li><code>string</code><ol>
<li><code>String.split()</code> 将字符串分割为数组。</li>
<li><code>String.replace()</code> 替换指定字符串。</li>
<li><code>String.slice()</code> 截取指定长度字符串并返回。</li>
<li><code>String.includes()</code> 判断字符串是否包含某个指定字符。</li>
<li><code>String.concat()</code> 将两个字符串链接成一个。</li>
<li><code>String.toLowerCase()</code> 转换小写。</li>
<li><code>String.toUpperCase()</code> 转换大写。</li>
<li><code>String.indexOf()</code> 查找指定字符第一次出现的位置。</li>
</ol>
</li>
</ul>
<h3 id="2-15-Promise-的静态方法"><a href="#2-15-Promise-的静态方法" class="headerlink" title="2.15 Promise 的静态方法"></a>2.15 Promise 的静态方法</h3><ol>
<li><p><code>Promise.prototype.then()</code></p>
<p><code>Promise.prototype.then()</code>是<code>Promise</code>返回<code>resolve</code>时的回调。</p>
</li>
<li><p><code>Promise.prototype.catch()</code></p>
<p><code>Promise.prototype.catch()</code>是<code>Promise</code>返回<code>reject</code>时的回调。</p>
</li>
<li><p><code>Promise.prototype.finally()</code></p>
<p><code>Promise.prototype.finally()</code>不关心<code>Promise</code>的返回是<code>resolve</code>还是<code>reject</code>，这个函数在<code>Promise</code>有返回值后执行。</p>
</li>
<li><p><code>Promise.all()</code></p>
<p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<p><code>Promise.all()</code>的参数是一个数组，数组成员都是<code>Promise</code>实例。返回结果有两种情况：</p>
<ol>
<li>参数中所有的<code>Promise</code>实例都返回<code>resolve</code>，则<code>Promise.all()</code>返回<code>fulfilled</code>，返货值为一个数组，数组成员为各个<code>Promise</code>实例<code>resolve</code>的值。</li>
<li>只要有一个返回<code>reject</code>，则直接执行<code>Promise.all()</code>的<code>.catch()</code>。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch error:&#x27;</span>, e));</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, &quot;world&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p3])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch error:&#x27;</span>, e));</span><br><span class="line"><span class="comment">// catch error: Error: 报错了</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如果返回<code>reject</code>的<code>Promise</code>实例有自己的<code>.catch()</code>方法，那么并不会执行<code>Promise.all()</code>的<code>.catch()</code>方法，而是作为<code>fulfilled</code>执行<code>.then()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> result)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> result)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: 报错了]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.race()</code></p>
<p><code>Promise.race()</code>和<code>Promise.all()</code>接受的参数相同，也是一个<code>Promise</code>实例数组，不同的是，<code>Promise.race()</code>中只要有一个返回<code>resolve</code>或者<code>reject</code>就直接执行<code>Promise.race()</code>的<code>.then()</code>或者<code>.catch()</code>方法。不等待其他的实例完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch error:&#x27;</span>, e));</span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.allSettled()</code></p>
<p><code>Promise.allSettled()</code>和<code>Promise.all()</code>接受的参数相同，也是一个<code>Promise</code>实例数组，不同的是，<code>Promise.allSettled()</code>不关心参数中每个<code>Promise</code>实例返回的是<code>resolve</code>还是<code>reject</code>，关心的是数组中所有的<code>Promise</code>对象都完成了，该方法的返回值是参数中各个<code>Promise</code>实例的返回结果组成的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch error:&#x27;</span>, e));</span><br><span class="line"><span class="comment">// [&#123;&quot;status&quot;:&quot;fulfilled&quot;,&quot;value&quot;:&quot;hello&quot;&#125;,&#123;&quot;status&quot;:&quot;fulfilled&quot;,&quot;value&quot;:&quot;world&quot;&#125;,&#123;&quot;status&quot;:&quot;rejected&quot;,&quot;reason&quot;:&#123;&#125;&#125;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.any()</code></p>
<p><code>Promise.any()</code>和<code>Promise.all()</code>接受的参数相同，也是一个<code>Promise</code>实例数组，不同的是，<code>Promise.any()</code>中只要有一个<code>Promise</code>实例返回<code>resolve</code>，<code>Promise.any()</code>就返回<code>resolve</code>，并执行<code>.then()</code>后面的方法，所有<code>Promise</code>实例都返回<code>reject</code>，则返回<code>reject</code>，<code>Promise.any()</code>返回的错误是一个<code>AggregateError </code>错误实例数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([p1, p2, p3])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch error:&#x27;</span>, e));</span><br><span class="line"><span class="comment">// catch error: AggregateError: All promises were rejected</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([p1, p2, p3])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch error:&#x27;</span>, e));</span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-16-Js-包含哪几部分？"><a href="#2-16-Js-包含哪几部分？" class="headerlink" title="2.16 Js 包含哪几部分？"></a>2.16 Js 包含哪几部分？</h3><p>核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）</p>
<p>常见的 BOM 对象：</p>
<p>window：代表整个浏览器窗口（window 是 BOM 中的一个对象，并且是顶级的对象）</p>
<p>Navigator ：代表浏览器当前的信息，通过 Navigator 我们可以获取用户当前使用的是什么浏览器</p>
<p>Location： 代表浏览器当前的地址信息，通过 Location 我们可以获取或者设置当前的地址信息</p>
<p>History：代表浏览器的历史信息，通过 History 我们可以实现上一步/刷新/下一步操作（出于对用户的隐私考虑，我们只能拿到当前的浏览记录，不能拿到所有的历史记录）</p>
<p>Screen：代表用户的屏幕信息</p>
<h3 id="2-17-设计模式："><a href="#2-17-设计模式：" class="headerlink" title="2.17 设计模式："></a>2.17 设计模式：</h3><h4 id="2-17-1-工厂模式"><a href="#2-17-1-工厂模式" class="headerlink" title="2.17.1 工厂模式"></a>2.17.1 工厂模式</h4><h4 id="2-17-2-观察者模式"><a href="#2-17-2-观察者模式" class="headerlink" title="2.17.2 观察者模式"></a>2.17.2 观察者模式</h4><h4 id="2-17-3-订阅发布模式"><a href="#2-17-3-订阅发布模式" class="headerlink" title="2.17.3 订阅发布模式"></a>2.17.3 订阅发布模式</h4><h4 id="2-17-4-单例模式"><a href="#2-17-4-单例模式" class="headerlink" title="2.17.4 单例模式"></a>2.17.4 单例模式</h4><h4 id="2-17-5-装饰器模式"><a href="#2-17-5-装饰器模式" class="headerlink" title="2.17.5 装饰器模式"></a>2.17.5 装饰器模式</h4><h3 id="2-18-for-in-与-for-of"><a href="#2-18-for-in-与-for-of" class="headerlink" title="2.18 for in 与 for of"></a>2.18 for in 与 for of</h3><p>for in 遍历的是 key，for of 遍历的是 value。</p>
<h3 id="2-19-执行上下文"><a href="#2-19-执行上下文" class="headerlink" title="2.19 执行上下文"></a>2.19 执行上下文</h3><p>JavaScript 有三种执行上下文类型：</p>
<ul>
<li><p>全局执行上下文</p>
<p>一个程序中只会有一个全局执行上下文，它会执行两件事情：</p>
<ol>
<li>创建一个全局的 window 对象（浏览器情况下；</li>
<li>设置 this 的值等于这个全局对象。</li>
</ol>
</li>
<li><p>函数执行上下文</p>
<p>每当一个函数被调用时，都会为该函数创建一个新的上下文，每个函数都有它自己的执行上下文，不过是在函数调用的时候创建的；函数的上下文可以有任意多个，每当一个新的执行上下文被创建，它会按照定义的顺序执行一系列步骤。</p>
</li>
<li><p>Eval 函数执行上下文</p>
</li>
</ul>
<p>上下文有两个步骤：</p>
<ol>
<li><p>创建上下文</p>
<p>创建上下文分三步：</p>
<ol>
<li><p>this绑定</p>
</li>
<li><p>创建词法环境：确定词法环境是<em>全局环境</em>还是<em>函数环境</em></p>
</li>
<li><p>创建变量环境：确定变量环境是<em>全局环境</em>还是<em>函数环境</em></p>
</li>
</ol>
</li>
<li><p>执行</p>
<p>看一下2.3的经典小题。</p>
</li>
</ol>
<h3 id="2-20-JS-GC（Garbage-Collection）垃圾回收机制"><a href="#2-20-JS-GC（Garbage-Collection）垃圾回收机制" class="headerlink" title="2.20 JS GC（Garbage Collection）垃圾回收机制"></a>2.20 JS GC（Garbage Collection）垃圾回收机制</h3><ul>
<li><p>可达性</p>
<p>js 中“可达性”值就是那些可以以某种方式访问或可用的值，他们被保证储存在内存中。</p>
</li>
<li><p>垃圾是什么</p>
<p>一般来说，没有被引用到的对象就是垃圾，就是需要被清除的，如果几个对象引用成一个环，互相引用，但根访问不到他们，这几个对象也是垃圾，也要被清除。</p>
</li>
<li><p>标记-清除 算法</p>
<ol>
<li>标记阶段：从根集合出发，将所有活动对象及其子对象打上标记。</li>
<li>清除阶段：遍历堆，将非活动对象（未打上标记）清除。</li>
</ol>
</li>
</ul>
<p>参考：<a href="https://segmentfault.com/a/1190000018605776">思否-垃圾回收机制</a></p>
<h3 id="2-21-Polyfill"><a href="#2-21-Polyfill" class="headerlink" title="2.21 Polyfill"></a>2.21 Polyfill</h3><p>Polyfill 字面意思是垫片，意为用于实现浏览器并不支持的原生 AP 的代码。</p>
<p>常见的 Polyfill 有比如 new 函数，debounce 防抖函数，throttle 节流函数等。</p>
<h3 id="2-22-函数柯里化"><a href="#2-22-函数柯里化" class="headerlink" title="2.22 函数柯里化"></a>2.22 函数柯里化</h3><p>柯里化是一种函数的转变，它指将一个函数从可调用的 f(a,b,c)转换为可调用的 f(a)(b)(c)。</p>
<p>柯里化不会调用函数，他只是对函数进行转换。</p>
<p>柯里化的核心思想是：降低通用性，提高适用性。</p>
<p>例：正则判断</p>
<p>function curry(a){<br>    return (b) =&gt;{<br>        console.log(a+b)<br>    }<br>}</p>
<p>如下，封装一个正则判断的函数，传入正则表达式和目标字符串，返回判断结果。没有问题。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">targetString, reg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> reg.<span class="title function_">test</span>(targetString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">check</span>(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>, <span class="string">&#x27;14900000088&#x27;</span>);</span><br><span class="line"><span class="title function_">check</span>(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>, <span class="string">&#x27;test@163.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>当业务需求只是判断手机号或判断邮箱时，仍需要每次都传入相应的正则这就很低效，因此可以使用柯里化函数再次进行封装。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curring</span>(<span class="params">reg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reg.<span class="title function_">test</span>(str);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> checkPhone = <span class="title function_">curring</span>(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>);</span><br><span class="line"><span class="keyword">var</span> checkEmail = <span class="title function_">curring</span>(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">checkPhone</span>(<span class="string">&#x27;183888888&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">checkPhone</span>(<span class="string">&#x27;17654239819&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">checkEmail</span>(<span class="string">&#x27;exy@163.com&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 offer</title>
    <url>/2022/10/19/20221019-offer/</url>
    <content><![CDATA[<h1 id="剑指-offer-思路总结"><a href="#剑指-offer-思路总结" class="headerlink" title="剑指 offer 思路总结"></a>剑指 offer 思路总结</h1><p>本部分主要是笔者在练习剑指 offer 时所做的笔记，如果出现错误，希望大家指出！</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li>二维数组中的查找</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的</span><br><span class="line">一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>（1）第一种方式是使用两层循环依次遍历，判断是否含有该整数。这一种方式最坏情况下的时间复杂度为 O(n^2)。</p>
<p>（2）第二种方式是利用递增序列的特点，我们可以从二维数组的右上角开始遍历。如果当前数值比所求的数要小，则将位置向下移动<br>，再进行判断。如果当前数值比所求的数要大，则将位置向左移动，再进行判断。这一种方式最坏情况下的时间复杂度为 O(n)。</p>
<ol start="2">
<li>替换空格</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20</span><br><span class="line">Are%20Happy</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用正则表达式，结合字符串的 replace 方法将空格替换为 “%20”</span><br><span class="line"></span><br><span class="line">str.replace(/\s/g,&quot;%20&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>从尾到头打印链表</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line">输入一个链表，从尾到头打印链表每个节点的值。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用栈来实现，首先根据头结点以此遍历链表节点，将节点加入到栈中。当遍历完成后，再将栈中元素弹出并打印，以此来实现。栈的</span><br><span class="line">实现可以利用 Array 的 push 和 pop 方法来模拟。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>重建二叉树</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输</span><br><span class="line">入前序遍历序列 &#123;1,2,4,7,3,5,6,8&#125; 和中序遍历序列 &#123;4,7,2,1,5,3,8,6&#125;，则重建二叉树并返回。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用递归的思想来求解，首先先序序列中的第一个元素一定是根元素。然后我们去中序遍历中寻找到该元素的位置，找到后该元素的左</span><br><span class="line">边部分就是根节点的左子树，右边部分就是根节点的右子树。因此我们可以分别截取对应的部分进行子树的递归构建。使用这种方式的</span><br><span class="line">时间复杂度为 O(n)，空间复杂度为 O(logn)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>用两个栈实现队列</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">队列的一个基本特点是，元素先进先出。通过两个栈来模拟时，首先我们将两个栈分为栈 1 和栈 2。当执行队列的 push 操作时，直接</span><br><span class="line">将元素 push 进栈 1 中。当队列执行 pop 操作时，首先判断栈 2 是否为空，如果不为空则直接 pop 元素。如果栈 2 为空，则将栈 1 中</span><br><span class="line">的所有元素 pop 然后 push 到栈 2 中，然后再执行栈 2 的 pop 操作。</span><br><span class="line"></span><br><span class="line">扩展：</span><br><span class="line"></span><br><span class="line">当使用两个长度不同的栈来模拟队列时，队列的最大长度为较短栈的长度的两倍。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>旋转数组的最小数字</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的</span><br><span class="line">最小元素。 例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大</span><br><span class="line">小为 0，请返回 0。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值相</span><br><span class="line">邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。</span><br><span class="line"></span><br><span class="line">（2）二分法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相关资料可以参考：<br><a href="https://www.cnblogs.com/edisonchou/p/4746561.html">《旋转数组的最小数字》</a></p>
<ol start="7">
<li>斐波那契数列</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。 n&lt;=39</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">斐波那契数列的规律是，第一项为 0，第二项为 1，第三项以后的值都等于前面两项的和，因此我们可以通过循环的方式，不断通过叠</span><br><span class="line">加来实现第 n 项值的构建。通过循环而不是递归的方式来实现，时间复杂度降为了 O(n)，空间复杂度为 O(1)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>跳台阶</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">跳台阶的问题是一个动态规划的问题，由于一次只能够跳 1 级或者 2 级，因此跳上 n 级台阶一共有两种方案，一种是从 n-1 跳上，一</span><br><span class="line">种是从 n-2 级跳上，因此 f(n) = f(n-1) + f(n-2)。</span><br><span class="line"></span><br><span class="line">和斐波那契数列类似，不过初始两项的值变为了 1 和 2，后面每项的值等于前面两项的和。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>变态跳台阶</li>
</ol>
<p>题目：</p>
<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>思路：</p>
<p>变态跳台阶的问题同上一个问题的思考方案是一样的，我们可以得到一个结论是，每一项的值都等于前面所有项的值的和。</p>
<p>f(1) = 1<br>f(2) = f(2-1) + f(2-2) //f(2-2) 表示 2 阶一次跳 2 阶的次数。<br>f(3) = f(3-1) + f(3-2) + f(3-3)<br>…<br>f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n)</p>
<p>再次总结可得</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        | 1 ,(n=0 )</span><br><span class="line">f(n) =  | 1 ,(n=1 )</span><br><span class="line">        | 2\*f(n-1),(n&gt;=2)</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>矩形覆盖</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2\*n 的大矩形，总共</span><br><span class="line">有多少种方法？</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">依旧是斐波那契数列的应用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="11">
<li>二进制中 1 的个数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">一个不为 0 的整数的二进制表示，一定会有一位为 1。我们找到最右边的一位 1，当我们将整数减去 1 时，最右边的一位 1 变为 0，它后</span><br><span class="line">面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位 1。因此判断一个二进制中 1 的个数，我们可以判</span><br><span class="line">断这个数可以经历多少次这样的过程。</span><br><span class="line"></span><br><span class="line">如：1100&amp;1011=1000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="12">
<li>数值的整数次方</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先我们需要判断 exponent 正负和零取值三种情况，根据不同的情况通过递归来实现。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="13">
<li>调整数组顺序使奇数位于偶数前面</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半</span><br><span class="line">部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">由于需要考虑到调整之后的稳定性，因此我们可以使用辅助数组的方式。首先对数组中的元素进行遍历，每遇到一个奇数就将它加入到</span><br><span class="line">奇数辅助数组中，每遇到一个偶数，就将它将入到偶数辅助数组中。最后再将两个数组合并。这一种方法的时间复杂度为 O(n)，空间</span><br><span class="line">复杂度为 O(n)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="14">
<li>链表中倒数第 k 个节点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，输出该链表中倒数第 k 个结点。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用两个指针，先让第一个和第二个指针都指向头结点，然后再让第二个指针走 k-1 步，到达第 k 个节点。然后两个指针同时向后</span><br><span class="line">移动，当第二个指针到达末尾时，第一个指针指向的就是倒数第 k 个节点了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="15">
<li>反转链表</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，反转链表后，输出链表的所有元素。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过设置三个变量 pre、current 和 next，分别用来保存前继节点、当前节点和后继结点。从第一个节点开始向后遍历，首先将当</span><br><span class="line">前节点的后继节点保存到 next 中，然后将当前节点的后继节点设置为 pre，然后再将 pre 设置为当前节点，current 设置为 ne</span><br><span class="line">xt 节点，实现下一次循环。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="16">
<li>合并两个排序的链表</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过递归的方式，依次将两个链表的元素递归进行对比。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="17">
<li>树的子结构</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两棵二叉树 A、B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构）</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过递归的思想来解决</span><br><span class="line"></span><br><span class="line">第一步首先从树 A 的根节点开始遍历，在左右子树中找到和树 B 根结点的值一样的结点 R 。</span><br><span class="line">第二步两棵树同时从 R 节点和根节点以相同的遍历方式进行遍历，依次比较对应的值是否相同，当树 B 遍历结束时，结束比较。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="18">
<li>二叉树的镜像</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">操作给定的二叉树，将其变换为源二叉树的镜像。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">从根节点开始遍历，首先通过临时变量保存左子树的引用，然后将根节点的左右子树的引用交换。然后再递归左右节点的子树交换。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="19">
<li>顺时针打印矩阵</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，</span><br><span class="line">例如，如果输入如下矩阵： 1 2 3 4</span><br><span class="line">5 6 7 8</span><br><span class="line">9 10 11 12</span><br><span class="line">13 14 15 16</span><br><span class="line">则依次打印出数字 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）根据左上角和右下角可以定位出一次要旋转打印的数据。一次旋转打印结束后，往对角分别前进和后退一个单位，可以确定下一</span><br><span class="line">次需要打印的数据范围。</span><br><span class="line"></span><br><span class="line">（2）使用模拟魔方逆时针解法，每打印一行，则将矩阵逆时针旋转 90 度，打印下一行，依次重复。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="20">
<li>定义一个栈，实现 min 函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用一个辅助栈，每次将数据压入数据栈时，就把当前栈里面最小的值压入辅助栈当中。这样辅助栈的栈顶数据一直是数据栈中最小</span><br><span class="line">的值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="21">
<li>栈的压入弹出</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如</span><br><span class="line">序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序</span><br><span class="line">列的弹出序列。（注意：这两个序列的长度是相等的）</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们可以使用一个辅助栈的方式来实现，首先遍历压栈顺序，依次将元素压入辅助栈中，每次压入元素后我们首先判断该元素是否与出</span><br><span class="line">栈顺序中的此刻位置的元素相等，如果不相等，则将元素继续压栈，如果相等，则将辅助栈中的栈顶元素出栈，出栈后，将出栈顺序中</span><br><span class="line">的位置后移一位继续比较。当压栈顺序遍历完成后，如果辅助栈不为空，则说明该出栈顺序不正确。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="22">
<li>从上往下打印二叉树</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">从上往下打印出二叉树的每个节点，同层节点从左至右打印。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">本质上是二叉树的层序遍历，可以通过队列来实现。首先将根节点入队。然后对队列进行出队操作，每次出队时，将出队元素的左右子</span><br><span class="line">节点依次加入到队列中，直到队列长度变为 0 时，结束遍历。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="23">
<li>二叉搜索树的后序遍历</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes，否则输出 No。假设输入的数组的任意两</span><br><span class="line">个数字都互不相同。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">对于一个合法而二叉树的后序遍历来说，最末尾的元素为根元素。该元素前面的元素可以划分为两个部分，一部分为该元素的左子树，</span><br><span class="line">所有元素的值比根元素小，一部分为该元素的右子树，所有的元素的值比该根元素大。并且每一部分都是一个合法的后序序列，因此我</span><br><span class="line">们可以利用这些特点来递归判断。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="24">
<li>二叉树中和为某一值路径</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经</span><br><span class="line">过的结点形成一条路径。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过对树进行深度优先遍历，遍历时保存当前节点的值并判断是否和期望值相等，如果遍历到叶节点不符合要求则回退处理。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="25">
<li>复杂链表的复制</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为</span><br><span class="line">复制后复杂链表的 head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方式，首先对原有链表每个节点进行复制，通过 next 连接起来。然后当链表复制完成之后，再来设置每个节点的 ra</span><br><span class="line">ndom 指针，这个时候每个节点的 random 的设置都需要从头结点开始遍历，因此时间的复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种方式，首先对原有链表每个节点进行复制，并且使用 Map 以键值对的方式将原有节点和复制节点保存下来。当链表复</span><br><span class="line">制完成之后，再来设置每个节点的 random 指针，这个时候我们通过 Map 中的键值关系就可以获取到对应的复制节点，因此</span><br><span class="line">不必再从头结点遍历，将时间的复杂度降低为了 O(n)，但是空间复杂度变为了 O(n)。这是一种以空间换时间的做法。</span><br><span class="line"></span><br><span class="line">（3）第三种方式，首先对原有链表的每个节点进行复制，并将复制后的节点加入到原有节点的后面。当链表复制完成之后，再进行</span><br><span class="line">random 指针的设置，由于每个节点后面都跟着自己的复制节点，因此我们可以很容易的获取到 random 指向对应的复制节点</span><br><span class="line">。最后再将链表分离，通过这种方法我们也能够将时间复杂度降低为 O(n)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="26">
<li>二叉搜索树与双向链表</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">需要生成一个排序的双向列表，那么我们应该通过中序遍历的方式来调整树结构，因为只有中序遍历，返回才是一个从小到大的排序</span><br><span class="line">序列。</span><br><span class="line"></span><br><span class="line">基本的思路是我们首先从根节点开始遍历，先将左子树调整为一个双向链表，并将左子树双向链表的末尾元素的指针指向根节点，并</span><br><span class="line">将根节点的左节点指向末尾节点。再将右子树调整为一个双向链表，并将右子树双向链表的首部元素的指针指向根元素，再将根节点</span><br><span class="line">的右节点指向首部节点。通过对左右子树递归调整，因此来实现排序的双向链表的构建。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="27">
<li>字符串的排列</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a,b,c 所能排列出来的所有</span><br><span class="line">字符串 abc,acb,bac,bca,cab 和 cba。输入描述：输入一个字符串，长度不超过 9（可能有字符重复），字符只包括大小写字母。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们可以把一个字符串看做是两个部分，第一部分为它的第一个字符，第二部分是它后面的所有字符。求整个字符串的一个全排列，可</span><br><span class="line">以看做两步，第一步是求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换。第二步就是求后面所有字符的一</span><br><span class="line">个全排列。因此通过这种方式，我们可以以递归的思路来求出当前字符串的全排列。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://wiki.jikexueyuan.com/project/for-offer/question-twenty-eight.html">《字符串的排列》</a></p>
<ol start="28">
<li>数组中出现次数超过一半的数字</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">数组中有一个数字出现的次数超过数组长度的一半。请找出这个数字。例如输入一个长度为 9 的数组&#123;1,2,3,2,2,2,5,4,2&#125;。由于数</span><br><span class="line">字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2。如果不存在则输出 0。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）对数组进行排序，排序后的中位数就是所求数字。这种方法的时间复杂度取决于我们采用的排序方法的时间复杂度，因此最快为</span><br><span class="line">O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）由于所求数字的数量超过了数组长度的一半，因此排序后的中位数就是所求数字。因此我们可以将问题简化为求一个数组的中</span><br><span class="line">位数问题。其实数组并不需要全排序，只需要部分排序。我们通过利用快排中的 partition 函数来实现，我们现在数组中随</span><br><span class="line">机选取一个数字，而后通过 partition 函数返回该数字在数组中的索引 index，如果 index 刚好等于 n/2，则这个数字</span><br><span class="line">便是数组的中位数，也即是要求的数，如果 index 大于 n/2，则中位数肯定在 index 的左边，在左边继续寻找即可，反之</span><br><span class="line">在右边寻找。这样可以只在 index 的一边寻找，而不用两边都排序，减少了一半排序时间，这种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）由于该数字的出现次数比所有其他数字出现次数的和还要多，因此可以考虑在遍历数组时保存两个值：一个是数组中的一个数</span><br><span class="line">字，一个是次数。当遍历到下一个数字时，如果下一个数字与之前保存的数字相同，则次数加 1，如果不同，则次数减 1，如果</span><br><span class="line">次数为 0，则需要保存下一个数字，并把次数设定为 1。由于我们要找的数字出现的次数比其他所有数字的出现次数之和还要大，</span><br><span class="line">则要找的数字肯定是最后一次把次数设为 1 时对应的数字。该方法的时间复杂度为 O(n)，空间复杂度为 O(1)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/ns_code/article/details/26957383">《出现次数超过一半的数字》</a></p>
<ol start="29">
<li>最小的 K 个数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入 n 个整数，找出其中最小的 K 个数。例如输入 4,5,1,6,2,7,3,8 这 8 个数字，则最小的 4 个数字是 1,2,3,4 。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是首先将数组排序，排序后再取最小的 k 个数。这一种方法的时间复杂度取决于我们选择的排序算法的时间复杂</span><br><span class="line">度，最好的情况下为 O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是由于我们只需要获得最小的 k 个数，这 k 个数不一定是按序排序的。因此我们可以使用快速排序中的 part</span><br><span class="line">ition 函数来实现。每一次选择一个枢纽值，将数组分为比枢纽值大和比枢纽值小的两个部分，判断枢纽值的位置，如果该枢</span><br><span class="line">纽值的位置为 k-1 的话，那么枢纽值和它前面的所有数字就是最小的 k 个数。如果枢纽值的位置小于 k-1 的话，假设枢</span><br><span class="line">纽值的位置为 n-1，那么我们已经找到了前 n 小的数字了，我们就还需要到后半部分去寻找后半部分 k-n 小的值，进行划</span><br><span class="line">分。当该枢纽值的位置比 k-1 大时，说明最小的 k 个值还在左半部分，我们需要继续对左半部分进行划分。这一种方法的平</span><br><span class="line">均时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）第三种方法是维护一个容量为 k 的最大堆。对数组进行遍历时，如果堆的容量还没有达到 k ，则直接将元素加入到堆中，这</span><br><span class="line">就相当于我们假设前 k 个数就是最小的 k 个数。对 k 以后的元素遍历时，我们将该元素与堆的最大值进行比较，如果比最</span><br><span class="line">大值小，那么我们则将最大值与其交换，然后调整堆。如果大于等于堆的最大值，则继续向后遍历，直到数组遍历完成。这一</span><br><span class="line">种方法的平均时间复杂度为 O(nlogk)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.kancloud.cn/kancloud/the-art-of-programming/41579">《寻找最小的 k 个数》</a></p>
<ol start="30">
<li>连续子数组的最大和</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后，他又发话了:在古老的一维模式识别中，常常需要计</span><br><span class="line">算连续子向量的最大和,当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的</span><br><span class="line">正数会弥补它呢？例如：&#123;6,-3,-2,7,-15,1,2,2&#125;，连续子向量的最大和为 8（从第 0 个开始，到第 3 个为止）。你会不会被他忽悠</span><br><span class="line">住？（子向量的长度至少是 1）</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接暴力求解的方式，先以第一个数字为首往后开始叠加，叠加的过程中保存最大的值。然后再以第二个数字为首</span><br><span class="line">往后开始叠加，并与先前保存的最大的值进行比较。这一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是，首先我们观察一个最大和的连续数组的规律，我们可以发现，子数组一定是以正数开头的，中间包含了正负数。</span><br><span class="line">因此我们可以从第一个数开始向后叠加，每次保存最大的值。叠加的值如果为负数，则将叠加值初始化为 0，因为后面的数加上负</span><br><span class="line">数只会更小，因此需要寻找下一个正数开始下一个子数组的判断。一直往后判断，直到这个数组遍历完成为止，得到最大的值。</span><br><span class="line">使用这一种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-one.html">《连续子数组的最大和》</a></p>
<ol start="31">
<li>整数中 1 出现的次数（待深入理解）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">求出 1~13 的整数中 1 出现的次数，并算出 100~1300 的整数中 1 出现的次数？为此他特别数了一下 1~13 中包含 1 的数字有 1、10、11、</span><br><span class="line">12、13 因此共出现 6 次，但是对于后面问题他就没辙了。ACMer 希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整</span><br><span class="line">数区间中 1 出现的次数。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接遍历每个数，然后将判断每个数中 1 的个数，一直叠加。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是求出 1 出现在每位上的次数，然后进行叠加。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/yi_Afly/article/details/52012593">《从 1 到 n 整数中 1 出现的次数：O(logn)算法》</a></p>
<ol start="32">
<li>把数组排成最小的数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组&#123;3，32，321</span><br><span class="line">&#125;，则打印出这三个数字能排成的最小数字为 321323。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）求出数组的全排列，然后对每个排列结果进行比较。</span><br><span class="line"></span><br><span class="line">（2）利用排序算法实现，但是比较时，比较的并不是两个元素的大小，而是两个元素正序拼接和逆序拼接的大小，如果逆序拼接的</span><br><span class="line">结果更小，则交换两个元素的位置。排序结束后，数组的顺序则为最小数的排列组合顺序。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-three.html">《把数组排成最小的数》</a></p>
<ol start="33">
<li>丑数（待深入理解）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">把只包含质因子 2、3 和 5 的数称作丑数。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。 习惯上我们把 1 当做是第一个丑数。求</span><br><span class="line">按从小到大的顺序的第 N 个丑数。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）判断一个数是否为丑数，可以判断该数不断除以 2，最后余数是否为 1。判断该数不断除以 3，最后余数是否为 1。判断不断除以</span><br><span class="line">5，最后余数是否为 1。在不考虑时间复杂度的情况下，可以依次遍历找到第 N 个丑数。</span><br><span class="line"></span><br><span class="line">（2）使用一个数组来保存已排序好的丑数，后面的丑数由前面生成。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="34">
<li>第一个只出现一次的字符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个字符串（1&lt;=字符串长度&lt;=10000，全部由大写字母组成）中找到第一个只出现一次的字符，并返回它的位置。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是，从前往后遍历每一个字符。每遍历一个字符，则将字符与后边的所有字符依次比较，判断是否含有相同字符。这</span><br><span class="line">一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是，首先对字符串进行一次遍历，将字符和字符出现的次数以键值对的形式存储在 Map 结构中。然后第二次遍历时</span><br><span class="line">，去 Map 中获取对应字符出现的次数，找到第一个只出现一次的字符。这一种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="35">
<li>数组中的逆序对</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对</span><br><span class="line">的总数 P。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接求解的方式，顺序扫描整个数组。每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果</span><br><span class="line">后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有 n 个数字。由于每个数字都要和 O(n）个数字作比</span><br><span class="line">较，因此这个算法的时间复杂度是 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是使用归并排序的方式，通过利用归并排序分解后进行合并排序时，来进行逆序对的统计，这一种方法的时间复杂</span><br><span class="line">度为 O(nlogn)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-six.html">《数组中的逆序对》</a></p>
<ol start="36">
<li>两个链表的第一个公共结点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个链表，找出它们的第一个公共结点。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法是在第一个链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个链表上顺序遍历每个结点。如果在第二</span><br><span class="line">个链表上有一个结点和第一个链表上的结点一样，说明两个链表在这个结点上重合，于是就找到了它们的公共结点。如果第一</span><br><span class="line">个链表的长度为 m，第二个链表的长度为 n。这一种方法的时间复杂度是 O(mn）。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是利用栈的方式，通过观察我们可以发现两个链表的公共节点，都位于链表的尾部，以此我们可以分别使用两个栈</span><br><span class="line">，依次将链表元素入栈。然后在两个栈同时将元素出栈，比较出栈的节点，最后一个相同的节点就是我们要找的公共节点。这</span><br><span class="line">一种方法的时间复杂度为 O(m+n)，空间复杂度为 O(m+n)。</span><br><span class="line"></span><br><span class="line">（3）第三种方式是，首先分别遍历两个链表，得到两个链表的长度。然后得到较长的链表与较短的链表长度的差值。我们使用两个</span><br><span class="line">指针来分别对两个链表进行遍历，首先将较长链表的指针移动 n 步，n 为两个链表长度的差值，然后两个指针再同时移动，</span><br><span class="line">判断所指向节点是否为同一节点。这一种方法的时间复杂度为 O(m+n)，相同对于上一种方法不需要额外的空间。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-seven.html">《两个链表的第一个公共结点》</a></p>
<ol start="37">
<li>数字在排序数组中出现的次数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">统计一个数字：在排序数组中出现的次数。例如输入排序数组｛ 1, 2, 3, 3, 3, 3, 4, 5｝和数字 3 ，由于 3 在这个数组中出</span><br><span class="line">现了 4 次，因此输出 4 。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法是直接对数组顺序遍历的方式，通过这种方法来统计数字的出现次数。这种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（2）第二种方法是使用二分查找的方法，由于数组是排序好的数组，因此相同数字是排列在一起的。统计数字出现的次数，我们需要</span><br><span class="line">去找到该段数字开始和结束的位置，以此来确定数字出现的次数。因此我们可以使用二分查找的方式来确定该数字的开始和结束</span><br><span class="line">位置。如果我们第一次我们数组的中间值为 k ，如果 k 值比所求值大的话，那么我们下一次只需要判断前面一部分就行了，如</span><br><span class="line">果 k 值比所求值小的话，那么我们下一次就只需要判断后面一部分就行了。如果 k 值等于所求值的时候，我们则需要判断该值</span><br><span class="line">是否为开始位置或者结束位置。如果是开始位置，那么我们下一次需要到后半部分去寻找结束位置。如果是结束位置，那么我们</span><br><span class="line">下一次需要到前半部分去寻找开始位置。如果既不是开始位置也不是结束位置，那么我们就分别到前后两个部分去寻找开始和结</span><br><span class="line">束位置。这一种方法的平均时间复杂度为 O(logn)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="38">
<li>二叉树的深度</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深</span><br><span class="line">度。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">根节点的深度等于左右深度较大值加一，因此可以通过递归遍历来实现。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="39">
<li>平衡二叉树</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉树，判断该二叉树是否是平衡二叉树。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）在遍历树的每个结点的时候，调用函数得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过 1 ，那么它</span><br><span class="line">就是一棵平衡的二叉树。使用这种方法时，节点会被多次遍历，因此会造成效率不高的问题。</span><br><span class="line"></span><br><span class="line">（2）在求一个节点的深度时，同时判断它是否平衡。如果不平衡则直接返回 -1，否则返回树高度。如果一个节点的一个子树的深</span><br><span class="line">度为-1，那么就直接向上返回 -1 ，该树已经是不平衡的了。通过这种方式确保了节点只能够被访问一遍。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="40">
<li>数组中只出现一次的数字</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方式是依次遍历数组，记录下数字出现的次数，从而找出两个只出现一次的数字。</span><br><span class="line"></span><br><span class="line">（2）第二种方式，根据位运算的异或的性质，我们可以知道两个相同的数字异或等于 0，一个数和 0 异或还是它本身。由于数组中</span><br><span class="line">的其他数字都是成对出现的，因此我们可以将数组中的所有数依次进行异或运算。如果只有一个数出现一次的话，那么最后剩下</span><br><span class="line">的就是落单的数字。如果是两个数只出现了一次的话，那么最后剩下的就是这两个数异或的结果。这个结果中的 1 表示的是 A 和</span><br><span class="line">B 不同的位。我们取异或结果的第一个 1 所在的位数，假如是第 3 位，接着通过比较第三位来将数组分为两组，相同数字一定会</span><br><span class="line">被分到同一组。分组完成后再按照依次异或的思路，求得剩余数字即为两个只出现一次的数字。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="41">
<li>和为 S 的连续正数序列</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">小明很喜欢数学，有一天他在做数学作业时，要求计算出 9~16 的和，他马上就写出了正确答案是 100。但是他并不满足于此，他在想究</span><br><span class="line">竟有多少种连续的正数序列的和为 100（至少包括两个数）。没多久，他就得到另一组连续正数和为 100 的序列：18,19,20,21,22。</span><br><span class="line">现在把问题交给你，你能不能也很快的找出所有和为 S 的连续正数序列？Good Luck!输出描述：输出所有和为 S 的连续正数序列。序</span><br><span class="line">列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">维护一个正数序列数组，数组中初始只含有值 1 和 2，然后从 3 依次往后遍历，每遍历到一个元素则将这个元素加入到序列数组中，然后</span><br><span class="line">判断此时序列数组的和。如果序列数组的和大于所求值，则将第一个元素（最小的元素弹出）。如果序列数组的和小于所求值，则继续</span><br><span class="line">往后遍历，将元素加入到序列中继续判断。当序列数组的和等于所求值时，打印出此时的正数序列，然后继续往后遍历，寻找下一个连</span><br><span class="line">续序列，直到数组遍历完成终止。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-one.html">《和为 s 的连续正数序列》</a></p>
<ol start="42">
<li>和为 S 的两个数字</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个递增排序的数组和一个数字 S，在数组中查找两个数，是的他们的和正好是 S，如果有多对数字的和等于 S，输出两个数</span><br><span class="line">的乘积最小的。输出描述：对应每个测试案例，输出两个数，小的先输出。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先我们通过规律可以发现，和相同的两个数字，两个数字的差值越大，乘积越小。因此我们只需要从数组的首尾开始找到第一对和</span><br><span class="line">为 s 的数字对进行了。因此我们可以使用双指针的方式，左指针初始指向数组的第一个元素，右指针初始指向数组的最后一个元素</span><br><span class="line">。然后首先判断两个指针指向的数字的和是否为 s ，如果为 s ，两个指针指向的数字就是我们需要寻找的数字对。如果两数的和</span><br><span class="line">比 s 小，则将左指针向左移动一位后继续判断。如果两数的和比 s 大，则将右指针向右移动一位后继续判断。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/wuguanglin/p/FindNumbersWithSum.html">《和为 S 的字符串》</a></p>
<ol start="43">
<li>左旋转字符串</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的</span><br><span class="line">字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S=”abcXYZdef”，要求输出循环左移 3 位后的结果，即 “X</span><br><span class="line">YZdefabc”。是不是很简单？OK，搞定它！</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">字符串裁剪后拼接</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="44">
<li>翻转单词顺序列</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有</span><br><span class="line">一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了</span><br><span class="line">，正确的句子应该是“I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过空格将单词分隔，然后将数组反序后，重新拼接为字符串。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="45">
<li>扑克牌的顺子</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有 2 个大王，2 个小王（一副牌原本是 54 张^\_^）...他随机从中抽出</span><br><span class="line">了 5 张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！“红心 A，黑桃 3，小王，大王</span><br><span class="line">，方片 5”，“Oh My God!”不是顺子..... LL 不高兴了，他想了想，决定大\小王可以看成任何数字，并且 A 看作 1，J 为 11，</span><br><span class="line">Q 为 12，K 为 13。上面的 5 张牌就可以变成“1,2,3,4,5”（大小王分别看作 2 和 4），“So Lucky!”。LL 决定去买体育彩票啦。</span><br><span class="line">现在，要求你使用这幅牌模拟上面的过程，然后告诉我们 LL 的运气如何。为了方便起见，你可以认为大小王是 0。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先判断 5 个数字是不是连续的，最直观的方法是把数组排序。值得注意的是，由于 0 可以当成任意数字，我们可以用 0 去补满数</span><br><span class="line">组中的空缺。如果排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，但只要我们有足够的。可以补满这两个数字的空</span><br><span class="line">缺，这个数组实际上还是连续的。</span><br><span class="line"></span><br><span class="line">于是我们需要做 3 件事情：首先把数组排序，再统计数组中 0 的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。如</span><br><span class="line">果空缺的总数小于或者等于 0 的个数，那么这个数组就是连续的：反之则不连续。最后，我们还需要注意一点：如果数组中的非 0</span><br><span class="line">数字重复出现，则该数组不是连续的。换成扑克牌的描述方式就是如果一副牌里含有对子，则不可能是顺子。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-four.html">《扑克牌的顺子》</a></p>
<ol start="46">
<li>圆圈中最后剩下的数字（约瑟夫环问题）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数</span><br><span class="line">字。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）使用环形链表进行模拟。</span><br><span class="line"></span><br><span class="line">（2）根据规律得出（待深入理解）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-five.html">《圆圈中最后剩下的数字》</a></p>
<ol start="47">
<li>1+2+3+…+n</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">求 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">由于不能使用循环语句，因此我们可以通过递归来实现。并且由于不能够使用条件判断运算符，我们可以利用 &amp;&amp; 操作符的短路特</span><br><span class="line">性来实现。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="48">
<li>不用加减乘除做加法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">写一个函数，求两个整数之和，要求在函数体内不得使用 ＋、－、×、÷ 四则运算符号。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过位运算，递归来实现。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="49">
<li>把字符串转换成整数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。数值为 0 或者字符串不是一个合法的数值则返回 0。输入描</span><br><span class="line">述：输入一个字符串，包括数字字母符号，可以为空。输出描述：如果是合法的数值表达则返回该数字，否则返回 0。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先需要进行符号判断，其次我们根据字符串的每位通过减 0 运算转换为整数和，依次根据位数叠加。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="50">
<li>数组中重复的数字</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知</span><br><span class="line">道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）首先将数组排序，排序后再进行判断。这一种方法的时间复杂度为 O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）使用 Map 结构的方式，依次记录下每一个数字出现的次数，从而可以判断是否出现重复数字。这一种方法的时间复杂度为 O</span><br><span class="line">(n)，空间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）从数组首部开始遍历，每遍历一个数字，则将该数字和它的下标相比较，如果数字和下标不等，则将该数字和它对应下标的值</span><br><span class="line">交换。如果对应的下标值上已经是正确的值了，那么说明当前元素是一个重复数字。这一种方法相对于上一种方法来说不需要</span><br><span class="line">额外的内存空间。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="51">
<li>构建乘积数组</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个数组 A[0,1,...,n-1]，请构建一个数组 B[0,1,...,n-1]，其中 B 中的元素 B[i]=A[0]_A[1]_...*A[i-1]*A</span><br><span class="line">[i+1]*...*A[n-1]。不能使用除法。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）  C[i]=A[0]×A[1]×...×A[i-1]=C[i-1]×A[i-1]</span><br><span class="line">      D[i]=A[i+1]×...×A[n-1]=D[i+1]×A[i+1]</span><br><span class="line">      B[i]=C[i]×D[i]</span><br><span class="line">       将乘积分为前后两个部分，分别循环求出后，再进行相乘。</span><br><span class="line"></span><br><span class="line">（2）上面的方法需要额外的内存空间，我们可以引入中间变量的方式，来降低空间复杂度。（待深入理解）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/34804711">《构建乘积数组》</a></p>
<ol start="52">
<li>正则表达式的匹配</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来匹配包括&#x27;.&#x27;和&#x27;_&#x27;的正则表达式。模式中的字符&#x27;.&#x27;表示任意一个字符，而&#x27;_&#x27;表示它前面的字符可以出现任</span><br><span class="line">意次（包含 0 次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，</span><br><span class="line">但是与&quot;aa.a&quot;和&quot;ab\*a&quot;均不匹配。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）状态机思路（待深入理解）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-three.html">《正则表达式匹配》</a></p>
<ol start="53">
<li>表示数值的字符串</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-</span><br><span class="line">16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。、</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用正则表达式实现</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="54">
<li>字符流中第一个不重复的字符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 &quot;go&quot; 时，第一个只出现一次</span><br><span class="line">的字符是 &quot;g&quot; 。当从该字符流中读出前六个字符 &quot;google&quot; 时，第一个只出现一次的字符是 &quot;l&quot;。 输出描述：如果当前字符流</span><br><span class="line">没有存在出现一次的字符，返回#字符。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">同第 34 题</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="55">
<li>链表中环的入口结点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一个链表中包含环，如何找出环的入口结点？</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先使用快慢指针的方式我们可以判断链表中是否存在环，当快慢指针相遇时，说明链表中存在环。相遇点一定存在于环中，因此我</span><br><span class="line">们可以从使用一个指针从这个点开始向前移动，每移动一个点，环的长度加一，当指针再次回到这个点的时候，指针走了一圈，因此</span><br><span class="line">通过这个方法我们可以得到链表中的环的长度，我们将它记为 n 。</span><br><span class="line"></span><br><span class="line">然后我们设置两个指针，首先分别指向头结点，然后将一个指针先移动 n 步，然后两个指针再同时移动，当两个指针相遇时，相遇</span><br><span class="line">点就是环的入口节点。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-six.html">《链表中环的入口结点》</a><br><a href="https://blog.csdn.net/shansusu/article/details/50285735">《《剑指 offer》——链表中环的入口结点》</a></p>
<ol start="56">
<li>删除链表中重复的结点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如，链表 1-&gt;2-&gt;3-</span><br><span class="line"></span><br><span class="line">&gt; 3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">解决这个问题的第一步是确定删除的参数。当然这个函数需要输入待删除链表的头结点。头结点可能与后面的结点重复，也就是说头</span><br><span class="line">结点也可能被删除，所以在链表头额外添加一个结点。</span><br><span class="line"></span><br><span class="line">接下来我们从头遍历整个链表。如果当前结点的值与下一个结点的值相同，那么它们就是重复的结点，都可以被删除。为了保证删除</span><br><span class="line">之后的链表仍然是相连的而没有中间断开，我们要把当前的前一个结点和后面值比当前结点的值要大的结点相连。我们要确保 prev</span><br><span class="line">要始终与下一个没有重复的结点连接在一起。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="57">
<li>二叉树的下一个结点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，</span><br><span class="line">还有一个指向父节点的指针。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">这个问题我们可以分为三种情况来讨论。</span><br><span class="line"></span><br><span class="line">第一种情况，当前节点含有右子树，这种情况下，中序遍历的下一个节点为该节点右子树的最左子节点。因此我们只要从右子节点</span><br><span class="line">出发，一直沿着左子节点的指针，就能找到下一个节点。</span><br><span class="line"></span><br><span class="line">第二种情况是，当前节点不含有右子树，并且当前节点为父节点的左子节点，这种情况下中序遍历的下一个节点为当前节点的父节</span><br><span class="line">点。</span><br><span class="line"></span><br><span class="line">第三种情况是，当前节点不含有右子树，并且当前节点为父节点的右子节点，这种情况下我们沿着父节点一直向上查找，直到找到</span><br><span class="line">一个节点，该节点为父节点的左子节点。这个左子节点的父节点就是中序遍历的下一个节点。</span><br></pre></td></tr></table></figure>

<ol start="58">
<li>对称二叉树</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们对一颗二叉树进行前序遍历的时候，是先访问左子节点，然后再访问右子节点。因此我们可以定义一种对称的前序遍历的方式</span><br><span class="line">，就是先访问右子节点，然后再访问左子节点。通过比较两种遍历方式最后的结果是否相同，以此来判断该二叉树是否为对称二叉</span><br><span class="line">树。</span><br></pre></td></tr></table></figure>

<ol start="59">
<li>按之字形顺序打印二叉树（待深入理解）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，即第一行按照</span><br><span class="line">从左到右的顺序打印，第二层按照从右到左顺序打印，第三行再按照从左到右的顺序打印，其他以此类推。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">按之字形顺序打印二叉树需要两个栈。我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。如果当前打印的是奇数层</span><br><span class="line">，则先保存左子结点再保存右子结点到一个栈里；如果当前打印的是偶数层，则先保存右子结点再保存左子结点到第二个栈里。每</span><br><span class="line">一个栈遍历完成后进入下一层循环。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/wuguanglin/p/Print.html">《按之字形顺序打印二叉树》</a></p>
<ol start="60">
<li>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印一行。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">用一个队列来保存将要打印的结点。为了把二叉树的每一行单独打印到一行里，我们需要两个变量：一个变量表示在当前的层中还</span><br><span class="line">没有打印的结点数，另一个变量表示下一次结点的数目。</span><br></pre></td></tr></table></figure>

<ol start="61">
<li>序列化二叉树（带深入理解）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现两个函数，分别用来序列化和反序列化二叉树。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">数组模拟</span><br></pre></td></tr></table></figure>

<ol start="62">
<li>二叉搜索树的第 K 个节点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一颗二叉搜索树，请找出其中的第 k 小的结点。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">对一颗树首先进行中序遍历，在遍历的同时记录已经遍历的节点数，当遍历到第 k 个节点时，这个节点即为第 k 大的节点。</span><br></pre></td></tr></table></figure>

<ol start="63">
<li>数据流中的中位数（待深入理解）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有值排序之后位于中间的数值。如果数据</span><br><span class="line">流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</span><br></pre></td></tr></table></figure>

<ol start="64">
<li>滑动窗口中的最大值（待深入理解）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组&#123;2,3,4,2,6,2,5,1&#125;及滑动窗口的</span><br><span class="line">大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为&#123;4,4,6,6,6,5&#125;； 针对数组&#123;2,3,4,2,6,2,5,1&#125;的滑动窗口有以下</span><br><span class="line">6 个： &#123;[2,3,4],2,6,2,5,1&#125;， &#123;2,[3,4,2],6,2,5,1&#125;， &#123;2,3,[4,2,6],2,5,1&#125;， &#123;2,3,4,[2,6,2],5,1&#125;， &#123;2</span><br><span class="line">,3,4,2,[6,2,5],1&#125;， &#123;2,3,4,2,6,[2,5,1]&#125;。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用队列的方式模拟</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="65">
<li>矩阵中的路径（待深入理解）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每</span><br><span class="line">一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子</span><br><span class="line">。例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的</span><br><span class="line">第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</span><br></pre></td></tr></table></figure>

<ol start="66">
<li>机器人的运动范围（待深入理解）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">地上有一个 m 行和 n 列的方格。一个机器人从坐标 0,0 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能</span><br><span class="line">进入行坐标和列坐标的数位之和大于 k 的格子。 例如，当 k 为 18 时，机器人能够进入方格（35,37），因为 3+5+3+7 = 18。但是</span><br><span class="line">，它不能进入方格（35,38），因为 3+5+3+8 = 19。请问该机器人能够达到多少个格子？</span><br></pre></td></tr></table></figure>

<p>剑指 offer 相关资料可以参考：</p>
<ul>
<li><a href="https://blog.csdn.net/zzl819954692/article/details/79648054">《剑指 offer 题目练习及思路分析》</a></li>
<li><a href="https://www.cnblogs.com/wuguanglin/p/code-interview.html">《JS 版剑指 offer》</a></li>
<li><a href="https://wiki.jikexueyuan.com/project/for-offer/">《剑指 Offer 学习心得》</a></li>
</ul>
<h2 id="相关算法题"><a href="#相关算法题" class="headerlink" title="相关算法题"></a>相关算法题</h2><ol>
<li><p>明星问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">有 n 个人，其中一个明星和 n-1 个群众，群众都认识明星，明星不认识任何群众，群众和群众之间的认识关系不知道，现有一个</span><br><span class="line">函数 foo(A, B)，若 A 认识 B 返回 true，若 A 不认识 B 返回 false，试设计一种算法找出明星，并给出时间复杂度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法我们可以直接使用双层循环遍历的方式，每一个人都和其他人进行判断，如果一个人谁都不认识，那么他就是明星。</span><br><span class="line">    这一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）上一种方法没有充分利用题目所给的条件，其实我们每一次比较，都可以排除一个人的可能。比如如果 A 认识 B，那么说明</span><br><span class="line">    A 就不会是明星，因此 A 就可以从数组中移除。如果 A 不认识 B，那么说明 B 不可能是明星，因此 B 就可以从数组中移</span><br><span class="line">    除。因此每一次判断都能够减少一个可能性，我们只需要从数组从前往后进行遍历，每次移除一个不可能的人，直到数组中只剩</span><br><span class="line">    一人为止，那么这个人就是明星。这一种方法的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.nowcoder.com/questionTerminal/fd3caff374c945fb9ea5f107016bcd4f">《一个明星和 n-1 个群众》</a></p>
</li>
<li><p>正负数组求和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">有两个数组，一个数组里存放的是正整数，另一个数组里存放的是负整数，都是无序的，现在从两个数组里各拿一个，使得它们的和</span><br><span class="line">最接近零。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）首先我们可以对两个数组分别进行排序，正数数组按从小到大排序，负数数组按从大到小排序。排序完成后我们使用两个指针分</span><br><span class="line">    别指向两个数组的首部，判断两个指针的和。如果和大于0，则负数指针往后移动一个位置，如果和小于0，则正数指针往后移动</span><br><span class="line">    一个位置，每一次记录和的值，和当前保存下来的最小值进行比较。</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识</title>
    <url>/2022/10/19/20221019-web/</url>
    <content><![CDATA[<h1 id="计算机网络知识总结"><a href="#计算机网络知识总结" class="headerlink" title="计算机网络知识总结"></a>计算机网络知识总结</h1><p>本部分主要是笔者在复习计算机网络相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a><ul>
<li><a href="#http-%E5%8D%8F%E8%AE%AE">HTTP 协议</a><ul>
<li><a href="#%E6%A6%82%E5%86%B5">概况</a></li>
<li><a href="#http-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">HTTP 请求报文</a></li>
<li><a href="#http-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">HTTP 响应报文</a></li>
<li><a href="#%E9%A6%96%E9%83%A8%E8%A1%8C">首部行</a></li>
<li><a href="#http11-%E5%8D%8F%E8%AE%AE%E7%BC%BA%E7%82%B9">HTTP/1.1 协议缺点</a></li>
</ul>
</li>
<li><a href="#http2-%E5%8D%8F%E8%AE%AE">HTTP/2 协议</a><ul>
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%8F%E8%AE%AE">二进制协议</a></li>
<li><a href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">多路复用</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%B5%81">数据流</a></li>
<li><a href="#%E5%A4%B4%E4%BF%A1%E6%81%AF%E5%8E%8B%E7%BC%A9">头信息压缩</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81">服务器推送</a></li>
<li><a href="#http2-%E5%8D%8F%E8%AE%AE%E7%BC%BA%E7%82%B9">HTTP/2 协议缺点</a></li>
<li><a href="#http3-%E5%8D%8F%E8%AE%AE">HTTP/3 协议</a></li>
</ul>
</li>
<li><a href="#https-%E5%8D%8F%E8%AE%AE">HTTPS 协议</a><ul>
<li><a href="#http-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">HTTP 存在的问题</a></li>
<li><a href="#https-%E7%AE%80%E4%BB%8B">HTTPS 简介</a></li>
<li><a href="#tls-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">TLS 握手过程</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">实现原理</a></li>
</ul>
</li>
<li><a href="#dns-%E5%8D%8F%E8%AE%AE">DNS 协议</a><ul>
<li><a href="#%E6%A6%82%E5%86%B5-1">概况</a></li>
<li><a href="#%E5%9F%9F%E5%90%8D%E7%9A%84%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84">域名的层级结构</a></li>
<li><a href="#%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B">查询过程</a></li>
<li><a href="#dns-%E8%AE%B0%E5%BD%95%E5%92%8C%E6%8A%A5%E6%96%87">DNS 记录和报文</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2">递归查询和迭代查询</a></li>
<li><a href="#dns-%E7%BC%93%E5%AD%98">DNS 缓存</a></li>
<li><a href="#dns-%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1">DNS 实现负载平衡</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a><ul>
<li><a href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3">多路复用与多路分解</a></li>
<li><a href="#udp-%E5%8D%8F%E8%AE%AE">UDP 协议</a><ul>
<li><a href="#udp-%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84">UDP 报文段结构</a></li>
</ul>
</li>
<li><a href="#tcp-%E5%8D%8F%E8%AE%AE">TCP 协议</a><ul>
<li><a href="#tcp-%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84">TCP 报文段结构</a></li>
<li><a href="#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B">TCP 三次握手的过程</a></li>
<li><a href="#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B">TCP 四次挥手的过程</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96%E5%9B%BE">状态转化图</a></li>
<li><a href="#arq-%E5%8D%8F%E8%AE%AE">ARQ 协议</a></li>
<li><a href="#tcp-%E7%9A%84%E5%8F%AF%E9%9D%A0%E8%BF%90%E8%BE%93%E6%9C%BA%E5%88%B6">TCP 的可靠运输机制</a></li>
<li><a href="#tcp-%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6">TCP 的流量控制机制</a></li>
<li><a href="#tcp-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6">TCP 的拥塞控制机制</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a></li>
<li><a href="#%E7%89%A9%E7%90%86%E5%B1%82">物理层</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98">常考面试题</a><ul>
<li><a href="#1-post-%E5%92%8C-get-%E7%9A%84%E5%8C%BA%E5%88%AB">1. Post 和 Get 的区别？</a></li>
<li><a href="#2-tlsssl-%E4%B8%AD%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E4%B8%89%E4%B8%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%9D%A5%E7%94%9F%E6%88%90%E4%BC%9A%E8%AF%9D%E5%AF%86%E9%92%A5">2. TLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”？</a></li>
<li><a href="#3-ssl-%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80%E5%90%8E%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D">3. SSL 连接断开后如何恢复？</a></li>
<li><a href="#4-rsa-%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E4%BF%9D%E9%9A%9C">4. RSA 算法的安全性保障？</a></li>
<li><a href="#5-dns-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-udp-%E5%8D%8F%E8%AE%AE%E4%BD%9C%E4%B8%BA%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE">5. DNS 为什么使用 UDP 协议作为传输层协议？</a></li>
<li><a href="#6-%E5%BD%93%E4%BD%A0%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-googlecom-%E5%B9%B6%E4%B8%94%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">6. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？</a></li>
<li><a href="#7-%E8%B0%88%E8%B0%88-cdn-%E6%9C%8D%E5%8A%A1">7. 谈谈 CDN 服务？</a></li>
<li><a href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">8. 什么是正向代理和反向代理？</a></li>
<li><a href="#9-%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">9. 负载平衡的两种实现方式？</a></li>
<li><a href="#10-http-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95-options-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">10. http 请求方法 options 方法有什么用？</a></li>
<li><a href="#11-http11-%E5%92%8C-http10-%E4%B9%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB">11. http1.1 和 http1.0 之间有哪些区别？</a></li>
<li><a href="#12-%E7%BD%91%E7%AB%99%E5%9F%9F%E5%90%8D%E5%8A%A0-www-%E4%B8%8E%E4%B8%8D%E5%8A%A0-www-%E7%9A%84%E5%8C%BA%E5%88%AB">12. 网站域名加 www 与不加 www 的区别？</a></li>
<li><a href="#13-%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9F%AD%E8%BD%AE%E8%AF%A2%E9%95%BF%E8%BD%AE%E8%AF%A2sse-%E5%92%8C-websocket-%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">13. 即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？</a></li>
<li><a href="#14-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E7%BD%91%E7%AB%99%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81">14. 怎么实现多个网站之间共享登录状态</a></li>
</ul>
</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、<br>有哪些字段等等。</p>
<h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><h4 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h4><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传<br>输层协议，保证了数据传输的可靠性。</p>
<p>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</p>
<p>HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护<br>一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP<br>连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a<br>live 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持<br>同时建立 6 个持久连接。</p>
<h4 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h4><p>HTTP 报文有两种，一种是请求报文，一种是响应报文。</p>
<p>HTTP 请求报文的格式如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br></pre></td></tr></table></figure>

<p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这<br>个空行不能省略，它用来划分首部与实体。</p>
<p>请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。</p>
<p>方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。一般 GET 方法只被用于向服务器获取数据。<br>POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。HEAD 方法与 GET 方法类似，但是在返回的响应<br>中，不包含请求对象。PUT 方法用于上传文件到服务器，DELETE 方法用于删除服务器上的对象。虽然请求的方法很多，但<br>更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。更多的方法可以参<br>看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">文档</a>。</p>
<h4 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h4><p>HTTP 报文有两种，一种是请求报文，一种是响应报文。</p>
<p>HTTP 响应报文的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。</p>
<p>状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。</p>
<p>实体部分是报文的主要部分，它包含了所请求的对象。</p>
<p>常见的状态有</p>
<p>200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理<br>301-永久移动、302-临时移动、304-所请求的资源未修改、<br>400-客户端请求的语法错误、404-请求的资源不存在<br>500-服务器内部错误。</p>
<p>一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。</p>
<p>更多关于状态码的可以查看：</p>
<p><a href="http://www.runoob.com/http/http-status-codes.html">《HTTP 状态码》</a></p>
<h4 id="首部行"><a href="#首部行" class="headerlink" title="首部行"></a>首部行</h4><p>首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设<br>置，区别在于请求首部和响应首部。</p>
<p>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。</p>
<p>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。</p>
<p>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</p>
<p>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修<br>改时间。</p>
<p>更多关于首部的资料可以查看：</p>
<p><a href="https://www.cnblogs.com/jycboy/p/http_head.html">《HTTP 首部字段详细介绍》</a></p>
<p><a href="https://blog.csdn.net/qq_34289537/article/details/52971516">《图解 HTTP》</a></p>
<h4 id="HTTP-1-1-协议缺点"><a href="#HTTP-1-1-协议缺点" class="headerlink" title="HTTP/1.1 协议缺点"></a>HTTP/1.1 协议缺点</h4><p>HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序<br>是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许<br>多请求排队等待的情况，这种情况被称为“队头堵塞”。队头阻塞会导致持久连接在达到最大数量时，剩余的资源需要等待其他<br>资源请求完成后才能发起请求。</p>
<p>为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的<br>原因。</p>
<h3 id="HTTP-2-协议"><a href="#HTTP-2-协议" class="headerlink" title="HTTP/2 协议"></a>HTTP/2 协议</h3><p>2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在 Chrome 浏览器上证明<br>可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。2015 年，HTTP/2 发布。</p>
<p>HTTP/2 主要有以下新的特性：</p>
<h4 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h4><p>HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是<br>二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。<br>帧的概念是它实现多路复用的基础。</p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回<br>应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”的问题。</p>
<h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的<br>请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每<br>个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。</p>
<h4 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h4><p>HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是<br>重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p>
<p>HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，<br>客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引<br>号，这样就能提高速度了。</p>
<h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源<br>，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用<br>SSE 等方式向客户端发送即时数据的推送是不同的。</p>
<p>详细的资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP 协议入门》</a><br><a href="http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html">《HTTP/2 服务器推送（Server Push）教程》</a></p>
<h4 id="HTTP-2-协议缺点"><a href="#HTTP-2-协议缺点" class="headerlink" title="HTTP/2 协议缺点"></a>HTTP/2 协议缺点</h4><p>因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵<br>守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都<br>会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。</p>
<h4 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h4><p>由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC<br>协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能</p>
<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/302412059">《如何看待 HTTP/3 ？》</a></p>
<h3 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h3><h4 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h4><ol>
<li><p>HTTP 报文使用明文方式发送，可能被第三方窃听。</p>
</li>
<li><p>HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。</p>
</li>
<li><p>HTTP 还存在认证的问题，第三方可以冒充他人参与通信。</p>
</li>
</ol>
<h4 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h4><p>HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/<br>SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立<br>刻发现。它还配备了身份证书，防止身份被冒充的情况出现。</p>
<h4 id="TLS-握手过程"><a href="#TLS-握手过程" class="headerlink" title="TLS 握手过程"></a>TLS 握手过程</h4><ol>
<li><p>第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</p>
</li>
<li><p>第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</p>
</li>
<li><p>第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</p>
</li>
<li><p>第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</p>
</li>
<li><p>第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥<br>来加密信息。</p>
</li>
</ol>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>TLS 的握手过程主要用到了三个方法来保证传输的安全。</p>
<p>首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就<br>是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。<br>这就要用到非对称加密的方法。</p>
<p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p>
<p>因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存在的问题。</p>
<p>但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。</p>
<p>为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改<br>了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样我们才能保证数据的安全。</p>
<p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA">《一个故事讲完 https》</a><br><a href="http://ruanyifeng.com/blog/2014/02/ssl_tls.html">《SSL/TLS 协议运行机制的概述》</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">《图解 SSL/TLS 协议》</a><br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">《RSA 算法原理（一）》</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">《RSA 算法原理（二）》</a><br><a href="https://juejin.im/post/5ad6ad575188255c272273c4">《分分钟让你理解 HTTPS》</a></p>
<h3 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h3><h4 id="概况-1"><a href="#概况-1" class="headerlink" title="概况"></a>概况</h4><p>DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分<br>布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 号<br>端口。</p>
<h4 id="域名的层级结构"><a href="#域名的层级结构" class="headerlink" title="域名的层级结构"></a>域名的层级结构</h4><p>域名的层级结构可以如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主机名.次级域名.顶级域名.根域名</span><br><span class="line"></span><br><span class="line"># 即</span><br><span class="line"></span><br><span class="line">host.sld.tld.root</span><br></pre></td></tr></table></figure>

<p>根据域名的层级结构，管理不同层级域名的服务器，可以分为根域名服务器、顶级域名服务器和权威域名服务器。</p>
<h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h4><p>DNS 的查询过程一般为，我们首先将 DNS 请求发送到本地 DNS 服务器，由本地 DNS 服务器来代为请求。</p>
<ol>
<li>从”根域名服务器”查到”顶级域名服务器”的 NS 记录和 A 记录（ IP 地址）。</li>
<li>从”顶级域名服务器”查到”次级域名服务器”的 NS 记录和 A 记录（ IP 地址）。</li>
<li>从”次级域名服务器”查出”主机名”的 IP 地址。</li>
</ol>
<p>比如我们如果想要查询 <a href="http://www.baidu.com/">www.baidu.com</a> 的 IP 地址，我们首先会将请求发送到本地的 DNS 服务器中，本地 DNS 服务<br>器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名<br>服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com<br>的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服<br>务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p>
<h4 id="DNS-记录和报文"><a href="#DNS-记录和报文" class="headerlink" title="DNS 记录和报文"></a>DNS 记录和报文</h4><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p>
<p>（Name，Value，Type，TTL）</p>
<p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p>
<p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。</p>
<ol>
<li><p>如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标<br>准的主机名到 IP 地址的映射。</p>
</li>
<li><p>如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式<br>查询时，返回下一级需要查询的 DNS 服务器的信息。</p>
</li>
<li><p>如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名<br>对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供<br>一个便于记忆的简单的别名。</p>
</li>
<li><p>如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一<br>样的，都是为了解决规范主机名不利于记忆的缺点。</p>
</li>
</ol>
<h4 id="递归查询和迭代查询"><a href="#递归查询和迭代查询" class="headerlink" title="递归查询和迭代查询"></a>递归查询和迭代查询</h4><p>递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归<br>查询，用户只需要发出一次查询请求。</p>
<p>迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出<br>多次的查询请求。</p>
<p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我<br>们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次<br>查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p>
<h4 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h4><p>DNS 缓存的原理非常简单，在一个请求链中，当某个 DNS 服务器接收到一个 DNS 回答后，它能够将回答中的信息缓存在本<br>地存储器中。返回的资源记录中的 TTL 代表了该条记录的缓存的时间。</p>
<h4 id="DNS-实现负载平衡"><a href="#DNS-实现负载平衡" class="headerlink" title="DNS 实现负载平衡"></a>DNS 实现负载平衡</h4><p>DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应<br>多个服务器地址。当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在<br>每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不<br>同的服务器上，这样来实现负载均衡。</p>
<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html">《DNS 原理入门》</a><br><a href="http://www.ruanyifeng.com/blog/2018/05/root-domain.html">《根域名的知识》</a></p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。传输层只工作在端系统中。</p>
<h3 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h3><p>将传输层报文段中的数据交付到正确的套接字的工作被称为多路分解。</p>
<p>在源主机上从不同的套接字中收集数据，封装头信息生成报文段后，将报文段传递到网络层，这个过程被称为多路复用。</p>
<p>无连接的多路复用和多路分解指的是 UDP 套接字的分配过程，一个 UDP 套接字由一个二元组来标识，这个二元组包含了一<br>个目的地址和一个目的端口号。因此不同源地址和端口号的 UDP 报文段到达主机后，如果它们拥有相同的目的地址和目的端<br>口号，那么不同的报文段将会转交到同一个 UDP 套接字中。</p>
<p>面向连接的多路复用和多路分解指的是 TCP 套接字的分配过程，一个 TCP 套接字由一个四元组来标识，这个四元组包含了<br>源 IP 地址、源端口号、目的地址和目的端口号。因此，一个 TCP 报文段从网络中到达一台主机上时，该主机使用全部 4 个<br>值来将报文段定向到相应的套接字。</p>
<h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>UDP 是一种无连接的，不可靠的传输层协议。它只提供了传输层需要实现的最低限度的功能，除了复用/分解功能和少量的差<br>错检测外，它几乎没有对 IP 增加其他的东西。UDP 协议适用于对实时性要求高的应用场景。</p>
<p>特点：</p>
<ol>
<li><p>使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。因为没有握手<br>过程，相对于 TCP 来说，没有建立连接的时延。因为没有连接，所以不需要在端系统中保存连接的状态。</p>
</li>
<li><p>UDP 提供尽力而为的交付服务，也就是说 UDP 协议不保证数据的可靠交付。</p>
</li>
<li><p>UDP 没有拥塞控制和流量控制的机制，所以 UDP 报文段的发送速率没有限制。</p>
</li>
<li><p>因为一个 UDP 套接字只使用目的地址和目的端口来标识，所以 UDP 可以支持一对一、一对多、多对一和多对多的交互<br>通信。</p>
</li>
<li><p>UDP 首部小，只有 8 个字节。</p>
</li>
</ol>
<h4 id="UDP-报文段结构"><a href="#UDP-报文段结构" class="headerlink" title="UDP 报文段结构"></a>UDP 报文段结构</h4><p>UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，分别是源端口号、目的端口号、长度和检验和，每个字段的长<br>度为两个字节。长度字段指的是整个报文段的长度，包含了首部和应用数据的大小。校验和是 UDP 提供的一种差错校验机制。<br>虽然提供了差错校验的机制，但是 UDP 对于差错的恢复无能为力。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-16.png" alt="UDP 报文段结构"></p>
<h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>TCP 协议是面向连接的，提供可靠数据传输服务的传输层协议。</p>
<p>特点：</p>
<ol>
<li><p>TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。它需要在端系统中维护双方连接的状态信息。</p>
</li>
<li><p>TCP 协议通过序号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务。</p>
</li>
<li><p>TCP 协议提供的是点对点的服务，即它是在单个发送方和单个接收方之间的连接。</p>
</li>
<li><p>TCP 协议提供的是全双工的服务，也就是说连接的双方的能够向对方发送和接收数据。</p>
</li>
<li><p>TCP 提供了拥塞控制机制，在网络拥塞的时候会控制发送数据的速率，有助于减少数据包的丢失和减轻网络中的拥塞程度。</p>
</li>
<li><p>TCP 提供了流量控制机制，保证了通信双方的发送和接收速率相同。如果接收方可接收的缓存很小时，发送方会降低发送<br>速率，避免因为缓存填满而造成的数据包的丢失。</p>
</li>
</ol>
<h4 id="TCP-报文段结构"><a href="#TCP-报文段结构" class="headerlink" title="TCP 报文段结构"></a>TCP 报文段结构</h4><p>TCP 报文段由首部和数据组成，它的首部一般为 20 个字节。</p>
<p>源端口和目的端口号用于报文段的多路复用和分解。</p>
<p>32 比特的序号和 32 比特的确认号，用与实现可靠数据运输服务。</p>
<p>16 比特的接收窗口字段用于实现流量控制，该字段表示接收方愿意接收的字节的数量。</p>
<p>4 比特的首部长度字段，该字段指示了以 32 比特的字为单位的 TCP 首部的长度。</p>
<p>6 比特的标志字段，ACK 字段用于指示确认序号的值是有效的，RST、SYN 和 FIN 比特用于连接建立和拆除。设置 PSH 字<br>段指示接收方应该立即将数据交给上层，URG 字段用来指示报文段里存在紧急的数据。</p>
<p>校验和提供了对数据的差错检测。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-17.png" alt="TCP 报文段结构"></p>
<h4 id="TCP-三次握手的过程"><a href="#TCP-三次握手的过程" class="headerlink" title="TCP 三次握手的过程"></a>TCP 三次握手的过程</h4><p>第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的<br>随机数。它代表的是客户端数据的初始序号。</p>
<p>第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向<br>客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认，<br>同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加<br>一。</p>
<p>第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务<br>器端的报文段的确认。第三次握手可以在报文段中携带数据。</p>
<p>在我看来，TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。<br>第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否<br>已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p>
<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/24853633">《TCP 为什么是三次握手，而不是两次或四次？》</a><br><a href="https://blog.csdn.net/qzcsu/article/details/72861891">《TCP 的三次握手与四次挥手》</a></p>
<h4 id="TCP-四次挥手的过程"><a href="#TCP-四次挥手的过程" class="headerlink" title="TCP 四次挥手的过程"></a>TCP 四次挥手的过程</h4><p>因为 TCP 连接是全双工的，也就是说通信的双方都可以向对方发送和接收消息，所以断开连接需要双方的确认。</p>
<p>第一次挥手，客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 FIN 报文段，申请断开客户端到服务器端的<br>连接。发送后客户端进入 FIN_WAIT_1 状态。</p>
<p>第二次挥手，服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的<br>请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务<br>器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。</p>
<p>第三次挥手，服务器端发送完所有数据后，向客户端发送 FIN 报文段，申请断开服务器端到客户端的连接。发送后进入 LAS<br>T_ACK 状态。</p>
<p>第四次挥手，客户端接收到 FIN 请求后，向服务器端发送一个确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间，<br>这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到<br>服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被<br>释放了。</p>
<p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代<br>表不能再向对方发送数据，连接处于的是半释放的状态。</p>
<p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器<br>端不能正常关闭。</p>
<p>详细资料可以参考：</p>
<p><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5c447392e51d45524b02eaf5">《前端面试之道》</a></p>
<h4 id="状态转化图"><a href="#状态转化图" class="headerlink" title="状态转化图"></a>状态转化图</h4><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-18.png" alt="客户端状态图"></p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-19.png" alt="服务端状态图"></p>
<h4 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h4><p>ARQ 协议指的是自动重传请求，它通过超时和重传来保证数据的可靠交付，它是 TCP 协议实现可靠数据传输的一个很重要的<br>机制。</p>
<p>它分为停止等待 ARQ 协议和连续 ARQ 协议。</p>
<p>一、停止等待 ARQ 协议</p>
<p>停止等待 ARQ 协议的基本原理是，对于发送方来说发送方每发送一个分组，就为这个分组设置一个定时器。当发送分组的确认<br>回答返回了，则清除定时器，发送下一个分组。如果在规定的时间内没有收到已发送分组的肯定回答，则重新发送上一个分组。</p>
<p>对于接受方来说，每次接受到一个分组，就返回对这个分组的肯定应答，当收到冗余的分组时，就直接丢弃，并返回一个对冗余<br>分组的确认。当收到分组损坏的情况的时候，直接丢弃。</p>
<p>使用停止等待 ARQ 协议的缺点是每次发送分组必须等到分组确认后才能发送下一个分组，这样会造成信道的利用率过低。</p>
<p>二、连续 ARQ 协议</p>
<p>连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的利用率过低的问题。它通过连续发送一组分组，然后再等待对分组的<br>确认回答，对于如何处理分组中可能出现的差错恢复情况，一般可以使用滑动窗口协议和选择重传协议来实现。</p>
<ol>
<li>滑动窗口协议</li>
</ol>
<p>使用滑动窗口协议，在发送方维持了一个发送窗口，发送窗口以前的分组是已经发送并确认了的分组，发送窗口中包含了已经发<br>送但未确认的分组和允许发送但还未发送的分组，发送窗口以后的分组是缓存中还不允许发送的分组。当发送方向接收方发送分<br>组时，会依次发送窗口内的所有分组，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的分组。如果在定<br>时器的时间内收到某一个分组的确认回答，则滑动窗口，将窗口的首部移动到确认分组的后一个位置，此时如果还有已发送但没<br>有确认的分组，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的分<br>组。</p>
<p>接收方使用的是累计确认的机制，对于所有按序到达的分组，接收方返回一个分组的肯定回答。如果收到了一个乱序的分组，那<br>么接方会直接丢弃，并返回一个最近的按序到达的分组的肯定回答。使用累计确认保证了确认号以前的分组都已经按序到达了，<br>所以发送窗口可以移动到已确认分组的后面。</p>
<p>滑动窗口协议的缺点是因为使用了累计确认的机制，如果出现了只是窗口中的第一个分组丢失，而后面的分组都按序到达的情况<br>的话，那么滑动窗口协议会重新发送所有的分组，这样就造成了大量不必要分组的丢弃和重传。</p>
<ol start="2">
<li>选择重传协议</li>
</ol>
<p>因为滑动窗口使用累计确认的方式，所以会造成很多不必要分组的重传。使用选择重传协议可以解决这个问题。</p>
<p>选择重传协议在发送方维护了一个发送窗口。发送窗口的以前是已经发送并确认的分组，窗口内包含了已发送但未被确认的分组，<br>已确认的乱序分组，和允许发送但还未发送的分组，发送窗口以后的是缓存中还不允许发送的分组。选择重传协议与滑动窗口协<br>议最大的不同是，发送方发送分组时，为一个分组都创建了一个定时器。当发送方接受到一个分组的确认应答后，取消该分组的<br>定时器，并判断接受该分组后，是否存在由窗口首部为首的连续的确认分组，如果有则向后移动窗口的位置，如果没有则将该分<br>组标识为已接收的乱序分组。当某一个分组定时器到时后，则重新传递这个分组。</p>
<p>在接收方，它会确认每一个正确接收的分组，不管这个分组是按序的还是乱序的，乱序的分组将被缓存下来，直到所有的乱序分<br>组都到达形成一个有序序列后，再将这一段分组交付给上层。对于不能被正确接收的分组，接收方直接忽略该分组。</p>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/guoweimelon/article/details/50879588">《TCP 连续 ARQ 协议和滑动窗口协议》</a></p>
<h4 id="TCP-的可靠运输机制"><a href="#TCP-的可靠运输机制" class="headerlink" title="TCP 的可靠运输机制"></a>TCP 的可靠运输机制</h4><p>TCP 的可靠运输机制是基于连续 ARQ 协议和滑动窗口协议的。</p>
<p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但<br>未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发<br>送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。<br>如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如<br>果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送<br>但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示，<br>说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发<br>送但确认的报文段。</p>
<p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文<br>段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都<br>已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p>
<p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文<br>段的发送速率。</p>
<p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重<br>传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p>
<h4 id="TCP-的流量控制机制"><a href="#TCP-的流量控制机制" class="headerlink" title="TCP 的流量控制机制"></a>TCP 的流量控制机制</h4><p>TCP 提供了流量控制的服务，这个服务的主要目的是控制发送方的发送速率，保证接收方来得及接收。因为一旦发送的速率大<br>于接收方所能接收的速率，就会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据<br>接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。</p>
<h4 id="TCP-的拥塞控制机制"><a href="#TCP-的拥塞控制机制" class="headerlink" title="TCP 的拥塞控制机制"></a>TCP 的拥塞控制机制</h4><p>TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞的状态，发送方就减小发送的<br>速率，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。</p>
<p>TCP 的拥塞控制主要使用了四个机制，分别是慢启动、拥塞避免、快速重传和快速恢复。</p>
<p>慢启动的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探<br>，每次收到一个确认报文，就将发动窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达<br>到一个阈值的时候就进入拥塞避免算法。</p>
<p>拥塞避免算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。<br>这样将窗口的增长速率由指数增长，变为加法线性增长。</p>
<p>快速重传指的是，当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的<br>丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。</p>
<p>快速恢复是对快速重传的后续处理，因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥<br>塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。</p>
<p>TCP 认为网络拥塞的主要依据是报文段的重传次数，它会根据网络中的拥塞程度，通过调整慢启动的阀值，然后交替使用上面四<br>种机制来达到拥塞控制的目的。</p>
<p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/7d59f9292b03">《TCP 的拥塞控制机制》</a><br><a href="http://www.voidcn.com/article/p-vrdkquop-ms.html">《网络基本功：TCP 拥塞控制机制》</a></p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层协议主要实现了不同主机间的逻辑通信功能。网络层协议一共包含两个主要的组件，一个 IP 网际协议，一个是路由选<br>择协议。</p>
<p>IP 网际协议规定了网络层的编址和转发方式，比如说我们接入网络的主机都会被分配一个 IP 地址，常用的比如 IPV4 使用<br>32 位来分配地址，还有 IPv6 使用 128 位来分配地址。</p>
<p>路由选择协议决定了数据报从源到目的地所流经的路径，常见的比如距离向量路由选择算法等。</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层提供的服务是如何将数据报通过单一通信链路从一个结点移动到相邻节点。每一台主机都有一个唯一的 MAC 地址，<br>这是由网络适配器决定的，在全世界都是独一无二的。</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层提供的服务是尽可能的屏蔽掉组成网络的物理设备和传输介质间的差异，使数据链路层不需要考虑网络的具体传输介质<br>是什么。</p>
<p>详细资料可以参考：<br><a href="https://juejin.im/post/5b7be0b2e51d4538db34a51e#heading-1">《搞定计算机网络面试，看这篇就够了（补充版）》</a><br><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">《互联网协议入门（一）》</a><br><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html">《互联网协议入门（二）》</a></p>
<h2 id="常考面试题"><a href="#常考面试题" class="headerlink" title="常考面试题"></a>常考面试题</h2><h4 id="1-Post-和-Get-的区别？"><a href="#1-Post-和-Get-的区别？" class="headerlink" title="1. Post 和 Get 的区别？"></a>1. Post 和 Get 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Post 和 Get 是 HTTP 请求的两种方法。</span><br><span class="line"></span><br><span class="line">（1）从应用场景上来说，GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网</span><br><span class="line">页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。</span><br><span class="line"></span><br><span class="line">（2）因为不同的应用场景，所以浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</span><br><span class="line"></span><br><span class="line">（3）从发送的报文格式来说，Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</span><br><span class="line"></span><br><span class="line">（4）但是 Get 请求也可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说，一个方面是不太安全，</span><br><span class="line">因为请求的 url 会被保留在历史记录中。并且浏览器由于对 url 有一个长度上的限制，所以会影响 get 请求发送数据时</span><br><span class="line">的长度。这个限制是浏览器规定的，并不是 RFC 规定的。还有就是 post 的参数传递支持更多的数据类型。</span><br></pre></td></tr></table></figure>

<h4 id="2-TLS-SSL-中什么一定要用三个随机数，来生成”会话密钥”？"><a href="#2-TLS-SSL-中什么一定要用三个随机数，来生成”会话密钥”？" class="headerlink" title="2. TLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”？"></a>2. TLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端和服务器都需要生成随机数，以此来保证每次生成的秘钥都不相同。使用三个随机数，是因为 SSL 的协议默认不信任每个主</span><br><span class="line">机都能产生完全随机的数，如果只使用一个伪随机的数来生成秘钥，就很容易被破解。通过使用三个随机数的方式，增加了自由度，</span><br><span class="line">一个伪随机可能被破解，但是三个伪随机就很接近于随机了，因此可以使用这种方法来保持生成秘钥的随机性和安全性。</span><br></pre></td></tr></table></figure>

<h4 id="3-SSL-连接断开后如何恢复？"><a href="#3-SSL-连接断开后如何恢复？" class="headerlink" title="3. SSL 连接断开后如何恢复？"></a>3. SSL 连接断开后如何恢复？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。</span><br><span class="line"></span><br><span class="line">使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器</span><br><span class="line">如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是</span><br><span class="line">这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那</span><br><span class="line">么就无法恢复对话。</span><br><span class="line"></span><br><span class="line">另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的</span><br><span class="line">，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器</span><br><span class="line">上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。</span><br></pre></td></tr></table></figure>

<h4 id="4-RSA-算法的安全性保障？"><a href="#4-RSA-算法的安全性保障？" class="headerlink" title="4. RSA 算法的安全性保障？"></a>4. RSA 算法的安全性保障？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。现在102</span><br><span class="line">4位的 RSA 密钥基本安全，2048位的密钥极其安全。</span><br></pre></td></tr></table></figure>

<h4 id="5-DNS-为什么使用-UDP-协议作为传输层协议？"><a href="#5-DNS-为什么使用-UDP-协议作为传输层协议？" class="headerlink" title="5. DNS 为什么使用 UDP 协议作为传输层协议？"></a>5. DNS 为什么使用 UDP 协议作为传输层协议？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。因为为了得到一个域名的 IP 地</span><br><span class="line">址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢，因为大</span><br><span class="line">多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。</span><br><span class="line"></span><br><span class="line">使用 UDP 协议作为 DNS 协议会有一个问题，由于历史原因，物理链路的最小MTU = 576，所以为了限制报文长度不超过576，</span><br><span class="line">UDP 的报文段的长度被限制在 512 个字节以内，这样一旦 DNS 的查询或者应答报文，超过了 512 字节，那么基于 UDP 的</span><br><span class="line">DNS 协议就会被截断为 512 字节，那么有可能用户得到的 DNS 应答就是不完整的。这里 DNS 报文的长度一旦超过限制，并不</span><br><span class="line">会像 TCP 协议那样被拆分成多个报文段传输，因为 UDP 协议不会维护连接状态，所以我们没有办法确定那几个报文段属于同一</span><br><span class="line">个数据，UDP 只会将多余的数据给截取掉。为了解决这个问题，我们可以使用 TCP 协议去请求报文。</span><br><span class="line"></span><br><span class="line">DNS 还存在的一个问题是安全问题，就是我们没有办法确定我们得到的应答，一定是一个安全的应答，因为应答可以被他人伪造，</span><br><span class="line">所以现在有了 DNS over HTTPS 来解决这个问题。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/310145373">《为什么 DNS 使用 UDP 而不是 TCP？》</a></p>
<h4 id="6-当你在浏览器中输入-Google-com-并且按下回车之后发生了什么？"><a href="#6-当你在浏览器中输入-Google-com-并且按下回车之后发生了什么？" class="headerlink" title="6. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？"></a>6. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，</span><br><span class="line">将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字</span><br><span class="line">符，则对非法字符进行转义后再进行下一过程。</span><br><span class="line"></span><br><span class="line">（2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新</span><br><span class="line">的请求。</span><br><span class="line"></span><br><span class="line">（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果</span><br><span class="line">有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域</span><br><span class="line">名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地</span><br><span class="line">址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用</span><br><span class="line">户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</span><br><span class="line"></span><br><span class="line">（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源</span><br><span class="line">端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给</span><br><span class="line">数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地</span><br><span class="line">址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果</span><br><span class="line">在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该</span><br><span class="line">转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应</span><br><span class="line">该为网关的地址。</span><br><span class="line"></span><br><span class="line">（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接</span><br><span class="line">收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的</span><br><span class="line">确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立</span><br><span class="line">状态，此时双方的连接就建立起来了。</span><br><span class="line"></span><br><span class="line">（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版</span><br><span class="line">本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证</span><br><span class="line">书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后</span><br><span class="line">发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解</span><br><span class="line">密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加</span><br><span class="line">密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</span><br><span class="line"></span><br><span class="line">（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行</span><br><span class="line">解析，开始页面的渲染过程。</span><br><span class="line"></span><br><span class="line">（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端</span><br><span class="line">是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建</span><br><span class="line">立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页</span><br><span class="line">面进行绘制。这个时候整个页面就显示出来了。</span><br><span class="line"></span><br><span class="line">（9）最后一步是 TCP 断开连接的四次挥手过程。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://blog.jobbole.com/84870/">《当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？》</a></p>
<h4 id="7-谈谈-CDN-服务？"><a href="#7-谈谈-CDN-服务？" class="headerlink" title="7. 谈谈 CDN 服务？"></a>7. 谈谈 CDN 服务？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资就近访问的</span><br><span class="line">功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器将请求定位到最近的含有该资源</span><br><span class="line">的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/36514327?rf=37353035">《CDN 是什么？使用 CDN 有什么优势？》</a></p>
<h4 id="8-什么是正向代理和反向代理？"><a href="#8-什么是正向代理和反向代理？" class="headerlink" title="8. 什么是正向代理和反向代理？"></a>8. 什么是正向代理和反向代理？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的</span><br><span class="line">服务都被代理服务器代替来请求。</span><br><span class="line"></span><br><span class="line">反向代理隐藏了真实的服务端，当我们请求一个网站的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，我们不知</span><br><span class="line">道，也不需要知道，我们只需要知道反向代理服务器是谁就好了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。反向</span><br><span class="line">代理器一般用来实现负载平衡。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s/ikrI3rmSYs83wdSWqq2QIg">《正向代理与反向代理有什么区别》</a><br><a href="https://segmentfault.com/q/1010000017502539/a-1020000017532348">《webpack 配置 proxy 反向代理的原理是什么？》</a></p>
<h4 id="9-负载平衡的两种实现方式？"><a href="#9-负载平衡的两种实现方式？" class="headerlink" title="9. 负载平衡的两种实现方式？"></a>9. 负载平衡的两种实现方式？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实</span><br><span class="line">现集群的负载平衡。</span><br><span class="line"></span><br><span class="line">另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一</span><br><span class="line">个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在</span><br><span class="line">每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服</span><br><span class="line">务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解</span><br><span class="line">析仍然返回的是那个 IP 地址，就会造成访问的问题。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5Njc2OTg4NQ==&mid=2247483870&idx=1&sn=bab36544ec62c394c104df699cf85154&chksm=90aa43eca7ddcafa01634cefee12fd8a332250d3f49d8b6647f536c215ac297e4b6a53af8253#rd">《负载均衡的原理》</a></p>
<h4 id="10-http-请求方法-options-方法有什么用？"><a href="#10-http-请求方法-options-方法有什么用？" class="headerlink" title="10. http 请求方法 options 方法有什么用？"></a>10. http 请求方法 options 方法有什么用？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。这个方法会请求服务器返回该资源所支持的所有 HTTP 请</span><br><span class="line">求方法，该方法会用&#x27;*&#x27;来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JS 的 XMLHttpRequest</span><br><span class="line">对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</span><br></pre></td></tr></table></figure>

<p>相关资料可以参考：<br><a href="https://itbilu.com/other/relate/EkwKysXIl.html">《HTTP 请求方法》</a></p>
<h4 id="11-http1-1-和-http1-0-之间有哪些区别？"><a href="#11-http1-1-和-http1-0-之间有哪些区别？" class="headerlink" title="11. http1.1 和 http1.0 之间有哪些区别？"></a>11. http1.1 和 http1.0 之间有哪些区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http1.1 相对于 http1.0 有这样几个区别：</span><br><span class="line">（1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</span><br><span class="line">（2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</span><br><span class="line"></span><br><span class="line">（3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</span><br><span class="line"></span><br><span class="line">（4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。</span><br><span class="line"></span><br><span class="line">（5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/entry/5981c5df518825359a2b9476">《HTTP1.0、HTTP1.1 和 HTTP2.0 的区别》</a><br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP 协议入门》</a><br><a href="https://blog.csdn.net/netdxy/article/details/51195560">《网络—一篇文章详解请求头 Host 的概念》</a></p>
<h4 id="12-网站域名加-www-与不加-www-的区别？"><a href="#12-网站域名加-www-与不加-www-的区别？" class="headerlink" title="12. 网站域名加 www 与不加 www 的区别？"></a>12. 网站域名加 www 与不加 www 的区别？</h4><p>详细资料可以参考：<br><a href="https://www.f9seo.com/post-816.html">《为什么域名前要加 www 前缀 www 是什么意思？》</a><br><a href="https://www.zhihu.com/question/20414602">《为什么越来越多的网站域名不加「www」前缀？》</a><br><a href="https://blog.csdn.net/andybruse/article/details/7982278">《域名有 www 与没有 www 有什么区别？》</a></p>
<h4 id="13-即时通讯的实现，短轮询、长轮询、SSE-和-WebSocket-间的区别？"><a href="#13-即时通讯的实现，短轮询、长轮询、SSE-和-WebSocket-间的区别？" class="headerlink" title="13. 即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？"></a>13. 即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</span><br><span class="line"></span><br><span class="line">短轮询的基本思路就是浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行</span><br><span class="line">响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客</span><br><span class="line">户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 ht</span><br><span class="line">tp 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</span><br><span class="line"></span><br><span class="line">长轮询的基本思路是，首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将</span><br><span class="line">这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。</span><br><span class="line">客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的</span><br><span class="line">优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</span><br><span class="line"></span><br><span class="line">SSE 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通</span><br><span class="line">方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断</span><br><span class="line">地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机</span><br><span class="line">制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不</span><br><span class="line">需要建立过多的 http 请求，相比之下节约了资源。</span><br><span class="line"></span><br><span class="line">上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。WebSocket 是 Html5 定义的一个新协</span><br><span class="line">议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置</span><br><span class="line">比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能</span><br><span class="line">由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://cloud.tencent.com/developer/article/1076547">《轮询、长轮询、长连接、websocket》</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html">《Server-Sent Events 教程》</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">《WebSocket 教程》</a></p>
<h4 id="14-怎么实现多个网站之间共享登录状态"><a href="#14-怎么实现多个网站之间共享登录状态" class="headerlink" title="14. 怎么实现多个网站之间共享登录状态"></a>14. 怎么实现多个网站之间共享登录状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</span><br><span class="line"></span><br><span class="line">我认为单点登录可以这样来实现，首先将用户信息的验证中心独立出来，作为一个单独的认证中心，该认证中心的作用是判断客户端发</span><br><span class="line">送的账号密码的正确性，然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密的登录信息的 token 给客户端，该</span><br><span class="line">token 具有一定的有效时限。当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式来传递 token，然后转移到的应用站</span><br><span class="line">点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端返回对应的用户信息，如果失效了则将</span><br><span class="line">页面重定向会单点登录页面。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/35906139">《HTTP 是个无状态协议，怎么保持登录状态？》</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Html</title>
    <url>/2022/10/19/20221019-Html/</url>
    <content><![CDATA[<h2 id="HTML-面试知识点总结"><a href="#HTML-面试知识点总结" class="headerlink" title="HTML 面试知识点总结"></a>HTML 面试知识点总结</h2><p>本部分主要是笔者在复习 HTML 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#1-doctype-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">1. DOCTYPE 的作用是什么？</a></li>
<li><a href="#2-%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%BC%E5%AE%B9%E6%A8%A1%E5%BC%8F%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">2. 标准模式与兼容模式各有什么区别？</a></li>
<li><a href="#3-html5-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E9%9C%80%E8%A6%81%E5%86%99-doctype-html%E8%80%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5-dtd">3. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;，而不需要引入 DTD？</a></li>
<li><a href="#4-sgml--html-xml-%E5%92%8C-xhtml-%E7%9A%84%E5%8C%BA%E5%88%AB">4. SGML 、 HTML 、XML 和 XHTML 的区别？</a></li>
<li><a href="#-5-dtd-%E4%BB%8B%E7%BB%8D">5. DTD 介绍</a></li>
<li><a href="#6-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%AE%9A%E4%B9%89">6. 行内元素定义</a></li>
<li><a href="#7-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%AE%9A%E4%B9%89">7. 块级元素定义</a></li>
<li><a href="#8-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB">8. 行内元素与块级元素的区别？</a></li>
<li><a href="#9-html5-%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%86%E7%B1%BB">9. HTML5 元素的分类</a></li>
<li><a href="#10-%E7%A9%BA%E5%85%83%E7%B4%A0%E5%AE%9A%E4%B9%89">10. 空元素定义</a></li>
<li><a href="#11-link-%E6%A0%87%E7%AD%BE%E5%AE%9A%E4%B9%89">11. link 标签定义</a></li>
<li><a href="#12-%E9%A1%B5%E9%9D%A2%E5%AF%BC%E5%85%A5%E6%A0%B7%E5%BC%8F%E6%97%B6%E4%BD%BF%E7%94%A8-link-%E5%92%8C-import-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">12. 页面导入样式时，使用 link 和 @import 有什么区别？</a></li>
<li><a href="#13-%E4%BD%A0%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3">13. 你对浏览器的理解？</a></li>
<li><a href="#14-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E7%9A%84%E7%90%86%E8%A7%A3">14. 介绍一下你对浏览器内核的理解？</a></li>
<li><a href="#15-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E6%AF%94%E8%BE%83">15. 常见的浏览器内核比较</a></li>
<li><a href="#16-%E5%B8%B8%E8%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E7%94%A8%E5%86%85%E6%A0%B8">16. 常见浏览器所用内核</a></li>
<li><a href="#17-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86">17. 浏览器的渲染原理？</a></li>
<li><a href="#18-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0-js-%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B">18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）</a></li>
<li><a href="#19-async-%E5%92%8C-defer-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B">19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）</a></li>
<li><a href="#20-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E6%A1%A3%E7%9A%84%E9%A2%84%E8%A7%A3%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B">20. 什么是文档的预解析？（浏览器解析过程）</a></li>
<li><a href="#21-css-%E5%A6%82%E4%BD%95%E9%98%BB%E5%A1%9E%E6%96%87%E6%A1%A3%E8%A7%A3%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B">21. CSS 如何阻塞文档解析？（浏览器解析过程）</a></li>
<li><a href="#22-%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E6%97%B6%E5%B8%B8%E8%A7%81%E5%93%AA%E4%BA%9B%E4%B8%8D%E8%89%AF%E7%8E%B0%E8%B1%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">22. 渲染页面时常见哪些不良现象？（浏览器渲染过程）</a></li>
<li><a href="#23-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">23. 如何优化关键渲染路径？（浏览器渲染过程）</a></li>
<li><a href="#24-%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B">24. 什么是重绘和回流？（浏览器绘制过程）</a></li>
<li><a href="#25-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%9B%9E%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B">25. 如何减少回流？（浏览器绘制过程）</a></li>
<li><a href="#26-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C-dom-%E6%85%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B">26. 为什么操作 DOM 慢？（浏览器绘制过程）</a></li>
<li><a href="#27-domcontentloaded-%E4%BA%8B%E4%BB%B6%E5%92%8C-load-%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB">27. DOMContentLoaded 事件和 Load 事件的区别？</a></li>
<li><a href="#28-html5-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E7%A7%BB%E9%99%A4%E4%BA%86%E9%82%A3%E4%BA%9B%E5%85%83%E7%B4%A0">28. HTML5 有哪些新特性、移除了那些元素？</a></li>
<li><a href="#29-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-html5-%E6%96%B0%E6%A0%87%E7%AD%BE%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98">29. 如何处理 HTML5 新标签的浏览器兼容问题？</a></li>
<li><a href="#30-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-html-%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3">30. 简述一下你对 HTML 语义化的理解？</a></li>
<li><a href="#31-b-%E4%B8%8E-strong-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C-i-%E4%B8%8E-em-%E7%9A%84%E5%8C%BA%E5%88%AB">31. b 与 strong 的区别和 i 与 em 的区别？</a></li>
<li><a href="#32-%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B-seo-">32. 前端需要注意哪些 SEO ？</a></li>
<li><a href="#33-html5-%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%82%A8%E5%AD%98%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%83%BD%E4%B8%8D%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B">33. HTML5 的离线储存怎么使用，工作原理能不能解释一下？</a></li>
<li><a href="#34-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AF%B9-html5-%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%82%A8%E5%AD%98%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E5%92%8C%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%91%A2">34. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</a></li>
<li><a href="#35-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E7%9A%84%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E6%9C%89%E5%93%AA%E4%BA%9B">35. 常见的浏览器端的存储技术有哪些？</a></li>
<li><a href="#36-%E8%AF%B7%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-cookiessessionstorage-%E5%92%8C-localstorage-%E7%9A%84%E5%8C%BA%E5%88%AB">36. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</a></li>
<li><a href="#37-iframe-%E6%9C%89%E9%82%A3%E4%BA%9B%E7%BC%BA%E7%82%B9">37. iframe 有那些缺点？</a></li>
<li><a href="#38-label-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84">38. Label 的作用是什么？是怎么用的？</a></li>
<li><a href="#39-html5-%E7%9A%84-form-%E7%9A%84%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88">39. HTML5 的 form 的自动完成功能是什么？</a></li>
<li><a href="#40-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1">40. 如何实现浏览器内多个标签页之间的通信?</a></li>
<li><a href="#41-websocket-%E5%A6%82%E4%BD%95%E5%85%BC%E5%AE%B9%E4%BD%8E%E7%89%88%E6%9C%AC%E6%B5%8F%E8%A7%88%E5%99%A8">41. webSocket 如何兼容低版本浏览器？</a></li>
<li><a href="#42-%E9%A1%B5%E9%9D%A2%E5%8F%AF%E8%A7%81%E6%80%A7page-visibility-api-%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E9%80%94">42. 页面可见性（Page Visibility API） 可以有哪些用途？</a></li>
<li><a href="#43-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9C%86%E5%BD%A2%E7%9A%84%E5%8F%AF%E7%82%B9%E5%87%BB%E5%8C%BA%E5%9F%9F">43. 如何在页面上实现一个圆形的可点击区域？</a></li>
<li><a href="#44-%E5%AE%9E%E7%8E%B0%E4%B8%8D%E4%BD%BF%E7%94%A8-border-%E7%94%BB%E5%87%BA-1-px-%E9%AB%98%E7%9A%84%E7%BA%BF%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%80%AA%E5%BC%82%E6%A8%A1%E5%BC%8F%E4%B8%8B%E9%83%BD%E8%83%BD%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E7%9A%84%E6%95%88%E6%9E%9C">44. 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</a></li>
<li><a href="#45-title-%E4%B8%8E-h1-%E7%9A%84%E5%8C%BA%E5%88%AB">45. title 与 h1 的区别？</a></li>
<li><a href="#46-img-%E7%9A%84-title-%E5%92%8C-alt-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">46. &lt;img&gt; 的 title 和 alt 有什么区别？</a></li>
<li><a href="#47-canvas-%E5%92%8C-svg-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">47. Canvas 和 SVG 有什么区别？</a></li>
<li><a href="#48-%E7%BD%91%E9%A1%B5%E9%AA%8C%E8%AF%81%E7%A0%81%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">48. 网页验证码是干嘛的，是为了解决什么安全问题？</a></li>
<li><a href="#49-%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E7%9A%84%E5%AE%9A%E4%B9%89">49. 渐进增强和优雅降级的定义</a></li>
<li><a href="#50-attribute-%E5%92%8C-property-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">50. attribute 和 property 的区别是什么？</a></li>
<li><a href="#51-%E5%AF%B9-web-%E6%A0%87%E5%87%86%E5%8F%AF%E7%94%A8%E6%80%A7%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3">51. 对 web 标准、可用性、可访问性的理解</a></li>
<li><a href="#52-ie-%E5%90%84%E7%89%88%E6%9C%AC%E5%92%8C-chrome-%E5%8F%AF%E4%BB%A5%E5%B9%B6%E8%A1%8C%E4%B8%8B%E8%BD%BD%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%B5%84%E6%BA%90">52. IE 各版本和 Chrome 可以并行下载多少个资源？</a></li>
<li><a href="#53-flashajax-%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%9C%A8%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8F%96%E8%88%8D">53. Flash、Ajax 各自的优缺点，在使用中如何取舍？</a></li>
<li><a href="#54-%E6%80%8E%E4%B9%88%E9%87%8D%E6%9E%84%E9%A1%B5%E9%9D%A2">54. 怎么重构页面？</a></li>
<li><a href="#55-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84">55. 浏览器架构</a></li>
<li><a href="#56-%E5%B8%B8%E7%94%A8%E7%9A%84-meta-%E6%A0%87%E7%AD%BE">56. 常用的 meta 标签</a></li>
<li><a href="#57-css-reset-%E5%92%8C-normalizecss-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">57. css reset 和 normalize.css 有什么区别？</a></li>
<li><a href="#58-%E7%94%A8%E4%BA%8E%E9%A2%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%87%E6%9C%AC%E7%9A%84%E6%A0%87%E7%AD%BE%E6%98%AF">58. 用于预格式化文本的标签是？</a></li>
<li><a href="#59-dhtml-%E6%98%AF%E4%BB%80%E4%B9%88">59. DHTML 是什么？</a></li>
<li><a href="#60-head-%E6%A0%87%E7%AD%BE%E4%B8%AD%E5%BF%85%E4%B8%8D%E5%B0%91%E7%9A%84%E6%98%AF">60. head 标签中必不少的是？</a></li>
<li><a href="#61-html5-%E6%96%B0%E5%A2%9E%E7%9A%84%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E6%9C%89">61. HTML5 新增的表单元素有？</a></li>
<li><a href="#62-%E5%9C%A8-html5-%E4%B8%AD%E5%93%AA%E4%B8%AA%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E8%8E%B7%E5%BE%97%E7%94%A8%E6%88%B7%E7%9A%84%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE">62. 在 HTML5 中，哪个方法用于获得用户的当前位置？</a></li>
<li><a href="#63-%E6%96%87%E6%A1%A3%E7%9A%84%E4%B8%8D%E5%90%8C%E6%B3%A8%E9%87%8A%E6%96%B9%E5%BC%8F">63. 文档的不同注释方式？</a></li>
<li><a href="#64-disabled-%E5%92%8C-readonly-%E7%9A%84%E5%8C%BA%E5%88%AB">64. disabled 和 readonly 的区别？</a></li>
<li><a href="#65-%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7-css-%E5%89%8D%E7%BC%80">65. 主流浏览器内核私有属性 css 前缀？</a></li>
<li><a href="#66-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">66. 前端性能优化？</a></li>
<li><a href="#67-chrome-%E4%B8%AD%E7%9A%84-waterfall-">67. Chrome 中的 Waterfall ？</a></li>
<li><a href="#68-%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95%E7%BD%91%E9%A1%B5%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%E5%89%8D%E5%90%8E%E4%B8%A4%E4%B8%AA%E4%BA%8B%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E8%81%94%E7%B3%BB%E7%9A%84">68. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</a></li>
<li><a href="#69-html-%E8%A7%84%E8%8C%83%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82%E5%BC%95%E7%94%A8%E8%B5%84%E6%BA%90%E4%B8%8D%E5%8A%A0%E5%8D%8F%E8%AE%AE%E5%A4%B4http%E6%88%96%E8%80%85https">69. Html 规范中为什么要求引用资源不加协议头 http 或者 https？</a></li>
</ul>
<h4 id="1-DOCTYPE-的作用是什么？"><a href="#1-DOCTYPE-的作用是什么？" class="headerlink" title="1. DOCTYPE 的作用是什么？"></a>1. DOCTYPE 的作用是什么？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE&gt;声明位于 HTML 文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。</span><br><span class="line"></span><br><span class="line">DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</span><br></pre></td></tr></table></figure>

<p>回答（参考 1-5）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE&gt;  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来</span><br><span class="line">进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏</span><br><span class="line">览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。</span><br><span class="line"></span><br><span class="line">在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文</span><br><span class="line">档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。</span><br></pre></td></tr></table></figure>

<h4 id="2-标准模式与兼容模式各有什么区别？"><a href="#2-标准模式与兼容模式各有什么区别？" class="headerlink" title="2. 标准模式与兼容模式各有什么区别？"></a>2. 标准模式与兼容模式各有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示</span><br><span class="line">，模拟老式浏览器的行为以防止站点无法工作。</span><br></pre></td></tr></table></figure>

<h4 id="3-HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-，而不需要引入-DTD？"><a href="#3-HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-，而不需要引入-DTD？" class="headerlink" title="3. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;，而不需要引入 DTD？"></a>3. HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code>，而不需要引入 DTD？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运</span><br><span class="line">行）。</span><br><span class="line"></span><br><span class="line">而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。</span><br></pre></td></tr></table></figure>

<h4 id="4-SGML-、-HTML-、XML-和-XHTML-的区别？"><a href="#4-SGML-、-HTML-、XML-和-XHTML-的区别？" class="headerlink" title="4. SGML 、 HTML 、XML 和 XHTML 的区别？"></a>4. SGML 、 HTML 、XML 和 XHTML 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SGML（Standard Generalized Markup language）是标准通用置标语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。</span><br><span class="line"></span><br><span class="line">HTML（HyperText Markup Language）是超文本标记语言，主要是用于规定怎么显示网页。</span><br><span class="line"></span><br><span class="line">XML（Extensible Markup Language）是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，</span><br><span class="line">而 HTML 的标签都是固定的而且数量有限。</span><br><span class="line"></span><br><span class="line">XHTML（Extensible Hypertext Markup Language）也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML</span><br><span class="line">更严格，比如标签必须都用小写，标签都必须有闭合标签等。</span><br></pre></td></tr></table></figure>

<h4 id="5-DTD-介绍"><a href="#5-DTD-介绍" class="headerlink" title="5. DTD 介绍"></a>5. DTD 介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元</span><br><span class="line">素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。</span><br><span class="line"></span><br><span class="line">DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。</span><br></pre></td></tr></table></figure>

<h4 id="6-行内元素定义"><a href="#6-行内元素定义" class="headerlink" title="6. 行内元素定义"></a>6. 行内元素定义</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空</span><br><span class="line">间。</span><br><span class="line"></span><br><span class="line">常见的行内元素有 a b span img strong sub sup button input label select textarea</span><br></pre></td></tr></table></figure>

<h4 id="7-块级元素定义"><a href="#7-块级元素定义" class="headerlink" title="7. 块级元素定义"></a>7. 块级元素定义</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。</span><br><span class="line"></span><br><span class="line">常见的块级元素有  div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</span><br></pre></td></tr></table></figure>

<h4 id="8-行内元素与块级元素的区别？"><a href="#8-行内元素与块级元素的区别？" class="headerlink" title="8. 行内元素与块级元素的区别？"></a>8. 行内元素与块级元素的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。</span><br><span class="line"></span><br><span class="line">（1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。</span><br><span class="line">（2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。</span><br><span class="line">（3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-hei</span><br><span class="line">     ght），设置 margin 和 padding 的上下不会对其他元素产生影响。</span><br></pre></td></tr></table></figure>

<h4 id="9-HTML5-元素的分类"><a href="#9-HTML5-元素的分类" class="headerlink" title="9. HTML5 元素的分类"></a>9. HTML5 元素的分类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，前</span><br><span class="line">端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display 值设定为</span><br><span class="line">inline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。因此，简单地把 HTML 元素划分为</span><br><span class="line">inline 与 block 已经不再符合实际需求。</span><br><span class="line"></span><br><span class="line">HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive</span><br></pre></td></tr></table></figure>

<h4 id="10-空元素定义"><a href="#10-空元素定义" class="headerlink" title="10. 空元素定义"></a>10. 空元素定义</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。</span><br><span class="line"></span><br><span class="line">常见的空元素有：br hr img input link meta</span><br></pre></td></tr></table></figure>

<h4 id="11-link-标签定义"><a href="#11-link-标签定义" class="headerlink" title="11. link 标签定义"></a>11. link 标签定义</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link 标签定义文档与外部资源的关系。</span><br><span class="line"></span><br><span class="line">link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。</span><br><span class="line"></span><br><span class="line">link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。</span><br></pre></td></tr></table></figure>

<h4 id="12-页面导入样式时，使用-link-和-import-有什么区别？"><a href="#12-页面导入样式时，使用-link-和-import-有什么区别？" class="headerlink" title="12. 页面导入样式时，使用 link 和 @import 有什么区别？"></a>12. 页面导入样式时，使用 link 和 @import 有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加</span><br><span class="line">     载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。</span><br><span class="line"></span><br><span class="line">（2）加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。</span><br><span class="line"></span><br><span class="line">（3）兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容</span><br><span class="line">     性问题。</span><br><span class="line"></span><br><span class="line">（4）DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 @i</span><br><span class="line">    mport 的方式插入样式。</span><br></pre></td></tr></table></figure>

<h4 id="13-你对浏览器的理解？"><a href="#13-你对浏览器的理解？" class="headerlink" title="13. 你对浏览器的理解？"></a>13. 你对浏览器的理解？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常</span><br><span class="line">是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请</span><br><span class="line">求资源的位置。</span><br><span class="line"></span><br><span class="line">HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的</span><br><span class="line">组织。</span><br><span class="line"></span><br><span class="line">但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。</span><br><span class="line"></span><br><span class="line">简单来说浏览器可以分为两部分，shell 和 内核。</span><br><span class="line"></span><br><span class="line">其中 shell 的种类相对比较多，内核则比较少。shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，</span><br><span class="line">参数设置等等。它是调用内核来实现各种功能的。内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些</span><br><span class="line"> 浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</span><br></pre></td></tr></table></figure>

<h4 id="14-介绍一下你对浏览器内核的理解？"><a href="#14-介绍一下你对浏览器内核的理解？" class="headerlink" title="14. 介绍一下你对浏览器内核的理解？"></a>14. 介绍一下你对浏览器内核的理解？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主要分成两部分：渲染引擎和 JS 引擎。</span><br><span class="line"></span><br><span class="line">渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也</span><br><span class="line">可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</span><br><span class="line"></span><br><span class="line">JS 引擎：解析和执行 javascript 来实现网页的动态效果。</span><br><span class="line"></span><br><span class="line">最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</span><br></pre></td></tr></table></figure>

<h4 id="15-常见的浏览器内核比较"><a href="#15-常见的浏览器内核比较" class="headerlink" title="15. 常见的浏览器内核比较"></a>15. 常见的浏览器内核比较</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多</span><br><span class="line">网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微</span><br><span class="line">软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等</span><br><span class="line">安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</span><br><span class="line"></span><br><span class="line">Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩</span><br><span class="line">展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</span><br><span class="line"></span><br><span class="line">Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的</span><br><span class="line">天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</span><br><span class="line"></span><br><span class="line">Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trid</span><br><span class="line">ent，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit</span><br><span class="line">前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</span><br><span class="line"></span><br><span class="line">Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 B</span><br><span class="line">link 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是</span><br><span class="line">KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto</span><br><span class="line">内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细的资料可以参考：<br><a href="http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html">《浏览器内核的解析和对比》</a><br><a href="https://blog.csdn.net/Summer_15/article/details/71249203">《五大主流浏览器内核的源起以及国内各大浏览器内核总结》</a></p>
<h4 id="16-常见浏览器所用内核"><a href="#16-常见浏览器所用内核" class="headerlink" title="16. 常见浏览器所用内核"></a>16. 常见浏览器所用内核</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</span><br><span class="line"></span><br><span class="line">（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</span><br><span class="line"></span><br><span class="line">（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</span><br><span class="line"></span><br><span class="line">（4） Safari 浏览器内核：Webkit 内核；</span><br><span class="line"></span><br><span class="line">（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</span><br><span class="line"></span><br><span class="line">（6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</span><br><span class="line"></span><br><span class="line">（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</span><br><span class="line"></span><br><span class="line">（8） 百度浏览器、世界之窗内核：IE 内核；</span><br><span class="line"></span><br><span class="line">（9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</span><br><span class="line"></span><br><span class="line">（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说</span><br><span class="line">     是基于火狐内核。</span><br></pre></td></tr></table></figure>

<h4 id="17-浏览器的渲染原理？"><a href="#17-浏览器的渲染原理？" class="headerlink" title="17. 浏览器的渲染原理？"></a>17. 浏览器的渲染原理？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</span><br><span class="line"></span><br><span class="line">（2）然后对 CSS 进行解析，生成 CSSOM 规则树。</span><br><span class="line"></span><br><span class="line">（3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩</span><br><span class="line">    形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM</span><br><span class="line">    元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</span><br><span class="line"></span><br><span class="line">（4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也</span><br><span class="line">    可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动</span><br><span class="line">    重排”。</span><br><span class="line"></span><br><span class="line">（5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组</span><br><span class="line">    件。</span><br><span class="line"></span><br><span class="line"> 值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的</span><br><span class="line"> html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其</span><br><span class="line"> 余内容。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc7207f265da613c09425d">《浏览器渲染原理》</a><br><a href="https://coolshell.cn/articles/9666.html">《浏览器的渲染原理简介》</a><br><a href="https://kb.cnblogs.com/page/129756/">《前端必读：浏览器内部工作原理》</a><br><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/">《深入浅出浏览器渲染原理》</a></p>
<h4 id="18-渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）"><a href="#18-渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）" class="headerlink" title="18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）"></a>18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么</span><br><span class="line">它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解</span><br><span class="line">析文档。</span><br><span class="line"></span><br><span class="line">也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的</span><br><span class="line">原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</span><br></pre></td></tr></table></figure>

<h4 id="19-async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）"><a href="#19-async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）" class="headerlink" title="19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）"></a>19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执</span><br><span class="line">    行。</span><br><span class="line"></span><br><span class="line">（2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。</span><br><span class="line">    当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</span><br><span class="line"></span><br><span class="line">（3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执</span><br><span class="line">    行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/q/1010000000640869">《defer 和 async 的区别》</a></p>
<h4 id="20-什么是文档的预解析？（浏览器解析过程）"><a href="#20-什么是文档的预解析？（浏览器解析过程）" class="headerlink" title="20. 什么是文档的预解析？（浏览器解析过程）"></a>20. 什么是文档的预解析？（浏览器解析过程）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加</span><br><span class="line">载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析</span><br><span class="line">过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</span><br></pre></td></tr></table></figure>

<h4 id="21-CSS-如何阻塞文档解析？（浏览器解析过程）"><a href="#21-CSS-如何阻塞文档解析？（浏览器解析过程）" class="headerlink" title="21. CSS 如何阻塞文档解析？（浏览器解析过程）"></a>21. CSS 如何阻塞文档解析？（浏览器解析过程）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可</span><br><span class="line">能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。</span><br><span class="line"></span><br><span class="line">所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档</span><br><span class="line">的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，</span><br><span class="line">最后再继续文档的解析。</span><br></pre></td></tr></table></figure>

<h4 id="22-渲染页面时常见哪些不良现象？（浏览器渲染过程）"><a href="#22-渲染页面时常见哪些不良现象？（浏览器渲染过程）" class="headerlink" title="22. 渲染页面时常见哪些不良现象？（浏览器渲染过程）"></a>22. 渲染页面时常见哪些不良现象？（浏览器渲染过程）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示</span><br><span class="line">      出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 CSS 加载时间过长，或者 CSS 被放在了文档底</span><br><span class="line">      部。</span><br><span class="line"></span><br><span class="line">白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML</span><br><span class="line">     尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 JS 文件放在头部，脚本的加载会阻塞后面</span><br><span class="line">     文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/entry/58f867045c497d0058e2ff3a">《前端魔法堂：解秘 FOUC》</a><br><a href="https://www.jianshu.com/p/6617efa874b0">《白屏问题和 FOUC》</a></p>
<h4 id="23-如何优化关键渲染路径？（浏览器渲染过程）"><a href="#23-如何优化关键渲染路径？（浏览器渲染过程）" class="headerlink" title="23. 如何优化关键渲染路径？（浏览器渲染过程）"></a>23. 如何优化关键渲染路径？（浏览器渲染过程）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</span><br><span class="line"></span><br><span class="line">（1）关键资源的数量。</span><br><span class="line">（2）关键路径长度。</span><br><span class="line">（3）关键字节的数量。</span><br><span class="line"></span><br><span class="line">关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。</span><br><span class="line"></span><br><span class="line">同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，</span><br><span class="line">并且资源越大，下载所需的往返次数就越多。</span><br><span class="line"></span><br><span class="line">最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它</span><br><span class="line">们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</span><br><span class="line"></span><br><span class="line">优化关键渲染路径的常规步骤如下：</span><br><span class="line"></span><br><span class="line">（1）对关键路径进行分析和特性描述：资源数、字节数、长度。</span><br><span class="line">（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</span><br><span class="line">（3）优化关键字节数以缩短下载时间（往返次数）。</span><br><span class="line">（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path?hl=zh-cn">《优化关键渲染路径》</a></p>
<h4 id="24-什么是重绘和回流？（浏览器绘制过程）"><a href="#24-什么是重绘和回流？（浏览器绘制过程）" class="headerlink" title="24. 什么是重绘和回流？（浏览器绘制过程）"></a>24. 什么是重绘和回流？（浏览器绘制过程）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background</span><br><span class="line">      -color，我们将这样的操作称为重绘。</span><br><span class="line"></span><br><span class="line">回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样</span><br><span class="line">     的操作我们称为回流。</span><br><span class="line"></span><br><span class="line">常见引起回流属性和方法：</span><br><span class="line"></span><br><span class="line">任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</span><br><span class="line"></span><br><span class="line">（1）添加或者删除可见的 DOM 元素；</span><br><span class="line">（2）元素尺寸改变——边距、填充、边框、宽度和高度</span><br><span class="line">（3）内容变化，比如用户在 input 框中输入文字</span><br><span class="line">（4）浏览器窗口尺寸改变——resize事件发生时</span><br><span class="line">（5）计算 offsetWidth 和 offsetHeight 属性</span><br><span class="line">（6）设置 style 属性的值</span><br><span class="line">（7）当你修改网页的默认字体时。</span><br><span class="line"></span><br><span class="line">回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列</span><br><span class="line">回流。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>常见引起重绘属性和方法：</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-14.png" alt="常见引起回流属性和方法"></p>
<p>常见引起回流属性和方法：</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-13.png" alt="常见引起重绘属性和方法"></p>
<p>详细资料可以参考：<br><a href="https://juejin.im/post/5a9923e9518825558251c96a">《浏览器的回流与重绘》</a></p>
<h4 id="25-如何减少回流？（浏览器绘制过程）"><a href="#25-如何减少回流？（浏览器绘制过程）" class="headerlink" title="25. 如何减少回流？（浏览器绘制过程）"></a>25. 如何减少回流？（浏览器绘制过程）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）使用 transform 替代 top</span><br><span class="line"></span><br><span class="line">（2）不要把节点的属性值放在一个循环里当成循环里的变量</span><br><span class="line"></span><br><span class="line">（3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</span><br><span class="line"></span><br><span class="line">（4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</span><br><span class="line"></span><br><span class="line">（5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。</span><br></pre></td></tr></table></figure>

<h4 id="26-为什么操作-DOM-慢？（浏览器绘制过程）"><a href="#26-为什么操作-DOM-慢？（浏览器绘制过程）" class="headerlink" title="26. 为什么操作 DOM 慢？（浏览器绘制过程）"></a>26. 为什么操作 DOM 慢？（浏览器绘制过程）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</span><br></pre></td></tr></table></figure>

<h4 id="27-DOMContentLoaded-事件和-Load-事件的区别？"><a href="#27-DOMContentLoaded-事件和-Load-事件的区别？" class="headerlink" title="27. DOMContentLoaded 事件和 Load 事件的区别？"></a>27. DOMContentLoaded 事件和 Load 事件的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和</span><br><span class="line">子框架的加载完成。</span><br><span class="line"></span><br><span class="line">Load 事件是当所有资源加载完成后触发的。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/ca8dae435a2c">《DOMContentLoaded 事件 和 Load 事件的区别？》</a></p>
<h4 id="28-HTML5-有哪些新特性、移除了那些元素？"><a href="#28-HTML5-有哪些新特性、移除了那些元素？" class="headerlink" title="28. HTML5 有哪些新特性、移除了那些元素？"></a>28. HTML5 有哪些新特性、移除了那些元素？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</span><br><span class="line"></span><br><span class="line">新增的有：</span><br><span class="line"></span><br><span class="line">绘画 canvas;</span><br><span class="line">用于媒介回放的 video 和 audio 元素;</span><br><span class="line">本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</span><br><span class="line">sessionStorage 的数据在浏览器关闭后自动删除;</span><br><span class="line">语意化更好的内容元素，比如 article、footer、header、nav、section;</span><br><span class="line">表单控件，calendar、date、time、email、url、search;</span><br><span class="line">新的技术 webworker, websocket;</span><br><span class="line">新的文档属性 document.visibilityState</span><br><span class="line"></span><br><span class="line">移除的元素有：</span><br><span class="line"></span><br><span class="line">纯表现的元素：basefont，big，center，font, s，strike，tt，u;</span><br><span class="line">对可用性产生负面影响的元素：frame，frameset，noframes；</span><br></pre></td></tr></table></figure>

<h4 id="29-如何处理-HTML5-新标签的浏览器兼容问题？"><a href="#29-如何处理-HTML5-新标签的浏览器兼容问题？" class="headerlink" title="29. 如何处理 HTML5 新标签的浏览器兼容问题？"></a>29. 如何处理 HTML5 新标签的浏览器兼容问题？</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">（1） IE8/IE7/IE6 支持通过 document.createElement</span><br><span class="line">方法产生的标签，可以利用这一特性让这些浏览器 支持 HTML5</span><br><span class="line">新标签，浏览器支持新标签后，还需要添加标签默认的样式。 （2）</span><br><span class="line">当然也可以直接使用成熟的框架，比如 html5shiv ; `<span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">  &lt;script&gt;</span></span><br><span class="line"><span class="comment">    src = &#x27;https://cdn.jsdelivr.net/npm/html5shiv/dist/html5shiv.min.js&#x27;;</span></span><br><span class="line"><span class="comment">  &lt;/script&gt; &lt;!</span></span><br><span class="line"><span class="comment">[endif]--&gt;</span>` [if lte IE 9]……[endif] 判断 IE 的版本，限定只有 IE9</span><br><span class="line">以下浏览器版本需要执行的语句。</span><br></pre></td></tr></table></figure>

<h4 id="30-简述一下你对-HTML-语义化的理解？"><a href="#30-简述一下你对-HTML-语义化的理解？" class="headerlink" title="30. 简述一下你对 HTML 语义化的理解？"></a>30. 简述一下你对 HTML 语义化的理解？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1） 用正确的标签做正确的事情。</span><br><span class="line">（2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</span><br><span class="line">（3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;</span><br><span class="line">（4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;</span><br><span class="line">（5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我认为 html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页文档的结构，</span><br><span class="line">一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进</span><br><span class="line">行正确的解读。比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。</span><br><span class="line">对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的</span><br><span class="line">话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会</span><br><span class="line">依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，</span><br><span class="line">从而有利于我们网站的 SEO 。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、fo</span><br><span class="line">oter 这些语义标签，删除了 big 、font 这些没有语义的标签。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.html.cn/archives/1668">《语义化的 HTML 结构到底有什么好处？》</a><br><a href="https://www.zhihu.com/question/20455165">《如何理解 Web 语义化？》</a><br><a href="https://juejin.im/post/5a9c8866f265da23741072bf#heading-5">《我的 HTML 会说话——从实用出发，谈谈 HTML 的语义化》</a></p>
<h4 id="31-b-与-strong-的区别和-i-与-em-的区别？"><a href="#31-b-与-strong-的区别和-i-与-em-的区别？" class="headerlink" title="31. b 与 strong 的区别和 i 与 em 的区别？"></a>31. b 与 strong 的区别和 i 与 em 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从页面显示效果来看，被 &lt;b&gt; 和 &lt;strong&gt; 包围的文字将会被加粗，而被 &lt;i&gt; 和 &lt;em&gt; 包围的文字将以斜体的形式呈现。</span><br><span class="line"></span><br><span class="line">但是 &lt;b&gt; &lt;i&gt; 是自然样式标签，分别表示无意义的加粗，无意义的斜体，表现样式为 &#123; font-weight: bolder&#125;，仅仅表示「这</span><br><span class="line">里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在 HTML4.01 中并不被推荐使用。</span><br><span class="line"></span><br><span class="line">而 &lt;em&gt; 和 &lt;strong&gt; 是语义样式标签。 &lt;em&gt; 表示一般的强调文本，而 &lt;strong&gt; 表示比 &lt;em&gt; 语义更强的强调文本。</span><br><span class="line"></span><br><span class="line">使用阅读设备阅读网页时：&lt;strong&gt; 会重读，而 &lt;b&gt; 是展示强调内容。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19551271">《HTML5 中的 b/strong，i/em 有什么区别？》</a></p>
<h4 id="32-前端需要注意哪些-SEO-？"><a href="#32-前端需要注意哪些-SEO-？" class="headerlink" title="32. 前端需要注意哪些 SEO ？"></a>32. 前端需要注意哪些 SEO ？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超</span><br><span class="line">    过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不</span><br><span class="line">    同页面 description 有所不同；keywords 列举出重要关键词即可。</span><br><span class="line"></span><br><span class="line">（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。</span><br><span class="line"></span><br><span class="line">（3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被</span><br><span class="line">    抓取。</span><br><span class="line"></span><br><span class="line">（4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容</span><br><span class="line"></span><br><span class="line">（5）少用 iframe：搜索引擎不会抓取 iframe 中的内容</span><br><span class="line"></span><br><span class="line">（6）非装饰性图片必须加 alt</span><br><span class="line"></span><br><span class="line">（7）提高网站速度：网站速度是搜索引擎排序的一个重要指标</span><br></pre></td></tr></table></figure>

<h4 id="33-HTML5-的离线储存怎么使用，工作原理能不能解释一下？"><a href="#33-HTML5-的离线储存怎么使用，工作原理能不能解释一下？" class="headerlink" title="33. HTML5 的离线储存怎么使用，工作原理能不能解释一下？"></a>33. HTML5 的离线储存怎么使用，工作原理能不能解释一下？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</span><br><span class="line"></span><br><span class="line">原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资</span><br><span class="line">     源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面</span><br><span class="line">     展示。</span><br><span class="line"></span><br><span class="line">如何使用：</span><br><span class="line"></span><br><span class="line">（1）创建一个和 html 同名的 manifest 文件，然后在页面头部像下面一样加入一个 manifest 的属性。</span><br><span class="line"></span><br><span class="line">    &lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</span><br><span class="line"></span><br><span class="line">（2）在如下 cache.manifest 文件的编写离线存储的资源。</span><br><span class="line">  	CACHE MANIFEST</span><br><span class="line">  	#v0.11</span><br><span class="line">  	CACHE:</span><br><span class="line">  	js/app.js</span><br><span class="line">  	css/style.css</span><br><span class="line">  	NETWORK:</span><br><span class="line">  	resourse/logo.png</span><br><span class="line">  	FALLBACK:</span><br><span class="line">  	/ /offline.html</span><br><span class="line"></span><br><span class="line">    CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出</span><br><span class="line">           来。</span><br><span class="line"></span><br><span class="line">    NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些</span><br><span class="line">             资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 C</span><br><span class="line">             ACHE 的优先级更高。</span><br><span class="line"></span><br><span class="line">    FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下</span><br><span class="line">              任何一个资源失败了，那么就去访问 offline.html 。</span><br><span class="line"></span><br><span class="line">（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如何更新缓存：</span><br><span class="line"></span><br><span class="line">（1）更新 manifest 文件</span><br><span class="line">（2）通过 javascript 操作</span><br><span class="line">（3）清除浏览器缓存</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</span><br><span class="line">（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</span><br><span class="line">（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</span><br><span class="line">（4）FALLBACK 中的资源必须和 manifest 文件同源。</span><br><span class="line">（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</span><br><span class="line">（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</span><br><span class="line">（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细的使用可以参考：<br><a href="https://yanhaijing.com/html/2014/12/28/html5-manifest/">《HTML5 离线缓存-manifest 简介》</a><br><a href="https://segmentfault.com/a/1190000000732617">《有趣的 HTML5：离线存储》</a></p>
<h4 id="34-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？"><a href="#34-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？" class="headerlink" title="34. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？"></a>34. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器</span><br><span class="line">就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器</span><br><span class="line">就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做</span><br><span class="line">任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</span><br><span class="line"></span><br><span class="line">离线的情况下，浏览器就直接使用离线存储的资源。</span><br></pre></td></tr></table></figure>

<h4 id="35-常见的浏览器端的存储技术有哪些？"><a href="#35-常见的浏览器端的存储技术有哪些？" class="headerlink" title="35. 常见的浏览器端的存储技术有哪些？"></a>35. 常见的浏览器端的存储技术有哪些？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器常见的存储技术有 cookie、localStorage 和 sessionStorage。</span><br><span class="line"></span><br><span class="line">还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。</span><br><span class="line"></span><br><span class="line">IE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。</span><br></pre></td></tr></table></figure>

<p>详细的资料可以参考：<br><a href="https://segmentfault.com/a/1190000012578794#articleHeader0">《很全很全的前端本地存储讲解》</a></p>
<h4 id="36-请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#36-请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="36. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>36. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h4><p>相关资料：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别</span><br><span class="line">在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是网站为了标示用户身份而储存在用户</span><br><span class="line">本地终端上的数据（通常经过加密）。cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会</span><br><span class="line">在浏览器和服务器间来回传递。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存储大小：</span><br><span class="line">  	cookie 数据大小不能超过4 k 。</span><br><span class="line">  	sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</span><br><span class="line"></span><br><span class="line">有期时间：</span><br><span class="line">  	localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。</span><br><span class="line">  	sessionStorage  数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会</span><br><span class="line">                    保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。</span><br><span class="line">  	cookie          设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</span><br><span class="line"></span><br><span class="line">作用域：</span><br><span class="line">    sessionStorage  只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。</span><br><span class="line">    localStorage    在所有同源窗口中都是共享的。</span><br><span class="line">    cookie          在所有同源窗口中都是共享的。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</span><br><span class="line"></span><br><span class="line">cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服</span><br><span class="line">务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</span><br><span class="line"></span><br><span class="line">sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保</span><br><span class="line">存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源</span><br><span class="line">页面所访问共享。</span><br><span class="line"></span><br><span class="line">localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage</span><br><span class="line">不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</span><br><span class="line"></span><br><span class="line">上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏</span><br><span class="line">览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</span><br></pre></td></tr></table></figure>

<p>详细的资料可以参考：<br><a href="https://segmentfault.com/a/1190000017423117">《请描述一下 cookies，sessionStorage 和 localStorage 的区别？》</a><br><a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html">《浏览器数据库 IndexedDB 入门教程》</a></p>
<h4 id="37-iframe-有那些缺点？"><a href="#37-iframe-有那些缺点？" class="headerlink" title="37. iframe 有那些缺点？"></a>37. iframe 有那些缺点？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</span><br><span class="line"></span><br><span class="line">主要缺点有：</span><br><span class="line"></span><br><span class="line">（1） iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才</span><br><span class="line">     会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。</span><br><span class="line">（2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。</span><br><span class="line">（3） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</span><br><span class="line">（4） 浏览器的后退按钮失效。</span><br><span class="line">（5） 小型的移动设备无法完全显示框架。</span><br></pre></td></tr></table></figure>

<p>详细的资料可以参考：<br><a href="https://blog.csdn.net/yintianqin/article/details/72625785">《使用 iframe 的优缺点》</a><br><a href="https://segmentfault.com/a/1190000009891683">《iframe 简单探索以及 iframe 跨域处理》</a></p>
<h4 id="38-Label-的作用是什么？是怎么用的？"><a href="#38-Label-的作用是什么？是怎么用的？" class="headerlink" title="38. Label 的作用是什么？是怎么用的？"></a>38. Label 的作用是什么？是怎么用的？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</span><br><span class="line"></span><br><span class="line">&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;</span><br><span class="line">&lt;input type=“text“ name=&quot;Name&quot; id=&quot;Name&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="39-HTML5-的-form-的自动完成功能是什么？"><a href="#39-HTML5-的-form-的自动完成功能是什么？" class="headerlink" title="39. HTML5 的 form 的自动完成功能是什么？"></a>39. HTML5 的 form 的自动完成功能是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autocomplete 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 autocomplete=off 可以关闭该功能。</span><br><span class="line"></span><br><span class="line">自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。</span><br><span class="line"></span><br><span class="line">autocomplete 属性适用于 &lt;form&gt;，以及下面的 &lt;input&gt; 类型：text, search, url, telephone, email, password,</span><br><span class="line">datepickers, range 以及 color。</span><br></pre></td></tr></table></figure>

<h4 id="40-如何实现浏览器内多个标签页之间的通信"><a href="#40-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="40. 如何实现浏览器内多个标签页之间的通信?"></a>40. 如何实现浏览器内多个标签页之间的通信?</h4><p>相关资料：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。</span><br><span class="line"></span><br><span class="line">（2）使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标</span><br><span class="line">    签页之间的双向通行。</span><br><span class="line"></span><br><span class="line">（3）可以调用 localStorage、cookies 等本地存储方式，localStorge 另一个浏览上下文里被添加、修改或删除时，它都会触</span><br><span class="line">    发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信；</span><br><span class="line"></span><br><span class="line">（4）如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，</span><br><span class="line">让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。</span><br><span class="line"></span><br><span class="line">第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。</span><br><span class="line">标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</span><br><span class="line"></span><br><span class="line">第二种是使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使</span><br><span class="line">用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交</span><br><span class="line">换。</span><br><span class="line"></span><br><span class="line">第三种方式是使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页</span><br><span class="line">修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</span><br><span class="line"></span><br><span class="line">还有一种方式是使用 postMessage 方法，如果我们能够获得对应标签页的引用，我们就可以使用 postMessage 方法，进行通信。</span><br></pre></td></tr></table></figure>

<p>详细的资料可以参考：</p>
<p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">《WebSocket 教程》</a><br><a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html">《WebSocket 协议：5 分钟从入门到精通》</a><br><a href="https://segmentfault.com/a/1190000011538416">《WebSocket 学习（一）——基于 socket.io 实现简单多人聊天室》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API">《使用 Web Storage API》</a><br><a href="https://www.zhuwenlong.com/blog/article/590ea64fe55f0f385f9a12e5">《JavaScript 的多线程，Worker 和 SharedWorker》</a><br><a href="https://juejin.im/post/5acdba01f265da23826e5633#heading-1">《实现多个标签页之间通信的几种方法》</a></p>
<h4 id="41-webSocket-如何兼容低版本浏览器？"><a href="#41-webSocket-如何兼容低版本浏览器？" class="headerlink" title="41. webSocket 如何兼容低版本浏览器？"></a>41. webSocket 如何兼容低版本浏览器？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Adobe Flash Socket 、</span><br><span class="line">ActiveX HTMLFile (IE) 、</span><br><span class="line">基于 multipart 编码发送 XHR 、</span><br><span class="line">基于长轮询的 XHR</span><br></pre></td></tr></table></figure>

<h4 id="42-页面可见性（Page-Visibility-API）-可以有哪些用途？"><a href="#42-页面可见性（Page-Visibility-API）-可以有哪些用途？" class="headerlink" title="42. 页面可见性（Page Visibility API） 可以有哪些用途？"></a>42. 页面可见性（Page Visibility API） 可以有哪些用途？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户</span><br><span class="line">不看网页，下面这些网页行为都是可以暂停的。</span><br><span class="line"></span><br><span class="line">（1）对服务器的轮询</span><br><span class="line">（2）网页动画</span><br><span class="line">（3）正在播放的音频或视频</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2018/10/page_visibility_api.html">《Page Visibility API 教程》</a></p>
<h4 id="43-如何在页面上实现一个圆形的可点击区域？"><a href="#43-如何在页面上实现一个圆形的可点击区域？" class="headerlink" title="43. 如何在页面上实现一个圆形的可点击区域？"></a>43. 如何在页面上实现一个圆形的可点击区域？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）纯 html 实现，使用 &lt;area&gt; 来给 &lt;img&gt; 图像标记热点区域的方式，&lt;map&gt; 标签用来定义一个客户端图像映射，&lt;area&gt;</span><br><span class="line">    标签用来定义图像映射中的区域，area 元素永远嵌套在 map 元素内部，我们可以将 area 区域设置为圆形，从而实现可点击</span><br><span class="line">    的圆形区域。</span><br><span class="line"></span><br><span class="line">（2）纯 css 实现，使用 border-radius ，当 border-radius 的长度等于宽高相等的元素值的一半时，即可实现一个圆形的</span><br><span class="line">    点击区域。</span><br><span class="line"></span><br><span class="line">（3）纯 js 实现，判断一个点在不在圆上的简单算法，通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我</span><br><span class="line">    们规定的圆形区域内。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://maizi93.github.io/2017/08/29/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9C%86%E5%BD%A2%E7%9A%84%E5%8F%AF%E7%82%B9%E5%87%BB%E5%8C%BA%E5%9F%9F%EF%BC%9F/">《如何在页面上实现一个圆形的可点击区域？》</a><br><a href="https://www.zhangxinxu.com/wordpress/2017/05/html-area-map/">《HTML <area><map> 标签及在实际开发中的应用》</a></p>
<h4 id="44-实现不使用-border-画出-1-px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#44-实现不使用-border-画出-1-px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="headerlink" title="44. 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"></a>44. 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height:1px;overflow:hidden;background:red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="45-title-与-h1-的区别？"><a href="#45-title-与-h1-的区别？" class="headerlink" title="45. title 与 h1 的区别？"></a>45. title 与 h1 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title 属性没有明确意义只表示是个标题，h1 则表示层次明确的标题，对页面信息的抓取也有很大的影响。</span><br></pre></td></tr></table></figure>

<h4 id="46-lt-img-gt-的-title-和-alt-有什么区别？"><a href="#46-lt-img-gt-的-title-和-alt-有什么区别？" class="headerlink" title="46. &lt;img&gt; 的 title 和 alt 有什么区别？"></a>46. <code>&lt;img&gt;</code> 的 title 和 alt 有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title 通常当鼠标滑动到元素上的时候显示</span><br><span class="line"></span><br><span class="line">alt 是 &lt;img&gt; 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装</span><br><span class="line">饰图片外都必须设置有意义的值，搜索引擎会重点分析。</span><br></pre></td></tr></table></figure>

<h4 id="47-Canvas-和-SVG-有什么区别？"><a href="#47-Canvas-和-SVG-有什么区别？" class="headerlink" title="47. Canvas 和 SVG 有什么区别？"></a>47. Canvas 和 SVG 有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，</span><br><span class="line">会出现锯齿或者失真的情况。</span><br><span class="line"></span><br><span class="line">SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素</span><br><span class="line">附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19690014">《SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？》</a></p>
<h4 id="48-网页验证码是干嘛的，是为了解决什么安全问题？"><a href="#48-网页验证码是干嘛的，是为了解决什么安全问题？" class="headerlink" title="48. 网页验证码是干嘛的，是为了解决什么安全问题？"></a>48. 网页验证码是干嘛的，是为了解决什么安全问题？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</span><br><span class="line">（2）有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</span><br></pre></td></tr></table></figure>

<h4 id="49-渐进增强和优雅降级的定义"><a href="#49-渐进增强和优雅降级的定义" class="headerlink" title="49. 渐进增强和优雅降级的定义"></a>49. 渐进增强和优雅降级的定义</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的</span><br><span class="line">        用户体验。</span><br><span class="line"></span><br><span class="line">优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。</span><br></pre></td></tr></table></figure>

<h4 id="50-attribute-和-property-的区别是什么？"><a href="#50-attribute-和-property-的区别是什么？" class="headerlink" title="50. attribute 和 property 的区别是什么？"></a>50. attribute 和 property 的区别是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attribute 是 dom 元素在文档中作为 html 标签拥有的属性；</span><br><span class="line">property 就是 dom 元素在 js 中作为对象拥有的属性。</span><br><span class="line">对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，</span><br><span class="line">但是对于自定义的属性来说，他们是不同步的。</span><br></pre></td></tr></table></figure>

<h4 id="51-对-web-标准、可用性、可访问性的理解"><a href="#51-对-web-标准、可用性、可访问性的理解" class="headerlink" title="51. 对 web 标准、可用性、可访问性的理解"></a>51. 对 web 标准、可用性、可访问性的理解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看</span><br><span class="line">产品的质量。可用性好意味着产品质量高，是企业的核心竞争力</span><br><span class="line"></span><br><span class="line">可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性</span><br><span class="line"></span><br><span class="line">可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。</span><br><span class="line">二是代码是否容易被人理解，是否容易修改和增强功能。</span><br></pre></td></tr></table></figure>

<h4 id="52-IE-各版本和-Chrome-可以并行下载多少个资源？"><a href="#52-IE-各版本和-Chrome-可以并行下载多少个资源？" class="headerlink" title="52. IE 各版本和 Chrome 可以并行下载多少个资源？"></a>52. IE 各版本和 Chrome 可以并行下载多少个资源？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）  IE6 2 个并发</span><br><span class="line">（2）  iE7 升级之后的 6 个并发，之后版本也是 6 个</span><br><span class="line">（3）  Firefox，chrome 也是6个</span><br></pre></td></tr></table></figure>

<h4 id="53-Flash、Ajax-各自的优缺点，在使用中如何取舍？"><a href="#53-Flash、Ajax-各自的优缺点，在使用中如何取舍？" class="headerlink" title="53. Flash、Ajax 各自的优缺点，在使用中如何取舍？"></a>53. Flash、Ajax 各自的优缺点，在使用中如何取舍？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flash：</span><br><span class="line">（1） Flash 适合处理多媒体、矢量图形、访问机器</span><br><span class="line">（2） 对 CSS、处理文本上不足，不容易被搜索</span><br><span class="line"></span><br><span class="line">Ajax：</span><br><span class="line">（1） Ajax 对 CSS、文本支持很好，支持搜索</span><br><span class="line">（2） 多媒体、矢量图形、机器访问不足</span><br><span class="line"></span><br><span class="line">共同点：</span><br><span class="line">（1） 与服务器的无刷新传递消息</span><br><span class="line">（2） 可以检测用户离线和在线状态</span><br><span class="line">（3） 操作 DOM</span><br></pre></td></tr></table></figure>

<h4 id="54-怎么重构页面？"><a href="#54-怎么重构页面？" class="headerlink" title="54. 怎么重构页面？"></a>54. 怎么重构页面？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1） 编写 CSS</span><br><span class="line">（2） 让页面结构更合理化，提升用户体验</span><br><span class="line">（3） 实现良好的页面效果和提升性能</span><br></pre></td></tr></table></figure>

<h4 id="55-浏览器架构"><a href="#55-浏览器架构" class="headerlink" title="55. 浏览器架构"></a>55. 浏览器架构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 用户界面</span><br><span class="line">  * 主进程</span><br><span class="line">  * 内核</span><br><span class="line">      * 渲染引擎</span><br><span class="line">      * JS 引擎</span><br><span class="line">          * 执行栈</span><br><span class="line">      * 事件触发线程</span><br><span class="line">          * 消息队列</span><br><span class="line">              * 微任务</span><br><span class="line">              * 宏任务</span><br><span class="line">      * 网络异步线程</span><br><span class="line">      * 定时器线程</span><br></pre></td></tr></table></figure>

<h4 id="56-常用的-meta-标签"><a href="#56-常用的-meta-标签" class="headerlink" title="56. 常用的 meta 标签"></a>56. 常用的 meta 标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</span><br><span class="line">&lt;meta&gt; 标签位于文档的头部，不包含任何内容。&lt;meta&gt; 标签的属性定义了与文档相关联的名称/值对。</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;  H5标准声明，使用 HTML5 doctype，不区分大小写</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt; 标准的 lang 属性写法</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;    声明文档使用的字符编码</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;   优先使用 IE 最新版本和 Chrome</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt;       页面描述</span><br><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;      页面关键词者</span><br><span class="line">&lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt;    网页作</span><br><span class="line">&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;      搜索引擎抓取</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt; 为移动设备添加 viewport</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt; iOS 设备 begin</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;  添加到主屏后的标题（iOS 6 新增）</span><br><span class="line">是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏</span><br><span class="line">&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt;</span><br><span class="line">添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt;</span><br><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt;  设置苹果工具栏颜色</span><br><span class="line">&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;  启用360浏览器的极速模式(webkit)</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;     避免IE使用兼容模式</span><br><span class="line">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;    不让百度转码</span><br><span class="line">&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;     针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓</span><br><span class="line">&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;   微软的老式浏览器</span><br><span class="line">&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;   uc强制竖屏</span><br><span class="line">&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;    QQ强制竖屏</span><br><span class="line">&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;              UC强制全屏</span><br><span class="line">&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;       QQ强制全屏</span><br><span class="line">&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;   UC应用模式</span><br><span class="line">&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;    QQ应用模式</span><br><span class="line">&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;    windows phone 点击无高光</span><br><span class="line">设置页面不缓存</span><br><span class="line">&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.cnblogs.com/qiumohanyu/p/5431859.html">《Meta 标签用法大全》</a></p>
<h4 id="57-css-reset-和-normalize-css-有什么区别？"><a href="#57-css-reset-和-normalize-css-有什么区别？" class="headerlink" title="57. css reset 和 normalize.css 有什么区别？"></a>57. css reset 和 normalize.css 有什么区别？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么会有 CSS Reset 的存在呢？那是因为早期的浏览器支持和理解的 CSS 规范不同，导致渲染页面时效果不一致，会出现很多</span><br><span class="line">兼容性问题。</span><br><span class="line"></span><br><span class="line">reset 的目的，是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性。</span><br><span class="line"></span><br><span class="line">normalize 的理念则是尽量保留浏览器的默认样式，不进行太多的重置，而尽力让这些样式保持一致并尽可能与现代标准相符合。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1.Normalize.css 保护了有价值的默认值</span><br><span class="line"></span><br><span class="line">Reset 通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。 相比之下，Normalize.css 保持了许多默认的浏</span><br><span class="line">览器样式。 这就意味着你不用再为所有公共的排版元素重新设置样式。 当一个元素在不同的浏览器中有不同的默认值时，Normali</span><br><span class="line">ze.css 会力求让这些样式保持一致并尽可能与现代标准相符合。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.Normalize.css 修复了浏览器的 bug</span><br><span class="line"></span><br><span class="line">它修复了常见的桌面端和移动端浏览器的 bug。这往往超出了 Reset 所能做到的范畴。关于这一点，Normalize.css 修复的问题</span><br><span class="line">包含了 HTML5 元素的显示设置、预格式化文字的 font-size 问题、在 IE9 中 SVG 的溢出、许多出现在各浏览器和操作系统中</span><br><span class="line">的与表单相关的 bug。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.Normalize.css 没有复杂的继承链</span><br><span class="line"></span><br><span class="line">使用 Reset 最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链。在 Normalize.css 中就不会有这样的问题，因为在</span><br><span class="line">我们的准则中对多选择器的使用时非常谨慎的，我们仅会有目的地对目标元素设置样式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.Normalize.css 是模块化的</span><br><span class="line"></span><br><span class="line">这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己</span><br><span class="line">选择性地移除掉某些永远不会用到部分（比如表单的一般化）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.Normalize.css 拥有详细的文档</span><br><span class="line"></span><br><span class="line">Normalize.css 的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在 Github Wiki 中有进一步的</span><br><span class="line">说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己</span><br><span class="line">的测试。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">css reset 是最早的一种解决浏览器间样式不兼容问题的方案，它的基本思想是将浏览器的所有样式都重置掉，从而达到所有浏览器</span><br><span class="line">样式保持一致的效果。但是使用这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式的重置，其实反而会造成</span><br><span class="line">画蛇添足的效果。</span><br><span class="line"></span><br><span class="line">后面出现一种更好的解决浏览器间样式不兼容的方法，就是 normalize.css ，它的思想是尽量的保留浏览器自带的样式，通过在原</span><br><span class="line">有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。相对与 css reset，normalize.css 的方法保留了有价值的默</span><br><span class="line">认值，并且修复了一些浏览器的 bug，而且使用 normalize.css 不会造成元素复杂的继承链。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000003021766#articleHeader0">《关于 CSS Reset 那些事（一）之 历史演变与 Normalize.css》</a><br><a href="https://segmentfault.com/q/1010000000117189">《Normalize.css 和 Reset CSS 有什么本质区别没？》</a></p>
<h4 id="58-用于预格式化文本的标签是？"><a href="#58-用于预格式化文本的标签是？" class="headerlink" title="58. 用于预格式化文本的标签是？"></a>58. 用于预格式化文本的标签是？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">预格式化就是保留文字在源码中的格式 最后显示出来样式与源码中的样式一致 所见即所得。</span><br><span class="line"></span><br><span class="line">&lt;pre&gt; 定义预格式文本，保持文本原有的格式</span><br></pre></td></tr></table></figure>

<h4 id="59-DHTML-是什么？"><a href="#59-DHTML-是什么？" class="headerlink" title="59. DHTML 是什么？"></a>59. DHTML 是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DHTML 将 HTML、JavaScript、DOM 以及 CSS 组合在一起，用于创造动态性更强的网页。通过 JavaScript 和 HTML DOM，能</span><br><span class="line">够动态地改变 HTML 元素的样式。</span><br><span class="line"></span><br><span class="line">DHTML 实现了网页从 Web 服务器下载后无需再经过服务的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功</span><br><span class="line">能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链</span><br><span class="line">接目录等。</span><br><span class="line"></span><br><span class="line">包括：</span><br><span class="line">（1）动态内容（Dynamic Content）：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。</span><br><span class="line"></span><br><span class="line">（2）动态排版样式（Dynamic Style Sheets）：W3C 的 CSS 样式表提供了设定 HTML 标记的字体大小、字形、样式、粗细、</span><br><span class="line">    文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、背景图片或颜色等排版功能，而“动态排版样</span><br><span class="line">    式”即可以“动态”地改变排版样式。</span><br></pre></td></tr></table></figure>

<h4 id="60-head-标签中必不少的是？"><a href="#60-head-标签中必不少的是？" class="headerlink" title="60. head 标签中必不少的是？"></a>60. head 标签中必不少的是？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt; 标签用于定义文档的头部，它是所有头部元素的容器。&lt;head&gt; 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供</span><br><span class="line">元信息等等。</span><br><span class="line"></span><br><span class="line">文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数</span><br><span class="line">据都不会真正作为内容显示给读者。</span><br><span class="line"></span><br><span class="line">下面这些标签可用在 head 部分：&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, 以及 &lt;title&gt;。</span><br><span class="line"></span><br><span class="line">&lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。</span><br></pre></td></tr></table></figure>

<h4 id="61-HTML5-新增的表单元素有？"><a href="#61-HTML5-新增的表单元素有？" class="headerlink" title="61. HTML5 新增的表单元素有？"></a>61. HTML5 新增的表单元素有？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datalist 规定输入域的选项列表，通过 option 创建！</span><br><span class="line"></span><br><span class="line">keygen 提供一种验证用户的可靠方法，密钥对生成器，私钥存于客户端，公钥发到服务器，用于之后验证客户端证书！</span><br><span class="line"></span><br><span class="line">output 元素用于不同类型的输出！</span><br></pre></td></tr></table></figure>

<h4 id="62-在-HTML5-中，哪个方法用于获得用户的当前位置？"><a href="#62-在-HTML5-中，哪个方法用于获得用户的当前位置？" class="headerlink" title="62. 在 HTML5 中，哪个方法用于获得用户的当前位置？"></a>62. 在 HTML5 中，哪个方法用于获得用户的当前位置？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getCurrentPosition()</span><br></pre></td></tr></table></figure>

<h4 id="63-文档的不同注释方式？"><a href="#63-文档的不同注释方式？" class="headerlink" title="63. 文档的不同注释方式？"></a>63. 文档的不同注释方式？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTML 的注释方法 &lt;!--注释内容--&gt;</span><br><span class="line"></span><br><span class="line">CSS 的注释方法 /*注释内容*/</span><br><span class="line"></span><br><span class="line">JavaScript 的注释方法 /* 多行注释方式 */ //单行注释方式</span><br></pre></td></tr></table></figure>

<h4 id="64-disabled-和-readonly-的区别？"><a href="#64-disabled-和-readonly-的区别？" class="headerlink" title="64. disabled 和 readonly 的区别？"></a>64. disabled 和 readonly 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disabled 指当 input 元素加载时禁用此元素。input 内容不会随着表单提交。</span><br><span class="line"></span><br><span class="line">readonly 规定输入字段为只读。input 内容会随着表单提交。</span><br><span class="line"></span><br><span class="line">无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value</span><br></pre></td></tr></table></figure>

<h4 id="65-主流浏览器内核私有属性-css-前缀？"><a href="#65-主流浏览器内核私有属性-css-前缀？" class="headerlink" title="65. 主流浏览器内核私有属性 css 前缀？"></a>65. 主流浏览器内核私有属性 css 前缀？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mozilla 内核 （firefox,flock 等）    -moz</span><br><span class="line">webkit  内核 （safari,chrome 等）   -webkit</span><br><span class="line">opera   内核 （opera 浏览器）        -o</span><br><span class="line">trident 内核 （ie 浏览器）           -ms</span><br></pre></td></tr></table></figure>

<h4 id="66-前端性能优化？"><a href="#66-前端性能优化？" class="headerlink" title="66. 前端性能优化？"></a>66. 前端性能优化？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。</span><br><span class="line"></span><br><span class="line">第一个方面是页面的内容方面</span><br><span class="line"></span><br><span class="line">（1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。</span><br><span class="line"></span><br><span class="line">（2）通过 DNS 缓存等机制来减少 DNS 的查询次数。</span><br><span class="line"></span><br><span class="line">（3）通过设置缓存策略，对常用不变的资源进行缓存。</span><br><span class="line"></span><br><span class="line">（4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。</span><br><span class="line"></span><br><span class="line">（5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。</span><br><span class="line"></span><br><span class="line">第二个方面是服务器方面</span><br><span class="line"></span><br><span class="line">（1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。</span><br><span class="line"></span><br><span class="line">（2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。</span><br><span class="line"></span><br><span class="line">（3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie</span><br><span class="line"></span><br><span class="line">第三个方面是 CSS 和 JavaScript 方面</span><br><span class="line"></span><br><span class="line">（1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。</span><br><span class="line"></span><br><span class="line">（2）避免使用 @import 标签。</span><br><span class="line"></span><br><span class="line">（3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。</span><br><span class="line"></span><br><span class="line">（4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。</span><br></pre></td></tr></table></figure>

<p>详细的资料可以参考：<br><a href="https://juejin.im/post/5b73ef38f265da281e048e51#heading-10">《前端性能优化之雅虎 35 条军规》</a><br><a href="https://juejin.im/entry/58709b9a128fe1006b29cd5d">《你真的了解 gzip 吗？》</a><br><a href="https://segmentfault.com/a/1190000012571492">《前端性能优化之 gzip》</a></p>
<h4 id="67-Chrome-中的-Waterfall-？"><a href="#67-Chrome-中的-Waterfall-？" class="headerlink" title="67. Chrome 中的 Waterfall ？"></a>67. Chrome 中的 Waterfall ？</h4><p>详细资料可以参考：<br><a href="https://blog.csdn.net/carian_violet/article/details/84954360">《前端性能之 Chrome 的 Waterfall》</a><br><a href="https://blog.csdn.net/csdn_girl/article/details/54911632">《教你读懂网络请求的瀑布图》</a> <a href="https://www.zhihu.com/question/27085552/answer/35194131">《前端妹子跟我抱怨她们的页面加载很慢的时候，如何在她面前优雅地装逼？》</a></p>
<h4 id="68-扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"><a href="#68-扫描二维码登录网页是什么原理，前后两个事件是如何联系的？" class="headerlink" title="68. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"></a>68. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">核心过程应该是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 serv</span><br><span class="line">er的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备</span><br><span class="line">上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。</span><br><span class="line"></span><br><span class="line">我的理解</span><br><span class="line"></span><br><span class="line">二维码登录网页的基本原理是，用户进入登录网页后，服务器生成一个 uid 来标识一个用户。对应的二维码对应了一个对应 uid</span><br><span class="line">的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应。比如微信的二维码登录，只</span><br><span class="line">有用微信识这个二维码才有效。当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。这个时候登录网页根据</span><br><span class="line">先前的长连接获取到服务器传过来的用户信息进行显示。然后提前预加载一些登录后可能用到的信息。当客户端点击确认授权登陆后，</span><br><span class="line">服务器生成一个权限令牌给网页，网页之后使用这个令牌进行信息的交互过程。由于整个授权的过程都是在手机端进行的，因此能够</span><br><span class="line">很好的防止 PC 上泛滥的病毒。并且在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程能够形成</span><br><span class="line">有效的安全防护。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20368066">《微信扫描二维码登录网页》</a></p>
<h4 id="69-Html-规范中为什么要求引用资源不加协议头http或者https？"><a href="#69-Html-规范中为什么要求引用资源不加协议头http或者https？" class="headerlink" title="69. Html 规范中为什么要求引用资源不加协议头http或者https？"></a>69. Html 规范中为什么要求引用资源不加协议头<code>http</code>或者<code>https</code>？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现</span><br><span class="line">警告信息，不同浏览器警告信息展现形式不同。</span><br><span class="line"></span><br><span class="line">为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为</span><br><span class="line"> protocol-relative URL，暂且可译作协议相对 URL。</span><br><span class="line"></span><br><span class="line">如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似</span><br><span class="line">的警告信息，同时还可以节省5字节的数据量。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.ludou.org/the-protocol-relative-url.html">《协议相对 URL》</a><br><a href="https://www.tuicool.com/articles/nEjU7b">《Why you need protocol-relative URLs _now_》</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>wabpack</title>
    <url>/2022/10/21/20221021-webpack/</url>
    <content><![CDATA[<span id="more"></span>

<p>这里我找了一些代表性的问题，试试看你能回答多少 😉</p>
<blockquote>
<p>问：Webpack 配置中用过哪些 Loader ？都有什么作用？</p>
</blockquote>
<blockquote>
<p>问：Webpack 配置中用过哪些 Plugin ？都有什么作用？</p>
</blockquote>
<blockquote>
<p>问：Loader 和 Plugin 有什么区别？</p>
</blockquote>
<blockquote>
<p>问：如何编写 Loader ? 介绍一下思路？</p>
</blockquote>
<blockquote>
<p>问：如何编写 Plugin ? 介绍一下思路？</p>
</blockquote>
<blockquote>
<p>问：Webpack optimize 有配置过吗？可以简单说说吗？</p>
</blockquote>
<blockquote>
<p>问：Webpack 层面如何性能优化？</p>
</blockquote>
<blockquote>
<p>问：Webpack 打包流程是怎样的？</p>
</blockquote>
<blockquote>
<p>问：tree-shaking 实现原理是怎样的？</p>
</blockquote>
<blockquote>
<p>问：Webpack 热更新（HMR）是如何实现？</p>
</blockquote>
<blockquote>
<p>问：Webpack 打包中 Babel 插件是如何工作的？</p>
</blockquote>
<blockquote>
<p>问：Webpack 和 Rollup 有什么相同点与不同点？</p>
</blockquote>
<blockquote>
<p>问：Webpack5 更新了哪些新特性？</p>
</blockquote>
<p>怎么样？这些问题都 OK 吗？</p>
<p>接下来，我们拆解归纳一下这些面试题，绘制一个大概的知识体系</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4588ccf24c024448847ecfe6eb8722b0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="webpack.jpg"></p>
<p>建立好知识体系之后，我们会围绕知识体系，简单分为三个层级：</p>
<ol>
<li><strong>基础</strong> – 会配置</li>
<li><strong>进阶</strong> – 能优化</li>
<li><strong>深入</strong> – 懂原理</li>
</ol>
<p>一层层晋级打怪 🦖 ，解答不同深度的 Webpack 面试题问题 🤓</p>
<p>来，我们现在开始吧 🤜</p>
<h2 id="一、Webpack-基础"><a href="#一、Webpack-基础" class="headerlink" title="一、Webpack 基础"></a>一、Webpack 基础</h2><p>第一部分，先从简单的“会配置”的要求出发，先了解 Webpack 简单配置以及简单配置会涉及到的面试题。</p>
<h3 id="1-简单配置"><a href="#1-简单配置" class="headerlink" title="1. 简单配置"></a>1. 简单配置</h3><blockquote>
<p>该部分需要掌握：</p>
<ol>
<li>Webpack 常规配置项有哪些？</li>
<li>常用 Loader 有哪些？如何配置？</li>
<li>常用插件（Plugin）有哪些？如何的配置？</li>
<li>Babel 的如何配置？Babel 插件如何使用？</li>
</ol>
</blockquote>
<h4 id="1-1-安装依赖"><a href="#1-1-安装依赖" class="headerlink" title="1.1 安装依赖"></a>1.1 安装依赖</h4><p>毫无疑问，先本地安装一下 <code>webpack</code> 以及 <code>webpack-cli</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install webpack webpack-cli -D <span class="comment"># 安装到本地依赖</span></span><br></pre></td></tr></table></figure>

<p>安装完成 ✅</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+ webpack-cli@<span class="number">4.7</span><span class="number">.2</span></span><br><span class="line">+ webpack@<span class="number">5.44</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-工作模式"><a href="#1-2-工作模式" class="headerlink" title="1.2 工作模式"></a>1.2 工作模式</h4><p>webpack 在 4 以后就支持 0 配置打包，我们可以测试一下</p>
<ol>
<li>新建 <code>./src/index.js</code> 文件，写一段简单的代码</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;Hello ITEM&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = a;</span><br></pre></td></tr></table></figure>

<p>此时目录结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack_work                  </span><br><span class="line">├─ src                </span><br><span class="line">│  └─ index.js         </span><br><span class="line">└─ package.json       </span><br></pre></td></tr></table></figure>

<ol>
<li>直接运行 <code>npx webpack</code>，启动打包</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64c6c6a172d549959c57a936dded4c43~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>打包完成，我们看到日志上面有一段提示：<code>The &#39;mode&#39; option has not been set,...</code></p>
<p>意思就是，我们没有配置 mode（模式），这里提醒我们配置一下</p>
<blockquote>
<p><strong>模式：</strong> 供 mode 配置选项，告知 webpack 使用相应模式的内置优化，默认值为 <code>production</code>，另外还有 <code>development</code>、<code>none</code>，他们的区别如下</p>
</blockquote>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>development</td>
<td>开发模式，打包更加快速，省了代码优化步骤</td>
</tr>
<tr>
<td>production</td>
<td>生产模式，打包比较慢，会开启 tree-shaking 和 压缩代码</td>
</tr>
<tr>
<td>none</td>
<td>不使用任何默认优化选项</td>
</tr>
</tbody></table>
<p>怎么配置呢？很简单</p>
<ol>
<li>只需在配置对象中提供 mode 选项：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>从 CLI 参数中传递：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ webpack --mode=development</span><br></pre></td></tr></table></figure>

<h4 id="1-3-配置文件"><a href="#1-3-配置文件" class="headerlink" title="1.3 配置文件"></a>1.3 配置文件</h4><p>虽然有 0 配置打包，但是实际工作中，我们还是需要使用配置文件的方式，来满足不同项目的需求</p>
<ol>
<li>根路径下新建一个配置文件 <code>webpack.config.js</code></li>
<li>新增基本配置信息</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">// 打包入口地址</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>) <span class="comment">// 输出文件目录</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就不过多说了，最基本的配置</p>
<h4 id="1-4-Loader"><a href="#1-4-Loader" class="headerlink" title="1.4 Loader"></a>1.4 Loader</h4><p>这里我们把入口改成 CSS 文件，可能打包结果会如何</p>
<p>1.新增 <code>./src/main.css</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f4f8fb</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>修改 entry 配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/main.css&#x27;</span>, <span class="comment">// 打包入口地址</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.css&#x27;</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>) <span class="comment">// 输出文件目录</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.运行打包命令：<code>npx webpack</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db44786adb79445bb26bb86d37dff920~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>这里就报错了！</p>
<p>这是因为：<strong>webpack 默认支持处理 JS 与 JSON 文件，其他类型都处理不了，这里必须借助 Loader 来对不同类型的文件的进行处理。</strong></p>
<ol>
<li>安装 <code>css-loader</code> 来处理 CSS</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npn install css-loader -D</span><br></pre></td></tr></table></figure>

<ol>
<li>配置资源加载模块</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/main.css&#x27;</span>, <span class="comment">// 打包入口地址</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.css&#x27;</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>) <span class="comment">// 输出文件目录</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">rules</span>: [ <span class="comment">// 转换规则</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="comment">//匹配所有的 css 文件</span></span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;css-loader&#x27;</span> <span class="comment">// use: 对应的 Loader 名称</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>重新运行打包命令 <code>npx webpack</code></li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/182ddecce9fa4dc08b7d55ab48dfd760~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>哎嘿，可以打包了 😁</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dist           </span><br><span class="line">└─ bundle.css  <span class="comment"># 打包得到的结果</span></span><br></pre></td></tr></table></figure>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/026b10e416d84d1e87e2dab32e52e862~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>这里这是尝试，入口文件还是需要改回 <code>./src/index.js</code></p>
<p>这里我们可以得到一个结论：<strong>Loader 就是将 Webpack 不认识的内容转化为认识的内容</strong></p>
<h4 id="1-5-插件（plugin）"><a href="#1-5-插件（plugin）" class="headerlink" title="1.5 插件（plugin）"></a>1.5 插件（plugin）</h4><p>与 Loader 用于转换特定类型的文件不同，<strong>插件（Plugin）可以贯穿 Webpack 打包的生命周期，执行不同的任务</strong></p>
<p>下面来看一个使用的列子：</p>
<p>1.新建 <code>./src/index.html</code> 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>ITEM<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果我想打包后的资源文件，例如：js 或者 css 文件可以自动引入到 Html 中，就需要使用插件 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/html-webpack-plugin">html-webpack-plugin</a>来帮助你完成这个操作</p>
<p>2.本地安装 <code>html-webpack-plugin</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>3.配置插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">// 打包入口地址</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>) <span class="comment">// 输出文件目录</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="comment">//匹配所有的 css 文件</span></span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;css-loader&#x27;</span> <span class="comment">// use: 对应的 Loader 名称</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>:[ <span class="comment">// 配置插件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一下打包，打开 dist 目录下生成的 index.html 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>ITEM<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到它自动的引入了打包好的 bundle.js ，非常方便实用</p>
<h4 id="1-6-自动清空打包目录"><a href="#1-6-自动清空打包目录" class="headerlink" title="1.6 自动清空打包目录"></a>1.6 自动清空打包目录</h4><p>每次打包的时候，打包目录都会遗留上次打包的文件，为了保持打包目录的纯净，我们需要在打包前将打包目录清空</p>
<p>这里我们可以使用插件 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/clean-webpack-plugin">clean-webpack-plugin</a> 来实现</p>
<ol>
<li>安装</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm install clean-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<ol>
<li>配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>:[ <span class="comment">// 配置插件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>() <span class="comment">// 引入插件</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-7-区分环境"><a href="#1-7-区分环境" class="headerlink" title="1.7 区分环境"></a>1.7 区分环境</h4><p>本地开发和部署线上，肯定是有不同的需求</p>
<p><strong>本地环境：</strong></p>
<ul>
<li>需要更快的构建速度</li>
<li>需要打印 debug 信息</li>
<li>需要 live reload 或 hot reload 功能</li>
<li>需要 sourcemap 方便定位问题</li>
<li>…</li>
</ul>
<p><strong>生产环境：</strong></p>
<ul>
<li>需要更小的包体积，代码压缩+tree-shaking</li>
<li>需要进行代码分割</li>
<li>需要压缩图片体积</li>
<li>…</li>
</ul>
<p>针对不同的需求，首先要做的就是做好环境的区分</p>
<ol>
<li>本地安装 cross-env [<a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/cross-env">文档地址</a>]</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install cross-env -D</span><br></pre></td></tr></table></figure>

<ol>
<li>配置启动命令</li>
</ol>
<p>打开 <code>./package.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=dev webpack serve --mode development&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=test webpack --mode production&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=prod webpack --mode production&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<ol>
<li>在 Webpack 配置文件中获取环境变量</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;process.env.NODE_ENV=&#x27;</span>, process.<span class="property">env</span>.<span class="property">NODE_ENV</span>) <span class="comment">// 打印环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">// 打包入口地址</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>) <span class="comment">// 输出文件目录</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="comment">//匹配所有的 css 文件</span></span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;css-loader&#x27;</span> <span class="comment">// use: 对应的 Loader 名称</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>:[ <span class="comment">// 配置插件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;argv.mode=&#x27;</span>,argv.<span class="property">mode</span>) <span class="comment">// 打印 mode(模式) 值</span></span><br><span class="line">  <span class="comment">// 这里可以通过不同的模式修改 config 配置</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.测试一下看看</p>
<ul>
<li>执行 <code>npm run build</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">process.env.NODE_ENV= prod</span><br><span class="line">argv.mode= production</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 <code>npm run test</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">process.env.NODE_ENV= <span class="built_in">test</span></span><br><span class="line">argv.mode= production</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 <code>npm run dev</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">process.env.NODE_ENV= dev</span><br><span class="line">argv.mode= development</span><br></pre></td></tr></table></figure>

<p>这样我们就可以不同的环境来动态修改 Webpack 的配置</p>
<h4 id="1-8-启动-devServer"><a href="#1-8-启动-devServer" class="headerlink" title="1.8 启动 devServer"></a>1.8 启动 devServer</h4><p>1.安装 <a href="https://link.juejin.cn/?target=https://webpack.docschina.org/configuration/dev-server/%23devserver">webpack-dev-server</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm intall webpack-dev-server@3.11.2 -D</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️注意：本文使用的 <code>webpack-dev-server</code> 版本是 <code>3.11.2</code>，当版本 <code>version &gt;= 4.0.0</code> 时，需要使用 <a href="https://link.juejin.cn/?target=https://webpack.docschina.org/configuration/dev-server/%23devserverstatic">devServer.static</a> 进行配置，不再有 <code>devServer.contentBase</code> 配置项。</p>
</blockquote>
<p>2.配置本地服务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;public&#x27;</span>), <span class="comment">// 静态文件目录</span></span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">true</span>, <span class="comment">//是否启动压缩 gzip</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">8080</span>, <span class="comment">// 端口号</span></span><br><span class="line">    <span class="comment">// open:true  // 是否自动打开浏览器</span></span><br><span class="line">  &#125;,</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;argv.mode=&#x27;</span>,argv.<span class="property">mode</span>) <span class="comment">// 打印 mode(模式) 值</span></span><br><span class="line">  <span class="comment">// 这里可以通过不同的模式修改 config 配置</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要配置 contentBase ？</strong></p>
<p>因为 webpack 在进行打包的时候，对静态文件的处理，例如图片，都是直接 copy 到 dist 目录下面。但是对于本地开发来说，这个过程太费时，也没有必要，所以在设置 contentBase 之后，就直接到对应的静态目录下面去读取文件，而不需对文件做任何移动，节省了时间和性能开销。</p>
<ol>
<li>启动本地服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure>

<p>为了看到效果，我在 html 中添加了一段文字，并在 public 下面放入了一张图片 logo.png</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>ITEM<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>ITEM<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">public       </span><br><span class="line">└─ logo.png  </span><br></pre></td></tr></table></figure>

<p>打开地址 <code>http://localhost:8080/</code></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86b5b3175a2a47248c8da77cf51b752d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>接着访问 <code>http://localhost:8080/logo.png</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa86c70642db455c91a2c49129dfe9c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>OK，没问题 👌</p>
<h4 id="1-9-引入-CSS"><a href="#1-9-引入-CSS" class="headerlink" title="1.9 引入 CSS"></a>1.9 引入 CSS</h4><p>上面，我们在 Loader 里面讲到了使用 css-loader 来处理 css，但是单靠 css-loader 是没有办法将样式加载到页面上。这个时候，我们需要再安装一个 style-loader 来完成这个功能</p>
<p>style-loader 就是将处理好的 css 通过 style 标签的形式添加到页面上</p>
<ol>
<li>安装 <code>style-loader</code> [<a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/style-loader">文档地址</a>]</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install style-loader -D</span><br></pre></td></tr></table></figure>

<ol>
<li>配置 Loader</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="comment">//匹配所有的 css 文件</span></span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>⚠️注意：</strong> Loader 的执行顺序是固定从后往前，即按 <code>css-loader --&gt; style-loader</code> 的顺序执行</p>
</blockquote>
<ol>
<li>引用样式文件</li>
</ol>
<p>在入口文件 <code>./src/index.js</code> 引入样式文件 <code>./src/main.css</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./main.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;Hello ITEM&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ./src/main.css */</span> </span><br><span class="line">body &#123;</span><br><span class="line">  <span class="attr">margin</span>: 10px auto;</span><br><span class="line">  <span class="attr">background</span>: cyan;</span><br><span class="line">  max-<span class="attr">width</span>: 800px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>重启一下本地服务，访问 <code>http://localhost:8080/</code></li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a39e673799d42338feb714bc0d5c88e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>这样样式就起作用了，继续修改一下样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> auto;</span><br><span class="line">  <span class="attribute">background</span>: cyan;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="comment">/* 新增 */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">46px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存之后，样式就自动修改完成了</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f95106fac594e21a566ae298d0504cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>style-loader 核心逻辑相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> content = <span class="string">`<span class="subst">$&#123;样式内容&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">style.<span class="property">innerHTML</span> = content;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(style);</span><br></pre></td></tr></table></figure>

<p>通过动态添加 style 标签的方式，将样式引入页面</p>
<h4 id="1-10-CSS-兼容性"><a href="#1-10-CSS-兼容性" class="headerlink" title="1.10 CSS 兼容性"></a>1.10 CSS 兼容性</h4><p>使用 <a href="https://link.juejin.cn/?target=https://webpack.docschina.org/loaders/postcss-loader/">postcss-loader</a>，自动添加 CSS3 部分属性的浏览器前缀</p>
<p>上面我们用到的 <code>transform: translateX(-50%);</code>，需要加上不同的浏览器前缀，这个我们可以使用 postcss-loader 来帮助我们完成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install postcss-loader postcss -D</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  module: &#123; </span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">test</span>: /\.css$/, //匹配所有的 css 文件</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;postcss-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️ 这里有个很大的坑点：<strong>参考文档配置好后，运行的时候会报错</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Error</span>: <span class="title class_">Loading</span> <span class="title class_">PostCSS</span> <span class="string">&quot;postcss-import&quot;</span> plugin <span class="attr">failed</span>: </span><br><span class="line"><span class="title class_">Cannot</span> find <span class="variable language_">module</span> <span class="string">&#x27;postcss-import&#x27;</span></span><br></pre></td></tr></table></figure>

<p>后面尝试安装插件的集合 <code>postcss-preset-env</code> ，然后修改配置为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="comment">// 失败配置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">        <span class="attr">plugins</span>: [</span><br><span class="line">          [</span><br><span class="line">            <span class="string">&#x27;postcss-preset-env&#x27;</span>, </span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 其他选项</span></span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>运行之后依然会报错，在查阅资料后，终于找到了正确的打开方式，我们重新来一遍 😁</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install postcss postcss-loader postcss-preset-env -D</span><br></pre></td></tr></table></figure>

<p>添加 postcss-loader 加载器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="comment">//匹配所有的 css 文件</span></span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>, </span><br><span class="line">          <span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 postcss 配置文件 <code>postcss.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// postcss.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="built_in">require</span>(<span class="string">&#x27;postcss-preset-env&#x27;</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 postcss-preset-env 配置文件 <code>.browserslistrc</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 换行相当于 and</span></span><br><span class="line">last 2 versions <span class="comment"># 回退两个浏览器版本</span></span><br><span class="line">&gt; 0.5% <span class="comment"># 全球超过0.5%人使用的浏览器，可以通过 caniuse.com 查看不同浏览器不同版本占有率</span></span><br><span class="line">IE 10 <span class="comment"># 兼容IE 10</span></span><br></pre></td></tr></table></figure>

<p>再尝试运行一下</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b86c4d718c2f4601b02e02c8d49bc7df~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>前缀自动加上了 👏</p>
<p>如果你对 <code>.browserslistrc</code> 不同配置产生的效果感兴趣，可以使用 <a href="https://link.juejin.cn/?target=http://autoprefixer.github.io/">autoprefixer</a> 进行在线转化查看效果</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e664743f10b5470e9d7152458ba765aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<h4 id="1-11-引入-Less-或者-Sass"><a href="#1-11-引入-Less-或者-Sass" class="headerlink" title="1.11 引入 Less 或者 Sass"></a>1.11 引入 Less 或者 Sass</h4><p>less 和 sass 同样是 Webpack 无法识别的，需要使用对应的 Loader 来处理一下</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>loader</th>
</tr>
</thead>
<tbody><tr>
<td>Less</td>
<td>less-loader</td>
</tr>
<tr>
<td>Sass</td>
<td>sass-loader node-sass 或 dart-sass</td>
</tr>
</tbody></table>
<p>Less 处理相对比较简单，直接添加对应的 Loader 就好了</p>
<p>Sass 不光需要安装 <code>sass-loader</code> 还得搭配一个 <code>node-sass</code>，这里 <code>node-sass</code> 建议用淘宝镜像来安装，npm 安装成功的概率太小了 🤣</p>
<p>这里我们就使用 Sass 来做案例</p>
<ol>
<li>安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install sass-loader -D</span><br><span class="line"><span class="comment"># 淘宝镜像</span></span><br><span class="line">$ npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</span><br></pre></td></tr></table></figure>

<ol>
<li>新建 <code>./src/sass.scss</code></li>
</ol>
<p>Sass 文件的后缀可以是 <code>.scss(常用)</code> 或者 <code>.sass</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">$<span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">190</span>, <span class="number">23</span>, <span class="number">168</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: $color;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>引入 Sass 文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./main.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./sass.scss&#x27;</span> <span class="comment">// 引入 Sass 文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;Hello ITEM&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = a;</span><br></pre></td></tr></table></figure>

<ol>
<li>修改配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(s[ac]|c)ss$/i</span>, <span class="comment">//匹配所有的 sass/scss/css 文件</span></span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;sass-loader&#x27;</span>, </span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一下执行结果</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a6e15eec0674eb6be0eb8b18b5f8e3f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>成功 👏</p>
<h4 id="1-12-分离样式文件"><a href="#1-12-分离样式文件" class="headerlink" title="1.12 分离样式文件"></a>1.12 分离样式文件</h4><p>前面，我们都是依赖 <code>style-loader</code> 将样式通过 style 标签的形式添加到页面上</p>
<p>但是，更多时候，我们都希望可以通过 CSS 文件的形式引入到页面上</p>
<ol>
<li>安装 <a href="https://link.juejin.cn/?target=https://webpack.docschina.org/plugins/mini-css-extract-plugin/"><code>mini-css-extract-plugin</code></a></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install mini-css-extract-plugin -D</span></span><br></pre></td></tr></table></figure>

<ol>
<li>修改 <code>webpack.config.js</code> 配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(s[ac]|c)ss$/i</span>, <span class="comment">//匹配所有的 sass/scss/css 文件</span></span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="comment">// &#x27;style-loader&#x27;,</span></span><br><span class="line">          <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="comment">// 添加 loader</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;sass-loader&#x27;</span>, </span><br><span class="line">        ] </span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>:[ <span class="comment">// 配置插件</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123; <span class="comment">// 添加插件</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;[name].[hash:8].css&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ol>
<li>查看打包结果</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dist                    </span><br><span class="line">├─ avatar.d4d42d52.png  </span><br><span class="line">├─ bundle.js            </span><br><span class="line">├─ index.html           </span><br><span class="line">├─ logo.56482c77.png    </span><br><span class="line">└─ main.3bcbae64.css <span class="comment"># 生成的样式文件  </span></span><br></pre></td></tr></table></figure>

<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eeb21ada61c14841bb340f9a8cb36aca~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<h4 id="1-13-图片和字体文件"><a href="#1-13-图片和字体文件" class="headerlink" title="1.13 图片和字体文件"></a>1.13 图片和字体文件</h4><p>虽然上面在配置开发环境的时候，我们可以通过设置 <code>contentBase</code> 去直接读取图片类的静态文件，看一下下面这两种图片使用情况</p>
<ol>
<li>页面直接引入</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 本地可以访问，生产环境会找不到图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>背景图引入</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;imgBox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">/* ./src/main.css */</span><br><span class="line">...</span><br><span class="line">#imgBox &#123;</span><br><span class="line">  height: 400px;</span><br><span class="line">  width: 400px;</span><br><span class="line">  background: url(&#x27;../public/logo.png&#x27;);</span><br><span class="line">  background-size: contain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接会报错</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed6515db830d41549c457c5e2aa4dd88~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>所以实际上，Webpack 无法识别图片文件，需要在打包的时候处理一下</p>
<p>常用的处理图片文件的 Loader 包含：</p>
<table>
<thead>
<tr>
<th>Loader</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>file-loader</td>
<td>解决图片引入问题，并将图片 copy 到指定目录，默认为 dist</td>
</tr>
<tr>
<td>url-loader</td>
<td>解依赖 file-loader，当图片小于 limit 值的时候，会将图片转为 base64 编码，大于 limit 值的时候依然是使用 file-loader 进行拷贝</td>
</tr>
<tr>
<td>img-loader</td>
<td>压缩图片</td>
</tr>
</tbody></table>
<ol>
<li>安装 <code>file-loader</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install file-loader -D</span><br></pre></td></tr></table></figure>

<ol>
<li>修改配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">      &#125;, </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpe?g|png|gif)$/i</span>, <span class="comment">// 匹配图片文件</span></span><br><span class="line">        <span class="attr">use</span>:[</span><br><span class="line">          <span class="string">&#x27;file-loader&#x27;</span> <span class="comment">// 使用 file-loader</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.引入图片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ./src/index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;imgBox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>样式文件中引入</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ./src/sass.scss */</span></span><br><span class="line"></span><br><span class="line">$<span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">190</span>, <span class="number">23</span>, <span class="number">168</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;../public/logo.png&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: contain;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>js 文件中引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./main.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./sass.scss&#x27;</span></span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">&#x27;../public/avatar.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;Hello ITEM&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line">img.<span class="property">src</span> = logo</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;imgBox&#x27;</span>).<span class="title function_">appendChild</span>(img)</span><br></pre></td></tr></table></figure>

<p>启动服务，我们看一下效果</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1a5bc99ab384641912b82ce921b62c5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>显示正常 ✌️</p>
<p>我们可以看到图片文件的名字都已经变了，并且带上了 hash 值，然后我看一下打包目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dist                                     </span><br><span class="line">├─ 56482c77280b3c4ad2f083b727dfcbf9.<span class="property">png</span>  </span><br><span class="line">├─ bundle.<span class="property">js</span>                             </span><br><span class="line">├─ d4d42d529da4b5120ac85878f6f69694.<span class="property">png</span>  </span><br><span class="line">└─ index.<span class="property">html</span>                            </span><br></pre></td></tr></table></figure>

<p>dist 目录下面多了两个文件，这正是 file-loader 拷贝过来的</p>
<p>如果想要修改一下名称，可以加个配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">      &#125;, </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpe?g|png|gif)$/i</span>,</span><br><span class="line">        <span class="attr">use</span>:[</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;[name][hash:8].[ext]&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[name][hash:8].[ext]&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次打包看一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dist                   </span><br><span class="line">├─ avatard4d42d52.png  </span><br><span class="line">├─ bundle.js           </span><br><span class="line">├─ index.html          </span><br><span class="line">└─ logo56482c77.png    </span><br></pre></td></tr></table></figure>

<p>再看一下 url-loader</p>
<ol>
<li>安装 <code>url-loader</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install url-loader -D</span><br></pre></td></tr></table></figure>

<ol>
<li>配置 <code>url-loader</code></li>
</ol>
<p>配置和 file-loader 类似，多了一个 limit 的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">      &#125;, </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpe?g|png|gif)$/i</span>,</span><br><span class="line">        <span class="attr">use</span>:[</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;[name][hash:8].[ext]&#x27;</span>,</span><br><span class="line">              <span class="comment">// 文件小于 50k 会转换为 base64，大于则拷贝文件</span></span><br><span class="line">              <span class="attr">limit</span>: <span class="number">50</span> * <span class="number">1024</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下，我们两个图片文件的体积</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public         </span><br><span class="line">├─ avatar.png <span class="comment"># 167kb</span></span><br><span class="line">└─ logo.png   <span class="comment"># 43kb </span></span><br></pre></td></tr></table></figure>

<p>我们打包看一下效果</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87741d3bd67a4b7fbe3a8ce626690579~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>很明显可以看到 logo.png 文件已经转为 base64 了👌</p>
<p>再看字体文件的处理</p>
<ol>
<li>配置字体文件</li>
</ol>
<p>首先，从 <a href="https://link.juejin.cn/?target=https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2">iconfont.cn</a> 下载字体文件到本地</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fca370ecf0c4dfba36feb7385377b77~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>在项目中，新建 <code>./src/fonts</code> 文件夹来存放字体文件</p>
<p>然后，引入到入口文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./main.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./sass.scss&#x27;</span></span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">&#x27;../public/avatar.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入字体图标文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./fonts/iconfont.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;Hello ITEM&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line">img.<span class="property">src</span> = logo</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;imgBox&#x27;</span>).<span class="title function_">appendChild</span>(img)</span><br></pre></td></tr></table></figure>

<p>接着，在 <code>./src/index.html</code> 中使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用字体图标文件 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1）iconfont 对应 font-family 设置的值--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 2）icon-member 图标 class 名称可以在 iconfont.cn 中查找--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-member&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;imgBox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后，增加字体文件的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/i</span>,  <span class="comment">// 匹配字体文件</span></span><br><span class="line">    <span class="attr">use</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;fonts/[name][hash:8].[ext]&#x27;</span>, <span class="comment">// 体积大于 10KB 打包到 fonts 目录下 </span></span><br><span class="line">          <span class="attr">limit</span>: <span class="number">10</span> * <span class="number">1024</span>,</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包一下，看看效果</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a0646f552f1458fb290efb2be864360~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>但是在 webpack5，内置了资源处理模块，<code>file-loader</code> 和 <code>url-loader</code> 都可以不用安装</p>
<h4 id="1-14-资源模块的使用"><a href="#1-14-资源模块的使用" class="headerlink" title="1.14 资源模块的使用"></a>1.14 资源模块的使用</h4><blockquote>
<p>webpack5 新增资源模块(asset module)，允许使用资源文件（字体，图标等）而无需配置额外的 loader。</p>
</blockquote>
<p>资源模块支持以下四个配置：</p>
<blockquote>
<ol>
<li><code>asset/resource</code> 将资源分割为单独的文件，并导出 url，类似之前的 file-loader 的功能.</li>
<li><code>asset/inline</code> 将资源导出为 dataUrl 的形式，类似之前的 url-loader 的小于 limit 参数时功能.</li>
<li><code>asset/source</code> 将资源导出为源码（source code）. 类似的 raw-loader 功能.</li>
<li><code>asset</code> 会根据文件大小来选择使用哪种类型，当文件小于 8 KB（默认） 的时候会使用 asset/inline，否则会使用 asset/resource</li>
</ol>
</blockquote>
<p>贴一下修改后的完整代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpe?g|png|gif)$/i</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 输出文件位置以及文件名</span></span><br><span class="line">          <span class="comment">// [ext] 自带 &quot;.&quot; 这个与 url-loader 配置不同</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;[name][hash:8][ext]&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">50</span> * <span class="number">1024</span> <span class="comment">//超过50kb不转 base64</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/i</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="comment">// 输出文件位置以及文件名</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&quot;[name][hash:8][ext]&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span> <span class="comment">// 超过100kb不转 base64</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;argv.mode=&#x27;</span>,argv.<span class="property">mode</span>) <span class="comment">// 打印 mode(模式) 值</span></span><br><span class="line">  <span class="comment">// 这里可以通过不同的模式修改 config 配置</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行打包，结果和之前一样</p>
<h4 id="1-15-JS-兼容性（Babel）"><a href="#1-15-JS-兼容性（Babel）" class="headerlink" title="1.15 JS 兼容性（Babel）"></a>1.15 JS 兼容性（Babel）</h4><p>在开发中我们想使用最新的 Js 特性，但是有些新特性的浏览器支持并不是很好，所以 Js 也需要做兼容处理，常见的就是将 ES6 语法转化为 ES5。</p>
<p>这里将登场的“全场最靓的仔” – Babel</p>
<ol>
<li>未配置 Babel</li>
</ol>
<p>我们写点 ES6 的东西</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./main.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./sass.scss&#x27;</span></span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">&#x27;../public/avatar.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./fonts/iconfont.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Author</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;ITEM&#x27;</span></span><br><span class="line">  age = <span class="number">18</span></span><br><span class="line">  email = <span class="string">&#x27;lxp_work@163.com&#x27;</span></span><br><span class="line"></span><br><span class="line">  info =  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">name</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="variable language_">this</span>.<span class="property">age</span>,</span><br><span class="line">      <span class="attr">email</span>: <span class="variable language_">this</span>.<span class="property">email</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">Author</span></span><br></pre></td></tr></table></figure>

<p>为了方便看源码，我们把 mode 换成 <code>development</code></p>
<p>接着执行打包命令</p>
<p>打包完成之后，打开 <code>bundle.js</code> 查看打包后的结果</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7599da93b146442b89380f1a0b6b60d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72c389e772c84716bc2d39d9d3460f63~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>虽然我们还是可以找打我们的代码，但是阅读起来比较不直观，我们先设置 mode 为 <code>none</code>，以最原始的形式打包，再看一下打包结果</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2d7d5965779444d9a0e547f0643de1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>打包后的代码变化不大，只是对图片地址做了替换，接下来看看配置 babel 后的打包结果会有什么变化</p>
<ol>
<li>安装依赖</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install babel-loader @babel/core @babel/preset-env -D</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>babel-loader</code> 使用 Babel 加载 ES2015+ 代码并将其转换为 ES5</p>
</li>
<li><p><code>@babel/core</code> Babel 编译的核心包</p>
</li>
<li><p><code>@babel/preset-env</code> Babel 编译的预设，可以理解为 Babel 插件的超集</p>
</li>
</ul>
<ol>
<li>配置 Babel 预设</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">// 打包入口地址</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 输出文件目录</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/i</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">presets</span>: [</span><br><span class="line">                <span class="string">&#x27;@babel/preset-env&#x27;</span></span><br><span class="line">              ],</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>配置完成之后执行一下打包</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/150bfa173e2640969731294876d75a22~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>刚才写的 ES6 class 写法 已经转换为了 ES5 的构造函数形式</p>
<p>尽然是做兼容处理，我们自然也可以指定到底要兼容哪些浏览器</p>
<p>为了避免 <code>webpack.config.js</code> 太臃肿，建议将 Babel 配置文件提取出来</p>
<p>根目录下新增 <code>.babelrc.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./babelrc.js</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// useBuiltIns: false 默认值，无视浏览器兼容配置，引入所有 polyfill</span></span><br><span class="line">        <span class="comment">// useBuiltIns: entry 根据配置的浏览器兼容，引入浏览器不兼容的 polyfill</span></span><br><span class="line">        <span class="comment">// useBuiltIns: usage 会根据配置的浏览器兼容，以及你代码中用到的 API 来进行 polyfill，实现了按需添加</span></span><br><span class="line">        <span class="attr">useBuiltIns</span>: <span class="string">&quot;entry&quot;</span>,</span><br><span class="line">        <span class="attr">corejs</span>: <span class="string">&quot;3.9.1&quot;</span>, <span class="comment">// 是 core-js 版本号</span></span><br><span class="line">        <span class="attr">targets</span>: &#123;</span><br><span class="line">          <span class="attr">chrome</span>: <span class="string">&quot;58&quot;</span>,</span><br><span class="line">          <span class="attr">ie</span>: <span class="string">&quot;11&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>好了，这里一个简单的 Babel 预设就配置完了</p>
<p>常见 Babel 预设还有：</p>
<ul>
<li><code>@babel/preset-flow</code></li>
<li><code>@babel/preset-react</code></li>
<li><code>@babel/preset-typescript</code></li>
</ul>
<p>感兴趣的可以自己去了解一下，这里不做扩展了，下面再说说插件的使用</p>
<ol>
<li>配置 Babel 插件</li>
</ol>
<p>对于正在提案中，还未进入 ECMA 规范中的新特性，Babel 是无法进行处理的，必须要安装对应的插件，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./ index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./main.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./sass.scss&#x27;</span></span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">&#x27;../public/avatar.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./fonts/iconfont.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;Hello ITEM&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line">img.<span class="property">src</span> = logo</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;imgBox&#x27;</span>).<span class="title function_">appendChild</span>(img)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增装饰器的使用</span></span><br><span class="line">@<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    target.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">logger</span> = <span class="function">() =&gt;</span> <span class="string">`<span class="subst">$&#123;text&#125;</span>，<span class="subst">$&#123;target.name&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> <span class="title class_">MyClass</span>()</span><br><span class="line">test.<span class="title function_">logger</span>()</span><br></pre></td></tr></table></figure>

<p>执行一下打包</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4b0bc28b22d4ce0a1ead379099dc888~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>不出所料，识别不了 🙅🏻‍♀️</p>
<p>怎么才能使用呢？Babel 其实提供了对应的插件：</p>
<ul>
<li><code>@babel/plugin-proposal-decorators</code></li>
<li><code>@babel/plugin-proposal-class-properties</code></li>
</ul>
<p>安装一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm install babel/plugin-proposal-decorators @babel/plugin-proposal-<span class="keyword">class</span>-properties -D</span><br></pre></td></tr></table></figure>

<p>打开 <code>.babelrc.js</code> 加上插件的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">useBuiltIns</span>: <span class="string">&quot;entry&quot;</span>,</span><br><span class="line">        <span class="attr">corejs</span>: <span class="string">&quot;3.9.1&quot;</span>,</span><br><span class="line">        <span class="attr">targets</span>: &#123;</span><br><span class="line">          <span class="attr">chrome</span>: <span class="string">&quot;58&quot;</span>,</span><br><span class="line">          <span class="attr">ie</span>: <span class="string">&quot;11&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">plugins</span>: [    </span><br><span class="line">    [<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>, &#123; <span class="attr">legacy</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    [<span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span>, &#123; <span class="attr">loose</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样就可以打包了，在 <code>bundle.js</code> 中已经转化为浏览器支持的 Js 代码</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98984317dfe044e3beb9bcb865115720~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>同理，我们可以根据自己的实际需求，搭配不同的插件进行使用</p>
<h3 id="2-SourceMap-配置选择"><a href="#2-SourceMap-配置选择" class="headerlink" title="2 SourceMap 配置选择"></a>2 SourceMap 配置选择</h3><p>SourceMap 是一种映射关系，当项目运行后，如果出现错误，我们可以利用 SourceMap 反向定位到源码位置</p>
<h4 id="2-1-devtool-配置"><a href="#2-1-devtool-配置" class="headerlink" title="2.1 devtool 配置"></a>2.1 devtool 配置</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">// 打包入口地址</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 输出文件目录</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>执行打包后，dist 目录下会生成以 <code>.map</code> 结尾的 SourceMap 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dist                   </span><br><span class="line">├─ avatard4d42d52.png  </span><br><span class="line">├─ bundle.js           </span><br><span class="line">├─ bundle.js.map     </span><br><span class="line">└─ index.html          </span><br></pre></td></tr></table></figure>

<p>除了 <code>source-map</code> 这种类型之外，还有很多种类型可以用，例如：</p>
<ul>
<li><code>eval</code></li>
<li><code>eval-source-map</code></li>
<li><code>cheap-source-map</code></li>
<li><code>inline-source-map</code></li>
<li><code>cheap-module-source-map</code></li>
<li><code>inline-cheap-source-map</code></li>
<li><code>cheap-module-eval-source-map</code></li>
<li><code>inline-cheap-module-source-map</code></li>
<li><code>hidden-source-map</code></li>
<li><code>nosources-source-map</code></li>
</ul>
<p>这么多种，到底都有什么区别？如何选择呢？</p>
<h4 id="2-2-配置项差异"><a href="#2-2-配置项差异" class="headerlink" title="2.2 配置项差异"></a>2.2 配置项差异</h4><ol>
<li>为了方便比较它们的不同，我们<strong>新建一个项目</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">webpack_source_map                                             </span><br><span class="line">├─ src                                      </span><br><span class="line">│  ├─ <span class="title class_">Author</span>.<span class="property">js</span>                            </span><br><span class="line">│  └─ index.<span class="property">js</span>                               </span><br><span class="line">├─ package.<span class="property">json</span>                             </span><br><span class="line">└─ webpack.<span class="property">config</span>.<span class="property">js</span>                        </span><br></pre></td></tr></table></figure>

<ol>
<li>打开 <code>./src/Author.js</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Author</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;ITEM&#x27;</span></span><br><span class="line">  age = <span class="number">18</span></span><br><span class="line">  email = <span class="string">&#x27;lxp_work@163.com&#x27;</span></span><br><span class="line"></span><br><span class="line">  info =  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">name</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="variable language_">this</span>.<span class="property">age</span>,</span><br><span class="line">      <span class="attr">email</span>: <span class="variable language_">this</span>.<span class="property">email</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">Author</span></span><br></pre></td></tr></table></figure>

<ol>
<li>打开 <code>./src/index.js</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Author</span> <span class="keyword">from</span> <span class="string">&#x27;./Author&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;Hello ITEM&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line">img.<span class="property">src</span> = logo</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;imgBox&#x27;</span>).<span class="title function_">appendChild</span>(img)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> author = <span class="keyword">new</span> <span class="title class_">Author</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(author.<span class="property">info</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>打开 <code>package.json</code></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-source-map&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MIT&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@babel/core&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.6.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@babel/preset-env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.6.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;babel-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.0.6&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;html-webpack-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.44.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;webpack-cli&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.7.2&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>打开 <code>webpack.config.js</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多入口打包</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;a.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;b.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>执行打包命令 <code>npm run build</code>，看一下结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dist     </span><br><span class="line">├─ a.js  </span><br><span class="line">└─ b.js  </span><br></pre></td></tr></table></figure>

<p>不用关心打包结果 <code>a.js b.js</code> 里面是什么，到这步的目的是测试多入口打包</p>
<p>改造成多入口的目的是方便我们后面进行比较</p>
<ol>
<li>不同配置项使用单独的打包入口，打开 <code>webpack.config.js</code> 修改</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1）定义不同的打包类型</span></span><br><span class="line"><span class="keyword">const</span> allModes = [</span><br><span class="line">  <span class="string">&#x27;eval&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;eval-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;cheap-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;inline-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;cheap-eval-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;cheap-module-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;inline-cheap-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;inline-cheap-module-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;hidden-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;nosources-source-map&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2）循环不同 SourceMap 模式，生成多个打包入口</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = allModes.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">devtool</span>: item,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">`js/<span class="subst">$&#123;item&#125;</span>.js`</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">      <span class="attr">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/.js$/</span>,</span><br><span class="line">          <span class="attr">use</span>: &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="number">3</span>）输出到不同的页面</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">`<span class="subst">$&#123;item&#125;</span>.html`</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>模拟代码错误</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Author</span> <span class="keyword">from</span> <span class="string">&#x27;./Author&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;Hello ITEM&#x27;</span></span><br><span class="line"><span class="comment">// 故意使用了错误的 console.log </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log11</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line">img.<span class="property">src</span> = logo</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;imgBox&#x27;</span>).<span class="title function_">appendChild</span>(img)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> author = <span class="keyword">new</span> <span class="title class_">Author</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(author.<span class="property">info</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>尝试打包</li>
</ol>
<p>报错了!!</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a867a6e05a8c4f199ca9958825b21b4f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>提示有SourceMap 模式的名称不对，原来它们的拼接是有规律和意义的</p>
<p>我们按照校验规则 <code>^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$</code> 检查一下</p>
<p><code>cheap-eval-source-map</code> 和 <code>cheap-module-eval-source-map</code> 好像有问题，<code>eval</code> 跑后面去了，改一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改之后</span></span><br><span class="line"><span class="keyword">const</span> allModes = [</span><br><span class="line">  <span class="string">&#x27;eval&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;eval-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;cheap-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;inline-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;eval-cheap-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;cheap-module-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;inline-cheap-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;eval-cheap-module-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;inline-cheap-module-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;hidden-source-map&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;nosources-source-map&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>再执行一下打包</p>
<p>还是有报错！！接着改</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af32b5fa675e45c8880d637ccbba1681~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>错误信息我查了一下，大概率是 <code>html-webpack-pugin</code> 的版本太老，不兼容 webpack5，我们升级一下版本至 <code>&quot;html-webpack-plugin&quot;: &quot;^5.3.2&quot;</code> 再尝试一下，OK 了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dist                                     </span><br><span class="line">├─ js                                    </span><br><span class="line">│  ├─ cheap-module-source-map.js <span class="comment">#............ 有对应的 .map 文件        </span></span><br><span class="line">│  ├─ cheap-module-source-map.js.map     </span><br><span class="line">│  ├─ cheap-source-map.js <span class="comment">#................... 有              </span></span><br><span class="line">│  ├─ cheap-source-map.js.map            </span><br><span class="line">│  ├─ eval-cheap-module-source-map.js <span class="comment">#....... 无  </span></span><br><span class="line">│  ├─ eval-cheap-source-map.js <span class="comment">#.............. 无          </span></span><br><span class="line">│  ├─ eval-source-map.js <span class="comment">#.................... 无               </span></span><br><span class="line">│  ├─ eval.js <span class="comment">#............................... 无                           </span></span><br><span class="line">│  ├─ hidden-source-map.js <span class="comment">#.................. 有              </span></span><br><span class="line">│  ├─ hidden-source-map.js.map           </span><br><span class="line">│  ├─ inline-cheap-module-source-map.js <span class="comment">#..... 无  </span></span><br><span class="line">│  ├─ inline-cheap-source-map.js <span class="comment">#............ 无         </span></span><br><span class="line">│  ├─ inline-source-map.js <span class="comment">#.................. 无               </span></span><br><span class="line">│  ├─ nosources-source-map.js <span class="comment">#............... 有           </span></span><br><span class="line">│  ├─ nosources-source-map.js.map        </span><br><span class="line">│  ├─ source-map.js <span class="comment">#......................... 有                     </span></span><br><span class="line">│  └─ source-map.js.map                  </span><br><span class="line">├─ cheap-module-source-map.html          </span><br><span class="line">├─ cheap-source-map.html                 </span><br><span class="line">├─ eval-cheap-module-source-map.html     </span><br><span class="line">├─ eval-cheap-source-map.html            </span><br><span class="line">├─ eval-source-map.html                  </span><br><span class="line">├─ eval.html                             </span><br><span class="line">├─ hidden-source-map.html                </span><br><span class="line">├─ inline-cheap-module-source-map.html   </span><br><span class="line">├─ inline-cheap-source-map.html          </span><br><span class="line">├─ inline-source-map.html                </span><br><span class="line">├─ nosources-source-map.html             </span><br><span class="line">└─ source-map.html                       </span><br></pre></td></tr></table></figure>

<p>从目录结构我们可以很容易看出来，含 <code>eval</code> 和 <code>inline</code> 模式的都没有对应的<code>.map</code> 文件，具体为什么，下面接着分析</p>
<p>接着，我们在 dist 目录起一个服务，在浏览器打开</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4201c3390f4242adbb92be333f6159cb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>然后，我们一个个来分析</p>
<p><strong><code>eval</code> 模式：</strong></p>
<ol>
<li>生成代码通过 <strong><code>eval</code></strong> 执行 👇🏻 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14663eba6d0d4f66b12586ecda2b2616~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></li>
<li>源代码位置通过 <strong><code>@sourceURL</code></strong> 注明 👇🏻</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23343307c41c4e9cba4e7912e4117af4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<ol>
<li>无法定位到错误位置，只能定位到<strong>某个文件</strong></li>
<li>不用生成 SourceMap 文件，<strong>打包速度快</strong></li>
</ol>
<p><strong><code>source-map</code> 模式：</strong></p>
<ol>
<li>生成了对应的 SourceMap 文件，<strong>打包速度慢</strong></li>
<li>在<strong>源代码</strong>中定位到错误所在<strong>行列</strong>信息 👇🏻</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0ac476816cc455eb29264c51cbcd434~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p><strong><code>eval-source-map</code> 模式：</strong></p>
<ol>
<li>生成代码通过 <strong><code>eval</code> 执行</strong> 👇🏻</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c61268e879747b78db39d6f4a58adac~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"> 2. 包含 <strong>dataUrl</strong> 形式的 SourceMap 文件</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b23cb999e644e3aba37182e2da1ebd4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<ol>
<li>可以在<strong>编译后</strong>的代码中定位到错误所在<strong>行列</strong>信息</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d1c061a71274b3182b1ad9fa2cb55d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<ol>
<li>生成 dataUrl 形式的 SourceMap，打包速度慢</li>
</ol>
<p><strong><code>eval-cheap-source-map</code> 模式：</strong></p>
<ol>
<li>生成代码通过 <strong><code>eval</code> 执行</strong></li>
<li>包含 <strong>dataUrl</strong> 形式的 SourceMap 文件</li>
<li>可以在<strong>编译后</strong>的代码中定位到错误所在<strong>行</strong>信息</li>
<li>不需要定位列信息，打包<strong>速度较快</strong></li>
</ol>
<p><strong><code>eval-cheap-module-source-map</code> 模式：</strong></p>
<ol>
<li>生成代码通过 <strong><code>eval</code></strong> 执行</li>
<li>包含 <strong>dataUrl</strong> 形式的 SourceMap 文件</li>
<li>可以在<strong>编译后</strong>的代码中定位到错误所在<strong>行</strong>信息</li>
<li>不需要定位列信息，打包<strong>速度较快</strong></li>
<li>在<strong>源代码</strong>中定位到错误所在<strong>行</strong>信息 👇🏻 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b4a0ab355de438098f544fd339bd5c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></li>
</ol>
<p><strong><code>inline-source-map</code> 模式：</strong></p>
<ol>
<li>通过 <strong>dataUrl</strong> 的形式引入 SourceMap 文件 👇🏻 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/127071e076ce40d0a9567d8a9ff2128d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></li>
</ol>
<p>… 余下和 <code>source-map</code> 模式一样</p>
<p><strong><code>hidden-source-map</code> 模式：</strong></p>
<ol>
<li>看不到 SourceMap 效果，但是生成了 SourceMap 文件</li>
</ol>
<p><strong><code>nosources-source-map</code> 模式：</strong></p>
<ol>
<li>能看到错误出现的位置 👇🏻</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1935a054b1dc47f7b2a0156a635a8ce7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<ol>
<li>但是没有办法现实对应的源码</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a64e5446bd0c454091db7b72864a7504~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>接下来，我们稍微总结一下：</p>
<table>
<thead>
<tr>
<th>devtool</th>
<th>build</th>
<th>rebuild</th>
<th>显示代码</th>
<th>SourceMap 文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>(none)</td>
<td>很快</td>
<td>很快</td>
<td>无</td>
<td>无</td>
<td>无法定位错误</td>
</tr>
<tr>
<td>eval</td>
<td>快</td>
<td>很快（cache）</td>
<td>编译后</td>
<td>无</td>
<td>定位到文件</td>
</tr>
<tr>
<td>source-map</td>
<td>很慢</td>
<td>很慢</td>
<td>源代码</td>
<td>有</td>
<td>定位到行列</td>
</tr>
<tr>
<td>eval-source-map</td>
<td>很慢</td>
<td>一般（cache）</td>
<td>编译后</td>
<td>有（dataUrl）</td>
<td>定位到行列</td>
</tr>
<tr>
<td>eval-cheap-source-map</td>
<td>一般</td>
<td>快（cache）</td>
<td>编译后</td>
<td>有（dataUrl）</td>
<td>定位到行</td>
</tr>
<tr>
<td>eval-cheap-module-source-map</td>
<td>慢</td>
<td>快（cache）</td>
<td>源代码</td>
<td>有（dataUrl）</td>
<td>定位到行</td>
</tr>
<tr>
<td>inline-source-map</td>
<td>很慢</td>
<td>很慢</td>
<td>源代码</td>
<td>有（dataUrl）</td>
<td>定位到行列</td>
</tr>
<tr>
<td>hidden-source-map</td>
<td>很慢</td>
<td>很慢</td>
<td>源代码</td>
<td>有</td>
<td>无法定位错误</td>
</tr>
<tr>
<td>nosource-source-map</td>
<td>很慢</td>
<td>很慢</td>
<td>源代码</td>
<td>无</td>
<td>定位到文件</td>
</tr>
</tbody></table>
<p>对照一下校验规则 <code>^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$</code> 分析一下关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>inline</td>
<td>代码内通过 dataUrl 形式引入 SourceMap</td>
</tr>
<tr>
<td>hidden</td>
<td>生成 SourceMap 文件，但不使用</td>
</tr>
<tr>
<td>eval</td>
<td><code>eval(...)</code> 形式执行代码，通过 dataUrl 形式引入 SourceMap</td>
</tr>
<tr>
<td>nosources</td>
<td>不生成 SourceMap</td>
</tr>
<tr>
<td>cheap</td>
<td>只需要定位到行信息，不需要列信息</td>
</tr>
<tr>
<td>module</td>
<td>展示源代码中的错误位置</td>
</tr>
</tbody></table>
<p>好了，到这里 SourceMap 就分析完了</p>
<h4 id="2-3-推荐配置"><a href="#2-3-推荐配置" class="headerlink" title="2.3 推荐配置"></a>2.3 推荐配置</h4><ol>
<li>本地开发：</li>
</ol>
<p>推荐：<code>eval-cheap-module-source-map</code></p>
<p>理由：</p>
<ul>
<li><p>本地开发首次打包慢点没关系，因为 <code>eval</code> 缓存的原因，rebuild 会很快</p>
</li>
<li><p>开发中，我们每行代码不会写的太长，只需要定位到行就行，所以加上 <code>cheap</code></p>
</li>
<li><p>我们希望能够找到源代码的错误，而不是打包后的，所以需要加上 <code>module</code></p>
</li>
</ul>
<ol>
<li>生产环境：</li>
</ol>
<p>推荐：<code>(none)</code></p>
<p>理由：</p>
<ul>
<li>就是不想别人看到我的源代码</li>
</ul>
<h3 id="3-三种-hash-值"><a href="#3-三种-hash-值" class="headerlink" title="3. 三种 hash 值"></a>3. 三种 hash 值</h3><p>Webpack 文件指纹策略是将文件名后面加上 hash 值。特别在使用 CDN 的时候，缓存是它的特点与优势，但如果打包的文件名，没有 hash 后缀的话，你肯定会被缓存折磨的够呛 😂</p>
<p>例如我们在基础配置中用到的：<code>filename: &quot;[name][hash:8][ext]&quot;</code></p>
<p>这里里面 <code>[]</code> 包起来的，就叫占位符，它们都是什么意思呢？请看下面这个表 👇🏻</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ext</td>
<td>文件后缀名</td>
</tr>
<tr>
<td>name</td>
<td>文件名</td>
</tr>
<tr>
<td>path</td>
<td>文件相对路径</td>
</tr>
<tr>
<td>folder</td>
<td>文件所在文件夹</td>
</tr>
<tr>
<td>hash</td>
<td>每次构建生成的唯一 hash 值</td>
</tr>
<tr>
<td>chunkhash</td>
<td>根据 chunk 生成 hash 值</td>
</tr>
<tr>
<td>contenthash</td>
<td>根据文件内容生成hash 值</td>
</tr>
</tbody></table>
<p>表格里面的 <code>hash</code>、<code>chunkhash</code>、<code>contenthash</code> 你可能还是不清楚差别在哪</p>
<ul>
<li><strong>hash</strong> ：任何一个文件改动，整个项目的构建 hash 值都会改变；</li>
<li><strong>chunkhash</strong>：文件的改动只会影响其所在 chunk 的 hash 值；</li>
<li><strong>contenthash</strong>：每个文件都有单独的 hash 值，文件的改动只会影响自身的 hash 值；</li>
</ul>
<h2 id="二、Webpack-进阶"><a href="#二、Webpack-进阶" class="headerlink" title="二、Webpack 进阶"></a>二、Webpack 进阶</h2><p>第二部分，我们将向“能优化”的方向前进 🏃</p>
<p>除了配置上的优化外，我们也要学习如何自己开发 Loader 和 Plugin</p>
<h3 id="1-优化构建速度"><a href="#1-优化构建速度" class="headerlink" title="1. 优化构建速度"></a>1. 优化构建速度</h3><h4 id="1-1-构建费时分析"><a href="#1-1-构建费时分析" class="headerlink" title="1.1 构建费时分析"></a>1.1 构建费时分析</h4><p>这里我们需要使用插件 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/speed-measure-webpack-plugin">speed-measure-webpack-plugin</a>，我们参考文档配置一下</p>
<ol>
<li>首先安装一下</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i -D speed-measure-webpack-plugin</span><br></pre></td></tr></table></figure>

<ol>
<li>修改我们的配置文件 webpack.config.js</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 费时分析</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SpeedMeasurePlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;speed-measure-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> <span class="title class_">SpeedMeasurePlugin</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里可以通过不同的模式修改 config 配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> smp.<span class="title function_">wrap</span>(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>执行打包</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae510d710d494d22a00378d8d52753d2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>报错了🤦🏻‍♂️</p>
<p>这里就暴露了使用这个插件的一个弊端，就是：</p>
<ul>
<li><strong>有些 Loader 或者 Plugin 新版本会不兼容，需要进行降级处理</strong></li>
</ul>
<p>这里我们对 <code>mini-css-extract-plugin</code> 进行一下降级处理: <code>^2.1.0</code> -&gt; <code>^1.3.6</code></p>
<p>重新安装一下依赖，再次执行打包</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e369fd6b2994270971fd87291e694f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>降了版本之后，还是报错，根据提示信息，我们给配置加上 <code>publicPath: &#39;./&#39;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 输出文件目录</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>在尝试一次</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8abe8e0dfeb94ffe94adce229d04d0e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>成功了！</p>
<blockquote>
<p><strong>注意：在 webpack5.x 中为了使用费时分析去对插件进行降级或者修改配置写法是非常不划算的</strong>，这里因为演示需要，我后面会继续使用，但是在平时开发中，建议还是不要使用。</p>
</blockquote>
<h4 id="1-2-优化-resolve-配置"><a href="#1-2-优化-resolve-配置" class="headerlink" title="1.2 优化 resolve 配置"></a>1.2 优化 resolve 配置</h4><h5 id="1-2-1-alias"><a href="#1-2-1-alias" class="headerlink" title="1.2.1 alias"></a>1.2.1 alias</h5><p>alias 用的创建 <code>import</code> 或 <code>require</code> 的别名，用来简化模块引用，项目中基本都需要进行配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 路径处理方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">dir</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> path.<span class="title function_">join</span>(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> config  = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">resolve</span>:&#123;</span><br><span class="line">    <span class="comment">// 配置别名</span></span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;~&#x27;</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">      <span class="string">&#x27;components&#x27;</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src/components&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配置完成之后，我们在项目中就可以</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 src 别名 ~ </span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;~/fonts/iconfont.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 src 别名 @ </span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/fonts/iconfont.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 components 别名</span></span><br><span class="line"><span class="keyword">import</span> footer <span class="keyword">from</span> <span class="string">&quot;components/footer&quot;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-extensions"><a href="#1-2-2-extensions" class="headerlink" title="1.2.2 extensions"></a>1.2.2 extensions</h5><p>webpack 默认配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;.wasm&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果用户引入模块时不带扩展名，例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> file <span class="keyword">from</span> <span class="string">&#x27;../path/to/file&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>那么 webpack 就会按照 extensions 配置的数组从左到右的顺序去尝试解析模块</p>
<p>需要注意的是：</p>
<ol>
<li>高频文件后缀名放前面；</li>
<li>手动配置后，默认配置会被覆盖</li>
</ol>
<p>如果想保留默认配置，可以用 <code>...</code> 扩展运算符代表默认配置，例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;...&#x27;</span>], </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-3-modules"><a href="#1-2-3-modules" class="headerlink" title="1.2.3 modules"></a>1.2.3 modules</h5><p>告诉 webpack 解析模块时应该搜索的目录，常见配置如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径处理方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">dir</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> path.<span class="title function_">join</span>(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">     <span class="attr">modules</span>: [<span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>), <span class="string">&#x27;node_modules&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>告诉 webpack 优先 src 目录下查找需要解析的文件，会大大节省查找时间</p>
<h5 id="1-2-4-resolveLoader"><a href="#1-2-4-resolveLoader" class="headerlink" title="1.2.4 resolveLoader"></a>1.2.4 resolveLoader</h5><p>resolveLoader 与上面的 resolve 对象的属性集合相同， 但仅用于解析 webpack 的 <a href="https://link.juejin.cn/?target=https://webpack.docschina.org/concepts/loaders">loader</a> 包。</p>
<p><strong>一般情况下保持默认配置就可以了，但如果你有自定义的 Loader 就需要配置一下</strong>，不配可能会因为找不到 loader 报错</p>
<ul>
<li>例如：我们在 loader 文件夹下面，放着我们自己写的 loader</li>
</ul>
<p>我们就可以怎么配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径处理方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">dir</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> path.<span class="title function_">join</span>(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">resolveLoader</span>: &#123;</span><br><span class="line">    <span class="attr">modules</span>: [<span class="string">&#x27;node_modules&#x27;</span>,<span class="title function_">resolve</span>(<span class="string">&#x27;loader&#x27;</span>)]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-externals"><a href="#1-3-externals" class="headerlink" title="1.3 externals"></a>1.3 externals</h4><p><code>externals</code> 配置选项提供了「<strong>从输出的 bundle 中排除依赖</strong>」的方法。此功能通常对 <strong>library 开发人员</strong>来说是最有用的，然而也会有各种各样的应用程序用到它。</p>
<p>例如，从 CDN 引入 jQuery，而不是把它打包：</p>
<ol>
<li>引入链接</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">integrity</span>=<span class="string">&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>配置 externals</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">externals</span>: &#123;</span><br><span class="line">    <span class="attr">jquery</span>: <span class="string">&#x27;jQuery&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 jQuery</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;.my-element&#x27;</span>).<span class="title function_">animate</span>(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure>

<p>我们可以用这样的方法来剥离不需要改动的一些依赖，大大节省打包构建的时间。</p>
<h4 id="1-3-缩小范围"><a href="#1-3-缩小范围" class="headerlink" title="1.3 缩小范围"></a>1.3 缩小范围</h4><p>在配置 loader 的时候，我们需要更精确的去指定 loader 的作用目录或者需要排除的目录，通过使用 <code>include</code> 和 <code>exclude</code> 两个配置项，可以实现这个功能，常见的例如：</p>
<ul>
<li>**<code>include</code>**：符合条件的模块进行解析</li>
<li>**<code>exclude</code>**：排除符合条件的模块，不解析</li>
<li><strong><code>exclude</code></strong> 优先级更高</li>
</ul>
<p>例如在配置 babel 的时候</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径处理方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">dir</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> path.<span class="title function_">join</span>(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">noParse</span>: <span class="regexp">/jquery|lodash/</span>,</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/i</span>,</span><br><span class="line">        <span class="attr">include</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-noParse"><a href="#1-3-noParse" class="headerlink" title="1.3 noParse"></a>1.3 noParse</h4><ul>
<li>不需要解析依赖的第三方大型类库等，可以通过这个字段进行配置，以提高构建速度</li>
<li>使用 noParse 进行忽略的模块文件中不会解析 <code>import</code>、<code>require</code> 等语法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">noParse</span>: <span class="regexp">/jquery|lodash/</span>,</span><br><span class="line">    <span class="attr">rules</span>:[...]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-IgnorePlugin"><a href="#1-4-IgnorePlugin" class="headerlink" title="1.4 IgnorePlugin"></a>1.4 IgnorePlugin</h4><p>防止在 <code>import</code> 或 <code>require</code> 调用时，生成以下正则表达式匹配的模块：</p>
<ul>
<li><code>requestRegExp</code> 匹配(test)资源请求路径的正则表达式。</li>
<li><code>contextRegExp</code> 匹配(test)资源上下文（目录）的正则表达式。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.<span class="title class_">IgnorePlugin</span>(&#123; resourceRegExp, contextRegExp &#125;);</span><br></pre></td></tr></table></figure>

<p>以下示例演示了此插件的几种用法。</p>
<ol>
<li>安装 moment 插件（时间处理库）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm i -S moment</span><br></pre></td></tr></table></figure>

<ol>
<li>配置 IgnorePlugin</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 webpack</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">plugins</span>:[ <span class="comment">// 配置插件</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">IgnorePlugin</span>(&#123;</span><br><span class="line">      <span class="attr">resourceRegExp</span>: <span class="regexp">/^\.\/locale$/</span>,</span><br><span class="line">      <span class="attr">contextRegExp</span>: <span class="regexp">/moment$/</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ]  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>目的是将插件中的非中文语音排除掉，这样就可以大大节省打包的体积了</p>
<h4 id="1-5-多进程配置"><a href="#1-5-多进程配置" class="headerlink" title="1.5 多进程配置"></a>1.5 多进程配置</h4><blockquote>
<p><strong>注意</strong>：实际上在小型项目中，开启多进程打包反而会增加时间成本，因为启动进程和进程间通信都会有一定开销。</p>
</blockquote>
<h5 id="1-5-1-thread-loader"><a href="#1-5-1-thread-loader" class="headerlink" title="1.5.1 thread-loader"></a>1.5.1 thread-loader</h5><p>配置在 <a href="https://link.juejin.cn/?target=https://webpack.docschina.org/loaders/thread-loader/%23root">thread-loader</a> 之后的 loader 都会在一个单独的 worker 池（worker pool）中运行</p>
<ol>
<li>安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i -D  thread-loader</span><br></pre></td></tr></table></figure>

<ol>
<li>配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径处理方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">dir</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> path.<span class="title function_">join</span>(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">noParse</span>: <span class="regexp">/jquery|lodash/</span>,</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/i</span>,</span><br><span class="line">        <span class="attr">include</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;thread-loader&#x27;</span>, <span class="comment">// 开启多进程打包</span></span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">worker</span>: <span class="number">3</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-2-happypack-❌"><a href="#1-5-2-happypack-❌" class="headerlink" title="1.5.2 happypack ❌"></a>1.5.2 happypack ❌</h5><p>同样为开启多进程打包的工具，webpack5 已弃用。</p>
<h4 id="1-6-利用缓存"><a href="#1-6-利用缓存" class="headerlink" title="1.6 利用缓存"></a>1.6 利用缓存</h4><p>利用缓存可以大幅提升重复构建的速度</p>
<h5 id="1-6-1-babel-loader-开启缓存"><a href="#1-6-1-babel-loader-开启缓存" class="headerlink" title="1.6.1 babel-loader 开启缓存"></a>1.6.1 babel-loader 开启缓存</h5><ul>
<li>babel 在转译 js 过程中时间开销比价大，将 babel-loader 的执行结果缓存起来，重新打包的时候，直接读取缓存</li>
<li>缓存位置： <code>node_modules/.cache/babel-loader</code></li>
</ul>
<p>具体配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"> <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="attr">noParse</span>: <span class="regexp">/jquery|lodash/</span>,</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/i</span>,</span><br><span class="line">        <span class="attr">include</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">cacheDirectory</span>: <span class="literal">true</span> <span class="comment">// 启用缓存</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那其他的 loader 如何将结果缓存呢？</p>
<p><a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/cache-loader">cache-loader</a> 就可以帮我们完成这件事情</p>
<h5 id="1-6-2-cache-loader"><a href="#1-6-2-cache-loader" class="headerlink" title="1.6.2 cache-loader"></a>1.6.2 cache-loader</h5><ul>
<li><p>缓存一些性能开销比较大的 loader 的处理结果</p>
</li>
<li><p>缓存位置：<code>node_modules/.cache/cache-loader</code></p>
</li>
</ul>
<ol>
<li>安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i -D cache-loader</span><br></pre></td></tr></table></figure>

<ol>
<li>配置 cache-loader</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"> <span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(s[ac]|c)ss$/i</span>, <span class="comment">//匹配所有的 sass/scss/css 文件</span></span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="comment">// &#x27;style-loader&#x27;,</span></span><br><span class="line">          <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">          <span class="string">&#x27;cache-loader&#x27;</span>, <span class="comment">// 获取前面 loader 转换的结果</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;sass-loader&#x27;</span>, </span><br><span class="line">        ]</span><br><span class="line">      &#125;, </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-6-3-hard-source-webpack-plugin"><a href="#1-6-3-hard-source-webpack-plugin" class="headerlink" title="1.6.3 hard-source-webpack-plugin"></a>1.6.3 hard-source-webpack-plugin</h5><ul>
<li><a href="https://link.juejin.cn/?target=https://github.com/mzgoddard/hard-source-webpack-plugin">hard-source-webpack-plugin</a> 为模块提供了中间缓存，重复构建时间大约可以减少 80%，但是在 <strong>webpack5 中已经内置了模块缓存，不需要再使用此插件</strong></li>
</ul>
<h5 id="1-6-4-dll-❌"><a href="#1-6-4-dll-❌" class="headerlink" title="1.6.4 dll ❌"></a>1.6.4 dll ❌</h5><p>在 webpack5.x 中已经不建议使用这种方式进行模块缓存，因为其已经内置了更好体验的 cache 方法</p>
<h5 id="1-6-5-cache-持久化缓存"><a href="#1-6-5-cache-持久化缓存" class="headerlink" title="1.6.5 cache 持久化缓存"></a>1.6.5 cache 持久化缓存</h5><p>通过配置 <a href="https://link.juejin.cn/?target=https://webpack.docschina.org/configuration/cache/%23root">cache</a> 缓存生成的 webpack 模块和 chunk，来改善构建速度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">cache</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;filesystem&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-优化构建结果"><a href="#2-优化构建结果" class="headerlink" title="2. 优化构建结果"></a>2. 优化构建结果</h3><h4 id="2-1-构建结果分析"><a href="#2-1-构建结果分析" class="headerlink" title="2.1 构建结果分析"></a>2.1 构建结果分析</h4><p>借助插件 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a> 我们可以直观的看到打包结果中，文件的体积大小、各模块依赖关系、文件是够重复等问题，极大的方便我们在进行项目优化的时候，进行问题诊断。</p>
<ol>
<li>安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i -D webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>

<ol>
<li>配置插件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BundleAnalyzerPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).<span class="property">BundleAnalyzerPlugin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>:[ </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 配置插件 </span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// analyzerMode: &#x27;disabled&#x27;,  // 不启动展示打包报告的http服务器</span></span><br><span class="line">      <span class="comment">// generateStatsFile: true, // 是否生成stats.json文件</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>修改启动命令</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=prod webpack --progress --mode production&quot;</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<ol>
<li>执行编译命令 <code>npm run analyzer</code></li>
</ol>
<p>打包结束后，会自行启动地址为 <code>http://127.0.0.1:8888</code> 的 web 服务，访问地址就可以看到</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee392f0838bd43e5aeeb405c76f2fbc7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>如果，我们只想保留数据不想启动 web 服务，这个时候，我们可以加上两个配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>(&#123;</span><br><span class="line">   <span class="attr">analyzerMode</span>: <span class="string">&#x27;disabled&#x27;</span>,  <span class="comment">// 不启动展示打包报告的http服务器</span></span><br><span class="line">   <span class="attr">generateStatsFile</span>: <span class="literal">true</span>, <span class="comment">// 是否生成stats.json文件</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样再次执行打包的时候就只会产生 state.json 的文件了</p>
<h4 id="2-2-压缩-CSS"><a href="#2-2-压缩-CSS" class="headerlink" title="2.2 压缩 CSS"></a>2.2 压缩 CSS</h4><ol>
<li>安装 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/optimize-css-assets-webpack-plugin"><code>optimize-css-assets-webpack-plugin</code></a></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -D optimize-css-assets-webpack-plugin </span><br></pre></td></tr></table></figure>

<ol>
<li>修改 <code>webapck.config.js</code> 配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 压缩css</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OptimizeCssAssetsPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="comment">// 添加 css 压缩配置</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">OptimizeCssAssetsPlugin</span>(&#123;&#125;),</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ol>
<li>查看打包结果</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b3174e204994b2e9c845f5bbc144577~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<h4 id="2-3-压缩-JS"><a href="#2-3-压缩-JS" class="headerlink" title="2.3 压缩 JS"></a>2.3 压缩 JS</h4><blockquote>
<p>在生成环境下打包默认会开启 js 压缩，但是当我们手动配置 <code>optimization</code> 选项之后，就不再默认对 js 进行压缩，需要我们手动去配置。</p>
</blockquote>
<p>因为 webpack5 内置了<a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/terser-webpack-plugin">terser-webpack-plugin</a> 插件，所以我们不需重复安装，直接引用就可以了，具体配置如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimize</span>: <span class="literal">true</span>, <span class="comment">// 开启最小化</span></span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;&#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-清除无用的-CSS"><a href="#2-4-清除无用的-CSS" class="headerlink" title="2.4 清除无用的 CSS"></a>2.4 清除无用的 CSS</h4><p><a href="https://link.juejin.cn/?target=https://www.purgecss.cn/plugins/webpack.html%23%E7%94%A8%E6%B3%95">purgecss-webpack-plugin</a> 会单独提取 CSS 并清除用不到的 CSS</p>
<ol>
<li>安装插件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i -D purgecss-webpack-plugin</span><br></pre></td></tr></table></figure>

<ol>
<li>添加配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PurgecssWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;purgecss-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">&#x27;glob&#x27;</span>); <span class="comment">// 文件匹配模式</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">dir</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> path.<span class="title function_">join</span>(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PATHS</span> = &#123;</span><br><span class="line">  <span class="attr">src</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">plugins</span>:[ <span class="comment">// 配置插件</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PurgecssPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">paths</span>: glob.<span class="title function_">sync</span>(<span class="string">`<span class="subst">$&#123;PATHS.src&#125;</span>/**/*`</span>, &#123;<span class="attr">nodir</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>index.html 新增节点</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>ITEM<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用字体图标文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-member&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;imgBox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 新增 div，设置 class 为 used --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;used&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>在 sass.scss 中添加样式</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.used</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.unused</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: chocolate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>执行一下打包</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ca0ac6b477146ad82d6b1332ae626a6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>我们可以看到只有 <code>.used</code> 被保存下来</p>
<p>如何证明是这个插件的作用呢？注释掉再打包就可以看到，<code>.unused</code> 也会被打包进去，由此可证…</p>
<h4 id="2-5-Tree-shaking"><a href="#2-5-Tree-shaking" class="headerlink" title="2.5 Tree-shaking"></a>2.5 Tree-shaking</h4><p>Tree-shaking 作用是剔除没有使用的代码，以降低包的体积</p>
<ul>
<li>webpack 默认支持，需要在 .bablerc 里面设置 <code>model：false</code>，即可在生产环境下默认开启</li>
</ul>
<p>了解更多 Tree-shaking 知识，推荐阅读 👉🏻 <a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s/TNXO2ifPymaTxIqzBAmkSQ">从过去到现在，聊聊 Tree-shaking</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">module</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">useBuiltIns</span>: <span class="string">&quot;entry&quot;</span>,</span><br><span class="line">        <span class="attr">corejs</span>: <span class="string">&quot;3.9.1&quot;</span>,</span><br><span class="line">        <span class="attr">targets</span>: &#123;</span><br><span class="line">          <span class="attr">chrome</span>: <span class="string">&quot;58&quot;</span>,</span><br><span class="line">          <span class="attr">ie</span>: <span class="string">&quot;11&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">plugins</span>: [    </span><br><span class="line">    [<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>, &#123; <span class="attr">legacy</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    [<span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span>, &#123; <span class="attr">loose</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-Scope-Hoisting"><a href="#2-6-Scope-Hoisting" class="headerlink" title="2.6 Scope Hoisting"></a>2.6 Scope Hoisting</h4><p>Scope Hoisting 即作用域提升，原理是将多个模块放在同一个作用域下，并重命名防止命名冲突，<strong>通过这种方式可以减少函数声明和内存开销</strong>。</p>
<ul>
<li>webpack 默认支持，在生产环境下默认开启</li>
<li>只支持 es6 代码</li>
</ul>
<h3 id="3-优化运行时体验"><a href="#3-优化运行时体验" class="headerlink" title="3. 优化运行时体验"></a>3. 优化运行时体验</h3><p>运行时优化的核心就是提升首屏的加载速度，主要的方式就是</p>
<ul>
<li>降低首屏加载文件体积，首屏不需要的文件进行预加载或者按需加载</li>
</ul>
<h4 id="3-1-入口点分割"><a href="#3-1-入口点分割" class="headerlink" title="3.1 入口点分割"></a>3.1 入口点分割</h4><p>配置多个打包入口，多页打包，这里不过多介绍</p>
<h4 id="3-2-splitChunks-分包配置"><a href="#3-2-splitChunks-分包配置" class="headerlink" title="3.2 splitChunks 分包配置"></a>3.2 splitChunks 分包配置</h4><p>optimization.splitChunks 是基于 <a href="https://link.juejin.cn/?target=https://webpack.docschina.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a> 插件实现的</p>
<p>默认情况下，它只会影响到按需加载的 chunks，因为修改 initial chunks 会影响到项目的 HTML 文件中的脚本标签。</p>
<p>webpack 将根据以下条件自动拆分 chunks：</p>
<ul>
<li><p>新的 chunk 可以被共享，或者模块来自于 <code>node_modules</code> 文件夹</p>
</li>
<li><p>新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积）</p>
</li>
<li><p>当按需加载 chunks 时，并行请求的最大数量小于或等于 30</p>
</li>
<li><p>当加载初始化页面时，并发请求的最大数量小于或等于 30</p>
</li>
</ul>
<ol>
<li>默认配置介绍</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&#x27;async&#x27;</span>, <span class="comment">// 有效值为 `all`，`async` 和 `initial`</span></span><br><span class="line">      <span class="attr">minSize</span>: <span class="number">20000</span>, <span class="comment">// 生成 chunk 的最小体积（≈ 20kb)</span></span><br><span class="line">      <span class="attr">minRemainingSize</span>: <span class="number">0</span>, <span class="comment">// 确保拆分后剩余的最小 chunk 体积超过限制来避免大小为零的模块</span></span><br><span class="line">      <span class="attr">minChunks</span>: <span class="number">1</span>, <span class="comment">// 拆分前必须共享模块的最小 chunks 数。</span></span><br><span class="line">      <span class="attr">maxAsyncRequests</span>: <span class="number">30</span>, <span class="comment">// 最大的按需(异步)加载次数</span></span><br><span class="line">      <span class="attr">maxInitialRequests</span>: <span class="number">30</span>, <span class="comment">// 打包后的入口文件加载时，还能同时加载js文件的数量（包括入口文件）</span></span><br><span class="line">      <span class="attr">enforceSizeThreshold</span>: <span class="number">50000</span>,</span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123; <span class="comment">// 配置提取模块的方案</span></span><br><span class="line">        <span class="attr">defaultVendors</span>: &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/[\/]node_modules[\/]/</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">10</span>,</span><br><span class="line">          <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">          <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">20</span>,</span><br><span class="line">          <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>项目中的使用</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123; <span class="comment">// 配置提取模块的方案</span></span><br><span class="line">        <span class="attr">default</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">styles</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;styles&#x27;</span>,</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.(s?css|less|sass)$/</span>,</span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">            <span class="attr">enforce</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">priority</span>: <span class="number">10</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">common</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;chunk-common&#x27;</span>,</span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">            <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">maxInitialRequests</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">minSize</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">priority</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">enforce</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">vendors</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;chunk-vendors&#x27;</span>,</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">            <span class="attr">priority</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">enforce</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">         <span class="comment">// ... 根据不同项目再细化拆分内容</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-代码懒加载"><a href="#3-3-代码懒加载" class="headerlink" title="3.3 代码懒加载"></a>3.3 代码懒加载</h4><p>针对首屏加载不太需要的一些资源，我们可以通过懒加载的方式去实现，下面看一个小🌰</p>
<ul>
<li>需求：点击图片给图片加一个描述</li>
</ul>
<p><strong>1. 新建图片描述信息</strong></p>
<p><strong>desc.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ele = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">ele.<span class="property">innerHTML</span> = <span class="string">&#x27;我是图片描述&#x27;</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = ele</span><br></pre></td></tr></table></figure>

<p><strong>2. 点击图片引入描述</strong></p>
<p><strong>index.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./main.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./sass.scss&#x27;</span></span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">&#x27;../public/avatar.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/fonts/iconfont.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;Hello ITEM&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line">img.<span class="property">src</span> = logo</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;imgBox&#x27;</span>).<span class="title function_">appendChild</span>(img)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按需加载</span></span><br><span class="line">img.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./desc&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: element &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(element)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>3. 查看效果</strong></p>
<ul>
<li>点击前</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cdeeabe18da4e5f93edc40e429b30c8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c9ac178ffa340b8824e0dc18f8a6a1a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<ul>
<li>点击后</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1f0d664c3e34deda3e8270ce20f6116~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2f2be3f57164f06863b0283ea396e12~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<h4 id="3-4-prefetch-与-preload"><a href="#3-4-prefetch-与-preload" class="headerlink" title="3.4 prefetch 与 preload"></a>3.4 prefetch 与 preload</h4><p>上面我们使用异步加载的方式引入图片的描述，但是如果需要异步加载的文件比较大时，在点击的时候去加载也会影响到我们的体验，这个时候我们就可以考虑使用 prefetch 来进行预拉取</p>
<h5 id="3-4-1-prefetch"><a href="#3-4-1-prefetch" class="headerlink" title="3.4.1 prefetch"></a>3.4.1 prefetch</h5><blockquote>
<ul>
<li><strong>prefetch</strong> (预获取)：浏览器空闲的时候进行资源的拉取</li>
</ul>
</blockquote>
<p>改造一下上面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按需加载</span></span><br><span class="line">img.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>( <span class="comment">/* webpackPrefetch: true */</span> <span class="string">&#x27;./desc&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: element &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(element)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-4-2-preload"><a href="#3-4-2-preload" class="headerlink" title="3.4.2 preload"></a>3.4.2 preload</h5><blockquote>
<ul>
<li><strong>preload</strong> (预加载)：提前加载后面会用到的关键资源</li>
<li>⚠️ 因为会提前拉取资源，如果不是特殊需要，谨慎使用</li>
</ul>
</blockquote>
<p>官网示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPreload: true */</span> <span class="string">&#x27;ChartingLibrary&#x27;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Css</title>
    <url>/2022/10/19/20221019-Css/</url>
    <content><![CDATA[<h2 id="CSS-面试知识点总结"><a href="#CSS-面试知识点总结" class="headerlink" title="CSS 面试知识点总结"></a>CSS 面试知识点总结</h2><p>本部分主要是笔者在复习 CSS 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#1%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%A0%87%E5%87%86%E7%9A%84-css-%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%BD%8E%E7%89%88%E6%9C%AC-ie-%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E7%9A%84">1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</a></li>
<li><a href="#2css-%E9%80%89%E6%8B%A9%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B">2.CSS 选择符有哪些？</a></li>
<li><a href="#3before-%E5%92%8Cafter-%E4%B8%AD%E5%8F%8C%E5%86%92%E5%8F%B7%E5%92%8C%E5%8D%95%E5%86%92%E5%8F%B7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E8%BF%99-2-%E4%B8%AA%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%9C%E7%94%A8">3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。</a></li>
<li><a href="#4%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB">4.伪类与伪元素的区别</a></li>
<li><a href="#5css-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF">5.CSS 中哪些属性可以继承？</a></li>
<li><a href="#6css-%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97">6.CSS 优先级算法如何计算？</a></li>
<li><a href="#7%E5%85%B3%E4%BA%8E%E4%BC%AA%E7%B1%BB-lvha-%E7%9A%84%E8%A7%A3%E9%87%8A">7.关于伪类 LVHA 的解释?</a></li>
<li><a href="#8css3-%E6%96%B0%E5%A2%9E%E4%BC%AA%E7%B1%BB%E6%9C%89%E9%82%A3%E4%BA%9B">8.CSS3 新增伪类有那些？</a></li>
<li><a href="#9%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%AD-div">9.如何居中 div？</a></li>
<li><a href="#10display-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%80%BC%E8%AF%B4%E6%98%8E%E4%BB%96%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8">10.display 有哪些值？说明他们的作用。</a></li>
<li><a href="#11position-%E7%9A%84%E5%80%BC-relative-%E5%92%8C-absolute-%E5%AE%9A%E4%BD%8D%E5%8E%9F%E7%82%B9%E6%98%AF">11.position 的值 relative 和 absolute 定位原点是？</a></li>
<li><a href="#12css3-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E6%A0%B9%E6%8D%AE%E9%A1%B9%E7%9B%AE%E5%9B%9E%E7%AD%94">12.CSS3 有哪些新特性？（根据项目回答）</a></li>
<li><a href="#13%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-css3-%E7%9A%84-flex-box%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">13.请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？</a></li>
<li><a href="#14%E7%94%A8%E7%BA%AF-css-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">14.用纯 CSS 创建一个三角形的原理是什么？</a></li>
<li><a href="#15%E4%B8%80%E4%B8%AA%E6%BB%A1%E5%B1%8F%E5%93%81%E5%AD%97%E5%B8%83%E5%B1%80%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1">15.一个满屏品字布局如何设计?</a></li>
<li><a href="#16css-%E5%A4%9A%E5%88%97%E7%AD%89%E9%AB%98%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0">16.CSS 多列等高如何实现？</a></li>
<li><a href="#17%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%9B%A0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%E5%B8%B8%E7%94%A8-hack-%E7%9A%84%E6%8A%80%E5%B7%A7">17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？</a></li>
<li><a href="#18li-%E4%B8%8E-li-%E4%B9%8B%E9%97%B4%E6%9C%89%E7%9C%8B%E4%B8%8D%E8%A7%81%E7%9A%84%E7%A9%BA%E7%99%BD%E9%97%B4%E9%9A%94%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%BC%95%E8%B5%B7%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</a></li>
<li><a href="#19%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96-css-%E6%A0%B7%E5%BC%8F">19.为什么要初始化 CSS 样式？</a></li>
<li><a href="#20%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%85%E5%90%AB%E5%9D%97%E5%AF%B9%E4%BA%8E%E5%8C%85%E5%90%AB%E5%9D%97%E7%9A%84%E7%90%86%E8%A7%A3">20.什么是包含块，对于包含块的理解?</a></li>
<li><a href="#21css-%E9%87%8C%E7%9A%84-visibility-%E5%B1%9E%E6%80%A7%E6%9C%89%E4%B8%AA-collapse-%E5%B1%9E%E6%80%A7%E5%80%BC%E6%98%AF%E5%B9%B2%E5%98%9B%E7%94%A8%E7%9A%84%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E4%BB%A5%E5%90%8E%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？</a></li>
<li><a href="#22widthauto-%E5%92%8C-width100%E7%9A%84%E5%8C%BA%E5%88%AB">22.width:auto 和 width:100\x 的区别</a></li>
<li><a href="#23%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0%E4%B8%8E%E9%9D%9E%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E8%AE%A1%E7%AE%97%E7%9A%84%E5%8C%BA%E5%88%AB">23.绝对定位元素与非绝对定位元素的百分比计算的区别</a></li>
<li><a href="#24%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87-base64-%E7%BC%96%E7%A0%81%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9">24.简单介绍使用图片 base64 编码的优点和缺点。</a></li>
<li><a href="#25displayposition%E5%92%8Cfloat%E7%9A%84%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB">25.’display’、’position’和’float’的相互关系？</a></li>
<li><a href="#26margin-%E9%87%8D%E5%8F%A0%E9%97%AE%E9%A2%98%E7%9A%84%E7%90%86%E8%A7%A3">26.margin 重叠问题的理解。</a></li>
<li><a href="#27%E5%AF%B9-bfc-%E8%A7%84%E8%8C%83%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87block-formatting-context%E7%9A%84%E7%90%86%E8%A7%A3">27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？</a></li>
<li><a href="#28ifc-%E6%98%AF%E4%BB%80%E4%B9%88">28.IFC 是什么？</a></li>
<li><a href="#29%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F">29.请解释一下为什么需要清除浮动？清除浮动的方式</a></li>
<li><a href="#30%E4%BD%BF%E7%94%A8-clear-%E5%B1%9E%E6%80%A7%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E5%8E%9F%E7%90%86">30.使用 clear 属性清除浮动的原理？</a></li>
<li><a href="#31zoom1-%E7%9A%84%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%8E%9F%E7%90%86">31.zoom:1 的清除浮动原理?</a></li>
<li><a href="#32%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%B8%83%E5%B1%80%E7%94%A8%E8%BF%87%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%90%97">32.移动端的布局用过媒体查询吗？</a></li>
<li><a href="#33%E4%BD%BF%E7%94%A8-css-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%90%97%E5%96%9C%E6%AC%A2%E5%93%AA%E4%B8%AA">33.使用 CSS 预处理器吗？喜欢哪个？</a></li>
<li><a href="#34css-%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">34.CSS 优化、提高性能的方法有哪些？</a></li>
<li><a href="#35%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E6%A0%B7%E8%A7%A3%E6%9E%90-css-%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84">35.浏览器是怎样解析 CSS 选择器的？</a></li>
<li><a href="#36%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%A5%87%E6%95%B0%E8%BF%98%E6%98%AF%E5%81%B6%E6%95%B0%E7%9A%84%E5%AD%97%E4%BD%93%E4%B8%BA%E4%BB%80%E4%B9%88%E5%91%A2">36.在网页中应该使用奇数还是偶数的字体？为什么呢？</a></li>
<li><a href="#37margin-%E5%92%8C-padding-%E5%88%86%E5%88%AB%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8">37.margin 和 padding 分别适合什么场景使用？</a></li>
<li><a href="#38%E6%8A%BD%E7%A6%BB%E6%A0%B7%E5%BC%8F%E6%A8%A1%E5%9D%97%E6%80%8E%E4%B9%88%E5%86%99%E8%AF%B4%E5%87%BA%E6%80%9D%E8%B7%AF%E6%9C%89%E6%97%A0%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C%E9%98%BF%E9%87%8C%E8%88%AA%E6%97%85%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98">38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</a></li>
<li><a href="#39%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B-css3-%E7%9A%84-all-%E5%B1%9E%E6%80%A7">39.简单说一下 css3 的 all 属性。</a></li>
<li><a href="#40%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%BB%9F%E9%85%8D%E7%AC%A6%E5%88%9D%E5%A7%8B%E5%8C%96-css-%E6%A0%B7%E5%BC%8F">40.为什么不建议使用统配符初始化 css 样式。</a></li>
<li><a href="#41absolute-%E7%9A%84-containingblock%E5%8C%85%E5%90%AB%E5%9D%97%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F%E8%B7%9F%E6%AD%A3%E5%B8%B8%E6%B5%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C">41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？</a></li>
<li><a href="#42%E5%AF%B9%E4%BA%8E-haslayout-%E7%9A%84%E7%90%86%E8%A7%A3">42.对于 hasLayout 的理解？</a></li>
<li><a href="#43%E5%85%83%E7%B4%A0%E7%AB%96%E5%90%91%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E8%AE%BE%E5%AE%9A%E6%98%AF%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E9%AB%98%E5%BA%A6%E5%90%97">43.元素竖向的百分比设定是相对于容器的高度吗？</a></li>
<li><a href="#44%E5%85%A8%E5%B1%8F%E6%BB%9A%E5%8A%A8%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E7%94%A8%E5%88%B0%E4%BA%86-css-%E7%9A%84%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%BE%85%E6%B7%B1%E5%85%A5%E5%AE%9E%E8%B7%B5">44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）</a></li>
<li><a href="#45%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E5%85%BC%E5%AE%B9%E4%BD%8E%E7%89%88%E6%9C%AC%E7%9A%84-ie%E5%BE%85%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3">45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）</a></li>
<li><a href="#46%E8%A7%86%E5%B7%AE%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C%E5%A6%82%E4%BD%95%E7%BB%99%E6%AF%8F%E9%A1%B5%E5%81%9A%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8A%A8%E7%94%BB%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8%E5%90%91%E4%B8%8B%E6%BB%91%E5%8A%A8%E8%A6%81%E5%86%8D%E6%AC%A1%E5%87%BA%E7%8E%B0%E5%92%8C%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E5%81%9A">46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</a></li>
<li><a href="#47%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9-chrome-%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81%E5%90%8E%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E8%A1%A8%E5%8D%95%E7%9A%84%E9%BB%84%E8%89%B2%E8%83%8C%E6%99%AF">47.如何修改 chrome 记住密码后自动填充表单的黄色背景？</a></li>
<li><a href="#48%E6%80%8E%E4%B9%88%E8%AE%A9-chrome-%E6%94%AF%E6%8C%81%E5%B0%8F%E4%BA%8E-12px-%E7%9A%84%E6%96%87%E5%AD%97">48.怎么让 Chrome 支持小于 12px 的文字？</a></li>
<li><a href="#49%E8%AE%A9%E9%A1%B5%E9%9D%A2%E9%87%8C%E7%9A%84%E5%AD%97%E4%BD%93%E5%8F%98%E6%B8%85%E6%99%B0%E5%8F%98%E7%BB%86%E7%94%A8-css-%E6%80%8E%E4%B9%88%E5%81%9A">49.让页面里的字体变清晰，变细用 CSS 怎么做？</a></li>
<li><a href="#50font-style-%E5%B1%9E%E6%80%A7%E4%B8%AD-italic-%E5%92%8C-oblique-%E7%9A%84%E5%8C%BA%E5%88%AB">50.font-style 属性中 italic 和 oblique 的区别？</a></li>
<li><a href="#51%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0css-%E5%83%8F%E7%B4%A0%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E5%83%8F%E7%B4%A0dprppi-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</a></li>
<li><a href="#52layout-viewportvisual-viewport-%E5%92%8C-ideal-viewport-%E7%9A%84%E5%8C%BA%E5%88%AB">52.layout viewport、visual viewport 和 ideal viewport 的区别？</a></li>
<li><a href="#53positionfixed%E5%9C%A8-android-%E4%B8%8B%E6%97%A0%E6%95%88%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86">53.position:fixed;在 android 下无效怎么处理？</a></li>
<li><a href="#54%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E5%86%99%E5%8A%A8%E7%94%BB%E4%BD%A0%E8%AE%A4%E4%B8%BA%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E6%98%AF%E5%A4%9A%E4%B9%85%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C">54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</a></li>
<li><a href="#55%E5%A6%82%E4%BD%95%E8%AE%A9%E5%8E%BB%E9%99%A4-inline-block-%E5%85%83%E7%B4%A0%E9%97%B4%E9%97%B4%E8%B7%9D">55.如何让去除 inline-block 元素间间距？</a></li>
<li><a href="#56overflowscroll-%E6%97%B6%E4%B8%8D%E8%83%BD%E5%B9%B3%E6%BB%91%E6%BB%9A%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86">56.overflow:scroll 时不能平滑滚动的问题怎么处理？</a></li>
<li><a href="#57%E6%9C%89%E4%B8%80%E4%B8%AA%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84-div%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%A4%E4%B8%AA-div%E4%B8%80%E4%B8%AA%E9%AB%98%E5%BA%A6-100px%E5%B8%8C%E6%9C%9B%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%A1%AB%E6%BB%A1%E5%89%A9%E4%B8%8B%E7%9A%84%E9%AB%98%E5%BA%A6">57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。</a></li>
<li><a href="#58pngjpggif-%E8%BF%99%E4%BA%9B%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%88%86%E5%88%AB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87-webp">58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</a></li>
<li><a href="#59%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81-webp-%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87">59.浏览器如何判断是否支持 webp 格式图片</a></li>
<li><a href="#60%E4%BB%80%E4%B9%88%E6%98%AF-cookie-%E9%9A%94%E7%A6%BB%E6%88%96%E8%80%85%E8%AF%B4%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E8%A6%81%E8%AE%A9%E5%AE%83%E5%B8%A6-cookie-%E6%80%8E%E4%B9%88%E5%81%9A">60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</a></li>
<li><a href="#61style-%E6%A0%87%E7%AD%BE%E5%86%99%E5%9C%A8-body-%E5%90%8E%E4%B8%8E-body-%E5%89%8D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">61.style 标签写在 body 后与 body 前有什么区别？</a></li>
<li><a href="#62%E4%BB%80%E4%B9%88%E6%98%AF-css-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8">62.什么是 CSS 预处理器/后处理器？</a></li>
<li><a href="#63%E9%98%90%E8%BF%B0%E4%B8%80%E4%B8%8B-csssprites">63.阐述一下 CSSSprites</a></li>
<li><a href="#64%E4%BD%BF%E7%94%A8-rem-%E5%B8%83%E5%B1%80%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">64.使用 rem 布局的优缺点？</a></li>
<li><a href="#65%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84-css-%E5%B8%83%E5%B1%80">65.几种常见的 CSS 布局</a></li>
<li><a href="#66%E7%94%BB%E4%B8%80%E6%9D%A1-05px-%E7%9A%84%E7%BA%BF">66.画一条 0.5px 的线</a></li>
<li><a href="#67transition-%E5%92%8C-animation-%E7%9A%84%E5%8C%BA%E5%88%AB">67.transition 和 animation 的区别</a></li>
<li><a href="#68%E4%BB%80%E4%B9%88%E6%98%AF%E9%A6%96%E9%80%89%E6%9C%80%E5%B0%8F%E5%AE%BD%E5%BA%A6">68.什么是首选最小宽度？</a></li>
<li><a href="#69%E4%B8%BA%E4%BB%80%E4%B9%88-height100%E4%BC%9A%E6%97%A0%E6%95%88">69.为什么 height:100\x 会无效？</a></li>
<li><a href="#70min-widthmax-width-%E5%92%8C-min-heightmax-height-%E5%B1%9E%E6%80%A7%E9%97%B4%E7%9A%84%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99">70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？</a></li>
<li><a href="#71%E5%86%85%E8%81%94%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">71.内联盒模型基本概念</a></li>
<li><a href="#72%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BD%E7%81%B5%E7%A9%BA%E7%99%BD%E8%8A%82%E7%82%B9">72.什么是幽灵空白节点？</a></li>
<li><a href="#73%E4%BB%80%E4%B9%88%E6%98%AF%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0">73.什么是替换元素？</a></li>
<li><a href="#74%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99">74.替换元素的计算规则？</a></li>
<li><a href="#75content-%E4%B8%8E%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%B3%E7%B3%BB">75.content 与替换元素的关系？</a></li>
<li><a href="#76marginauto-%E7%9A%84%E5%A1%AB%E5%85%85%E8%A7%84%E5%88%99">76.margin:auto 的填充规则？</a></li>
<li><a href="#77margin-%E6%97%A0%E6%95%88%E7%9A%84%E6%83%85%E5%BD%A2">77.margin 无效的情形</a></li>
<li><a href="#78border-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">78.border 的特殊性？</a></li>
<li><a href="#79%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E7%BA%BF%E5%92%8C-x-height">79.什么是基线和 x-height？</a></li>
<li><a href="#80line-height-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">80.line-height 的特殊性？</a></li>
<li><a href="#81vertical-align-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">81.vertical-align 的特殊性？</a></li>
<li><a href="#82overflow-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">82.overflow 的特殊性？</a></li>
<li><a href="#83%E6%97%A0%E4%BE%9D%E8%B5%96%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E6%98%AF%E4%BB%80%E4%B9%88">83.无依赖绝对定位是什么？</a></li>
<li><a href="#84absolute-%E4%B8%8E-overflow-%E7%9A%84%E5%85%B3%E7%B3%BB">84.absolute 与 overflow 的关系？</a></li>
<li><a href="#85clip-%E8%A3%81%E5%89%AA%E6%98%AF%E4%BB%80%E4%B9%88">85.clip 裁剪是什么？</a></li>
<li><a href="#86relative-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">86.relative 的特殊性？</a></li>
<li><a href="#87%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87">87.什么是层叠上下文？</a></li>
<li><a href="#88%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%82%E5%8F%A0%E6%B0%B4%E5%B9%B3">88.什么是层叠水平？</a></li>
<li><a href="#89%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F">89.元素的层叠顺序？</a></li>
<li><a href="#90%E5%B1%82%E5%8F%A0%E5%87%86%E5%88%99">90.层叠准则？</a></li>
<li><a href="#91font-weight-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">91.font-weight 的特殊性？</a></li>
<li><a href="#92text-indent-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">92.text-indent 的特殊性？</a></li>
<li><a href="#93letter-spacing-%E4%B8%8E%E5%AD%97%E7%AC%A6%E9%97%B4%E8%B7%9D">93.letter-spacing 与字符间距？</a></li>
<li><a href="#94word-spacing-%E4%B8%8E%E5%8D%95%E8%AF%8D%E9%97%B4%E8%B7%9D">94.word-spacing 与单词间距？</a></li>
<li><a href="#95white-space-%E4%B8%8E%E6%8D%A2%E8%A1%8C%E5%92%8C%E7%A9%BA%E6%A0%BC%E7%9A%84%E6%8E%A7%E5%88%B6">95.white-space 与换行和空格的控制？</a></li>
<li><a href="#96%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84-background-image-%E5%88%B0%E5%BA%95%E5%8A%A0%E4%B8%8D%E5%8A%A0%E8%BD%BD">96.隐藏元素的 background-image 到底加不加载？</a></li>
<li><a href="#97%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%A1%8C%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E7%9C%81%E7%95%A5">97.如何实现单行／多行文本溢出的省略（…）？</a></li>
<li><a href="#98%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%83%E7%B4%A0%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F">98.常见的元素隐藏方式？</a></li>
<li><a href="#99css-%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%B8%8B%E5%9B%BA%E5%AE%9A%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80">99.css 实现上下固定中间自适应布局？</a></li>
<li><a href="#100css-%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%AE%9E%E7%8E%B0">100.css 两栏布局的实现？</a></li>
<li><a href="#101css-%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%AE%9E%E7%8E%B0">101.css 三栏布局的实现？</a></li>
<li><a href="#102%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%BD%E9%AB%98%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2">102.实现一个宽高自适应的正方形</a></li>
<li><a href="#103%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2">103.实现一个三角形</a></li>
<li><a href="#104%E4%B8%80%E4%B8%AA%E8%87%AA%E9%80%82%E5%BA%94%E7%9F%A9%E5%BD%A2%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E4%B8%94%E5%AE%BD%E9%AB%98%E6%AF%94%E4%B8%BA-21">104.一个自适应矩形，水平垂直居中，且宽高比为 2:1</a></li>
<li><a href="#105-%E4%BD%A0%E7%9F%A5%E9%81%93-css-%E4%B8%AD%E4%B8%8D%E5%90%8C%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%99%BE%E5%88%86%E6%AF%94%E6%97%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E8%AE%A1%E7%AE%97%E5%9F%BA%E5%87%86">105.你知道 CSS 中不同属性设置为百分比\x 时对应的计算基准？</a></li>
</ul>
<h4 id="1-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？"><a href="#1-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？"></a>1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）</span><br><span class="line">（2）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分</span><br><span class="line"></span><br><span class="line">IE盒模型和W3C标准盒模型的区别：</span><br><span class="line"></span><br><span class="line">（1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding</span><br><span class="line">（2）IE盒模型：属性width，height包含content、border和padding，指的是content</span><br><span class="line">+padding+border。</span><br><span class="line"></span><br><span class="line">在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；</span><br><span class="line">如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE</span><br><span class="line">盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">盒模型都是由四个部分组成的，分别是margin、border、padding和content。</span><br><span class="line"></span><br><span class="line">标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的</span><br><span class="line">范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。</span><br><span class="line"></span><br><span class="line">一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。</span><br></pre></td></tr></table></figure>

<p>详细的资料可以参考：<br><a href="https://juejin.im/post/59ef72f5f265da4320026f76">《CSS 盒模型详解》</a></p>
<h4 id="2-CSS-选择符有哪些？"><a href="#2-CSS-选择符有哪些？" class="headerlink" title="2.CSS 选择符有哪些？"></a>2.CSS 选择符有哪些？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）id选择器（#myid）</span><br><span class="line">（2）类选择器（.myclassname）</span><br><span class="line">（3）标签选择器（div,h1,p）</span><br><span class="line">（4）后代选择器（h1 p）</span><br><span class="line">（5）相邻后代选择器（子）选择器（ul&gt;li）</span><br><span class="line">（6）兄弟选择器（li~a）</span><br><span class="line">（7）相邻兄弟选择器（li+a）</span><br><span class="line">（8）属性选择器（a[rel=&quot;external&quot;]）</span><br><span class="line">（9）伪类选择器（a:hover,li:nth-child）</span><br><span class="line">（10）伪元素选择器（::before、::after）</span><br><span class="line">（11）通配符选择器（*）</span><br></pre></td></tr></table></figure>

<h4 id="3-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用。"><a href="#3-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用。" class="headerlink" title="3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。"></a>3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）</span><br><span class="line">双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，</span><br><span class="line">比如:first-line、:first-letter、:before、:after等，</span><br><span class="line">而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</span><br><span class="line"></span><br><span class="line">想让插入的内容出现在其它内容前，使用::before，否者，使用::after；</span><br><span class="line">在代码顺序上，::after生成的内容也比::before生成的内容靠后。</span><br><span class="line">如果按堆栈视角，::after生成的内容会在::before生成的内容之上。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号</span><br><span class="line">来表示伪元素。</span><br><span class="line"></span><br><span class="line">伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。</span><br></pre></td></tr></table></figure>

<h4 id="4-伪类与伪元素的区别"><a href="#4-伪类与伪元素的区别" class="headerlink" title="4.伪类与伪元素的区别"></a>4.伪类与伪元素的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句</span><br><span class="line">话中的第一个字母，或者是列表中的第一个元素。</span><br><span class="line"></span><br><span class="line">伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的</span><br><span class="line">元素时，我们可以通过:hover来描述这个元素的状态。</span><br><span class="line"></span><br><span class="line">伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::be</span><br><span class="line">fore来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</span><br><span class="line"></span><br><span class="line">有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是CSS3的一部分，并尝试区分伪类和伪元素。大多数浏览</span><br><span class="line">器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的W3C规范并未对此进行</span><br><span class="line">特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/">《总结伪类与伪元素》</a></p>
<h4 id="5-CSS-中哪些属性可以继承？"><a href="#5-CSS-中哪些属性可以继承？" class="headerlink" title="5.CSS 中哪些属性可以继承？"></a>5.CSS 中哪些属性可以继承？</h4><p>相关资料：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每个CSS属性定义的概述都指出了这个属性是默认继承的，还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算</span><br><span class="line">值。</span><br><span class="line"></span><br><span class="line">当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应</span><br><span class="line">该是在该属性本身的定义中的默认值）。</span><br><span class="line"></span><br><span class="line">当元素的一个非继承属性（在Mozilla code里有时称之为reset property）没有指定值时，则取属性的初始值initial v</span><br><span class="line">alue（该值在该属性的概述里被指定）。</span><br><span class="line"></span><br><span class="line">有继承性的属性：</span><br><span class="line"></span><br><span class="line">（1）字体系列属性</span><br><span class="line">font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust</span><br><span class="line"></span><br><span class="line">（2）文本系列属性</span><br><span class="line">text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、</span><br><span class="line">text-transform、direction、color</span><br><span class="line"></span><br><span class="line">（3）表格布局属性</span><br><span class="line">caption-side border-collapse empty-cells</span><br><span class="line"></span><br><span class="line">（4）列表属性</span><br><span class="line">list-style-type、list-style-image、list-style-position、list-style</span><br><span class="line"></span><br><span class="line">（5）光标属性</span><br><span class="line">cursor</span><br><span class="line"></span><br><span class="line">（6）元素可见性</span><br><span class="line">visibility</span><br><span class="line"></span><br><span class="line">（7）还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地</span><br><span class="line">指定继承性，可用于任何继承性/非继承性属性。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值</span><br><span class="line">来作为自己的值。</span><br><span class="line"></span><br><span class="line">一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。</span><br><span class="line">表格的一些布局属性、列表属性如list-style等。还有光标属性cursor、元素可见性visibility。</span><br><span class="line"></span><br><span class="line">当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。</span><br></pre></td></tr></table></figure>

<p>详细的资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inheritance">《继承属性》</a><br><a href="https://www.jianshu.com/p/34044e3c9317">《CSS 有哪些属性可以继承？》</a></p>
<h4 id="6-CSS-优先级算法如何计算？"><a href="#6-CSS-优先级算法如何计算？" class="headerlink" title="6.CSS 优先级算法如何计算？"></a>6.CSS 优先级算法如何计算？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSS的优先级是根据样式声明的特殊性值来判断的。</span><br><span class="line"></span><br><span class="line">选择器的特殊性值分为四个等级，如下：</span><br><span class="line"></span><br><span class="line">（1）标签内选择符x,0,0,0</span><br><span class="line">（2）ID选择符0,x,0,0</span><br><span class="line">（3）class选择符/属性选择符/伪类选择符	0,0,x,0</span><br><span class="line">（4）元素和伪元素选择符0,0,0,x</span><br><span class="line"></span><br><span class="line">计算方法：</span><br><span class="line"></span><br><span class="line">（1）每个等级的初始值为0</span><br><span class="line">（2）每个等级的叠加为选择器出现的次数相加</span><br><span class="line">（3）不可进位，比如0,99,99,99</span><br><span class="line">（4）依次表示为：0,0,0,0</span><br><span class="line">（5）每个等级计数之间没关联</span><br><span class="line">（6）等级判断从左向右，如果某一位数值相同，则判断下一位数值</span><br><span class="line">（7）如果两个优先级相同，则最后出现的优先级高，!important也适用</span><br><span class="line">（8）通配符选择器的特殊性值为：0,0,0,0</span><br><span class="line">（9）继承样式优先级最低，通配符样式优先级高于继承样式</span><br><span class="line">（10）!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。</span><br><span class="line"></span><br><span class="line">计算实例：</span><br><span class="line"></span><br><span class="line">（1）#demo a&#123;color: orange;&#125;/*特殊性值：0,1,0,1*/</span><br><span class="line">（2）div#demo a&#123;color: red;&#125;/*特殊性值：0,1,0,2*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">（1）样式应用时，css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。</span><br><span class="line"></span><br><span class="line">（2）特殊性值越大的声明优先级越高。</span><br><span class="line"></span><br><span class="line">（3）相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的）</span><br><span class="line"></span><br><span class="line"> (4) 部分浏览器由于字节溢出问题出现的进位表现不做考虑</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，</span><br><span class="line">那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。</span><br><span class="line"></span><br><span class="line">一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，</span><br><span class="line">第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，</span><br><span class="line">第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等</span><br><span class="line">级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。</span><br><span class="line">比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引</span><br><span class="line">入的顺序，后出现的规则的优先级最高。</span><br></pre></td></tr></table></figure>

<p>对于组合声明的特殊性值计算可以参考：<br><a href="https://www.jianshu.com/p/1c4e639ff7d5">《CSS 优先级计算及应用》</a><br><a href="http://www.cnblogs.com/wangmeijian/p/4207433.html">《CSS 优先级计算规则》</a><br><a href="https://www.zhangxinxu.com/wordpress/2012/08/256-class-selector-beat-id-selector/">《有趣：256 个 class 选择器可以干掉 1 个 id 选择器》</a></p>
<h4 id="7-关于伪类-LVHA-的解释"><a href="#7-关于伪类-LVHA-的解释" class="headerlink" title="7.关于伪类 LVHA 的解释?"></a>7.关于伪类 LVHA 的解释?</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；</span><br><span class="line"></span><br><span class="line">当链接未访问过时：</span><br><span class="line"></span><br><span class="line">（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪</span><br><span class="line">类后面声明；</span><br><span class="line">（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），</span><br><span class="line">必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。</span><br><span class="line"></span><br><span class="line">当链接访问过时，情况基本同上，只不过需要将:link换成:visited。</span><br><span class="line"></span><br><span class="line">这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，</span><br><span class="line">也就不存在覆盖的问题。</span><br></pre></td></tr></table></figure>

<h4 id="8-CSS3-新增伪类有那些？"><a href="#8-CSS3-新增伪类有那些？" class="headerlink" title="8.CSS3 新增伪类有那些？"></a>8.CSS3 新增伪类有那些？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）elem:nth-child(n)选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数</span><br><span class="line">值，也可以接受函数。</span><br><span class="line"></span><br><span class="line">（2）elem:nth-last-child(n)作用同上，不过是从后开始查找。</span><br><span class="line"></span><br><span class="line">（3）elem:last-child选中最后一个子元素。</span><br><span class="line"></span><br><span class="line">（4）elem:only-child如果elem是父元素下唯一的子元素，则选中之。</span><br><span class="line"></span><br><span class="line">（5）elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。</span><br><span class="line"></span><br><span class="line">（6）elem:first-of-type选中父元素下第一个elem类型元素。</span><br><span class="line"></span><br><span class="line">（7）elem:last-of-type选中父元素下最后一个elem类型元素。</span><br><span class="line"></span><br><span class="line">（8）elem:only-of-type如果父元素下的子元素只有一个elem类型元素，则选中该元素。</span><br><span class="line"></span><br><span class="line">（9）elem:empty选中不包含子元素和内容的elem类型元素。</span><br><span class="line"></span><br><span class="line">（10）elem:target选择当前活动的elem元素。</span><br><span class="line"></span><br><span class="line">（11）:not(elem)选择非elem元素的每个元素。</span><br><span class="line"></span><br><span class="line">（12）:enabled 控制表单控件的禁用状态。</span><br><span class="line"></span><br><span class="line">（13）:disabled	控制表单控件的禁用状态。</span><br><span class="line"></span><br><span class="line">(14):checked单选框或复选框被选中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细的资料可以参考：<br><a href="https://www.cnblogs.com/SKLthegoodman/p/css3.html">《CSS3 新特性总结(伪类)》</a><br><a href="https://blog.csdn.net/zhouziyu2011/article/details/58605705">《浅谈 CSS 伪类和伪元素及 CSS3 新增伪类》</a></p>
<h4 id="9-如何居中-div？"><a href="#9-如何居中-div？" class="headerlink" title="9.如何居中 div？"></a>9.如何居中 div？</h4><p>-水平居中：给 div 设置一个宽度，然后添加 margin:0 auto 属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-水平居中，利用 text-align:center 实现</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-让绝对定位的 div 居中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink; <span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-水平垂直居中一</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*确定容器的宽高宽500高300的层设置层的外边距div&#123;*/</span></span><br><span class="line"><span class="attribute">position</span>: absolute;<span class="comment">/*绝对定位*/</span></span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin</span>: -<span class="number">150px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">250px</span>;<span class="comment">/*外边距为自身宽高的一半*/</span></span><br><span class="line"><span class="attribute">background-color</span>: pink;<span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-水平垂直居中二</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*未知容器的宽高，利用`transform`属性*/</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="comment">/*相对定位或绝对定位均可*/</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">background-color</span>: pink; <span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-水平垂直居中三</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*利用flex布局实际使用时应考虑兼容性*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/*垂直居中*/</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/*水平居中*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.containerdiv</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink; <span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-水平垂直居中四</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*利用text-align:center和vertical-align:middle属性*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">white-space</span>: normal;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般常见的几种居中的方法有：</span><br><span class="line"></span><br><span class="line">对于宽高固定的元素</span><br><span class="line"></span><br><span class="line">（1）我们可以利用margin:0 auto来实现元素的水平居中。</span><br><span class="line"></span><br><span class="line">（2）利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水</span><br><span class="line">平和垂直方向上的居中。</span><br><span class="line"></span><br><span class="line">（3）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素</span><br><span class="line">的中心点到页面的中心。</span><br><span class="line"></span><br><span class="line">（4）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素</span><br><span class="line">的中心点到页面的中心。</span><br><span class="line"></span><br><span class="line">（5）使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对</span><br><span class="line">齐，然后它的子元素也可以实现垂直和水平的居中。</span><br><span class="line"></span><br><span class="line">对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。</span><br></pre></td></tr></table></figure>

<h4 id="10-display-有哪些值？说明他们的作用。"><a href="#10-display-有哪些值？说明他们的作用。" class="headerlink" title="10.display 有哪些值？说明他们的作用。"></a>10.display 有哪些值？说明他们的作用。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">block	块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</span><br><span class="line">none	元素不显示，并从文档流中移除。</span><br><span class="line">inline	行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</span><br><span class="line">inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。</span><br><span class="line">list-item	像块类型元素一样显示，并添加样式列表标记。</span><br><span class="line">table	此元素会作为块级表格来显示。</span><br><span class="line">inherit	规定应该从父元素继承display属性的值。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.w3school.com.cn/css/pr_class_display.asp">《CSS display 属性》</a></p>
<h4 id="11-position-的值-relative-和-absolute-定位原点是？"><a href="#11-position-的值-relative-和-absolute-定位原点是？" class="headerlink" title="11.position 的值 relative 和 absolute 定位原点是？"></a>11.position 的值 relative 和 absolute 定位原点是？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">absolute</span><br><span class="line">生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的</span><br><span class="line">一级position设置为absolute或者relative的父元素的padding box的左上角为原点的。</span><br><span class="line"></span><br><span class="line">fixed（老IE不支持）</span><br><span class="line">生成绝对定位的元素，相对于浏览器窗口进行定位。</span><br><span class="line"></span><br><span class="line">relative</span><br><span class="line">生成相对定位的元素，相对于其元素本身所在正常位置进行定位。</span><br><span class="line"></span><br><span class="line">static</span><br><span class="line">默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。</span><br><span class="line"></span><br><span class="line">inherit</span><br><span class="line">规定从父元素继承position属性的值。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">relative定位的元素，是相对于元素本身的正常位置来进行定位的。</span><br><span class="line"></span><br><span class="line">absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的padding box来进行定位的。这句话</span><br><span class="line">我们可以这样来理解，我们首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元</span><br><span class="line">素的padding box来定位，也就是说在计算定位距离的时候，padding的值也要算进去。</span><br></pre></td></tr></table></figure>

<h4 id="12-CSS3-有哪些新特性？（根据项目回答）"><a href="#12-CSS3-有哪些新特性？（根据项目回答）" class="headerlink" title="12.CSS3 有哪些新特性？（根据项目回答）"></a>12.CSS3 有哪些新特性？（根据项目回答）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新增各种CSS选择器	（:not(.input)：所有class不是“input”的节点）</span><br><span class="line">圆角		（border-radius:8px）</span><br><span class="line">多列布局	（multi-column layout）</span><br><span class="line">阴影和反射	（Shadow\Reflect）</span><br><span class="line">文字特效		（text-shadow）</span><br><span class="line">文字渲染		（Text-decoration）</span><br><span class="line">线性渐变		（gradient）</span><br><span class="line">旋转			（transform）</span><br><span class="line">缩放，定位，倾斜，动画，多背景</span><br><span class="line">例如：transform:\scale(0.85,0.90)\translate(0px,-30px)\skew(-9deg,0deg)\Animation:</span><br></pre></td></tr></table></figure>

<h4 id="13-请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？"><a href="#13-请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？" class="headerlink" title="13.请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？"></a>13.请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flex是FlexibleBox的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</span><br><span class="line"></span><br><span class="line">任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的float、cl</span><br><span class="line">ear和vertical-align属性将失效。</span><br><span class="line"></span><br><span class="line">采用Flex布局的元素，称为Flex容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为Flex</span><br><span class="line">项目（flex item），简称&quot;项目&quot;。</span><br><span class="line"></span><br><span class="line">容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿主轴排列。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下6个属性设置在容器上。</span><br><span class="line"></span><br><span class="line">flex-direction属性决定主轴的方向（即项目的排列方向）。</span><br><span class="line"></span><br><span class="line">flex-wrap属性定义，如果一条轴线排不下，如何换行。</span><br><span class="line"></span><br><span class="line">flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</span><br><span class="line"></span><br><span class="line">justify-content属性定义了项目在主轴上的对齐方式。</span><br><span class="line"></span><br><span class="line">align-items属性定义项目在交叉轴上如何对齐。</span><br><span class="line"></span><br><span class="line">align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下6个属性设置在项目上。</span><br><span class="line"></span><br><span class="line">order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</span><br><span class="line"></span><br><span class="line">flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</span><br><span class="line"></span><br><span class="line">flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</span><br><span class="line"></span><br><span class="line">flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认</span><br><span class="line">值为auto，即项目的本来大小。</span><br><span class="line"></span><br><span class="line">flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</span><br><span class="line"></span><br><span class="line">align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父</span><br><span class="line">元素的align-items属性，如果没有父元素，则等同于stretch。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex</span><br><span class="line">容器，它的所有子元素都会成为它的项目。</span><br><span class="line"></span><br><span class="line">一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。</span><br><span class="line">我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还</span><br><span class="line">可以使用flex-wrap来规定当一行排列不下时的换行方式。</span><br><span class="line"></span><br><span class="line">对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，</span><br><span class="line">项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">《Flex 布局教程：语法篇》</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">《Flex 布局教程：实例篇》</a></p>
<h4 id="14-用纯-CSS-创建一个三角形的原理是什么？"><a href="#14-用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="14.用纯 CSS 创建一个三角形的原理是什么？"></a>14.用纯 CSS 创建一个三角形的原理是什么？</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">采用的是相邻边框连接处的均分原理。</span><br><span class="line">  将元素的宽高设为<span class="number">0</span>，只设置</span><br><span class="line">  <span class="attribute">border</span></span><br><span class="line">  ，把任意三条边隐藏掉（颜色设为</span><br><span class="line">  transparent），剩下的就是一个三角形。</span><br><span class="line">  <span class="selector-id">#demo</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: transparent transparent red transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-一个满屏品字布局如何设计"><a href="#15-一个满屏品字布局如何设计" class="headerlink" title="15.一个满屏品字布局如何设计?"></a>15.一个满屏品字布局如何设计?</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单的方式：</span><br><span class="line">	上面的div宽100%，</span><br><span class="line">	下面的两个div分别宽50%，</span><br><span class="line">	然后用float或者inline使其不换行即可</span><br></pre></td></tr></table></figure>

<h4 id="16-CSS-多列等高如何实现？"><a href="#16-CSS-多列等高如何实现？" class="headerlink" title="16.CSS 多列等高如何实现？"></a>16.CSS 多列等高如何实现？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:</span><br><span class="line">hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则</span><br><span class="line">父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</span><br><span class="line"></span><br><span class="line">（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。</span><br><span class="line"></span><br><span class="line">（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度</span><br><span class="line">的特性，来实现多列等高。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5b0fb34151882515662238fd">《前端应该掌握的 CSS 实现多列等高布局》</a><br><a href="https://codepen.io/yangbo5207/post/equh">《CSS：多列等高布局》</a></p>
<h4 id="17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？"><a href="#17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？" class="headerlink" title="17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？"></a>17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）png24位的图片在iE6浏览器上出现背景</span><br><span class="line">解决方案：做成PNG8，也可以引用一段脚本处理。</span><br><span class="line"></span><br><span class="line">（2）浏览器默认的margin和padding不同</span><br><span class="line">解决方案：加一个全局的*&#123;margin:0;padding:0;&#125;来统一。</span><br><span class="line"></span><br><span class="line">（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或</span><br><span class="line">margin-right，margin值会加倍。</span><br><span class="line"></span><br><span class="line">#box&#123;float:left;width:10px;margin:0 0 0 10px;&#125;</span><br><span class="line"></span><br><span class="line">这种情况之下IE会产生20px的距离</span><br><span class="line">解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</span><br><span class="line"></span><br><span class="line">（4）渐进识别的方式，从总体中逐渐排除局部。</span><br><span class="line">首先，巧妙的使用&quot;\9&quot;这一标记，将IE游览器从所有情况中分离出来。</span><br><span class="line">接着，再次使用&quot;+&quot;将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</span><br><span class="line">.bb&#123;</span><br><span class="line">background-color:#f1ee18;/*所有识别*/</span><br><span class="line">.background-color:#00deff\9;/*IE6、7、8识别*/</span><br><span class="line">+background-color:#a200ff;/*IE6、7识别*/</span><br><span class="line">_background-color:#1e0bd1;/*IE6识别*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义</span><br><span class="line">属性；Firefox下，只能使用getAttribute()获取自定义属性</span><br><span class="line">解决方法：统一通过getAttribute()获取自定义属性。</span><br><span class="line"></span><br><span class="line">（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有</span><br><span class="line">pageX、pageY属性，但是没有x、y属性。</span><br><span class="line">解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</span><br><span class="line"></span><br><span class="line">（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示</span><br><span class="line">解决方法：</span><br><span class="line"></span><br><span class="line">1.可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome</span><br><span class="line">更新到27版本之后就不可以用了。</span><br><span class="line"></span><br><span class="line">2.还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);</span><br><span class="line">收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block/inline-block/...；</span><br><span class="line"></span><br><span class="line">（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了</span><br><span class="line">解决方法：改变CSS属性的排列顺序L-V-H-A</span><br><span class="line"></span><br><span class="line">（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模</span><br><span class="line">式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。</span><br></pre></td></tr></table></figure>

<h4 id="18-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#18-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个&lt;li&gt;放在一行，</span><br><span class="line">这导致&lt;li&gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">（1）为&lt;li&gt;设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</span><br><span class="line"></span><br><span class="line">（2）将所有&lt;li&gt;写在同一行。不足：代码不美观。</span><br><span class="line"></span><br><span class="line">（3）将&lt;ul&gt;内的字符尺寸直接设为0，即font-size:0。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他</span><br><span class="line">字符尺寸，且在Safari浏览器依然会出现空白间隔。</span><br><span class="line"></span><br><span class="line">（4）消除&lt;ul&gt;的字符间隔letter-spacing:-8px，不足：这也设置了&lt;li&gt;内的字符间隔，因此需要将&lt;li&gt;内的字符</span><br><span class="line">间隔设为默认letter-spacing:normal。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/sjinsa/article/details/70919546">《li 与 li 之间有看不见的空白间隔是什么原因引起的？》</a></p>
<h4 id="19-为什么要初始化-CSS-样式？"><a href="#19-为什么要初始化-CSS-样式？" class="headerlink" title="19.为什么要初始化 CSS 样式？"></a>19.为什么要初始化 CSS 样式？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</span><br><span class="line"></span><br><span class="line">-当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</span><br><span class="line"></span><br><span class="line">最简单的初始化方法：*&#123;padding:0;margin:0;&#125;（强烈不建议）</span><br><span class="line"></span><br><span class="line">淘宝的样式初始化代码：</span><br><span class="line">body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend</span><br><span class="line">,button,input,textarea,th,td&#123;margin:0;padding:0;&#125;</span><br><span class="line">body,button,input,select,textarea&#123;font:12px/1.5tahoma,arial,\5b8b\4f53;&#125;</span><br><span class="line">h1,h2,h3,h4,h5,h6&#123;font-size:100%;&#125;</span><br><span class="line">address,cite,dfn,em,var&#123;font-style:normal;&#125;</span><br><span class="line">code,kbd,pre,samp&#123;font-family:couriernew,courier,monospace;&#125;</span><br><span class="line">small&#123;font-size:12px;&#125;</span><br><span class="line">ul,ol&#123;list-style:none;&#125;</span><br><span class="line">a&#123;text-decoration:none;&#125;</span><br><span class="line">a:hover&#123;text-decoration:underline;&#125;</span><br><span class="line">sup&#123;vertical-align:text-top;&#125;</span><br><span class="line">sub&#123;vertical-align:text-bottom;&#125;</span><br><span class="line">legend&#123;color:#000;&#125;</span><br><span class="line">fieldset,img&#123;border:0;&#125;</span><br><span class="line">button,input,select,textarea&#123;font-size:100%;&#125;</span><br><span class="line">table&#123;border-collapse:collapse;border-spacing:0;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-什么是包含块，对于包含块的理解"><a href="#20-什么是包含块，对于包含块的理解" class="headerlink" title="20.什么是包含块，对于包含块的理解?"></a>20.什么是包含块，对于包含块的理解?</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">包含块（containing block）就是元素用来计算和定位的一个框。</span><br><span class="line"></span><br><span class="line">（1）根元素（很多场景下可以看成是&lt;html&gt;）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。</span><br><span class="line"></span><br><span class="line">（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box</span><br><span class="line">边界形成。</span><br><span class="line"></span><br><span class="line">（3）如果元素position:fixed，则“包含块”是“初始包含块”。</span><br><span class="line"></span><br><span class="line">（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：</span><br><span class="line"></span><br><span class="line">如果该祖先元素是纯inline元素，则规则略复杂：</span><br><span class="line">•假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包</span><br><span class="line">围盒就是内联元素的“包含块”；</span><br><span class="line">•如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥</span><br><span class="line">否则，“包含块”由该祖先的padding box边界形成。</span><br><span class="line"></span><br><span class="line">如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。</span><br></pre></td></tr></table></figure>

<h4 id="21-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？在不同浏览器下以后什么区别？"><a href="#21-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？在不同浏览器下以后什么区别？" class="headerlink" title="21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？"></a>21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。</span><br><span class="line"></span><br><span class="line">（2）但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的</span><br><span class="line">表现却跟display:none一样，也就是说，它们占用的空间也会释放。</span><br><span class="line"></span><br><span class="line">在不同浏览器下的区别：</span><br><span class="line"></span><br><span class="line">在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。</span><br><span class="line"></span><br><span class="line">在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位</span><br><span class="line">置。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.webhek.com/post/visibility-collapse.html">《CSS 里的 visibility 属性有个鲜为人知的属性值：collapse》</a></p>
<h4 id="22-width-auto-和-width-100-的区别"><a href="#22-width-auto-和-width-100-的区别" class="headerlink" title="22.width:auto 和 width:100%的区别"></a>22.width:auto 和 width:100%的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般而言</span><br><span class="line"></span><br><span class="line">width:100%会使元素box的宽度等于父元素的content box的宽度。</span><br><span class="line"></span><br><span class="line">width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。</span><br></pre></td></tr></table></figure>

<h4 id="23-绝对定位元素与非绝对定位元素的百分比计算的区别"><a href="#23-绝对定位元素与非绝对定位元素的百分比计算的区别" class="headerlink" title="23.绝对定位元素与非绝对定位元素的百分比计算的区别"></a>23.绝对定位元素与非绝对定位元素的百分比计算的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的padding box来计算的。</span><br><span class="line"></span><br><span class="line">非绝对定位元素的宽高百分比则是相对于父元素的content box来计算的。</span><br></pre></td></tr></table></figure>

<h4 id="24-简单介绍使用图片-base64-编码的优点和缺点。"><a href="#24-简单介绍使用图片-base64-编码的优点和缺点。" class="headerlink" title="24.简单介绍使用图片 base64 编码的优点和缺点。"></a>24.简单介绍使用图片 base64 编码的优点和缺点。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的</span><br><span class="line">url属性。</span><br><span class="line"></span><br><span class="line">使用base64的优点是：</span><br><span class="line"></span><br><span class="line">（1）减少一个图片的HTTP请求</span><br><span class="line"></span><br><span class="line">使用base64的缺点是：</span><br><span class="line"></span><br><span class="line">（1）根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体</span><br><span class="line">积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。</span><br><span class="line"></span><br><span class="line">（2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要</span><br><span class="line">差很多。</span><br><span class="line"></span><br><span class="line">（3）兼容性的问题，ie8以前的浏览器不支持。</span><br><span class="line"></span><br><span class="line">一般一些网站的小图标可以使用base64图片来引入。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/coco1s/p/4375774.html">《玩转图片 base64 编码》</a><br><a href="https://www.zhihu.com/question/31155574">《前端开发中，使用 base64 图片的弊端是什么？》</a><br><a href="https://www.zhangxinxu.com/wordpress/2012/04/base64-url-image-%E5%9B%BE%E7%89%87-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">《小 tip:base64:URL 背景图片与 web 页面性能优化》</a></p>
<h4 id="25-’display’、’position’和’float’的相互关系？"><a href="#25-’display’、’position’和’float’的相互关系？" class="headerlink" title="25.’display’、’position’和’float’的相互关系？"></a>25.’display’、’position’和’float’的相互关系？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</span><br><span class="line"></span><br><span class="line">（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被</span><br><span class="line">设置为table或者block，具体转换需要看初始转换值。</span><br><span class="line"></span><br><span class="line">（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display</span><br><span class="line">的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对</span><br><span class="line">于浮动后的最终位置定位。</span><br><span class="line"></span><br><span class="line">（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，</span><br><span class="line">则保持指定的display属性值不变。</span><br><span class="line"></span><br><span class="line">总的来说，可以把它看作是一个类似优先级的机制，&quot;position:absolute&quot;和&quot;position:fixed&quot;优先级最高，有它存在</span><br><span class="line">的时候，浮动不起作用，&#x27;display&#x27;的值也需要调整；其次，元素的&#x27;float&#x27;特性的值不是&quot;none&quot;的时候或者它是根元素</span><br><span class="line">的时候，调整&#x27;display&#x27;的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，&#x27;display&#x27;特性值同设置值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/jackyWHJ/p/3756087.html">《position 跟 display、margincollapse、overflow、float 这些特性相互叠加后会怎么样？》</a></p>
<h4 id="26-margin-重叠问题的理解。"><a href="#26-margin-重叠问题的理解。" class="headerlink" title="26.margin 重叠问题的理解。"></a>26.margin 重叠问题的理解。</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合</span><br><span class="line">并”。</span><br><span class="line"></span><br><span class="line">产生折叠的必备条件：margin必须是邻接的!</span><br><span class="line"></span><br><span class="line">而根据w3c规范，两个margin是邻接的必须满足以下条件：</span><br><span class="line"></span><br><span class="line">•必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。</span><br><span class="line">•没有线盒，没有空隙，没有padding和border将他们分隔开</span><br><span class="line">•都属于垂直方向上相邻的外边距，可以是下面任意一种情况</span><br><span class="line">•元素的margin-top与其第一个常规文档流的子元素的margin-top</span><br><span class="line">•元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top</span><br><span class="line">•height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom</span><br><span class="line">•高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top</span><br><span class="line">和margin-bottom</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">margin合并的3种场景：</span><br><span class="line"></span><br><span class="line">（1）相邻兄弟元素margin合并。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line">•设置块状格式化上下文元素（BFC）</span><br><span class="line"></span><br><span class="line">（2）父级和第一个/最后一个子元素的margin合并。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">对于margin-top合并，可以进行如下操作（满足一个条件即可）：</span><br><span class="line">•父元素设置为块状格式化上下文元素；</span><br><span class="line">•父元素设置border-top值；</span><br><span class="line">•父元素设置padding-top值；</span><br><span class="line">•父元素和第一个子元素之间添加内联元素进行分隔。</span><br><span class="line"></span><br><span class="line">对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：</span><br><span class="line">•父元素设置为块状格式化上下文元素；</span><br><span class="line">•父元素设置border-bottom值；</span><br><span class="line">•父元素设置padding-bottom值；</span><br><span class="line">•父元素和最后一个子元素之间添加内联元素进行分隔；</span><br><span class="line">•父元素设置height、min-height或max-height。</span><br><span class="line"></span><br><span class="line">（3）空块级元素的margin合并。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line">•设置垂直方向的border；</span><br><span class="line">•设置垂直方向的padding；</span><br><span class="line">•里面添加内联元素（直接Space键空格是没用的）；</span><br><span class="line">•设置height或者min-height。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">margin重叠指的是在垂直方向上，两个相邻元素的margin发生重叠的情况。</span><br><span class="line"></span><br><span class="line">一般来说可以分为四种情形：</span><br><span class="line"></span><br><span class="line">第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC</span><br><span class="line">来解决。</span><br><span class="line"></span><br><span class="line">第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这</span><br><span class="line">一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC</span><br><span class="line">来解决。</span><br><span class="line"></span><br><span class="line">第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相</span><br><span class="line">邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为</span><br><span class="line">父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。</span><br><span class="line"></span><br><span class="line">第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、pa</span><br><span class="line">dding或者高度来解决这个问题。</span><br></pre></td></tr></table></figure>

<h4 id="27-对-BFC-规范（块级格式化上下文：block-formatting-context）的理解？"><a href="#27-对-BFC-规范（块级格式化上下文：block-formatting-context）的理解？" class="headerlink" title="27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？"></a>27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒</span><br><span class="line">子的区域，也是浮动元素与其他元素的交互限定区域。</span><br><span class="line"></span><br><span class="line">通俗来讲</span><br><span class="line"></span><br><span class="line">•BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。</span><br><span class="line">•如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</span><br><span class="line"></span><br><span class="line">创建BFC</span><br><span class="line"></span><br><span class="line">（1）根元素或包含根元素的元素</span><br><span class="line">（2）浮动元素float＝left|right或inherit（≠none）</span><br><span class="line">（3）绝对定位元素position＝absolute或fixed</span><br><span class="line">（4）display＝inline-block|flex|inline-flex|table-cell或table-caption</span><br><span class="line">（5）overflow＝hidden|auto或scroll(≠visible)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也</span><br><span class="line">不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。</span><br><span class="line"></span><br><span class="line">一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些</span><br><span class="line">属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html">《深入理解 BFC 和 MarginCollapse》</a><br><a href="https://segmentfault.com/a/1190000013647777">《前端面试题-BFC（块格式化上下文）》</a></p>
<h4 id="28-IFC-是什么？"><a href="#28-IFC-是什么？" class="headerlink" title="28.IFC 是什么？"></a>28.IFC 是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IFC指的是行级格式化上下文，它有这样的一些布局规则：</span><br><span class="line"></span><br><span class="line">（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。</span><br><span class="line">（2）当一行不够的时候会自动切换到下一行。</span><br><span class="line">（3）行级上下文的高度由内部最高的内联盒子的高度决定。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000004466536#articleHeader5">《[译]:BFC 与 IFC》</a><br><a href="https://blog.csdn.net/paintandraw/article/details/80401741">《BFC 和 IFC 的理解（布局）》</a></p>
<h4 id="29-请解释一下为什么需要清除浮动？清除浮动的方式"><a href="#29-请解释一下为什么需要清除浮动？清除浮动的方式" class="headerlink" title="29.请解释一下为什么需要清除浮动？清除浮动的方式"></a>29.请解释一下为什么需要清除浮动？清除浮动的方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，</span><br><span class="line">不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框</span><br><span class="line">的高度小于浮动框的时候，此时就会出现“高度塌陷”。</span><br><span class="line"></span><br><span class="line">清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</span><br><span class="line"></span><br><span class="line">清除浮动的方式</span><br><span class="line"></span><br><span class="line">（1）使用clear属性清除浮动。参考28。</span><br><span class="line"></span><br><span class="line">（2）使用BFC块级格式化上下文来清除浮动。参考26。</span><br><span class="line"></span><br><span class="line">因为BFC元素不会影响外部元素的特点，所以BFC元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元</span><br><span class="line">素高度塌陷，必然会影响后面元素布局和定位，这显然有违BFC元素的子元素不会影响外部元素的设定。</span><br></pre></td></tr></table></figure>

<h4 id="30-使用-clear-属性清除浮动的原理？"><a href="#30-使用-clear-属性清除浮动的原理？" class="headerlink" title="30.使用 clear 属性清除浮动的原理？"></a>30.使用 clear 属性清除浮动的原理？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用clear属性清除浮动，其语法如下：</span><br><span class="line"></span><br><span class="line">clear:none|left|right|both</span><br><span class="line"></span><br><span class="line">如果单看字面意思，clear:left应该是“清除左浮动”，clear:right应该是“清除右浮动”的意思，实际上，这种解释是有问</span><br><span class="line">题的，因为浮动一直还在，并没有清除。</span><br><span class="line"></span><br><span class="line">官方对clear属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置clear属性是为了避免浮动元素</span><br><span class="line">对该元素的影响，而不是清除掉浮动。</span><br><span class="line"></span><br><span class="line">还需要注意的一点是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属</span><br><span class="line">性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear</span><br><span class="line">属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left</span><br><span class="line">等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和cle</span><br><span class="line">ar:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</span><br><span class="line"></span><br><span class="line">一般使用伪元素的方式清除浮动</span><br><span class="line"></span><br><span class="line">.clear::after&#123;</span><br><span class="line">content:&#x27;&#x27;;</span><br><span class="line">display:table;//也可以是&#x27;block&#x27;，或者是&#x27;list-item&#x27;</span><br><span class="line">clear:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置disp</span><br><span class="line">lay属性值的原因。</span><br></pre></td></tr></table></figure>

<h4 id="31-zoom-1-的清除浮动原理"><a href="#31-zoom-1-的清除浮动原理" class="headerlink" title="31.zoom:1 的清除浮动原理?"></a>31.zoom:1 的清除浮动原理?</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">清除浮动，触发hasLayout；</span><br><span class="line">zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）</span><br><span class="line">的重叠，浮动清除，触发ie的haslayout属性等。</span><br><span class="line"></span><br><span class="line">来龙去脉大概如下：</span><br><span class="line">当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发</span><br><span class="line">生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。</span><br><span class="line"></span><br><span class="line">zoom属性是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标</span><br><span class="line">准化，出现在CSS3.0规范草案中。</span><br><span class="line"></span><br><span class="line">目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。</span><br></pre></td></tr></table></figure>

<h4 id="32-移动端的布局用过媒体查询吗？"><a href="#32-移动端的布局用过媒体查询吗？" class="headerlink" title="32.移动端的布局用过媒体查询吗？"></a>32.移动端的布局用过媒体查询吗？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些</span><br><span class="line">媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法</span><br><span class="line"></span><br><span class="line">当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被</span><br><span class="line">下载（只不过不会被应用）。</span><br><span class="line"></span><br><span class="line">包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改</span><br><span class="line">内容便可以使样式应用于某些特定的设备范围。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.runoob.com/cssref/css3-pr-mediaquery.html">《CSS3@media 查询》</a><br><a href="http://caibaojian.com/356.html">《响应式布局和自适应布局详解》</a></p>
<h4 id="33-使用-CSS-预处理器吗？喜欢哪个？"><a href="#33-使用-CSS-预处理器吗？喜欢哪个？" class="headerlink" title="33.使用 CSS 预处理器吗？喜欢哪个？"></a>33.使用 CSS 预处理器吗？喜欢哪个？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SASS（SASS、LESS没有本质区别，只因为团队前端都是用的SASS）</span><br></pre></td></tr></table></figure>

<h4 id="34-CSS-优化、提高性能的方法有哪些？"><a href="#34-CSS-优化、提高性能的方法有哪些？" class="headerlink" title="34.CSS 优化、提高性能的方法有哪些？"></a>34.CSS 优化、提高性能的方法有哪些？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加载性能：</span><br><span class="line"></span><br><span class="line">（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。</span><br><span class="line">（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bot</span><br><span class="line">tom;margin-left:left;执行的效率更高。</span><br><span class="line">（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</span><br><span class="line"></span><br><span class="line">选择器性能：</span><br><span class="line"></span><br><span class="line">（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到</span><br><span class="line">左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</span><br><span class="line"></span><br><span class="line">（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹</span><br><span class="line">配它们了）。</span><br><span class="line"></span><br><span class="line">（3）避免使用通配规则，如*&#123;&#125;计算次数惊人！只对需要用到的元素进行选择。</span><br><span class="line"></span><br><span class="line">（4）尽量少的去对标签进行选择，而是用class。</span><br><span class="line"></span><br><span class="line">（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过</span><br><span class="line">三层，更多的使用类来关联每一个标签元素。</span><br><span class="line"></span><br><span class="line">（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</span><br><span class="line"></span><br><span class="line">渲染性能：</span><br><span class="line"></span><br><span class="line">（1）慎重使用高性能属性：浮动、定位。</span><br><span class="line"></span><br><span class="line">（2）尽量减少页面重排、重绘。</span><br><span class="line"></span><br><span class="line">（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</span><br><span class="line"></span><br><span class="line">（4）属性值为0时，不加单位。</span><br><span class="line"></span><br><span class="line">（5）属性值为浮动小数0.**，可以省略小数点之前的0。</span><br><span class="line"></span><br><span class="line">（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</span><br><span class="line"></span><br><span class="line">（7）不使用@import前缀，它会影响css的加载速度。</span><br><span class="line"></span><br><span class="line">（8）选择器优化嵌套，尽量避免层级过深。</span><br><span class="line"></span><br><span class="line">（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清</span><br><span class="line">楚，再使用。</span><br><span class="line"></span><br><span class="line">（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</span><br><span class="line"></span><br><span class="line">（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏</span><br><span class="line">览器在下载web fonts时会阻塞页面渲染损伤性能。</span><br><span class="line"></span><br><span class="line">可维护性、健壮性：</span><br><span class="line"></span><br><span class="line">（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</span><br><span class="line">（2）样式与内容分离：将css代码定义到外部css中。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19886806">《CSS 优化、提高性能的方法有哪些？》</a><br><a href="https://www.jianshu.com/p/4e673bf24a3b">《CSS 优化，提高性能的方法》</a></p>
<h4 id="35-浏览器是怎样解析-CSS-选择器的？"><a href="#35-浏览器是怎样解析-CSS-选择器的？" class="headerlink" title="35.浏览器是怎样解析 CSS 选择器的？"></a>35.浏览器是怎样解析 CSS 选择器的？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直</span><br><span class="line">到和规则匹配，或者是因为不匹配而放弃该规则。</span><br><span class="line"></span><br><span class="line">试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，</span><br><span class="line">最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/entry/5a123c55f265da432240cc90">《探究 CSS 解析原理》</a></p>
<h4 id="36-在网页中应该使用奇数还是偶数的字体？为什么呢？"><a href="#36-在网页中应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="36.在网页中应该使用奇数还是偶数的字体？为什么呢？"></a>36.在网页中应该使用奇数还是偶数的字体？为什么呢？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14</span><br><span class="line">×0.5=7px的margin，在另一些地方用14×1.5=21px的标题字号。</span><br><span class="line">（2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。</span><br><span class="line">（3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/jian_xi/article/details/79346477">《谈谈网页中使用奇数字体和偶数字体》</a><br><a href="https://www.zhihu.com/question/20440679">《现在网页设计中的为什么少有人用 11px、13px、15px 等奇数的字体？》</a></p>
<h4 id="37-margin-和-padding-分别适合什么场景使用？"><a href="#37-margin-和-padding-分别适合什么场景使用？" class="headerlink" title="37.margin 和 padding 分别适合什么场景使用？"></a>37.margin 和 padding 分别适合什么场景使用？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。</span><br><span class="line">margin用于布局分开元素使元素与元素互不相干。</span><br><span class="line">padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。</span><br><span class="line"></span><br><span class="line">何时应当使用margin：</span><br><span class="line">•需要在border外侧添加空白时。</span><br><span class="line">•空白处不需要背景（色）时。</span><br><span class="line">•上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。</span><br><span class="line"></span><br><span class="line">何时应当时用padding：</span><br><span class="line">•需要在border内测添加空白时。</span><br><span class="line">•空白处需要背景（色）时。</span><br><span class="line">•上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。</span><br></pre></td></tr></table></figure>

<h4 id="38-抽离样式模块怎么写，说出思路，有无实践经验？-阿里航旅的面试题"><a href="#38-抽离样式模块怎么写，说出思路，有无实践经验？-阿里航旅的面试题" class="headerlink" title="38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]"></a>38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放</span><br><span class="line">进业务相关的库里面做成对应功能的模块儿。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://nec.netease.com/standard/css-sort.html">《CSS 规范-分类方法》</a></p>
<h4 id="39-简单说一下-css3-的-all-属性。"><a href="#39-简单说一下-css3-的-all-属性。" class="headerlink" title="39.简单说一下 css3 的 all 属性。"></a>39.简单说一下 css3 的 all 属性。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction</span><br><span class="line">这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。</span><br><span class="line"></span><br><span class="line">initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始</span><br><span class="line">值。</span><br><span class="line"></span><br><span class="line">inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。</span><br><span class="line"></span><br><span class="line">unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则</span><br><span class="line">使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhangxinxu.com/wordpress/2016/03/know-about-css3-all/">《简单了解 CSS3 的 all 属性》</a></p>
<h4 id="40-为什么不建议使用统配符初始化-css-样式。"><a href="#40-为什么不建议使用统配符初始化-css-样式。" class="headerlink" title="40.为什么不建议使用统配符初始化 css 样式。"></a>40.为什么不建议使用统配符初始化 css 样式。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">采用*&#123;padding:0;margin:0;&#125;这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，</span><br><span class="line">样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一</span><br><span class="line">套初始化样式。</span><br><span class="line"></span><br><span class="line">出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即</span><br><span class="line">可，并不需使用通配符*来初始化。</span><br></pre></td></tr></table></figure>

<h4 id="41-absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？"><a href="#41-absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？" class="headerlink" title="41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？"></a>41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）内联元素也可以作为“包含块”所在的元素；</span><br><span class="line"></span><br><span class="line">（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；</span><br><span class="line"></span><br><span class="line">（3）边界是padding box而不是content box。</span><br></pre></td></tr></table></figure>

<h4 id="42-对于-hasLayout-的理解？"><a href="#42-对于-hasLayout-的理解？" class="headerlink" title="42.对于 hasLayout 的理解？"></a>42.对于 hasLayout 的理解？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hasLayout是IE特有的一个属性。很多的IE下的css bug都与其息息相关。在IE中，一个元素要么自己对自身的内容进</span><br><span class="line">行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可</span><br><span class="line">能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完</span><br><span class="line">成这些工作。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000010883974">《CSS 基础篇–CSS 中 IE 浏览器的 hasLayout，IE 低版本的 bug 根源》</a><br><a href="https://segmentfault.com/a/1190000004632071">《CSS 魔法堂：hasLayout 原来是这样的！》</a></p>
<h4 id="43-元素竖向的百分比设定是相对于容器的高度吗？"><a href="#43-元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="43.元素竖向的百分比设定是相对于容器的高度吗？"></a>43.元素竖向的百分比设定是相对于容器的高度吗？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果是height的话，是相对于包含块的高度。</span><br><span class="line"></span><br><span class="line">如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。</span><br></pre></td></tr></table></figure>

<h4 id="44-全屏滚动的原理是什么？用到了-CSS-的哪些属性？（待深入实践）"><a href="#44-全屏滚动的原理是什么？用到了-CSS-的哪些属性？（待深入实践）" class="headerlink" title="44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）"></a>44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，容器及容</span><br><span class="line">器内的页面取当前可视区高度，同时容器的父级元素overflow属性值设为hidden，通过更改容器可视区的位置来实现全</span><br><span class="line">屏滚动效果。主要是响应鼠标事件，页面通过CSS的动画效果，进行移动。</span><br><span class="line"></span><br><span class="line">overflow：hidden；transition：all 1000 ms ease；</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/liona_koukou/article/details/52680409">《js 实现网页全屏切换（平滑过渡），鼠标滚动切换》</a><br><a href="https://juejin.im/post/5aeef41cf265da0ba0630de0">《用 ES6 写全屏滚动插件》</a></p>
<h4 id="45-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？（待深入了解）"><a href="#45-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？（待深入了解）" class="headerlink" title="45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）"></a>45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏</span><br><span class="line">幕尺寸做处理。页面头部必须有meta声明的viewport。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/dreamerframework/article/details/8994741">《响应式布局原理》</a><br><a href="http://www.mahaixiang.cn/wzsj/278.html">《响应式布局的实现方法和原理》</a></p>
<h4 id="46-视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）"><a href="#46-视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）" class="headerlink" title="46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）"></a>46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20990029">《如何实现视差滚动效果的网页？》</a></p>
<h4 id="47-如何修改-chrome-记住密码后自动填充表单的黄色背景？"><a href="#47-如何修改-chrome-记住密码后自动填充表单的黄色背景？" class="headerlink" title="47.如何修改 chrome 记住密码后自动填充表单的黄色背景？"></a>47.如何修改 chrome 记住密码后自动填充表单的黄色背景？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的in</span><br><span class="line">put表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">background-color:rgb(250,255,189)!important;</span><br><span class="line">background-image:none!important;</span><br><span class="line">color:rgb(0,0,0)!important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是</span><br><span class="line">其他属性可使用。</span><br><span class="line"></span><br><span class="line">使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下</span><br><span class="line"></span><br><span class="line">input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill&#123;</span><br><span class="line">-webkit-box-shadow:000px 1000px white inset;</span><br><span class="line">border:1px solid #CCC !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/zsl_955200/article/details/78276209">《去掉 chrome 记住密码后的默认填充样式》</a><br><a href="https://blog.csdn.net/M_agician/article/details/73381706">《修改谷歌浏览器 chrome 记住密码后自动填充表单的黄色背景》</a></p>
<h4 id="48-怎么让-Chrome-支持小于-12px-的文字？"><a href="#48-怎么让-Chrome-支持小于-12px-的文字？" class="headerlink" title="48.怎么让 Chrome 支持小于 12px 的文字？"></a>48.怎么让 Chrome 支持小于 12px 的文字？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">（1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size</span><br><span class="line">-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器</span><br><span class="line">已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</span><br><span class="line"></span><br><span class="line">（2）还可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.</span><br><span class="line">75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/</span><br><span class="line">inline-block/...；</span><br><span class="line"></span><br><span class="line">（3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://570109268.iteye.com/blog/2406562">《谷歌浏览器不支持 CSS 设置小于 12px 的文字怎么办？》</a></p>
<h4 id="49-让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#49-让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="49.让页面里的字体变清晰，变细用 CSS 怎么做？"></a>49.让页面里的字体变清晰，变细用 CSS 怎么做？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webkit内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。</span><br><span class="line"></span><br><span class="line">在MacOS测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设</span><br><span class="line">置后无效。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/huo_bao/article/details/50251585">《让字体变的更清晰 CSS 中-webkit-font-smoothing》</a></p>
<h4 id="50-font-style-属性中-italic-和-oblique-的区别？"><a href="#50-font-style-属性中-italic-和-oblique-的区别？" class="headerlink" title="50.font-style 属性中 italic 和 oblique 的区别？"></a>50.font-style 属性中 italic 和 oblique 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">italic和oblique这两个关键字都表示“斜体”的意思。</span><br><span class="line"></span><br><span class="line">它们的区别在于，italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，</span><br><span class="line">则退而求其次，解析为oblique，也就是单纯形状倾斜。</span><br></pre></td></tr></table></figure>

<h4 id="51-设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？"><a href="#51-设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？" class="headerlink" title="51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？"></a>51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。</span><br><span class="line"></span><br><span class="line">css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相</span><br><span class="line">对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。</span><br><span class="line"></span><br><span class="line">dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr=1。在iphone4时，苹果推出了retina屏幕，它的dpr</span><br><span class="line">为2。屏幕的缩放会改变dpr的值。</span><br><span class="line"></span><br><span class="line">ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/libin-1/p/7148377.html">《什么是物理像素、虚拟像素、逻辑像素、设备像素，什么又是 PPI,DPI,DPR 和 DIP》</a><br><a href="https://www.jianshu.com/p/af6dad66e49a">《前端工程师需要明白的「像素」》</a><br><a href="https://github.com/jawil/blog/issues/21">《CSS 像素、物理像素、逻辑像素、设备像素比、PPI、Viewport》</a><br><a href="https://github.com/wujunchuan/wujunchuan.github.io/issues/15">《前端开发中像素的概念》</a></p>
<h4 id="52-layout-viewport、visual-viewport-和-ideal-viewport-的区别？"><a href="#52-layout-viewport、visual-viewport-和-ideal-viewport-的区别？" class="headerlink" title="52.layout viewport、visual viewport 和 ideal viewport 的区别？"></a>52.layout viewport、visual viewport 和 ideal viewport 的区别？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定</span><br><span class="line">默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。</span><br><span class="line">ppk把这个浏览器默认的viewport叫做layout viewport。</span><br><span class="line"></span><br><span class="line">layout viewport的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小，ppk把</span><br><span class="line">这个viewport叫做visual viewport。</span><br><span class="line"></span><br><span class="line">ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元</span><br><span class="line">素的宽度设为ideal viewport的宽度（单位用px），那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。i</span><br><span class="line">deal viewport的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport而设计的网站，不需要用户手动缩放，也</span><br><span class="line">不需要出现横向滚动条，都可以完美的呈现给用户。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">移动端一共需要理解三个viewport的概念的理解。</span><br><span class="line"></span><br><span class="line">第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整</span><br><span class="line">个页面的布局都会显示错乱。所以移动端浏览器提供了一个layout viewport布局视口的概念，使用这个视口来对页面进行布局展</span><br><span class="line">示，一般layout viewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。</span><br><span class="line"></span><br><span class="line">第二个视口指的是视觉视口，visual viewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visu</span><br><span class="line">al viewport和layout viewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口</span><br><span class="line">中的网页内容。</span><br><span class="line"></span><br><span class="line">第三个视口是理想视口，由于layout viewport一般比visual viewport要大，所以想要看到整个页面必须通过拖动和缩放才</span><br><span class="line">能实现。所以又提出了ideal viewport的概念，ideal viewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在</span><br><span class="line">不同分辨率下显示的内容大小相同。ideal viewport其实就是通过修改layout viewport的大小，让它等于设备的宽度，这个</span><br><span class="line">宽度可以理解为是设备独立像素，因此根据ideal viewport设计的页面，在不同分辨率的屏幕下，显示应该相同。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/2050/p/3877280.html">《移动前端开发之 viewport 的深入理解》</a><br><a href="https://www.html.cn/archives/5975">《说说移动前端中 viewport（视口）》</a><br><a href="https://juejin.im/post/5b6d21daf265da0f9d1a2ed7#heading-14">《移动端适配知识你到底知多少》</a></p>
<h4 id="53-position-fixed-在-android-下无效怎么处理？"><a href="#53-position-fixed-在-android-下无效怎么处理？" class="headerlink" title="53.position:fixed;在 android 下无效怎么处理？"></a>53.position:fixed;在 android 下无效怎么处理？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为移动端浏览器默认的viewport叫做layout viewport。在移动端显示时，因为layout viewport的宽度大于移动端屏幕</span><br><span class="line">的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layout viewport来固定位置的，而不是移动端屏幕来固定位置的</span><br><span class="line">，所以会出现感觉fixed无效的情况。</span><br><span class="line"></span><br><span class="line">如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为ideal viewport，可以如下设置：</span><br><span class="line"></span><br><span class="line">&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-sca</span><br><span class="line">le=1.0,user-scalable=no&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="54-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"><a href="#54-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）" class="headerlink" title="54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"></a>54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms</span><br></pre></td></tr></table></figure>

<h4 id="55-如何让去除-inline-block-元素间间距？"><a href="#55-如何让去除-inline-block-元素间间距？" class="headerlink" title="55.如何让去除 inline-block 元素间间距？"></a>55.如何让去除 inline-block 元素间间距？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/">《去除 inline-block 元素间间距的 N 种方法》</a></p>
<h4 id="56-overflow-scroll-时不能平滑滚动的问题怎么处理？"><a href="#56-overflow-scroll-时不能平滑滚动的问题怎么处理？" class="headerlink" title="56.overflow:scroll 时不能平滑滚动的问题怎么处理？"></a>56.overflow:scroll 时不能平滑滚动的问题怎么处理？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以下代码可解决这种卡顿的问题：-webkit-overflow-scrolling:touch;是因为这行代码启用了硬件加速特性，所以滑动很流</span><br><span class="line">畅。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/1f4693d0ad2d">《解决页面使用 overflow:scroll 在 iOS 上滑动卡顿的问题》</a></p>
<h4 id="57-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度。"><a href="#57-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度。" class="headerlink" title="57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。"></a>57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）外层div使用position：relative；高度要求自适应的div使用position:absolute;top:100px;bottom:0;</span><br><span class="line">left:0;right:0;</span><br><span class="line"></span><br><span class="line">（2）使用flex布局，设置主轴为竖轴，第二个div的flex-grow为1。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/xutongbao/article/details/79408522">《有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度(三种方案)》</a></p>
<h4 id="58-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？"><a href="#58-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？" class="headerlink" title="58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？"></a>58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）BMP，是无损的、既支持索引色也支持直接色的、点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常</span><br><span class="line">具有较大的文件大小。</span><br><span class="line"></span><br><span class="line">（2）GIF是无损的、采用索引色的、点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具</span><br><span class="line">有支持动画以及透明的优点。但，GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积</span><br><span class="line">较小的场景。</span><br><span class="line"></span><br><span class="line">（3）JPEG是有损的、采用直接色的、点阵图。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来</span><br><span class="line">存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，</span><br><span class="line">又会导致图片文件较GIF更大。</span><br><span class="line"></span><br><span class="line">（4）PNG-8是无损的、使用索引色的、点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的</span><br><span class="line">情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8</span><br><span class="line">还支持透明度的调节，而GIF并不支持。现在，除非需要动画的支持，否则我们没有理由使用GIF而不是PNG-8。</span><br><span class="line"></span><br><span class="line">（5）PNG-24是无损的、使用直接色的、点阵图。PNG-24的优点在于，它压缩了图片的数据，使得同样效果的图片，PNG-24格</span><br><span class="line">式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</span><br><span class="line"></span><br><span class="line">（6）SVG是无损的、矢量图。SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图</span><br><span class="line">片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企</span><br><span class="line">业Logo、Icon等。</span><br><span class="line"></span><br><span class="line">（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。从名字就可以看出来它是</span><br><span class="line">为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，</span><br><span class="line">如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。</span><br><span class="line"></span><br><span class="line">•在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</span><br><span class="line">•在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</span><br><span class="line">•WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</span><br><span class="line"></span><br><span class="line">但是目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我了解到的一共有七种常见的图片的格式。</span><br><span class="line"></span><br><span class="line">（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比</span><br><span class="line">较大。</span><br><span class="line"></span><br><span class="line">（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还</span><br><span class="line">支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。</span><br><span class="line"></span><br><span class="line">（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但</span><br><span class="line">由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。</span><br><span class="line"></span><br><span class="line">（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并</span><br><span class="line">且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。</span><br><span class="line"></span><br><span class="line">（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP</span><br><span class="line">格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。</span><br><span class="line"></span><br><span class="line">（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般</span><br><span class="line">适合于用来制作一些网站logo或者图标之类的图片。</span><br><span class="line"></span><br><span class="line">（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相</span><br><span class="line">同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，</span><br><span class="line">这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/xinzhao/p/5130410.html">《图片格式那么多，哪种更适合你？》</a></p>
<h4 id="59-浏览器如何判断是否支持-webp-格式图片"><a href="#59-浏览器如何判断是否支持-webp-格式图片" class="headerlink" title="59.浏览器如何判断是否支持 webp 格式图片"></a>59.浏览器如何判断是否支持 webp 格式图片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如</span><br><span class="line">果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格</span><br><span class="line">式的图片。</span><br><span class="line"></span><br><span class="line">（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断</span><br><span class="line">返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/jesslu/article/details/82495061">《判断浏览器是否支持 WebP 图片》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL">《toDataURL()》</a></p>
<h4 id="60-什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）"><a href="#60-什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）" class="headerlink" title="60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）"></a>60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。</span><br><span class="line"></span><br><span class="line">如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开</span><br><span class="line">，静态资源放CDN。</span><br><span class="line"></span><br><span class="line">因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请</span><br><span class="line">求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</span><br><span class="line"></span><br><span class="line">同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的</span><br><span class="line">http请求的解析速度。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/36514327?rf=37353035">《CDN 是什么？使用 CDN 有什么优势？》</a></p>
<h4 id="61-style-标签写在-body-后与-body-前有什么区别？"><a href="#61-style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="61.style 标签写在 body 后与 body 前有什么区别？"></a>61.style 标签写在 body 后与 body 前有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式</span><br><span class="line">表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可</span><br><span class="line">能会出现FOUC现象（即样式失效导致的页面闪烁问题）</span><br></pre></td></tr></table></figure>

<h4 id="62-什么是-CSS-预处理器-后处理器？"><a href="#62-什么是-CSS-预处理器-后处理器？" class="headerlink" title="62.什么是 CSS 预处理器/后处理器？"></a>62.什么是 CSS 预处理器/后处理器？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成</span><br><span class="line">文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然</span><br><span class="line">后再编译成正常的CSS文件。</span><br><span class="line"></span><br><span class="line">预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、</span><br><span class="line">变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</span><br><span class="line"></span><br><span class="line">CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后</span><br><span class="line">处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，</span><br><span class="line">以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。</span><br><span class="line"></span><br><span class="line">后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏</span><br><span class="line">览器私有前缀，实现跨浏览器兼容性的问题。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/yushuangyushuang/article/details/79209752">《CSS 预处理器和后处理器》</a></p>
<h4 id="63-阐述一下-CSSSprites"><a href="#63-阐述一下-CSSSprites" class="headerlink" title="63.阐述一下 CSSSprites"></a>63.阐述一下 CSSSprites</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background</span><br><span class="line">-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites</span><br><span class="line">能减少图片的字节。</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">减少HTTP请求数，极大地提高页面加载速度</span><br><span class="line">增加图片信息重复度，提高压缩比，减少图片大小</span><br><span class="line">更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">图片合并麻烦</span><br><span class="line">维护麻烦，修改一个图片可能需要重新布局整个图片，样式</span><br></pre></td></tr></table></figure>

<h4 id="64-使用-rem-布局的优缺点？"><a href="#64-使用-rem-布局的优缺点？" class="headerlink" title="64.使用 rem 布局的优缺点？"></a>64.使用 rem 布局的优缺点？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优点：</span><br><span class="line">在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。</span><br><span class="line">而且现在浏览器基本都已经支持rem了，兼容性也非常的好。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。</span><br><span class="line">（2）使用iframe引用也会出现问题。</span><br><span class="line">（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问</span><br><span class="line">题。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21504656">《css3 的字体大小单位 rem 到底好在哪？》</a><br><a href="https://www.jianshu.com/p/e8ae1c3861dc">《VW:是时候放弃 REM 布局了》</a><br><a href="https://blog.csdn.net/Honeymao/article/details/76795089">《为什么设计稿是 750px》</a><br><a href="https://github.com/amfe/article/issues/17">《使用 Flexible 实现手淘 H5 页面的终端适配》</a></p>
<h4 id="65-几种常见的-CSS-布局"><a href="#65-几种常见的-CSS-布局" class="headerlink" title="65.几种常见的 CSS 布局"></a>65.几种常见的 CSS 布局</h4><p>详细的资料可以参考：<br><a href="https://juejin.im/post/5bbcd7ff5188255c80668028#heading-12">《几种常见的 CSS 布局》</a></p>
<h4 id="66-画一条-0-5px-的线"><a href="#66-画一条-0-5px-的线" class="headerlink" title="66.画一条 0.5px 的线"></a>66.画一条 0.5px 的线</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">采用meta viewport的方式</span><br><span class="line"></span><br><span class="line">采用border-image的方式</span><br><span class="line"></span><br><span class="line">采用transform:scale()的方式</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5ab65f40f265da2384408a95">《怎么画一条 0.5px 的边（更新）》</a></p>
<h4 id="67-transition-和-animation-的区别"><a href="#67-transition-和-animation-的区别" class="headerlink" title="67.transition 和 animation 的区别"></a>67.transition 和 animation 的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。</span><br><span class="line"></span><br><span class="line">animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19749045">《CSSanimation 与 CSStransition 有何区别？》</a><br><a href="https://blog.csdn.net/cddcj/article/details/53582334">《CSS3Transition 和 Animation 区别及比较》</a><br><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html">《CSS 动画简介》</a><br><a href="https://juejin.im/post/5b137e6e51882513ac201dfb">《CSS 动画：animation、transition、transform、translate》</a></p>
<h4 id="68-什么是首选最小宽度？"><a href="#68-什么是首选最小宽度？" class="headerlink" title="68.什么是首选最小宽度？"></a>68.什么是首选最小宽度？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“首选最小宽度”，指的是元素最适合的最小宽度。</span><br><span class="line"></span><br><span class="line">东亚文字（如中文）最小宽度为每个汉字的宽度。</span><br><span class="line"></span><br><span class="line">西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短</span><br><span class="line">横线、问号以及其他非英文字符等。</span><br><span class="line"></span><br><span class="line">如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。</span><br></pre></td></tr></table></figure>

<h4 id="69-为什么-height-100-会无效？"><a href="#69-为什么-height-100-会无效？" class="headerlink" title="69.为什么 height:100%会无效？"></a>69.为什么 height:100%会无效？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。</span><br><span class="line"></span><br><span class="line">原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，</span><br><span class="line">所以无法参与计算。</span><br><span class="line"></span><br><span class="line">使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。</span><br></pre></td></tr></table></figure>

<h4 id="70-min-width-max-width-和-min-height-max-height-属性间的覆盖规则？"><a href="#70-min-width-max-width-和-min-height-max-height-属性间的覆盖规则？" class="headerlink" title="70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？"></a>70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）max-width会覆盖width，即使width是行类样式或者设置了!important。</span><br><span class="line"></span><br><span class="line">（2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。</span><br></pre></td></tr></table></figure>

<h4 id="71-内联盒模型基本概念"><a href="#71-内联盒模型基本概念" class="headerlink" title="71.内联盒模型基本概念"></a>71.内联盒模型基本概念</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）内容区域（content area）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子</span><br><span class="line">（character box）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些</span><br><span class="line">元素，内容区域可以看成元素自身。</span><br><span class="line"></span><br><span class="line">（2）内联盒子（inline box）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒</span><br><span class="line">子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。</span><br><span class="line"></span><br><span class="line">（3）行框盒子（line box），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。</span><br><span class="line"></span><br><span class="line">（4）包含块（containing box），由一行一行的“行框盒子”组成。</span><br></pre></td></tr></table></figure>

<h4 id="72-什么是幽灵空白节点？"><a href="#72-什么是幽灵空白节点？" class="headerlink" title="72.什么是幽灵空白节点？"></a>72.什么是幽灵空白节点？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同</span><br><span class="line">每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵</span><br><span class="line">一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。</span><br></pre></td></tr></table></figure>

<h4 id="73-什么是替换元素？"><a href="#73-什么是替换元素？" class="headerlink" title="73.什么是替换元素？"></a>73.什么是替换元素？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;iframe&gt;或者表</span><br><span class="line">单元素&lt;textarea&gt;和&lt;input&gt;和&lt;select&gt;都是典型的替换元素。</span><br><span class="line"></span><br><span class="line">替换元素除了内容可替换这一特性以外，还有以下一些特性。</span><br><span class="line"></span><br><span class="line">（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要</span><br><span class="line">类似appearance属性，或者浏览器自身暴露的一些样式接口，</span><br><span class="line"></span><br><span class="line">（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像</span><br><span class="line">素，如&lt;video&gt;、&lt;iframe&gt;或者&lt;canvas&gt;等，也有少部分替换元素为0像素，如&lt;img&gt;图片，而表单元素的替换元素</span><br><span class="line">的尺寸则和浏览器有关，没有明显的规律。</span><br><span class="line"></span><br><span class="line">（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，ve</span><br><span class="line">rtical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，</span><br><span class="line">被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</span><br><span class="line"></span><br><span class="line">（4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认</span><br><span class="line">的display值却是不一样的，有的是inline，有的是inline-block。</span><br></pre></td></tr></table></figure>

<h4 id="74-替换元素的计算规则？"><a href="#74-替换元素的计算规则？" class="headerlink" title="74.替换元素的计算规则？"></a>74.替换元素的计算规则？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。</span><br><span class="line"></span><br><span class="line">（1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</span><br><span class="line"></span><br><span class="line">（2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括&lt;img&gt;的width和height属性、&lt;input&gt;的s</span><br><span class="line">ize属性、&lt;textarea&gt;的cols和rows属性等。</span><br><span class="line"></span><br><span class="line">（3）CSS尺寸特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的</span><br><span class="line">尺寸，对应盒尺寸中的content box。</span><br><span class="line"></span><br><span class="line">这3层结构的计算规则具体如下</span><br><span class="line"></span><br><span class="line">（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。</span><br><span class="line"></span><br><span class="line">（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</span><br><span class="line"></span><br><span class="line">（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。</span><br><span class="line"></span><br><span class="line">（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。</span><br><span class="line"></span><br><span class="line">（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。</span><br><span class="line"></span><br><span class="line">（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</span><br></pre></td></tr></table></figure>

<h4 id="75-content-与替换元素的关系？"><a href="#75-content-与替换元素的关系？" class="headerlink" title="75.content 与替换元素的关系？"></a>75.content 与替换元素的关系？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content属性生成的对象称为“匿名替换元素”。</span><br><span class="line"></span><br><span class="line">（1）我们使用content生成的文本是无法选中、无法复制的，好像设置了user select:none声明一般，但是普通元素的文本</span><br><span class="line">却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是</span><br><span class="line">地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。</span><br><span class="line"></span><br><span class="line">（2）content生成的内容不能左右:empty伪类。</span><br><span class="line"></span><br><span class="line">（3）content动态生成值无法获取。</span><br></pre></td></tr></table></figure>

<h4 id="76-margin-auto-的填充规则？"><a href="#76-margin-auto-的填充规则？" class="headerlink" title="76.margin:auto 的填充规则？"></a>76.margin:auto 的填充规则？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">margin的&#x27;auto&#x27;可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发mar</span><br><span class="line">gin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。</span><br><span class="line"></span><br><span class="line">（1）如果一侧定值，一侧auto，则auto为剩余空间大小。</span><br><span class="line">（2）如果两侧均是auto，则平分剩余空间。</span><br></pre></td></tr></table></figure>

<h4 id="77-margin-无效的情形"><a href="#77-margin-无效的情形" class="headerlink" title="77.margin 无效的情形"></a>77.margin 无效的情形</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有ma</span><br><span class="line">rgin合并的问题。</span><br><span class="line"></span><br><span class="line">（2）表格中的&lt;tr&gt;和&lt;td&gt;元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。</span><br><span class="line"></span><br><span class="line">（3）绝对定位元素非定位方位的margin值“无效”。</span><br><span class="line"></span><br><span class="line">（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。</span><br></pre></td></tr></table></figure>

<h4 id="78-border-的特殊性？"><a href="#78-border-的特殊性？" class="headerlink" title="78.border 的特殊性？"></a>78.border 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）border-width却不支持百分比。</span><br><span class="line"></span><br><span class="line">（2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-col</span><br><span class="line">or没有边框显示的原因。</span><br><span class="line"></span><br><span class="line">（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。</span><br><span class="line"></span><br><span class="line">（4）border-color默认颜色就是color色值。</span><br><span class="line"></span><br><span class="line">（5）默认background背景图片是相对于padding box定位的。</span><br></pre></td></tr></table></figure>

<h4 id="79-什么是基线和-x-height？"><a href="#79-什么是基线和-x-height？" class="headerlink" title="79.什么是基线和 x-height？"></a>79.什么是基线和 x-height？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字母x的下边缘（线）就是我们的基线。</span><br><span class="line"></span><br><span class="line">x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在C</span><br><span class="line">SS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。</span><br><span class="line"></span><br><span class="line">ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影</span><br><span class="line">响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。</span><br></pre></td></tr></table></figure>

<h4 id="80-line-height-的特殊性？"><a href="#80-line-height-的特殊性？" class="headerlink" title="80.line-height 的特殊性？"></a>80.line-height 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高</span><br><span class="line">度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。</span><br><span class="line"></span><br><span class="line">（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作</span><br><span class="line">用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是</span><br><span class="line">有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。</span><br><span class="line"></span><br><span class="line">（3）行距=line-height-font-size。</span><br><span class="line"></span><br><span class="line">（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下</span><br><span class="line">边距，则向上取整。</span><br><span class="line"></span><br><span class="line">（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。</span><br><span class="line"></span><br><span class="line">（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是</span><br><span class="line">通过改变块级元素里面内联级别元素占据的高度实现的。</span><br><span class="line"></span><br><span class="line">（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-si</span><br><span class="line">ze相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。</span><br><span class="line"></span><br><span class="line">（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为</span><br><span class="line">属性值，那么所有的子元素继承的是最终的计算值。</span><br><span class="line"></span><br><span class="line">（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。</span><br><span class="line"></span><br><span class="line">（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个</span><br><span class="line">“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。</span><br></pre></td></tr></table></figure>

<h4 id="81-vertical-align-的特殊性？"><a href="#81-vertical-align-的特殊性？" class="headerlink" title="81.vertical-align 的特殊性？"></a>81.vertical-align 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字</span><br><span class="line">母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面</span><br><span class="line">没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行</span><br><span class="line">内联元素的基线。</span><br><span class="line"></span><br><span class="line">（2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display</span><br><span class="line">计算值是table-cell的元素，我们不妨脑补成&lt;td&gt;元素，则和&lt;tr&gt;元素上边缘对齐。</span><br><span class="line"></span><br><span class="line">（3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对</span><br><span class="line">于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。</span><br><span class="line"></span><br><span class="line">（4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上</span><br><span class="line">偏移。</span><br><span class="line"></span><br><span class="line">（5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。</span><br><span class="line"></span><br><span class="line">（6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元</span><br><span class="line">素。</span><br><span class="line"></span><br><span class="line">（7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。</span><br></pre></td></tr></table></figure>

<h4 id="82-overflow-的特殊性？"><a href="#82-overflow-的特殊性？" class="headerlink" title="82.overflow 的特殊性？"></a>82.overflow 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度</span><br><span class="line">高度限制的时候，剪裁的边界是border box的内边缘，而非padding box的内边缘。</span><br><span class="line"></span><br><span class="line">（2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素&lt;html&gt;，另一个是文本域&lt;textarea&gt;。</span><br><span class="line"></span><br><span class="line">（3）滚动条会占用容器的可用宽度或高度。</span><br><span class="line"></span><br><span class="line">（4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！</span><br></pre></td></tr></table></figure>

<h4 id="83-无依赖绝对定位是什么？"><a href="#83-无依赖绝对定位是什么？" class="headerlink" title="83.无依赖绝对定位是什么？"></a>83.无依赖绝对定位是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有设置left/top/right/bottom属性值的绝对定位称为“无依赖绝对定位”。</span><br><span class="line"></span><br><span class="line">无依赖绝对定位其定位的位置和没有设置position:absolute时候的位置相关。</span><br></pre></td></tr></table></figure>

<h4 id="84-absolute-与-overflow-的关系？"><a href="#84-absolute-与-overflow-的关系？" class="headerlink" title="84.absolute 与 overflow 的关系？"></a>84.absolute 与 overflow 的关系？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute</span><br><span class="line">元素进行剪裁。</span><br><span class="line"></span><br><span class="line">（2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也</span><br><span class="line">都不会出现滚动条。</span><br><span class="line"></span><br><span class="line">（3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。</span><br></pre></td></tr></table></figure>

<h4 id="85-clip-裁剪是什么？"><a href="#85-clip-裁剪是什么？" class="headerlink" title="85.clip 裁剪是什么？"></a>85.clip 裁剪是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。</span><br><span class="line"></span><br><span class="line">clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。</span><br></pre></td></tr></table></figure>

<h4 id="86-relative-的特殊性？"><a href="#86-relative-的特殊性？" class="headerlink" title="86.relative 的特殊性？"></a>86.relative 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。</span><br><span class="line"></span><br><span class="line">（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。</span><br><span class="line"></span><br><span class="line">（3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。</span><br></pre></td></tr></table></figure>

<h4 id="87-什么是层叠上下文？"><a href="#87-什么是层叠上下文？" class="headerlink" title="87.什么是层叠上下文？"></a>87.什么是层叠上下文？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">层叠上下文，英文称作stacking context，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元</span><br><span class="line">素在z轴上就“高人一等”。</span><br><span class="line"></span><br><span class="line">层叠上下文元素有如下特性：</span><br><span class="line"></span><br><span class="line">（1）层叠上下文的层叠水平要比普通元素高（原因后面会说明）。</span><br><span class="line">（2）层叠上下文可以阻断元素的混合模式。</span><br><span class="line">（3）层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。</span><br><span class="line">（4）每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。</span><br><span class="line">（5）每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">层叠上下文的创建：</span><br><span class="line"></span><br><span class="line">（1）页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是&lt;html&gt;元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。</span><br><span class="line"></span><br><span class="line">（2）对于position值为relative/absolute以及Firefox/IE浏览器（不包括Chrome浏览器）下含有position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。Chrome等WebKit内核浏览器下，position:fixed元素天然层叠上下文元素，无须z-index为数值。根据我的测试，目前IE和Firefox仍是老套路。</span><br><span class="line"></span><br><span class="line">（3）其他一些CSS3属性，比如元素的opacity值不是1。</span><br></pre></td></tr></table></figure>

<h4 id="88-什么是层叠水平？"><a href="#88-什么是层叠水平？" class="headerlink" title="88.什么是层叠水平？"></a>88.什么是层叠水平？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">层叠水平，英文称作stacking level，决定了同一个层叠上下文中元素在z轴上的显示顺序。</span><br><span class="line"></span><br><span class="line">显而易见，所有的元素都有层叠水平，包括层叠上下文元素，也包括普通元素。然而，对普通元素的层叠水平探讨只局限在当前层叠上</span><br><span class="line">下文元素中。</span><br></pre></td></tr></table></figure>

<h4 id="89-元素的层叠顺序？"><a href="#89-元素的层叠顺序？" class="headerlink" title="89.元素的层叠顺序？"></a>89.元素的层叠顺序？</h4><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。</p>
<p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-15.png" alt="层叠顺序"></p>
<h4 id="90-层叠准则？"><a href="#90-层叠准则？" class="headerlink" title="90.层叠准则？"></a>90.层叠准则？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。</span><br><span class="line"></span><br><span class="line">（2）后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</span><br></pre></td></tr></table></figure>

<h4 id="91-font-weight-的特殊性？"><a href="#91-font-weight-的特殊性？" class="headerlink" title="91.font-weight 的特殊性？"></a>91.font-weight 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果使用数值作为font-weight属性值，必须是100～900的整百数。因为这里的数值仅仅是外表长得像数值，实际上是一个具有特定含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。</span><br></pre></td></tr></table></figure>

<h4 id="92-text-indent-的特殊性？"><a href="#92-text-indent-的特殊性？" class="headerlink" title="92.text-indent 的特殊性？"></a>92.text-indent 的特殊性？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）text-indent仅对第一行内联盒子内容有效。</span><br><span class="line"></span><br><span class="line">（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inli</span><br><span class="line">ne-table则会生效。</span><br><span class="line"></span><br><span class="line">（3）&lt;input&gt;标签按钮text-indent值无效。</span><br><span class="line"></span><br><span class="line">（4）&lt;button&gt;标签按钮text-indent值有效。</span><br><span class="line"></span><br><span class="line">（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。</span><br></pre></td></tr></table></figure>

<h4 id="93-letter-spacing-与字符间距？"><a href="#93-letter-spacing-与字符间距？" class="headerlink" title="93.letter-spacing 与字符间距？"></a>93.letter-spacing 与字符间距？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。</span><br><span class="line"></span><br><span class="line">letter-spacing具有以下一些特性。</span><br><span class="line"></span><br><span class="line">（1）继承性。</span><br><span class="line">（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。</span><br><span class="line">（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。</span><br><span class="line">（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。</span><br><span class="line">（5）支持小数值，即使0.1px也是支持的。</span><br><span class="line">（6）暂不支持百分比值。</span><br></pre></td></tr></table></figure>

<h4 id="94-word-spacing-与单词间距？"><a href="#94-word-spacing-与单词间距？" class="headerlink" title="94.word-spacing 与单词间距？"></a>94.word-spacing 与单词间距？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙</span><br><span class="line">宽度。</span><br></pre></td></tr></table></figure>

<h4 id="95-white-space-与换行和空格的控制？"><a href="#95-white-space-与换行和空格的控制？" class="headerlink" title="95.white-space 与换行和空格的控制？"></a>95.white-space 与换行和空格的控制？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）</span><br><span class="line">键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否</span><br><span class="line">生效）等。</span><br><span class="line"></span><br><span class="line">其属性值包括下面这些。</span><br><span class="line">•normal：合并空白字符和换行符。</span><br><span class="line">•pre：空白字符不合并，并且内容只在有换行符的地方换行。</span><br><span class="line">•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。</span><br><span class="line">•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。</span><br><span class="line">•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。</span><br></pre></td></tr></table></figure>

<h4 id="96-隐藏元素的-background-image-到底加不加载？"><a href="#96-隐藏元素的-background-image-到底加不加载？" class="headerlink" title="96.隐藏元素的 background-image 到底加不加载？"></a>96.隐藏元素的 background-image 到底加不加载？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据测试，一个元素如果display计算值为none，在IE浏览器下（IE8～IE11，更高版本不确定）依然会发送图片请求，Fire</span><br><span class="line">fox浏览器不会，至于Chrome和Safari浏览器则似乎更加智能一点：如果隐藏元素同时又设置了background-image，则图片</span><br><span class="line">依然会去加载；如果是父元素的display计算值为none，则背景图不会请求，此时浏览器或许放心地认为这个背景图暂时是不会使</span><br><span class="line">用的。</span><br><span class="line"></span><br><span class="line">如果不是background-image，而是&lt;img&gt;元素，则设置display:none在所有浏览器下依旧都会请求图片资源。</span><br><span class="line"></span><br><span class="line">还需要注意的是如果设置的样式没有对应的元素，则background-image也不会加载。hover情况下的background-image，在触</span><br><span class="line">发时加载。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<p>-（1）元素的背景图片</p>
<p>-元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求<br>-:hover 样式下，触发时请求</p>
<p>-（2）img 标签图片任何情况下都会请求图片</p>
<p>详细资料可以参考：<br><a href="https://www.jb51.net/css/469033.html">《CSS 控制前端图片 HTTP 请求的各种情况示例》</a></p>
<h4 id="97-如何实现单行／多行文本溢出的省略（…）？"><a href="#97-如何实现单行／多行文本溢出的省略（…）？" class="headerlink" title="97.如何实现单行／多行文本溢出的省略（…）？"></a>97.如何实现单行／多行文本溢出的省略（…）？</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*单行文本溢出*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*多行文本溢出*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">  <span class="comment">/*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">3em</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/30707916">《【CSS/JS】如何实现单行／多行文本溢出的省略》</a><br><a href="https://juejin.im/entry/587f453e1b69e60058555a5f">《CSS 多行文本溢出省略显示》</a></p>
<h4 id="98-常见的元素隐藏方式？"><a href="#98-常见的元素隐藏方式？" class="headerlink" title="98.常见的元素隐藏方式？"></a>98.常见的元素隐藏方式？</h4><p>-（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</p>
<p>-（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。</p>
<p>-（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</p>
<p>-（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</p>
<p>-（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。</p>
<p>-（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p>
<p>-（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p>
<p>详细资料可以参考：<br><a href="https://juejin.im/post/584b645a128fe10058a0d625#heading-2">《CSS 隐藏元素的八种方法》</a></p>
<h4 id="99-css-实现上下固定中间自适应布局？"><a href="#99-css-实现上下固定中间自适应布局？" class="headerlink" title="99.css 实现上下固定中间自适应布局？"></a>99.css 实现上下固定中间自适应布局？</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">利用绝对定位实现<span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">利用<span class="attribute">flex</span>布局实现<span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/30bc9751e3e8">《css 实现上下固定中间自适应布局》</a></p>
<h4 id="100-css-两栏布局的实现？"><a href="#100-css-两栏布局的实现？" class="headerlink" title="100.css 两栏布局的实现？"></a>100.css 两栏布局的实现？</h4><p>相关资料：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。*/</span></span><br><span class="line"><span class="comment">/*以左边宽度固定为200px为例*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（2）第二种是利用flex布局，将左边元素的放大和缩小比例设置为0，基础大小设置为200px。将右边的元素的放大比例设置为1，缩小比例设置为1，基础大小设置为auto。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: auto;</span><br><span class="line">  <span class="comment">/*11auto*/</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为</span></span><br><span class="line"><span class="comment">200px。将右边元素的margin-left的值设置为200px。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://cavszhouyou.top/Demo-Display/TwoColumnLayout/index.html">《两栏布局 demo 展示》</a></p>
<p>回答：</p>
<p>两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。</p>
<p>以左边宽度固定为 200px 为例</p>
<p>-（1）利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。</p>
<p>-（2）第二种是利用 flex 布局，将左边元素的放大和缩小比例设置为 0，基础大小设置为 200px。将右边的元素的放大比例设置为 1，缩小比例设置为 1，基础大小设置为 auto。</p>
<p>-（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。</p>
<p>-（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。</p>
<h4 id="101-css-三栏布局的实现？"><a href="#101-css-三栏布局的实现？" class="headerlink" title="101.css 三栏布局的实现？"></a>101.css 三栏布局的实现？</h4><p>相关资料：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里以左边宽度固定为100px，右边宽度固定为200px为例。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">00100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">00200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: auto;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。*/</span></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元</span></span><br><span class="line"><span class="comment">素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://cavszhouyou.top/Demo-Display/ThreeColumnLayout/index.html">《三栏布局 demo 展示》</a></p>
<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</span><br><span class="line"></span><br><span class="line">这里以左边宽度固定为100px，右边宽度固定为200px为例。</span><br><span class="line"></span><br><span class="line">（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</span><br><span class="line"></span><br><span class="line">（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto。</span><br><span class="line"></span><br><span class="line">（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。</span><br><span class="line"></span><br><span class="line">（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。圣杯布局中间列的宽度不能小于两边任意列的宽度，而双飞翼布局则不存在这个问题。</span><br><span class="line"></span><br><span class="line">（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的padding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</span><br></pre></td></tr></table></figure>

<h4 id="102-实现一个宽高自适应的正方形"><a href="#102-实现一个宽高自适应的正方形" class="headerlink" title="102.实现一个宽高自适应的正方形"></a>102.实现一个宽高自适应的正方形</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.第一种方式是利用vw来实现*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10vw</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.第二种方式是利用元素的margin/padding百分比是相对父元素width的性质来实现*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3.第三种方式是利用子元素的margin-top的值来实现的*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.square</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://cavszhouyou.top/Demo-Display/AdaptiveSquare/index.html">《自适应正方形 demo 展示》</a></p>
<h4 id="103-实现一个三角形"><a href="#103-实现一个三角形" class="headerlink" title="103.实现一个三角形"></a>103.实现一个三角形</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*三角形的实现原理是利用了元素边框连接处的等分原理。*/</span></span><br><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: tomatotransparenttransparenttransparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://cavszhouyou.top/Demo-Display/Triangle/index.html">《三角形 demo 展示》</a></p>
<h4 id="104-一个自适应矩形，水平垂直居中，且宽高比为-2-1"><a href="#104-一个自适应矩形，水平垂直居中，且宽高比为-2-1" class="headerlink" title="104.一个自适应矩形，水平垂直居中，且宽高比为 2:1"></a>104.一个自适应矩形，水平垂直居中，且宽高比为 2:1</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*实现原理参考自适应正方形和水平居中方式*/</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="105-你知道-CSS-中不同属性设置为百分比-时对应的计算基准？"><a href="#105-你知道-CSS-中不同属性设置为百分比-时对应的计算基准？" class="headerlink" title="105.你知道 CSS 中不同属性设置为百分比%时对应的计算基准？"></a>105.你知道 CSS 中不同属性设置为百分比%时对应的计算基准？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公式：当前元素某CSS属性值 = 基准 * 对应的百分比</span><br><span class="line">元素的 position 为 relative 和 absolute 时，top和bottom、left和right基准分别为包含块的 height、width</span><br><span class="line">元素的 position 为 fixed 时，top和bottom、left和right基准分别为初始包含块（也就是视口）的 height、width，移动设备较为复杂，基准为 Layout viewport 的 height、width</span><br><span class="line">元素的 height 和 width 设置为百分比时，基准分别为包含块的 height 和 width</span><br><span class="line">元素的 margin 和 padding 设置为百分比时，基准为包含块的 width（易错）</span><br><span class="line">元素的 border-width，不支持百分比</span><br><span class="line">元素的 text-indent，基准为包含块的 width</span><br><span class="line"></span><br><span class="line">元素的 border-radius，基准为分别为自身的height、width</span><br><span class="line">元素的 background-size，基准为分别为自身的height、width</span><br><span class="line">元素的 translateX、translateY，基准为分别为自身的height、width</span><br><span class="line">元素的 line-height，基准为自身的 font-size</span><br><span class="line"></span><br><span class="line">元素的 font-size，基准为父元素字体</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2022/10/19/20221019-arithmetic/</url>
    <content><![CDATA[<h1 id="算法知识总结"><a href="#算法知识总结" class="headerlink" title="算法知识总结"></a>算法知识总结</h1><p>本部分主要是笔者在学习算法知识和一些相关面试题所做的笔记，如果出现错误，希望大家指出！</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93">常用算法和数据结构总结</a><ul>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a><ul>
<li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li>
<li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li>
<li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li>
<li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li>
<li><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%85%B6%E4%BB%96%E6%8E%92%E5%BA%8F%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0">快速排序相对于其他排序效率更高的原因</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0">系统自带排序实现</a></li>
<li><a href="#%E7%A8%B3%E5%AE%9A%E6%80%A7">稳定性</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93">排序面试题目总结</a></li>
</ul>
</li>
<li><a href="#%E6%A0%91">树</a><ul>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8">二叉树相关性质</a></li>
<li><a href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91">满二叉树</a></li>
<li><a href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树</a></li>
<li><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91avl">平衡二叉查找树（AVL）</a></li>
<li><a href="#b-%E6%A0%91">B-树</a></li>
<li><a href="#b%E6%A0%91">B 树</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95">数据库索引</a></li>
<li><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a></li>
<li><a href="#huffman-%E6%A0%91">Huffman 树</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a></li>
<li><a href="#%E6%B1%82%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9">求解二叉树中两个节点的最近公共祖先节点</a></li>
</ul>
</li>
<li><a href="#%E9%93%BE%E8%A1%A8">链表</a><ul>
<li><a href="#%E5%8F%8D%E8%BD%AC%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">反转单向链表</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a><ul>
<li><a href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98">爬楼梯问题</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90">递归方法分析</a></li>
<li><a href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%96%B9%E6%B3%95">备忘录方法</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E6%B3%95">迭代法</a></li>
</ul>
</li>
<li><a href="#%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98">经典笔试题</a><ul>
<li><a href="#1-js-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90%E8%B6%85%E8%BF%87%E8%8C%83%E5%9B%B4%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0%E5%8A%9F%E8%83%BD">1. js 实现一个函数，完成超过范围的两个大整数相加功能</a></li>
<li><a href="#2-js-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96">2. js 如何实现数组扁平化？</a></li>
<li><a href="#3-js-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D">3. js 如何实现数组去重？</a></li>
<li><a href="#4-%E5%A6%82%E4%BD%95%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC">4. 如何求数组的最大值和最小值？</a></li>
<li><a href="#5-%E5%A6%82%E4%BD%95%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">5. 如何求两个数的最大公约数？</a></li>
<li><a href="#6-%E5%A6%82%E4%BD%95%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0">6. 如何求两个数的最小公倍数？</a></li>
<li><a href="#7-%E5%AE%9E%E7%8E%B0-indexof-%E6%96%B9%E6%B3%95">7. 实现 IndexOf 方法？</a></li>
<li><a href="#8-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2">8. 判断一个字符串是否为回文字符串？</a></li>
<li><a href="#9-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B4%AF%E5%8A%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%AF%94%E5%A6%82-sum1232valueof">9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()</a></li>
<li><a href="#10-%E4%BD%BF%E7%94%A8-reduce-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0-foreachmapfilter">10. 使用 reduce 方法实现 forEach、map、filter</a></li>
<li><a href="#11-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E8%A6%81%E6%B1%82v%E5%88%86%E5%88%AB%E5%9C%A8-134-%E7%A7%92%E5%90%8E%E6%89%93%E5%8D%B0%E5%87%BA-1-2-3">11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”</a></li>
<li><a href="#12-%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%B8%80%E7%AF%87%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%95%E8%AF%8D">12. 如何查找一篇英文文章中出现频率最高的单词？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%99%BA%E5%8A%9B%E9%A2%98%E6%80%BB%E7%BB%93">常见面试智力题总结</a><ul>
<li><a href="#1-%E6%97%B6%E9%92%88%E4%B8%8E%E5%88%86%E9%92%88%E5%A4%B9%E8%A7%92%E5%BA%A6%E6%95%B0%E9%97%AE%E9%A2%98">1. 时针与分针夹角度数问题？</a></li>
<li><a href="#2-%E7%94%A83%E5%8D%875%E5%8D%87%E6%9D%AF%E5%AD%90%E6%80%8E%E4%B9%88%E9%87%8F%E5%87%BA4%E5%8D%87%E6%B0%B4">2. 用3升，5升杯子怎么量出4升水？</a></li>
<li><a href="#3-%E5%9B%9B%E4%B8%AA%E8%8D%AF%E7%BD%90%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%B5%91%E6%B5%8A%E7%9A%84%E8%8D%AF%E7%BD%90%E6%B5%91%E6%B5%8A%E7%9A%84%E6%AF%8F%E7%89%87%E8%8D%AF%E7%89%87%E9%83%BD%E6%AF%94%E5%85%B6%E4%BB%96%E4%B8%89%E4%B8%AA%E5%B9%B2%E5%87%80%E7%9A%84%E8%8D%AF%E7%BD%90%E5%A4%9A%E4%B8%80%E5%85%8B%E5%A6%82%E4%BD%95%E5%8F%AA%E7%94%A8%E4%B8%80%E6%AC%A1%E5%A4%A9%E5%B9%B3%E6%89%BE%E5%87%BA%E6%B5%91%E6%B5%8A%E7%9A%84%E8%8D%AF%E7%BD%90">3. 浑浊药罐问题</a></li>
<li><a href="#4-%E5%9B%9B%E5%BC%A0%E5%8D%A1%E7%89%87%E5%8D%A1%E7%89%87%E6%AD%A3%E9%9D%A2%E6%98%AF%E6%95%B0%E5%AD%97%E5%8F%8D%E9%9D%A2%E6%98%AF%E5%AD%97%E6%AF%8D%E7%8E%B0%E5%9C%A8%E6%A1%8C%E4%B8%8A%E5%9B%9B%E5%BC%A0%E5%8D%A1%E7%89%87%E7%8A%B6%E6%80%81%E4%B8%BA-a-1-b-2-%E7%8E%B0%E5%9C%A8%E6%88%91%E6%83%B3%E8%A6%81%E8%AF%81%E6%98%8E-a-%E7%9A%84%E5%8F%8D%E9%9D%A2%E5%BF%85%E7%84%B6%E6%98%AF-1">4. 卡片证明问题</a></li>
<li><a href="#5-%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%9825-%E5%8C%B9%E9%A9%AC5-%E4%B8%AA%E8%B5%9B%E9%81%93%E6%9C%80%E5%B0%91%E5%87%A0%E6%AC%A1%E8%83%BD%E9%80%89%E5%87%BA%E6%9C%80%E5%BF%AB%E7%9A%84%E4%B8%89%E5%8C%B9%E9%A9%AC">5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？</a></li>
<li><a href="#6-%E4%BA%94%E9%98%9F%E5%A4%AB%E5%A6%87%E5%8F%82%E5%8A%A0%E8%81%9A%E4%BC%9A%E6%AF%8F%E4%B8%AA%E4%BA%BA%E4%B8%8D%E8%83%BD%E5%92%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E9%85%8D%E5%81%B6%E6%8F%A1%E6%89%8B%E5%8F%AA%E8%83%BD%E6%9C%80%E5%A4%9A%E5%92%8C%E4%BB%96%E4%BA%BA%E6%8F%A1%E6%89%8B%E4%B8%80%E6%AC%A1a%E9%97%AE%E4%BA%86%E5%85%B6%E4%BB%96%E4%BA%BA%E5%8F%91%E7%8E%B0%E6%AF%8F%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%8F%A1%E6%89%8B%E6%AC%A1%E6%95%B0%E9%83%BD">6. 五队夫妇参加聚会握手问题</a></li>
<li><a href="#7-%E4%BD%A0%E5%8F%AA%E8%83%BD%E5%B8%A6%E8%A1%8C%E8%B5%B0-60-%E5%85%AC%E9%87%8C%E7%9A%84%E6%B2%B9%E5%8F%AA%E8%83%BD%E5%9C%A8%E8%B5%B7%E5%A7%8B%E7%82%B9%E5%8A%A0%E6%B2%B9%E5%A6%82%E4%BD%95%E7%A9%BF%E8%BF%87-80-%E5%85%AC%E9%87%8C%E7%9A%84%E6%B2%99%E6%BC%A0">7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？</a></li>
<li><a href="#8-%E7%83%A7%E4%B8%80%E6%A0%B9%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E7%BB%B3%E8%A6%81%E7%94%A8%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%A6%82%E4%BD%95%E7%94%A8%E5%AE%83%E6%9D%A5%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%8D%81%E4%BA%94%E5%88%86%E9%92%9F">8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？</a></li>
<li><a href="#9-%E6%9C%897%E5%85%8B2%E5%85%8B%E7%A0%9D%E7%A0%81%E5%90%84%E4%B8%80%E4%B8%AA%E5%A4%A9%E5%B9%B3%E4%B8%80%E5%8F%AA%E5%A6%82%E4%BD%95%E5%8F%AA%E7%94%A8%E8%BF%99%E4%BA%9B%E7%89%A9%E5%93%81%E4%B8%89%E6%AC%A1%E5%B0%86140%E5%85%8B%E7%9A%84%E7%9B%90%E5%88%86%E6%88%905090%E5%85%8B%E5%90%84%E4%B8%80%E4%BB%BD">9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？</a></li>
<li><a href="#10-%E6%9C%89%E4%B8%80%E8%BE%86%E7%81%AB%E8%BD%A6%E4%BB%A5%E6%AF%8F%E5%B0%8F%E6%97%B615%E5%85%AC%E9%87%8C%E7%9A%84%E9%80%9F%E5%BA%A6%E7%A6%BB%E5%BC%80%E6%B4%9B%E6%9D%89%E7%9F%B6%E7%9B%B4%E5%A5%94%E7%BA%BD%E7%BA%A6%E5%8F%A6%E4%B8%80%E8%BE%86%E7%81%AB%E8%BD%A6%E4%BB%A5%E7%AC%AC%E5%B0%8F%E6%97%B620%E5%85%AC%E9%87%8C%E7%9A%84%E9%80%9F%E5%BA%A6%E4%BB%8E%E7%BA%BD%E7%BA%A6%E5%BC%80%E5%BE%80%E6%B4%9B%E6%9D%89%E7%9F%B6%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E5%8F%AA%E9%B8%9F%E4%BB%A5%E5%A4%9630%E5%85%AC%E9%87%8C%E6%AF%8F%E5%B0%8F%E6%97%B6%E7%9A%84%E9%80%9F%E5%BA%A6%E5%92%8C%E4%B8%A4%E8%BE%86%E7%81%AB%E8%BD%A6%E7%8E%B0%E6%97%B6%E5%90%AF%E5%8A%A8%E4%BB%8E%E6%B4%9B%E6%9D%89%E7%9F%B6%E5%87%BA%E5%8F%91%E7%A2%B0%E5%88%B0%E5%8F%A6%E8%BE%86%E8%BD%A6%E5%90%8E%E8%BF%94%E5%9B%9E%E4%BE%9D%E6%AC%A1%E5%9C%A8%E4%B8%A4%E8%BE%86%E7%81%AB%E8%BD%A6%E6%9D%A5%E5%9B%9E%E7%9A%84%E9%A3%9E%E8%A1%8C%E7%9B%B4%E9%81%93%E4%B8%A4%E9%9D%A2%E8%BE%86%E7%81%AB%E8%BD%A6%E7%9B%B8%E9%81%87%E8%AF%B7%E9%97%AE%E8%BF%99%E5%8F%AA%E5%B0%8F%E9%B8%9F%E9%A3%9E%E8%A1%8C%E4%BA%86%E5%A4%9A%E9%95%BF%E8%B7%9D%E7%A6%BB">10. 火车相对而行，小鸟飞行距离问题 </a></li>
<li><a href="#11-%E4%BD%A0%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%BD%90%E5%AD%9050%E4%B8%AA%E7%BA%A2%E8%89%B2%E5%BC%B9%E7%90%8350%E4%B8%AA%E8%93%9D%E8%89%B2%E5%BC%B9%E7%90%83%E9%9A%8F%E6%9C%BA%E9%80%89%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BD%90%E5%AD%90%E9%9A%8F%E6%9C%BA%E9%80%89%E5%8F%96%E5%87%BA%E4%B8%80%E4%B8%AA%E5%BC%B9%E7%90%83%E6%94%BE%E5%85%A5%E7%BD%90%E5%AD%90%E6%80%8E%E4%B9%88%E7%BB%99%E7%BA%A2%E8%89%B2%E5%BC%B9%E7%90%83%E6%9C%80%E5%A4%A7%E7%9A%84%E9%80%89%E4%B8%AD%E6%9C%BA%E4%BC%9A%E5%9C%A8%E4%BD%A0%E7%9A%84%E8%AE%A1%E5%88%92%E4%B8%AD%E5%BE%97%E5%88%B0%E7%BA%A2%E7%90%83%E7%9A%84%E5%87%86%E7%A1%AE%E5%87%A0%E7%8E%87%E6%98%AF%E5%A4%9A%E5%B0%91">11. 弹球拾取几率问题</a></li>
<li><a href="#12-%E5%81%87%E8%AE%BE%E4%BD%A0%E6%9C%898%E4%B8%AA%E7%90%83%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%95%A5%E5%BE%AE%E9%87%8D%E4%B8%80%E4%BA%9B%E4%BD%86%E6%98%AF%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AA%E7%90%83%E7%9A%84%E6%83%9F%E4%B8%80%E6%96%B9%E6%B3%95%E6%98%AF%E5%B0%86%E4%B8%A4%E4%B8%AA%E7%90%83%E6%94%BE%E5%9C%A8%E5%A4%A9%E5%B9%B3%E4%B8%8A%E5%AF%B9%E6%AF%94%E6%9C%80%E5%B0%91%E8%A6%81%E7%A7%B0%E5%A4%9A%E5%B0%91%E6%AC%A1%E6%89%8D%E8%83%BD%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AA%E8%BE%83%E9%87%8D%E7%9A%84%E7%90%83">12. 8个球使用天平称重问题</a></li>
<li><a href="#13-%E5%9C%A8%E6%88%BF%E9%87%8C%E6%9C%89%E4%B8%89%E7%9B%8F%E7%81%AF%E6%88%BF%E5%A4%96%E6%9C%89%E4%B8%89%E4%B8%AA%E5%BC%80%E5%85%B3%E5%9C%A8%E6%88%BF%E5%A4%96%E7%9C%8B%E4%B8%8D%E8%A7%81%E6%88%BF%E5%86%85%E7%9A%84%E6%83%85%E5%86%B5%E4%BD%A0%E5%8F%AA%E8%83%BD%E8%BF%9B%E9%97%A8%E4%B8%80%E6%AC%A1%E4%BD%A0%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E6%9D%A5%E5%8C%BA%E5%88%86%E9%82%A3%E4%B8%AA%E5%BC%80%E5%85%B3%E6%8E%A7%E5%88%B6%E9%82%A3%E4%B8%80%E7%9B%8F%E7%81%AF">13. 三盏灯区分开关问题</a></li>
<li><a href="#14-%E4%BB%96%E4%BB%AC%E9%83%BD%E5%90%84%E8%87%AA%E4%B9%B0%E4%BA%86%E4%B8%A4%E5%AF%B9%E9%BB%91%E8%A2%9C%E5%92%8C%E4%B8%A4%E5%AF%B9%E7%99%BD%E8%A2%9C%E5%85%AB%E5%AF%B9%E8%A2%9C%E5%AD%90%E7%9A%84%E5%B8%83%E8%B4%A8%E5%A4%A7%E5%B0%8F%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C%E8%80%8C%E6%AF%8F%E5%AF%B9%E8%A2%9C%E5%AD%90%E9%83%BD%E6%9C%89%E4%B8%80%E5%BC%A0%E5%95%86%E6%A0%87%E7%BA%B8%E8%BF%9E%E7%9D%80%E4%B8%A4%E4%BD%8D%E7%9B%B2%E4%BA%BA%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%B0%86%E5%85%AB%E5%AF%B9%E8%A2%9C%E5%AD%90%E6%B7%B7%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BB%96%E4%BB%AC%E6%AF%8F%E4%BA%BA%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%8F%96%E5%9B%9E%E9%BB%91%E8%A2%9C%E5%92%8C%E7%99%BD%E8%A2%9C%E5%90%84%E4%B8%A4%E5%AF%B9%E5%91%A2">14. 盲人黑白袜子问题</a></li>
<li><a href="#15-%E6%9C%89%E4%B8%89%E7%AD%90%E6%B0%B4%E6%9E%9C%E4%B8%80%E7%AD%90%E8%A3%85%E7%9A%84%E5%85%A8%E6%98%AF%E8%8B%B9%E6%9E%9C%E7%AC%AC%E4%BA%8C%E7%AD%90%E8%A3%85%E7%9A%84%E5%85%A8%E6%98%AF%E6%A9%98%E5%AD%90%E7%AC%AC%E4%B8%89%E7%AD%90%E6%98%AF%E6%A9%98%E5%AD%90%E4%B8%8E%E8%8B%B9%E6%9E%9C%E6%B7%B7%E5%9C%A8%E4%B8%80%E8%B5%B7%E7%AD%90%E4%B8%8A%E7%9A%84%E6%A0%87%E7%AD%BE%E9%83%BD%E6%98%AF%E9%AA%97%E4%BA%BA%E7%9A%84%E5%B0%B1%E6%98%AF%E8%AF%B4%E7%AD%90%E4%B8%8A%E7%9A%84%E6%A0%87%E7%AD%BE%E9%83%BD%E6%98%AF%E9%94%99%E7%9A%84%E4%BD%A0%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%98%AF%E6%8B%BF%E5%87%BA%E5%85%B6%E4%B8%AD%E4%B8%80%E7%AD%90%E4%BB%8E%E9%87%8C%E9%9D%A2%E5%8F%AA%E6%8B%BF%E4%B8%80%E5%8F%AA%E6%B0%B4%E6%9E%9C%E7%84%B6%E5%90%8E%E6%AD%A3%E7%A1%AE%E5%86%99%E5%87%BA%E4%B8%89%E7%AD%90%E6%B0%B4%E6%9E%9C%E7%9A%84%E6%A0%87%E7%AD%BE">15. 水果标签问题</a></li>
<li><a href="#16-%E4%B8%80%E4%B8%AA%E7%8F%AD%E7%BA%A760%E5%96%9C%E6%AC%A2%E8%B6%B3%E7%90%8370%E5%96%9C%E6%AC%A2%E7%AF%AE%E7%90%8380%E5%96%9C%E6%AC%A2%E6%8E%92%E7%90%83%E9%97%AE%E5%8D%B3%E4%B8%89%E7%A7%8D%E7%90%83%E9%83%BD%E5%96%9C%E6%AC%A2%E5%8D%A0%E6%AF%94%E6%9C%89%E5%A4%9A%E5%B0%91">16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？</a></li>
<li><a href="#17-%E4%BA%94%E5%8F%AA%E9%B8%A1%E4%BA%94%E5%A4%A9%E8%83%BD%E4%B8%8B%E4%BA%94%E4%B8%AA%E8%9B%8B%E4%B8%80%E7%99%BE%E5%A4%A9%E4%B8%8B%E4%B8%80%E7%99%BE%E4%B8%AA%E8%9B%8B%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E5%8F%AA%E9%B8%A1">17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？</a></li>
</ul>
</li>
<li><a href="#%E5%89%91%E6%8C%87-offer-%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93">剑指 offer 思路总结</a><ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a><ul>
<li><a href="#1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">1. 二维数组中的查找</a></li>
<li><a href="#2-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC">2. 替换空格</a></li>
<li><a href="#3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">3. 从尾到头打印链表</a></li>
<li><a href="#4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">4. 重建二叉树</a></li>
<li><a href="#5-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">5. 用两个栈实现队列</a></li>
<li><a href="#6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97">6. 旋转数组的最小数字</a></li>
<li><a href="#7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">7. 斐波那契数列</a></li>
<li><a href="#8-%E8%B7%B3%E5%8F%B0%E9%98%B6">8. 跳台阶</a></li>
<li><a href="#9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6">9. 变态跳台阶</a></li>
<li><a href="#10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96">10. 矩形覆盖</a></li>
<li><a href="#11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0">11. 二进制中1的个数</a></li>
<li><a href="#12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9">12. 数值的整数次方</a></li>
<li><a href="#13-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2">13. 调整数组顺序使奇数位于偶数前面</a></li>
<li><a href="#14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9">14. 链表中倒数第 k 个节点</a></li>
<li><a href="#15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">15. 反转链表</a></li>
<li><a href="#16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">16. 合并两个排序的链表</a></li>
<li><a href="#17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">17. 树的子结构</a></li>
<li><a href="#18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F">18. 二叉树的镜像</a></li>
<li><a href="#19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5">19. 顺时针打印矩阵</a></li>
<li><a href="#20-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0-min-%E5%87%BD%E6%95%B0">20. 定义一个栈，实现 min 函数</a></li>
<li><a href="#21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA">21. 栈的压入弹出</a></li>
<li><a href="#22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">22. 从上往下打印二叉树</a></li>
<li><a href="#23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">23. 二叉搜索树的后序遍历</a></li>
<li><a href="#24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E8%B7%AF%E5%BE%84">24. 二叉树中和为某一值路径</a></li>
<li><a href="#25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">25. 复杂链表的复制</a></li>
<li><a href="#26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">26. 二叉搜索树与双向链表</a></li>
<li><a href="#27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97">27. 字符串的排列</a></li>
<li><a href="#28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97">28. 数组中出现次数超过一半的数字</a></li>
<li><a href="#29-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0">29. 最小的 K 个数</a></li>
<li><a href="#30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">30. 连续子数组的最大和</a></li>
<li><a href="#31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">31. 整数中1出现的次数（待深入理解）</a></li>
<li><a href="#32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0">32. 把数组排成最小的数</a></li>
<li><a href="#33-%E4%B8%91%E6%95%B0%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">33. 丑数（待深入理解）</a></li>
<li><a href="#34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6">34. 第一个只出现一次的字符</a></li>
<li><a href="#35-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9">35. 数组中的逆序对</a></li>
<li><a href="#36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9">36. 两个链表的第一个公共结点</a></li>
<li><a href="#37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">37. 数字在排序数组中出现的次数</a></li>
<li><a href="#38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">38. 二叉树的深度</a></li>
<li><a href="#39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">39. 平衡二叉树</a></li>
<li><a href="#40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97">40. 数组中只出现一次的数字</a></li>
<li><a href="#41-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97">41. 和为 S 的连续正数序列</a></li>
<li><a href="#42-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97">42. 和为 S 的两个数字</a></li>
<li><a href="#43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">43. 左旋转字符串</a></li>
<li><a href="#44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97">44. 翻转单词顺序列</a></li>
<li><a href="#45-%E6%89%91%E5%85%8B%E7%89%8C%E7%9A%84%E9%A1%BA%E5%AD%90">45. 扑克牌的顺子</a></li>
<li><a href="#46-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98">46. 圆圈中最后剩下的数字（约瑟夫环问题）</a></li>
<li><a href="#47-123n">47. 1 2 3 … n</a></li>
<li><a href="#48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95">48. 不用加减乘除做加法</a></li>
<li><a href="#49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0">49. 把字符串转换成整数。</a></li>
<li><a href="#50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">50. 数组中重复的数字</a></li>
<li><a href="#51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84">51. 构建乘积数组</a></li>
<li><a href="#52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D">52. 正则表达式的匹配</a></li>
<li><a href="#53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">53. 表示数值的字符串</a></li>
<li><a href="#54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6">54. 字符流中第一个不重复的字符</a></li>
<li><a href="#55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9">55. 链表中环的入口结点</a></li>
<li><a href="#56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9">56. 删除链表中重复的结点</a></li>
<li><a href="#57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9">57. 二叉树的下一个结点</a></li>
<li><a href="#58-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">58. 对称二叉树</a></li>
<li><a href="#59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">59. 按之字形顺序打印二叉树（待深入理解）</a></li>
<li><a href="#60-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8C%E4%B8%80%E5%B1%82%E7%BB%93%E7%82%B9%E4%BB%8E%E5%B7%A6%E8%87%B3%E5%8F%B3%E8%BE%93%E5%87%BA%E6%AF%8F%E4%B8%80%E5%B1%82%E8%BE%93%E5%87%BA%E4%B8%80%E8%A1%8C">60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</a></li>
<li><a href="#61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">61. 序列化二叉树（待深入理解）</a></li>
<li><a href="#62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9">62. 二叉搜索树的第 K 个节点</a></li>
<li><a href="#63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">63. 数据流中的中位数（待深入理解）</a></li>
<li><a href="#64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">64. 滑动窗口中的最大值（待深入理解）</a></li>
<li><a href="#65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">65. 矩阵中的路径（待深入理解）</a></li>
<li><a href="#66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E5%BE%85%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">66. 机器人的运动范围（待深入理解）</a></li>
</ul>
</li>
<li><a href="#%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98">相关算法题</a><ul>
<li><a href="#1-%E6%98%8E%E6%98%9F%E9%97%AE%E9%A2%98">1. 明星问题</a></li>
<li><a href="#2-%E6%AD%A3%E8%B4%9F%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C">2. 正负数组求和</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="常用算法和数据结构总结"><a href="#常用算法和数据结构总结" class="headerlink" title="常用算法和数据结构总结"></a>常用算法和数据结构总结</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，<br>最终达到完全有序。</p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) || arr.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> lastIndex = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lastIndex &gt; <span class="number">0</span>) &#123; <span class="comment">// 当最后一个交换的元素为第一个时，说明后面全部排序完毕</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">true</span>, k = lastIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">              	lastIndex = j; <span class="comment">// 设置最后一次交换元素的位置</span></span><br><span class="line">                [arr[j], arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>], arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>冒泡排序有两种优化方式。</p>
<p>一种是外层循环的优化，我们可以记录当前循环中是否发生了交换，如果没有发生交换，则说明该序列已经为有序序列了。<br>因此我们不需要再执行之后的外层循环，此时可以直接结束。</p>
<p>一种是内层循环的优化，我们可以记录当前循环中最后一次元素交换的位置，该位置以后的序列都是已排好的序列，因此下<br>一轮循环中无需再去比较。</p>
<p>优化后的冒泡排序，当排序序列为已排序序列时，为最好的时间复杂度为 O(n)。</p>
<p>冒泡排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。</p>
<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a><br><a href="http://bubkoo.com/2014/01/15/sort-algorithm/shaker-sort/">《常见排序算法 - 鸡尾酒排序 》</a><br><a href="https://juejin.im/post/5b72f0caf265da282809f3b5#heading-1">《前端笔试&amp;面试爬坑系列—算法》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc724af265da610f632e41">《前端面试之道》</a></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。</p>
<p>在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。其实<br>我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。我们可以通过设置一个变量 min，每一次比较<br>仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。</p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> minIndex = i; <span class="comment">// 设置当前循环最小元素索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前元素比最小元素索引，则更新最小元素索引</span></span><br><span class="line">      <span class="keyword">if</span> (array[minIndex] &gt; array[j]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换最小元素到当前位置</span></span><br><span class="line">    <span class="comment">// [array[i], array[minIndex]] = [array[minIndex], array[i]];</span></span><br><span class="line">    <span class="title function_">swap</span>(array, i, minIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数组中两个元素的位置</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">array, left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> temp = array[left];</span><br><span class="line">  array[left] = array[right];</span><br><span class="line">  array[right] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择排序不管初始序列是否有序，时间复杂度都为 O(n²)。</p>
<p>选择排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，不是稳定排序。</p>
<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</p>
<p>插入排序核心–扑克牌思想： 就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，<br>继续接，可能是中间数，就插在中间….依次</p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环从 1 开始，0 位置为默认的已排序的序列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = array[i]; <span class="comment">// 保存当前需要排序的元素</span></span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在当前已排序序列中比较，如果比需要排序的元素大，就依次往后移动位置</span></span><br><span class="line">    <span class="keyword">while</span> (j -<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">      array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将找到的位置插入元素</span></span><br><span class="line">    array[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当排序序列为已排序序列时，为最好的时间复杂度 O(n)。</p>
<p>插入排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。</p>
<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a></p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序的基本思想是把数组按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元<br>素越来越多，当增量减至1时，整个数组恰被分成一组，算法便终止。</p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hillSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一层确定增量的大小，每次增量的大小减半</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> gap = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>); gap &gt;= <span class="number">1</span>; gap = <span class="built_in">parseInt</span>(gap &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个分组使用插入排序，相当于将插入排序的1换成了 n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = array[i];</span><br><span class="line">      <span class="keyword">let</span> j = i;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; array[j - gap] &gt; temp) &#123;</span><br><span class="line">        array[j] = array[j - gap];</span><br><span class="line">        j -= gap;</span><br><span class="line">      &#125;</span><br><span class="line">      array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希尔排序是利用了插入排序对于已排序序列排序效果最好的特点，在一开始序列为无序序列时，将序列分为多个小的分组进行<br>基数排序，由于排序基数小，每次基数排序的效果较好，然后在逐步增大增量，将分组的大小增大，由于每一次都是基于上一<br>次排序后的结果，所以每一次都可以看做是一个基本排序的序列，所以能够最大化插入排序的优点。</p>
<p>简单来说就是，由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，<br>所以排序速度也很快。</p>
<p>希尔排序的时间复杂度根据选择的增量序列不同而不同，但总的来说时间复杂度是小于 O(n^2) 的。</p>
<p>插入排序是一个稳定排序，但是在希尔排序中，由于相同的元素可能在不同的分组中，所以可能会造成相同元素位置的变化，<br>所以希尔排序是一个不稳定的排序。</p>
<p>希尔排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n^s) ，空间复杂度为 O(1) ，不是稳定排序。</p>
<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">《图解排序算法(二)之希尔排序》</a><br><a href="https://blog.csdn.net/u013630349/article/details/48250109">《数据结构基础 希尔排序 之 算法复杂度浅析》</a></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。递归的将数组两两分开直到只包含一个元素，然后<br>将数组排序合并，最终合并为排序好的数组。</p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于0，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>), <span class="comment">// 找到中间索引值</span></span><br><span class="line">    left = array.<span class="title function_">slice</span>(<span class="number">0</span>, mid), <span class="comment">// 截取左半部分</span></span><br><span class="line">    right = array.<span class="title function_">slice</span>(mid, length); <span class="comment">// 截取右半部分</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right)); <span class="comment">// 递归分解后，进行排序合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">leftArray, rightArray</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = [],</span><br><span class="line">    leftLength = leftArray.<span class="property">length</span>,</span><br><span class="line">    rightLength = rightArray.<span class="property">length</span>,</span><br><span class="line">    il = <span class="number">0</span>,</span><br><span class="line">    ir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 左右两个数组的元素依次比较，将较小的元素加入结果数组中，直到其中一个数组的元素全部加入完则停止</span></span><br><span class="line">  <span class="keyword">while</span> (il &lt; leftLength &amp;&amp; ir &lt; rightLength) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftArray[il] &lt; rightArray[ir]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(leftArray[il++]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(rightArray[ir++]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是左边数组还有剩余，则把剩余的元素全部加入到结果数组中。</span></span><br><span class="line">  <span class="keyword">while</span> (il &lt; leftLength) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(leftArray[il++]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是右边数组还有剩余，则把剩余的元素全部加入到结果数组中。</span></span><br><span class="line">  <span class="keyword">while</span> (ir &lt; rightLength) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(rightArray[ir++]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序将整个排序序列看成一个二叉树进行分解，首先将树分解到每一个子节点，树的每一层都是一个归并排序的过程，每<br>一层归并的时间复杂度为 O(n)，因为整个树的高度为 lgn，所以归并排序的时间复杂度不管在什么情况下都为O(nlogn)。</p>
<p>归并排序的空间复杂度取决于递归的深度和用于归并时的临时数组，所以递归的深度为 logn，临时数组的大小为 n，所以归<br>并排序的空间复杂度为 O(n)。</p>
<p>归并排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(n) ，是稳定排序。</p>
<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">《图解排序算法(四)之归并排序》</a><br><a href="https://www.zhihu.com/question/27274006">《归并排序的空间复杂度？》</a></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据<br>都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">array, start, end</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span> || start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="title function_">partition</span>(array, start, end); <span class="comment">// 将数组划分为两部分，并返回右部分的第一个元素的索引值</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">quickSort</span>(array, start, index - <span class="number">1</span>); <span class="comment">// 递归排序左半部分</span></span><br><span class="line">  <span class="title function_">quickSort</span>(array, index + <span class="number">1</span>, end); <span class="comment">// 递归排序右半部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">array, start, end</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pivot = array[start]; <span class="comment">// 取第一个值为枢纽值，获取枢纽值的大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 start 等于 end 指针时结束循环</span></span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 end 指针指向的值大等于枢纽值时，end 指针向前移动</span></span><br><span class="line">    <span class="keyword">while</span> (array[end] &gt;= pivot &amp;&amp; start &lt; end) &#123;</span><br><span class="line">      end--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将比枢纽值小的值交换到 start 位置</span></span><br><span class="line">    array[start] = array[end];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动 start 值，当 start 指针指向的值小于枢纽值时，start 指针向后移动</span></span><br><span class="line">    <span class="keyword">while</span> (array[start] &lt; pivot &amp;&amp; start &lt; end) &#123;</span><br><span class="line">      start++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将比枢纽值大的值交换到 end 位置，进入下一次循环</span></span><br><span class="line">    array[end] = array[start];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将枢纽值交换到中间点</span></span><br><span class="line">  array[start] = pivot;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回中间索引值</span></span><br><span class="line">  <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一种方法是填空法，首先将第一个位置的数作为枢纽值，然后 end 指针向前移动，当遇到比枢纽值小的值或者 end 值<br>等于 start 值的时候停止，然后将这个值填入 start 的位置，然后 start 指针向后移动，当遇到比枢纽值大的值或者<br>start 值等于 end 值的时候停止，然后将这个值填入 end 的位置。反复循环这个过程，直到 start 的值等于 end 的<br>值为止。将一开始保留的枢纽值填入这个位置，此时枢纽值左边的值都比枢纽值小，枢纽值右边的值都比枢纽值大。然后在递<br>归左右两边的的序列。</p>
<p>当每次换分的结果为含 ⌊n/2⌋和 ⌈n/2⌉−1 个元素时，最好情况发生，此时递归的次数为 logn，然后每次划分的时间复杂<br>度为 O(n)，所以最优的时间复杂度为 O(nlogn)。一般来说只要每次换分都是常比例的划分，时间复杂度都为 O(nlogn)。</p>
<p>当每次换分的结果为 n-1 和 0 个元素时，最坏情况发生。划分操作的时间复杂度为 O(n)，递归的次数为 n-1，所以最坏<br>的时间复杂度为 O(n²)。所以当排序序列有序的时候，快速排序有可能被转换为冒泡排序。</p>
<p>快速排序的空间复杂度取决于递归的深度，所以最好的时候为 O(logn)，最坏的时候为 O(n)。</p>
<p>快速排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(logn) ，不是稳定排序。</p>
<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6262208.html">《图解排序算法(五)之快速排序——三数取中法》</a><br><a href="https://segmentfault.com/a/1190000004410119#articleHeader2">《关于快速排序的四种写法》</a><br><a href="https://harttle.land/2015/09/27/quick-sort.html">《快速排序的时间和空间复杂度》</a><br><a href="https://blog.csdn.net/weshjiness/article/details/8660583">《快速排序最好，最坏，平均复杂度分析》</a><br><a href="https://blog.csdn.net/qq_33758761/article/details/76782610">《快速排序算法的递归深度》</a></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行<br>交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，<br>便能得到一个有序序列了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">heapSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">buildMaxHeap</span>(array); <span class="comment">// 将传入的数组建立为大顶堆</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次循环，将最大的元素与末尾元素交换，然后剩下的元素重新构建为大顶堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">swap</span>(array, <span class="number">0</span>, i);</span><br><span class="line">    <span class="title function_">adjustMaxHeap</span>(array, <span class="number">0</span>, i); <span class="comment">// 将剩下的元素重新构建为大顶堆</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">adjustMaxHeap</span>(<span class="params">array, index, heapSize</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> iMax,</span><br><span class="line">    iLeft,</span><br><span class="line">    iRight;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    iMax = index; <span class="comment">// 保存最大值的索引</span></span><br><span class="line">    iLeft = <span class="number">2</span> * index + <span class="number">1</span>; <span class="comment">// 获取左子元素的索引</span></span><br><span class="line">    iRight = <span class="number">2</span> * index + <span class="number">2</span>; <span class="comment">// 获取右子元素的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子元素存在，且左子元素大于最大值，则更新最大值索引</span></span><br><span class="line">    <span class="keyword">if</span> (iLeft &lt; heapSize &amp;&amp; array[iMax] &lt; array[iLeft]) &#123;</span><br><span class="line">      iMax = iLeft;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子元素存在，且右子元素大于最大值，则更新最大值索引</span></span><br><span class="line">    <span class="keyword">if</span> (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123;</span><br><span class="line">      iMax = iRight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大元素被更新了，则交换位置，使父节点大于它的子节点，同时将索引值跟新为被替换的值，继续检查它的子树</span></span><br><span class="line">    <span class="keyword">if</span> (iMax !== index) &#123;</span><br><span class="line">      <span class="title function_">swap</span>(array, index, iMax);</span><br><span class="line">      index = iMax;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果未被更新，说明该子树满足大顶堆的要求，退出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建大顶堆</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildMaxHeap</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>,</span><br><span class="line">    iParent = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; <span class="comment">// 获取最后一个非叶子点的元素</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = iParent; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">adjustMaxHeap</span>(array, i, length); <span class="comment">// 循环调整每一个子树，使其满足大顶堆的要求</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数组中两个元素的位置</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">array, i, j</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = array[i];</span><br><span class="line">  array[i] = array[j];</span><br><span class="line">  array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立堆的时间复杂度为 O(n)，排序循环的次数为 n-1，每次调整堆的时间复杂度为 O(logn)，因此堆排序的时间复杂度在<br>不管什么情况下都是 O(nlogn)。</p>
<p>堆排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(1) ，不是稳定排序。</p>
<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">《图解排序算法(三)之堆排序》</a><br><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/">《常见排序算法 - 堆排序 (Heap Sort)》</a><br><a href="https://www.zhihu.com/question/20729324">《堆排序中建堆过程时间复杂度O(n)怎么来的？》</a><br><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44258297">《排序算法之 堆排序 及其时间复杂度和空间复杂度》</a><br><a href="https://blog.csdn.net/hrn1216/article/details/51465270">《最小堆 构建、插入、删除的过程图解》</a></p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程：将<br>所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样<br>从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">radixSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 </span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> bucket = [],</span><br><span class="line">    max = array[<span class="number">0</span>],</span><br><span class="line">    loop;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定排序数组中的最大值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">      max = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定最大值的位数</span></span><br><span class="line">  loop = (max + <span class="string">&#x27;&#x27;</span>).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化桶</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    bucket[i] = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> str = array[j] + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (str.<span class="property">length</span> &gt;= i + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> k = <span class="built_in">parseInt</span>(str[str.<span class="property">length</span> - <span class="number">1</span> - i]); <span class="comment">// 获取当前位的值，作为插入的索引</span></span><br><span class="line">        bucket[k].<span class="title function_">push</span>(array[j]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理位数不够的情况，高位默认为 0</span></span><br><span class="line">        bucket[<span class="number">0</span>].<span class="title function_">push</span>(array[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array.<span class="title function_">splice</span>(<span class="number">0</span>, length); <span class="comment">// 清空旧的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用桶重新初始化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> t = bucket[i].<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">        array.<span class="title function_">push</span>(bucket[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      bucket[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基数排序的平均时间复杂度为 O(nk)，k 为最大元素的长度，最坏时间复杂度为 O(nk)，空间复杂度为 O(n) ，是稳定<br>排序。</p>
<p>详细资料可以参考：<br><a href="http://bubkoo.com/2014/01/15/sort-algorithm/radix-sort/">《常见排序算法 - 基数排序》</a><br><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44594415">《排序算法之 基数排序 及其时间复杂度和空间复杂度》</a></p>
<p>算法总结可以参考：<br><a href="https://blog.csdn.net/zolalad/article/details/11848739">《算法的时间复杂度和空间复杂度-总结》</a><br><a href="https://www.cnblogs.com/onepixel/p/7674659.html">《十大经典排序算法（动图演示）》</a><br><a href="https://blog.csdn.net/wangiijing/article/details/51485119">《各类排序算法的对比及实现》</a></p>
<h3 id="快速排序相对于其他排序效率更高的原因"><a href="#快速排序相对于其他排序效率更高的原因" class="headerlink" title="快速排序相对于其他排序效率更高的原因"></a>快速排序相对于其他排序效率更高的原因</h3><p>上面一共提到了8种排序的方法，在实际使用中，应用最广泛的是快速排序。快速排序相对于其他排序算法的优势在于在相同<br>数据量的情况下，它的运算效率最高，并且它额外所需空间最小。</p>
<p>我们首先从时间复杂度来判断，由于前面几种方法的时间复杂度平均情况下基本趋向于 O(n²)，因此只从时间复杂度上来看<br>的话，显然归并排序、堆排序和快速排序的时间复杂度最小。但是既然这几种方法的时间复杂度基本一致，并且快速排序在最<br>坏情况下时间的复杂度还会变为 O(n²)，那么为什么它的效率反而更高呢？</p>
<p>首先在对大数据量排序的时候，由于归并排序的空间复杂度为 O(n)，因此归并排序在这种情况下会需要过多的额外内存，因<br>此归并排序首先就被排除掉了。</p>
<p>接下来就剩下了堆排序和快速排序的比较。我认为堆排序相对于快速排序的效率不高的原因有两个方面。</p>
<p>第一个方面是对于比较操作的有效性来说。对于快速排序来说，每一次元素的比较都会确定该元素在数组中的位置，也就是在<br>枢纽值的左边或者右边，快速排序的每一次比较操作都是有意义的结果。而对于堆排序来说，在每一次重新调整堆的时候，我<br>们在迭代时，已经知道上层的节点值一定比下层的节点值大，因此当我们每次为了打乱堆结构而将最后一个元素与堆顶元素互<br>换时，互换后的元素一定是比下层元素小的，因此我们知道比较结果却还要在堆结构调整时去进行再一次的比较，这样的比较<br>是没有意义的，以此在堆排序中会产生大量的没有意义的比较操作。</p>
<p>第二个方面是对于缓存局部性原理的利用上来考虑的，我认为这应该是造成堆排序的效率不如快速排序的主要原因。在计算机<br>中利用了多级缓存的机制，来解决 cpu 计算速度与存储器数据读取速度间差距过大的问题。缓存的原理主要是基于局部性原<br>理，局部性原理简单来说就是，当前被访问过的数据，很有可能在一段时间内被再次访问，这被称为时间局部性。还有就是当<br>前访问的数据，那么它相邻的数据，也有可能在一段时间内被访问到，这被称为空间局部性。计算机缓存利用了局部性的原理<br>来对数据进行缓存，来尽可能少的减少磁盘的 I/O 次数，以此来提高执行效率。对于堆排序来说，它最大的问题就是它对于<br>空间局部性的违背，它在进行比较时，比较的并不是相邻的元素，而是与自己相隔很远的元素，这对于利用空间局部性来进行<br>数据缓存的计算机来说，它的很多缓存都是无效的。并且对于大数据量的排序来说，缓存的命中率就会变得很低，因此会明显<br>提高磁盘的 I/O 次数，并且由于堆排序的大量的无效比较，因此这样就造成了堆排序执行效率的低下。而相对来快速排序来<br>说，它的排序每一次都是在相邻范围内的比较，并且比较的范围越来越小，它很好的利用了局部性原理，因此它的执行效率更<br>高。简单来说就是在堆排序中获取一个元素的值所花费的时间比在快速排序获取一个元素的值所花费的时间要大。因此我们可<br>以看出，时间复杂度类似的算法，在计算机中实际执行可能会有很大的差别，因为决定算法执行效率的还有内存读取这样的其<br>他的因素。</p>
<p>相关资料可以参考：<br><a href="https://www.zhihu.com/question/23873747">《为什么在平均情况下快速排序比堆排序要优秀？》</a><br><a href="https://blog.csdn.net/qq_36770641/article/details/82669788">《为什么说快速排序是性能最好的排序算法？》</a></p>
<h3 id="系统自带排序实现"><a href="#系统自带排序实现" class="headerlink" title="系统自带排序实现"></a>系统自带排序实现</h3><p>每个语言的排序内部实现都是不同的。</p>
<p>对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据<br>量很小的情况下和 O(N * logN) 相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定性的意思就是对于相同值来说，相对顺序不能改变。通俗的讲有两个相同的数 A 和 B，在排序之前 A 在 B 的前面，<br>而经过排序之后，B 跑到了 A 的前面，对于这种情况的发生，我们管他叫做排序的不稳定性。</p>
<p>稳定性有什么意义？个人理解对于前端来说，比如我们熟知框架中的虚拟 DOM 的比较，我们对一个<code>&lt;ul&gt;</code>列表进行渲染，<br>当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。</p>
<h3 id="排序面试题目总结"><a href="#排序面试题目总结" class="headerlink" title="排序面试题目总结"></a>排序面试题目总结</h3><ol>
<li><p>快速排序在完全无序的情况下效果最好，时间复杂度为O(nlogn)，在有序情况下效果最差，时间复杂度为O(n^2)。</p>
</li>
<li><p>初始数据集的排列顺序对算法的性能无影响的有堆排序，直接选择排序，归并排序，基数排序。</p>
</li>
<li><p>合并 m 个长度为 n 的已排序数组的时间复杂度为 O(nmlogm)。</p>
</li>
<li><p>外部排序常用的算法是归并排序。</p>
</li>
<li><p>数组元素基本有序的情况下，插入排序效果最好，因为这样只需要比较大小，不需要移动，时间复杂度趋近于O(n)。</p>
</li>
<li><p>如果只想得到1000个元素组成的序列中第5个最小元素之前的部分排序的序列，用堆排序方法最快。</p>
</li>
<li><p>插入排序和优化后的冒泡在最优情况（有序）都只用比较 n-1 次。</p>
</li>
<li><p>对长度为 n 的线性表作快速排序，在最坏情况下，比较次数为 n(n-1)/2。</p>
</li>
<li><p>下标从1开始，在含有 n 个关键字的小根堆（堆顶元素最小）中，关键字最大的记录有可能存储在 [n/2]+2 位置上。<br>因为小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于 [n/2]。</p>
</li>
<li><p>拓扑排序的算法，每次都选择入度为0的结点从图中删去，并从图中删除该顶点和所有以它为起点的有向边。</p>
</li>
<li><p>任何一个基于”比较”的内部排序的算法，若对 n 个元素进行排序，则在最坏情况下所需的比较次数 k 满足 2^k &gt; n!，<br>时间下界为 O(nlogn)</p>
</li>
<li><p>m 个元素 k 路归并的归并趟数 s=logk(m)，代入数据：logk(100)≦3</p>
</li>
<li><p>对 n 个记录的线性表进行快速排序为减少算法的递归深度，每次分区后，先处理较短的部分。</p>
</li>
<li><p>在用邻接表表示图时，拓扑排序算法时间复杂度为 O(n+e)</p>
</li>
</ol>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树相关性质"><a href="#二叉树相关性质" class="headerlink" title="二叉树相关性质"></a>二叉树相关性质</h3><ol>
<li><p>节点的度：一个节点含有的子树的个数称为该节点的度；</p>
</li>
<li><p>叶节点或终端节点：度为零的节点； </p>
</li>
<li><p>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推。 </p>
</li>
<li><p>树的高度或深度：树中节点的最大层次。</p>
</li>
<li><p>在非空二叉树中，第 i 层的结点总数不超过 2^(i-1)，i&gt;=1。 </p>
</li>
<li><p>深度为 h 的二叉树最多有 2^h-1个结点(h&gt;=1)，最少有 h 个结点。</p>
</li>
<li><p>对于任意一棵二叉树，如果其叶结点数为 N0，而度数为2的结点总数为 N2，则 N0 = N2+1； </p>
</li>
<li><p>给定 N 个节点，能构成 h(N) 种不同的二叉树。h(N)为卡特兰数的第 N 项。(2n)!/(n!(n+1)!)。</p>
</li>
<li><p>二叉树的前序遍历，首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。 </p>
</li>
<li><p>二叉树的中序遍历，首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。 </p>
</li>
<li><p>二叉树的后序遍历，首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根。</p>
</li>
<li><p>二叉树是非线性数据结构，但是顺序存储结构和链式存储结构都能存储。</p>
</li>
<li><p>一个带权的无向连通图的最小生成树的权值之和是唯一的。</p>
</li>
<li><p>只有一个结点的二叉树的度为 0 。</p>
</li>
<li><p>二叉树的度是以节点的最大的度数定义的。</p>
</li>
<li><p>树的后序遍历序列等同于该树对应的二叉树的中序序列。</p>
</li>
<li><p>树的先序遍历序列等同于该树对应的二叉树的先序序列。 </p>
</li>
<li><p>线索二叉树的线索实际上指向的是相应遍历序列特定结点的前驱结点和后继结点，所以先写出二叉树的中序遍历序列：<br>debxac，中序遍历中在x左边和右边的字符，就是它在中序线索化的左、右线索，即 b、a 。</p>
</li>
<li><p>递归式的先序遍历一个 n 节点，深度为 d 的二叉树，需要栈空间的大小为 O（d），因为二叉树并不一定是平衡的，<br>也就是深度d！=logn，有可能d&gt;&gt;logn。所以栈大小应该是O（d）</p>
</li>
<li><p>一棵具有 N 个结点的二叉树的前序序列和后序序列正好相反 ，则该二叉树一定满足该二叉树只有左子树或只有右子树，<br>即该二叉树一定是一条链（二叉树的高度为N，高度等于结点数）。</p>
</li>
<li><p>引入二叉线索树的目的是加快查找结点的前驱或后继的速度。</p>
</li>
<li><p>二叉树线索化后，先序线索化与后序线索化最多有1个空指针域，而中序线索化最多有2个空指针域。</p>
</li>
<li><p>不管是几叉树，节点数等于=分叉数+1</p>
</li>
<li><p>任何一棵二叉树的叶子结点在先序、中序和后序遍历中的相对次序不发生改变。</p>
</li>
</ol>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/adminabcd/article/details/46672759">《n 个节点的二叉树有多少种形态》</a><br><a href="https://www.cnblogs.com/guoyaohua/p/8595289.html">《数据结构二叉树知识点总结》</a><br><a href="https://www.jianshu.com/p/2943a21d2a99">《还原二叉树–已知先序中序或者后序中序》</a><br><a href="https://blog.csdn.net/linraise/article/details/11745559">《树、森林与二叉树的转换》</a></p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>对于一棵二叉树，如果每一个非叶子节点都存在左右子树，并且二叉树中所有的叶子节点都在同一层中，这样的二叉树称为满<br>二叉树。</p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>对于一棵具有 n 个节点的二叉树按照层次编号，同时，左右子树按照先左后右编号，如果编号为 i 的节点与同样深度的满<br>二叉树中编号为i的节点在满二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。</p>
<p>性质：</p>
<ol>
<li><p>具有 n 个结点的完全二叉树的深度为 K =[log2n」+1(取下整数) </p>
</li>
<li><p>有 N 个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若 I 为结点编号（从1开始编号）则<br>如果 I&gt;1，则其父结点的编号为 I/2；</p>
</li>
<li><p>完全二叉树，如果 2 * I &lt;= N，则其左儿子（即左子树的根结点）的编号为2 * I；若2 * I &gt; N，则无左儿子；如<br>果 2 * I + 1 &lt;= N，则其右儿子的结点编号为 2 * I + 1；若 2 * I + 1 &gt; N，则无右儿子。</p>
</li>
</ol>
<h3 id="平衡二叉查找树（AVL）"><a href="#平衡二叉查找树（AVL）" class="headerlink" title="平衡二叉查找树（AVL）"></a>平衡二叉查找树（AVL）</h3><p>平衡二叉查找树具有如下几个性质：</p>
<ol>
<li>可以是空树。</li>
<li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过1。</li>
</ol>
<p>平衡二叉树是为了解决二叉查找树中出现链式结构（只有左子树或只有右子树）的情况，这样的情况出现后对我们的查找没有<br>一点帮帮助，反而增加了维护的成本。</p>
<p>平衡因子使用两个字母来表示。第一个字母表示最小不平衡子树根结点的平衡因子，第二个字母表示最小不平衡子树较高子树<br>的根结点的平衡因子。根据不同的情况使用不同的方法来调整失衡的子树。</p>
<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/suimeng/p/4560056.html">《平衡二叉树，AVL树之图解篇》</a></p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树主要用于文件系统以及部分数据库索引，如 MongoDB。使用 B-树来作为数据库的索引主要是为了减少查找是磁盘的 I/O<br>次数。试想，如果我们使用二叉查找树来作为索引，那么查找次数的最坏情况等于二叉查找树的高度，由于索引存储在磁盘中，<br>我们每次都只能加载对应索引的磁盘页进入内存中比较，那么磁盘的 I/O 次数就等于索引树的高度。所以采用一种办法来减少<br>索引树的高度是提高索引效率的关键。</p>
<p>B-树是一种多路平衡查找树，它的每一个节点最多包含 K 个子节点，K 被称为 B-树的阶，K 的大小取决于磁盘页的大小。每<br>个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划。简单来说就是以前一个磁盘页<br>只存储一个索引的值，但 B-树中一个磁盘页中存储了多个索引的值，因此在相同的比较范围内，B-树相对于一般的二叉查找树<br>的高度更小。其实它的主要目的就是每次尽可能多的将索引值加载入内存中进行比较，以此来减少磁盘的 I/O 次数，其实就查<br>找次数而言，和二叉查找树比较差不了多少，只是说这个比较过程是在内存中完成的，速度更快而已。</p>
<p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561220&idx=1&sn=2a6d8a0290f967027b1d54456f586405&chksm=f1feec47c689655113fa65f7911a1f59bbd994030ad685152b30e53d643049f969eefaa13058&scene=21#wechat_redirect">《漫画：什么是 B- 树？》</a></p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B+ 树相对于 B-树有着更好的查找性能，根据 B-树我们可以知道，要想加快索引速度的方法就是尽量减少磁盘 I/O 的次数。<br>B+ 树相对于 B-的主要变化是，每个中间节点中不再包含卫星数据，只有叶子节点包含卫星数据，每个父节点都出现在子节点<br>中，叶子节点依次相连，形成一个顺序链表。中间节点不包含卫星数据，只用来作为索引使用，这意味着每一个磁盘页中能够<br>包含更多的索引值。因此 B+ 树的高度相对于 B-来说更低，所以磁盘的 I/O 次数更少。由于叶子节点依次相连，并且包含<br>了父节点，所以可以通过叶子节点来找到对应的值。同时 B+ 树所有查询都要查找到叶子节点，查询性能比 B-树稳定。</p>
<p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561244&idx=1&sn=df3abafd3aa2f5a3abfe507bfc26982f&chksm=f1feec5fc6896549f89cbb82ee3d8010c63da76814030b285fa29322795de512ccca207064ee&scene=21#wechat_redirect">《漫画：什么是 B+ 树？》</a></p>
<h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><p>数据库以 B 树或者 B+ 树格式来储存的数据的，一张表是根据主键来构建的树的结构。因此如果想查找其他字段，就需要建<br>立索引，我对于索引的理解是它就是以某个字段为关键字的 B 树文件，通过这个 B 树文件就能够提高数据查找的效率。但是<br>由于我们需要维护的是平衡树的结构，因此对于数据的写入、修改、删除就会变慢，因为这有可能会涉及到树的平衡调整。</p>
<p>相关资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/23624390">《深入浅出数据库索引原理》</a><br><a href="http://www.ruanyifeng.com/blog/2014/07/database_implementation.html">《数据库的最简单实现》</a></p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种自平衡的二叉查找树，它主要是为了解决不平衡的二叉查找树的查找效率不高的缺点。红黑树保证了从根到叶子<br>节点的最长路径不会超过最短路径的两倍。</p>
<p>红黑树的有具体的规则：</p>
<p>1.节点是红色或黑色。</p>
<p>2.根节点是黑色。</p>
<p>3.每个叶子节点都是黑色的空节点（NIL节点）。</p>
<p>4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p>
<p>5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<p>当红黑树发生删除和插入导致红黑树不满足这些规则时，需要通过处理，使其重新满足这些规则。</p>
<p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561574&idx=1&sn=edab54460a85c9686e0ec0f5d178907c&chksm=f1feeaa5c68963b3689d23db68ab14a9c50a33dd5e9244a74d7765321b42af7ec14abfadf9ac&scene=21#wechat_redirect">《漫画：什么是红黑树？》</a><br><a href="https://cloud.tencent.com/developer/article/1101517">《漫画算法等精选文章目录》</a></p>
<h3 id="Huffman-树"><a href="#Huffman-树" class="headerlink" title="Huffman 树"></a>Huffman 树</h3><p>给定 n 权值作为 n 个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉<br>树，也称为 Huffman 树。</p>
<p>利用 Huffman 树对每一个字符编码，该编码又称为 Huffman 编码，Huffman 编码是一种前缀编码，即一个字符的编码<br>不是另一个字符编码的前缀。</p>
<p>性质：</p>
<ol>
<li><p>对应一组权重构造出来的 Huffman 树一般不是唯一的</p>
</li>
<li><p>Huffman 树具有最小的带权路径长度</p>
</li>
<li><p>Huffman 树中没有度为1的结点</p>
</li>
<li><p>哈夫曼树是带权路径长度最短的树，路径上权值较大的结点离根较近</p>
</li>
<li><p>Huffman 树的带权路径长度 WPL 等于各叶子结点的带权路径长度之和</p>
</li>
</ol>
<p>详细资料可以参考：</p>
<p><a href="https://blog.csdn.net/google19890102/article/details/54848262">《数据结构和算法—— Huffman 树和 Huffman 编码》</a><br><a href="https://blog.csdn.net/fx677588/article/details/70767446">《详细图解哈夫曼 Huffman 编码树》</a></p>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，这一特性使得查找的效率很高，<br>对于数值型和非数值型数据，比如字母和字符串，都是如此。</p>
<p>实现树节点类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点类，树的节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现二叉查找树类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现树的节点插入方法</p>
<p>节点插入的基本思想是将插入节点和当前节点做比较，如果比当前节点值小，并且没有左子树，那么将节点作为左叶子节点，<br>否则继续和左子树进行比较。如果比当前节点值大，并且没有右子树，则将节点作为右叶子节点，否则继续和右子树进行比较。<br>循环这个过程直到找到合适的插入位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title function_">insert</span>(<span class="params">value</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断根节点是否为空，如果不为空则递归插入到树中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">insertNode</span>(<span class="params">node, newNode</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将插入节点的值与当前节点的进行比较，如果比当前节点小，则递归判断左子树，如果比当前节点大，则递归判断右子树。</span></span><br><span class="line">  <span class="keyword">if</span> (newNode.<span class="property">value</span> &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.<span class="property">left</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.<span class="property">right</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过递归实现树的先序、中序、后序遍历</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先序遍历通过递归实现</span></span><br><span class="line"><span class="comment">// 先序遍历则先打印当前节点，再递归打印左子节点和右子节点。</span></span><br><span class="line"> <span class="title function_">preOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">preOrderTraverseNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">     node.<span class="title function_">show</span>();</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 中序遍历通过递归实现</span></span><br><span class="line"> <span class="comment">// 中序遍历则先递归打印左子节点，再打印当前节点，最后再递归打印右子节点。</span></span><br><span class="line"> <span class="title function_">inOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">inOrderTraverseNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">     node.<span class="title function_">show</span>();</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 后序遍历通过递归实现</span></span><br><span class="line"> <span class="comment">// 后序遍历则先递归打印左子节点和右子节点，最后再打印当前节点。</span></span><br><span class="line"> <span class="title function_">postOrderTraverse</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">postOrderTraverseNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">left</span>);</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">right</span>);</span><br><span class="line">     node.<span class="title function_">show</span>();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>通过循环实现树的先序、中序、后序遍历</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先序遍历通过循环实现</span></span><br><span class="line"><span class="comment">// 通过栈来实现循环先序遍历，首先将根节点入栈。然后进入循环，每次循环开始，当前节点出栈，打印当前节点，然后将</span></span><br><span class="line"><span class="comment">// 右子节点入栈，再将左子节点入栈，然后进入下一循环，直到栈为空结束循环。</span></span><br><span class="line"><span class="title function_">preOrderTraverseByStack</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现将根节点入栈，开始遍历</span></span><br><span class="line">  stack.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从栈中获取当前节点</span></span><br><span class="line">    <span class="keyword">let</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行节点操作</span></span><br><span class="line">    node.<span class="title function_">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点是否还有左右子节点，如果存在则加入栈中，注意，由于中序遍历先序遍历是先访问根</span></span><br><span class="line">    <span class="comment">// 再访问左和右子节点，因此左右子节点的入栈顺序应该是反过来的</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">right</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历通过循环实现</span></span><br><span class="line"><span class="comment">// 中序遍历先将所有的左子节点入栈，如果左子节点为 null 时，打印栈顶元素，然后判断该元素是否有右子树，如果有</span></span><br><span class="line"><span class="comment">// 则将右子树作为起点重复上面的过程，一直循环直到栈为空并且节点为空时。</span></span><br><span class="line"><span class="title function_">inOrderTraverseByStack</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [],</span><br><span class="line">    node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中序遍历是先左再根最后右</span></span><br><span class="line">  <span class="comment">// 所以首先应该先把最左边节点遍历到底依次 push 进栈</span></span><br><span class="line">  <span class="comment">// 当左边没有节点时，就打印栈顶元素，然后寻找右节点</span></span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span> || node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(node);</span><br><span class="line">      node = node.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node = stack.<span class="title function_">pop</span>();</span><br><span class="line">      node.<span class="title function_">show</span>();</span><br><span class="line">      node = node.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历通过循环来实现</span></span><br><span class="line"><span class="comment">// 使用两个栈来是实现，先将根节点放入栈1中，然后进入循环，每次循环将栈顶元素加入栈2，再依次将左节点和右节点依次</span></span><br><span class="line"><span class="comment">// 加入栈1中，然后进入下一次循环，直到栈1的长度为0。最后再循环打印栈2的值。</span></span><br><span class="line"><span class="title function_">postOrderTraverseByStack</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> stack1 = [],</span><br><span class="line">    stack2 = [],</span><br><span class="line">    node = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后序遍历是先左再右最后根</span></span><br><span class="line">  <span class="comment">// 所以对于一个栈来说，应该先 push 根节点</span></span><br><span class="line">  <span class="comment">// 然后 push 右节点，最后 push 左节点</span></span><br><span class="line"></span><br><span class="line">  stack1.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (stack1.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    node = stack1.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    stack2.<span class="title function_">push</span>(node);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span>) &#123;</span><br><span class="line">      stack1.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">right</span>) &#123;</span><br><span class="line">      stack1.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (stack2.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    node = stack2.<span class="title function_">pop</span>();</span><br><span class="line">    node.<span class="title function_">show</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现寻找最大最小节点值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找最小值，在最左边的叶子节点上</span></span><br><span class="line"> <span class="title function_">findMinNode</span>(<span class="params">root</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> node = root;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (node &amp;&amp; node.<span class="property">left</span>) &#123;</span><br><span class="line">     node = node.<span class="property">left</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> node;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 寻找最大值，在最右边的叶子节点上</span></span><br><span class="line"></span><br><span class="line"> <span class="title function_">findMaxNode</span>(<span class="params">root</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> node = root;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (node &amp;&amp; node.<span class="property">right</span>) &#123;</span><br><span class="line">     node = node.<span class="property">right</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> node;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>实现寻找特定大小节点值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找特定值</span></span><br><span class="line"><span class="title function_">find</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">findNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">findNode</span>(<span class="params">node, value</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">findNode</span>(node.<span class="property">left</span>, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; node.<span class="property">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">findNode</span>(node.<span class="property">right</span>, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现移除节点值</p>
<p>移除节点的基本思想是，首先找到需要移除的节点的位置，然后判断该节点是否有叶节点。如果没有叶节点，则直接删除，如<br>果有一个叶子节点，则用这个叶子节点替换当前的位置。如果有两个叶子节点，则去右子树中找到最小的节点来替换当前节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 移除指定值节点</span></span><br><span class="line"><span class="title function_">remove</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">removeNode</span>(<span class="params">node, value</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找指定节点</span></span><br><span class="line">  <span class="keyword">if</span> (value &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">    node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(node.<span class="property">left</span>, value);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; node.<span class="property">value</span>) &#123;</span><br><span class="line">    node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(node.<span class="property">right</span>, value);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种情况——没有叶节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种情况——一个只有一个子节点的节点，将节点替换为节点的子节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.<span class="property">right</span>;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种情况——一个有两个子节点的节点，去右子树中找到最小的节点，用它的值来替换当前节点</span></span><br><span class="line">    <span class="comment">// 的值，保持树的特性，然后将替换的节点去掉</span></span><br><span class="line">    <span class="keyword">let</span> aux = <span class="variable language_">this</span>.<span class="title function_">findMinNode</span>(node.<span class="property">right</span>);</span><br><span class="line">    node.<span class="property">value</span> = aux.<span class="property">value</span>;</span><br><span class="line">    node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(node.<span class="property">right</span>, aux);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求解二叉树中两个节点的最近公共祖先节点"><a href="#求解二叉树中两个节点的最近公共祖先节点" class="headerlink" title="求解二叉树中两个节点的最近公共祖先节点"></a>求解二叉树中两个节点的最近公共祖先节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">求解二叉树中的两个节点的最近公共祖先节点可以分为三种情况来考虑</span><br><span class="line"></span><br><span class="line">（1）该二叉树为搜索二叉树 </span><br><span class="line"></span><br><span class="line">    解决办法，首先从根节点开始遍历。如果根节点的值比两个节点的值都大的情况下，则说明两个节点的共同祖先存在于</span><br><span class="line">    根节点的左子树中，因此递归遍历左子树。反之，则遍历右子树。当当前节点的值比其中一个节点的值大，比其中一个</span><br><span class="line">    节点的值小时，该节点则为两个节点的最近公共祖先节点。</span><br><span class="line"></span><br><span class="line">（2）该二叉树为普通二叉树，但是每个节点含有指向父节点的指针。</span><br><span class="line"></span><br><span class="line">    通过指向父节点的指针，我们可以通过节点得到它的所有父节点，该父节点列表可以看做是一个链表，因此求两个节点</span><br><span class="line">    的最近公共祖先节点就可以看做是求两个链表的最近公共节点，以此来找到两个节点的最近公共祖先节点。</span><br><span class="line"></span><br><span class="line">（3）该二叉树为普通二叉树，节点不含有指向父节点的指针。</span><br><span class="line"></span><br><span class="line">    这种情况下，我们可以从根节点出发，分别得到根节点到两个节点的路径。然后遍历两条路径，直到遇到第一个不相同</span><br><span class="line">    的节点为止，这个时候该节点前面的那个节点则为两个节点的最近公共祖先节点。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/xyzbaihaiping/article/details/52122885">《二叉树中两个节点的最近公共祖先节点》</a></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转单向链表"><a href="#反转单向链表" class="headerlink" title="反转单向链表"></a>反转单向链表</h3><p>需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是<br>一道面试常考题。</p>
<p>思路是从头节点往后遍历，先获取下一个节点，然后将当前节点的 next 设置为前一个节点，然后再继续循环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断下变量边界问题</span></span><br><span class="line">    <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null</span></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> current = head;</span><br><span class="line">    <span class="keyword">let</span> next;</span><br><span class="line">    <span class="comment">// 判断当前节点是否为空</span></span><br><span class="line">    <span class="comment">// 不为空就先获取当前节点的下一节点</span></span><br><span class="line">    <span class="comment">// 然后把当前节点的 next 设为上一个节点</span></span><br><span class="line">    <span class="comment">// 然后把 current 设为下一个节点，pre 设为当前节点</span></span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        next = current.<span class="property">next</span>;</span><br><span class="line">        current.<span class="property">next</span> = pre;</span><br><span class="line">        pre = current;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h3><p>有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法？</p>
<h4 id="递归方法分析"><a href="#递归方法分析" class="headerlink" title="递归方法分析"></a>递归方法分析</h4><p>由分析可知，假设我们只差最后一步就能走上第10级阶梯，这个时候一共有两种情况，因为每一步只允许走1级或2级阶梯，<br>因此分别为从8级阶梯和从9九级阶梯走上去的情况。因此从0到10级阶梯的走法数量就等于从0到9级阶梯的走法数量加上<br>从0到8级阶梯的走法数量。依次类推，我们可以得到一个递归关系，递归结束的标志为从0到1级阶梯的走法数量和从0到<br>2级阶梯的走法数量。</p>
<p>代码实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getClimbingWays</span>(<span class="params">n</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getClimbingWays</span>(n - <span class="number">1</span>) + <span class="title function_">getClimbingWays</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种方法时整个的递归过程是一个二叉树的结构，因此该方法的时间复杂度可以近似的看为 O(2^n)，空间复杂度<br>为递归的深度 O(logn)。</p>
<h4 id="备忘录方法"><a href="#备忘录方法" class="headerlink" title="备忘录方法"></a>备忘录方法</h4><p>分析递归的方法我们可以发现，其实有很多的计算过程其实是重复的，因此我们可以使用一个数组，将已经计算出的值给<br>保存下来，每次计算时，先判断计算结果是否已经存在，如果已经存在就直接使用。</p>
<p>代码实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getClimbingWays</span>(<span class="params">n</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">has</span>(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> map.<span class="title function_">get</span>(n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="title function_">getClimbingWays</span>(n - <span class="number">1</span>) + <span class="title function_">getClimbingWays</span>(n - <span class="number">2</span>);</span><br><span class="line">    map.<span class="title function_">set</span>(n, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，我们将算法的时间复杂度降低为 O(n)，但是增加空间复杂度为 O(n)</p>
<h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><p>通过观察，我们可以发现每一个值其实都等于它的前面两个值的和，因此我们可以使用自底向上的方式来实现。</p>
<p>代码实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getClimbingWays</span>(<span class="params">n</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>,</span><br><span class="line">    temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    temp = a + b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式我们可以将算法的时间复杂度降低为 O(n)，并且将算法的空间复杂度降低为 O(1)。</p>
<p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561168&idx=1&sn=9d1c6f7ba6d651c75399c4aa5254a7d8&chksm=f1feec13c6896505f7886d9455278ad39749d377a63908c59c1fdceb11241e577ff6d66931e4&scene=21#wechat_redirect">《漫画：什么是动态规划？（整合版）》</a></p>
<h2 id="经典笔试题"><a href="#经典笔试题" class="headerlink" title="经典笔试题"></a>经典笔试题</h2><h4 id="1-js-实现一个函数，完成超过范围的两个大整数相加功能"><a href="#1-js-实现一个函数，完成超过范围的两个大整数相加功能" class="headerlink" title="1. js 实现一个函数，完成超过范围的两个大整数相加功能"></a>1. js 实现一个函数，完成超过范围的两个大整数相加功能</h4>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">主要思路是通过将数字转换为字符串，然后每个字符串在按位相加。</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumberAdd</span>(<span class="params">number1, number2</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>, <span class="comment">// 保存最后结果</span></span><br><span class="line">    carry = <span class="literal">false</span>; <span class="comment">// 保留进位结果</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将字符串转换为数组</span></span><br><span class="line">  number1 = number1.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  number2 = number2.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当数组的长度都变为0，并且最终不再进位时，结束循环</span></span><br><span class="line">  <span class="keyword">while</span> (number1.<span class="property">length</span> || number2.<span class="property">length</span> || carry) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次将最后的数字进行相加，使用~~的好处是，即使返回值为 undefined 也能转换为 0</span></span><br><span class="line">    carry += ~~number1.<span class="title function_">pop</span>() + ~~number2.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取加法结果的个位加入最终结果</span></span><br><span class="line">    result = carry % <span class="number">10</span> + result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要进位，true 和 false 的值在加法中会被转换为 1 和 0</span></span><br><span class="line">    carry = carry &gt; <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回最终结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/fe_dev/article/details/80079372">《JavaScript实现超范围的数相加》</a><br>   <a href="https://blog.csdn.net/q1059081877q/article/details/80689194">《js 实现大整数加法》</a></p>
<h4 id="2-js-如何实现数组扁平化？"><a href="#2-js-如何实现数组扁平化？" class="headerlink" title="2. js 如何实现数组扁平化？"></a>2. js 如何实现数组扁平化？</h4>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 这一种方法通过递归来实现，当元素为数组时递归调用，兼容性好</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">array</span>) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">     result = array.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">pre, item</span>) &#123;</span><br><span class="line">       <span class="comment">// 判断元素是否为数组，如果为数组则递归调用，如果不是则加入结果数组中</span></span><br><span class="line">       <span class="keyword">return</span> pre.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) ? <span class="title function_">flattenArray</span>(item) : item);</span><br><span class="line">     &#125;, []);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用递归的形式进行数组打平</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">flatArray</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">        arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(element))&#123;</span><br><span class="line">                <span class="title function_">flat</span>(element);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.<span class="title function_">push</span>(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">flat</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这一种方法是利用了 toString 方法，它的一个缺点是改变了元素的类型，只适合于数组中元素都是整数的情况</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">array</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> array.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(item);</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/36">《JavaScript专题之数组扁平化》</a></p>
<h4 id="3-js-如何实现数组去重？"><a href="#3-js-如何实现数组去重？" class="headerlink" title="3. js 如何实现数组去重？"></a>3. js 如何实现数组去重？</h4>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || array.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">  array.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="title function_">indexOf</span>(item) === -<span class="number">1</span>) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || array.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(array)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/27">《JavaScript专题之数组去重》</a></p>
<h4 id="4-如何求数组的最大值和最小值？"><a href="#4-如何求数组的最大值和最小值？" class="headerlink" title="4. 如何求数组的最大值和最小值？"></a>4. 如何求数组的最大值和最小值？</h4>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, arr))</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="https://github.com/mqyqingfeng/Blog/issues/35">《JavaScript专题之如何求数组的最大值和最小值》</a></p>
<h4 id="5-如何求两个数的最大公约数？"><a href="#5-如何求两个数的最大公约数？" class="headerlink" title="5. 如何求两个数的最大公约数？"></a>5. 如何求两个数的最大公约数？</h4>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">基本思想是采用辗转相除的方法，用大的数去除以小的那个数，然后再用小的数去除以的得到的余数，一直这样递归下去，</span><br><span class="line">直到余数为<span class="number">0</span>时，最后的被除数就是两个数的最大公约数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMaxCommonDivisor</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getMaxCommonDivisor</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-如何求两个数的最小公倍数？"><a href="#6-如何求两个数的最小公倍数？" class="headerlink" title="6. 如何求两个数的最小公倍数？"></a>6. 如何求两个数的最小公倍数？</h4>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">基本思想是采用将两个数相乘，然后除以它们的最大公约数</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMinCommonMultiple</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b / <span class="title function_">getMaxCommonDivisor</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/cssfirefly/archive/2012/10/23/2734936.html">《百度 web 前端面试题之求两个数的最大公约数和最小公倍数》</a></p>
<h4 id="7-实现-IndexOf-方法？"><a href="#7-实现-IndexOf-方法？" class="headerlink" title="7. 实现 IndexOf 方法？"></a>7. 实现 IndexOf 方法？</h4>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">indexFun</span>(<span class="params">array, val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] === val) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h4 id="8-判断一个字符串是否为回文字符串？"><a href="#8-判断一个字符串是否为回文字符串？" class="headerlink" title="8. 判断一个字符串是否为回文字符串？"></a>8. 判断一个字符串是否为回文字符串？</h4>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> reg = <span class="regexp">/[\W_]/g</span>, <span class="comment">// 匹配所有非单词的字符以及下划线</span></span><br><span class="line">    newStr = str.<span class="title function_">replace</span>(reg, <span class="string">&quot;&quot;</span>).<span class="title function_">toLowerCase</span>(), <span class="comment">// 替换为空字符并将大写字母转换为小写</span></span><br><span class="line">    reverseStr = newStr.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 将字符串反转</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reverseStr === newStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-实现一个累加函数的功能比如-sum-1-2-3-2-valueOf"><a href="#9-实现一个累加函数的功能比如-sum-1-2-3-2-valueOf" class="headerlink" title="9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()"></a>9. 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()</h4>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...args</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">result = args.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">pre, item</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> pre + item;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line"></span><br><span class="line">  result = args.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">pre, item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> pre + item;</span><br><span class="line">  &#125;, result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> add;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-使用-reduce-方法实现-forEach、map、filter"><a href="#10-使用-reduce-方法实现-forEach、map、filter" class="headerlink" title="10. 使用 reduce 方法实现 forEach、map、filter"></a>10. 使用 reduce 方法实现 forEach、map、filter</h4>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// forEach</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forEachUseReduce</span>(<span class="params">array, handler</span>) &#123;</span><br><span class="line">  array.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">pre, item, index</span>) &#123;</span><br><span class="line">    <span class="title function_">handler</span>(item, index);</span><br><span class="line">  &#125;, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapUseReduce</span>(<span class="params">array, handler</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  array.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">pre, item, index</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> mapItem = <span class="title function_">handler</span>(item, index);</span><br><span class="line">    result.<span class="title function_">push</span>(mapItem);</span><br><span class="line">  &#125;, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filterUseReduce</span>(<span class="params">array, handler</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  array.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">pre, item, index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">handler</span>(item, index)) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-设计一个简单的任务队列，要求分别在-1-3-4-秒后打印出-“1”-“2”-“3”"><a href="#11-设计一个简单的任务队列，要求分别在-1-3-4-秒后打印出-“1”-“2”-“3”" class="headerlink" title="11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”"></a>11. 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”</h4>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">time</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addTask</span>(<span class="params">task, t</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">time</span> += t;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>([task, <span class="variable language_">this</span>.<span class="property">time</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        item[<span class="number">0</span>]();</span><br><span class="line">      &#125;, item[<span class="number">1</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-如何查找一篇英文文章中出现频率最高的单词？"><a href="#12-如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="12. 如何查找一篇英文文章中出现频率最高的单词？"></a>12. 如何查找一篇英文文章中出现频率最高的单词？</h4>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findMostWord</span>(<span class="params">article</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法性判断</span></span><br><span class="line"><span class="keyword">if</span> (!article) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数处理</span></span><br><span class="line">article = article.<span class="title function_">trim</span>().<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wordList = article.<span class="title function_">match</span>(<span class="regexp">/[a-z]+/g</span>),</span><br><span class="line"> visited = [],</span><br><span class="line"> maxNum = <span class="number">0</span>,</span><br><span class="line"> maxWord = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">article = <span class="string">&quot; &quot;</span> + wordList.<span class="title function_">join</span>(<span class="string">&quot;  &quot;</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历判断单词出现次数</span></span><br><span class="line">wordList.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (visited.<span class="title function_">indexOf</span>(item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> word = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot; &quot;</span> + item + <span class="string">&quot; &quot;</span>, <span class="string">&quot;g&quot;</span>),</span><br><span class="line">     num = article.<span class="title function_">match</span>(word).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num &gt; maxNum) &#123;</span><br><span class="line">     maxNum = num;</span><br><span class="line">     maxWord = item;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxWord + <span class="string">&quot;  &quot;</span> + maxNum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="常见面试智力题总结"><a href="#常见面试智力题总结" class="headerlink" title="常见面试智力题总结"></a>常见面试智力题总结</h1><h4 id="1-时针与分针夹角度数问题？"><a href="#1-时针与分针夹角度数问题？" class="headerlink" title="1. 时针与分针夹角度数问题？"></a>1. 时针与分针夹角度数问题？</h4><p>   分析：<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当时间为 m 点 n 分时，其时针与分针夹角的度数为多少？</span><br><span class="line"></span><br><span class="line">我们可以这样考虑，分针每走一格为 6 度，分针每走一格对应的时针会走 0.5 度。</span><br><span class="line"></span><br><span class="line">时针每走一格为 30 度。</span><br><span class="line"></span><br><span class="line">因此，时针走过的度数为 m * 30 + n * 0.5，分针走过的度数为 n * 6。</span><br><span class="line"></span><br><span class="line">因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|;</span><br></pre></td></tr></table></figure></p>
<p>   答案：<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|; </span><br></pre></td></tr></table></figure></p>
<p>   详细资料参考：<br>   <a href="https://blog.csdn.net/prstaxy/article/details/22210829">《面试智力题 — 时针与分针夹角度数问题》</a></p>
<h4 id="2-用3升，5升杯子怎么量出4升水？"><a href="#2-用3升，5升杯子怎么量出4升水？" class="headerlink" title="2. 用3升，5升杯子怎么量出4升水？"></a>2. 用3升，5升杯子怎么量出4升水？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）将 5 升杯子装满水，然后倒入 3 升杯子中，之后 5 升杯子还剩 2 升水。</span><br><span class="line"></span><br><span class="line">（2）将 3 升杯子的水倒出，然后将 5 升杯子中的 2 升水倒入 3 升杯子中。</span><br><span class="line"></span><br><span class="line">（3）将 5 升杯子装满水，然后向 3 升杯子中倒水，直到 3 升杯子装满为止，此时 5 升杯子中就还剩 4 升水。</span><br></pre></td></tr></table></figure>

<h4 id="3-四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？"><a href="#3-四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？" class="headerlink" title="3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？"></a>3. 四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于浑浊的每片药片比正常药片都多出了一克，因此我认为可以通过控制药片的数量来实现判断。</span><br><span class="line"></span><br><span class="line">（1）首先将每个药罐进行编号，分别标记为 1、2、3、4 号药罐。</span><br><span class="line"></span><br><span class="line">（2）然后从 1 号药罐中取出 1 片药片，从 2 号药罐中取出 2 片药片，从 3 号药罐中取出 3 片药片，从 4 号药罐中取出 4</span><br><span class="line">    片药片。</span><br><span class="line"></span><br><span class="line">（3）将 10 片药片使用天平称重，药片的重量比正常重量多出几克，就是哪一号药罐的问题。</span><br></pre></td></tr></table></figure>

<h4 id="4-四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为-a-1-b-2-现在我想要证明-a-的反面必然是-1-，我只能翻两张牌，我翻哪两张？"><a href="#4-四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为-a-1-b-2-现在我想要证明-a-的反面必然是-1-，我只能翻两张牌，我翻哪两张？" class="headerlink" title="4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？"></a>4. 四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1 ，我只能翻两张牌，我翻哪两张？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我认为证明 a 的反面一定是 1 的充要条件为 a 的反面为 1，并且 2 的反面不能为 a，因此应该翻 a 和 2 两张牌。</span><br></pre></td></tr></table></figure>

<h4 id="5-赛马问题，25-匹马，5-个赛道，最少几次能选出最快的三匹马？"><a href="#5-赛马问题，25-匹马，5-个赛道，最少几次能选出最快的三匹马？" class="headerlink" title="5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？"></a>5. 赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我认为一共至少需要 7 次才能选出最快的三匹马。</span><br><span class="line"></span><br><span class="line">（1）首先，我们将 25 匹马分为 5 组，每组进行比赛，选出每组最快的三匹马，其余的马由于已经不可能成为前三了，因此可以直</span><br><span class="line">    接淘汰掉，那么我们现在还剩下了 15 匹马。</span><br><span class="line"></span><br><span class="line">（2）然后我们将 5 组中的第一名来进行一轮比赛，最终的结果能够确定最快的马一定是第一名，四五名的马以及它们对应组的其余</span><br><span class="line">    马就可以淘汰掉了，因为它们已经没有进入前三的机会了。并且第二名那一组的第三名和第三组的第二第三名都可以淘汰掉了，</span><br><span class="line">    它们也没有进入前三的机会了。因此我们最终剩下了第一名那一组的二三名和第二名那一组的一二名，以及第三名一共 5 匹马，</span><br><span class="line">    它们都有竞争最快第二第三的机会。</span><br><span class="line"></span><br><span class="line">（3）最后一次对最后的 5 匹马进行比赛，选择最快的一二名作为最终结果的二三名，因此就能够通过 7 次比较，选择出最快的马。</span><br></pre></td></tr></table></figure>

<h4 id="6-五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？"><a href="#6-五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？" class="headerlink" title="6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？"></a>6. 五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）由于每个人不能和自己的配偶握手，并且最多只能和他人握手一次，因此一个人最多能握 8 次手。</span><br><span class="line"></span><br><span class="line">（2）因为 A 问了除自己配偶的其他人，每个人的握手次数都不同。因此一共有九种握手的情况，由于一个人最多只能握 8 次手，因</span><br><span class="line">    此握手的情况分别为 0、1、2、3、4、5、6、7、8 这九种情况。</span><br><span class="line"></span><br><span class="line">（3）我们首先分析握了 8 次手的人，由于他和除了自己配偶的每一个人都握了一次手，因此其他人的握手次数都不为 0，因此只有</span><br><span class="line">    他的配偶握手次数为0，由此我们可以知道握手次数为 8 的人和握手次数为 0 的人是配偶。</span><br><span class="line"></span><br><span class="line">（4）我们再来分析握了 7 次手的人，他和除了握了 0 次手以外的人都握了一次手，由于握了 8 次手的人和其余人也都握了一次手</span><br><span class="line">    ，因此其他人的握手次数至少为 2 ，因此只有他的配偶的握手次数才能为 1。由此我们可以知道握手次数为 7 的人和握手次数</span><br><span class="line">    为 1 的人是配偶。</span><br><span class="line"></span><br><span class="line">（5）依次可以类推，握手次数为 6 的人和握手次数为 2 的人为配偶，握手次数为 5 的人和握手次数为 3 的人为配偶。</span><br><span class="line"></span><br><span class="line">（6）最终剩下了握手次数为 4 的人，按照规律我们可以得知他的配偶的握手次数也为4。</span><br><span class="line"></span><br><span class="line">（7）由于 A 和其他人的握手次数都不同，因此我们可以得知握手次数为 4 的人就是 A。因此他的配偶的握手次数为 4 。</span><br></pre></td></tr></table></figure>

<h4 id="7-你只能带行走-60-公里的油，只能在起始点加油，如何穿过-80-公里的沙漠？"><a href="#7-你只能带行走-60-公里的油，只能在起始点加油，如何穿过-80-公里的沙漠？" class="headerlink" title="7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？"></a>7. 你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）先走到离起点 20 公里的地方，然后放下 20 公里的油在这，然后返回起点加油。</span><br><span class="line"></span><br><span class="line">（2）当第二次到达这时，车还剩 40 公里的油，加上上一次放在这的 20 公里的油，一共就有 60 公里的油，能够走完剩下的路</span><br><span class="line">    程。</span><br></pre></td></tr></table></figure>

<h4 id="8-烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？"><a href="#8-烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？" class="headerlink" title="8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？"></a>8. 烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一共需要三根绳子，假设分别为 1、2、3 号绳子，每个绳子一共有 A、B 两端。</span><br><span class="line">  </span><br><span class="line">（1）首先点燃 1 号绳子的 A、B 两端，然后点燃 2 号绳子的 A 端。</span><br><span class="line"></span><br><span class="line">（2）当 1 号绳子燃尽时，此时过去了半小时，然后同时点燃 2 号绳子的 B 端。</span><br><span class="line"></span><br><span class="line">（3）当 2 号绳子燃尽时，此时又过去了 15 分钟，然后同时点燃 3 号绳子的 A、B 两端。</span><br><span class="line"></span><br><span class="line">（4）当 3 号绳子燃尽时，又过去了半小时，以此一共加起来过去了一个小时十五分钟。</span><br></pre></td></tr></table></figure>

<h4 id="9-有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？"><a href="#9-有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？" class="headerlink" title="9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？"></a>9. 有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1） 第一次用 7 克砝码和 2 克砝码称取 9 克盐。</span><br><span class="line"></span><br><span class="line">（2） 第二次再用第一次称取的盐和砝码称取 16 克盐。</span><br><span class="line"></span><br><span class="line">（3） 第三次再用前两次称取的盐和砝码称取 25 克盐，这样就总共称取了 50 克盐，剩下的就是 90 克。</span><br></pre></td></tr></table></figure>

<h4 id="10-有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第-小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和-两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？"><a href="#10-有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第-小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和-两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？" class="headerlink" title="10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？"></a>10. 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于小鸟一直都在飞，直到两车相遇时才停下来。因此小鸟飞行的时间为两车相遇的时间，由于两车是相向而行，因此</span><br><span class="line">两车相遇的时间为总路程除以两车的速度之和，然后再用飞行的时间去乘以小鸟的速度，就能够得出小鸟飞行的距离。</span><br></pre></td></tr></table></figure>

<h4 id="11-你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？"><a href="#11-你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？" class="headerlink" title="11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？"></a>11. 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个罐子里放一个红球，第二个罐子里放剩余的球，这样概率接近75%，这是概率最大的方法</span><br></pre></td></tr></table></figure>

<h4 id="12-假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？"><a href="#12-假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？" class="headerlink" title="12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？"></a>12. 假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最少两次可以称出。</span><br><span class="line"></span><br><span class="line">首先将 8 个球分为 3 组，其中两组为 3 个球，一组为 2 个球。</span><br><span class="line"></span><br><span class="line">第一次将两组三个的球进行比较，如果两边相等，则说明重的球在最后一组里。第二次将最后一组的球进行比较即可。如</span><br><span class="line">果两边不等，则说明重的球在较重的一边，第二次只需从这一组中随机取两球出来比较即可判断。</span><br></pre></td></tr></table></figure>

<h4 id="13-在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？"><a href="#13-在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？" class="headerlink" title="13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？"></a>13. 在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）首先打开一盏灯 10 分钟，然后打开第二盏。</span><br><span class="line">（2）进入房间，看看那盏灯亮，摸摸那盏灯热，热的是第一个开关打开的，亮的是第二个开关打开的，而剩下的就是第三个开关打开</span><br><span class="line">    的。</span><br></pre></td></tr></table></figure>

<h4 id="14-他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？"><a href="#14-他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？" class="headerlink" title="14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？"></a>14. 他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将每一对袜子分开，一人拿一只袜子，因为袜子不分左右脚的，因此最后每个人都能取回白袜和黑袜两对。</span><br></pre></td></tr></table></figure>

<h4 id="15-有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。"><a href="#15-有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。" class="headerlink" title="15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。"></a>15. 有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从混合标签里取出一个水果，取出的是什么水果，就写上相应的标签。</span><br><span class="line"></span><br><span class="line">对应水果标签的筐的标签改为另一种水果。</span><br><span class="line"></span><br><span class="line">另一种水果标签的框改为混合。</span><br></pre></td></tr></table></figure>

<h4 id="16-一个班级60-喜欢足球，70-喜欢篮球，80-喜欢排球，问即三种球都喜欢占比有多少？"><a href="#16-一个班级60-喜欢足球，70-喜欢篮球，80-喜欢排球，问即三种球都喜欢占比有多少？" class="headerlink" title="16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？"></a>16. 一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）首先确定最多的一种情况，就是 60% 喜欢足球的人同时也喜欢篮球和排球，此时为三种球都喜欢的人的最大比例。</span><br><span class="line"></span><br><span class="line">（2）然后确定最小的一种情况，根据题目可以知道有 40%的人不喜欢足球，30%的人不喜欢篮球，20%的人不喜欢排球，因此有最多</span><br><span class="line">    90% 的人三种球中有一种球不喜欢，因此三种球都喜欢的人的最小比例为 10%。</span><br><span class="line"></span><br><span class="line">因此三种球都喜欢的人占比为 10%-60%</span><br></pre></td></tr></table></figure>

<h4 id="17-五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？"><a href="#17-五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？" class="headerlink" title="17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？"></a>17. 五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">五只鸡五天能下五个蛋，平均下来五只鸡每天能下一个蛋，因此五只鸡一百天就能够下一百个蛋。</span><br></pre></td></tr></table></figure>
<p>   更多的智力题可以参考：<br>   <a href="https://blog.csdn.net/hilyoo/article/details/4445858">《经典面试智力题200+题和解答》</a></p>
<h1 id="剑指-offer-思路总结"><a href="#剑指-offer-思路总结" class="headerlink" title="剑指 offer 思路总结"></a>剑指 offer 思路总结</h1><p>本部分主要是笔者在练习剑指 offer 时所做的笔记，如果出现错误，希望大家指出！</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a>1. 二维数组中的查找</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line">在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的</span><br><span class="line">一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方式是使用两层循环依次遍历，判断是否含有该整数。这一种方式最坏情况下的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是利用递增序列的特点，我们可以从二维数组的右上角开始遍历。如果当前数值比所求的数要小，则将位置向下移动</span><br><span class="line">    ，再进行判断。如果当前数值比所求的数要大，则将位置向左移动，再进行判断。这一种方式最坏情况下的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure>

<h4 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20</span><br><span class="line">Are%20Happy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用正则表达式，结合字符串的 replace 方法将空格替换为 “%20”</span><br><span class="line"></span><br><span class="line">str.replace(/\s/g,&quot;%20&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3. 从尾到头打印链表"></a>3. 从尾到头打印链表</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，从尾到头打印链表每个节点的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用栈来实现，首先根据头结点以此遍历链表节点，将节点加入到栈中。当遍历完成后，再将栈中元素弹出并打印，以此来实现。栈的</span><br><span class="line">实现可以利用 Array 的 push 和 pop 方法来模拟。</span><br></pre></td></tr></table></figure>

<h4 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4. 重建二叉树"></a>4. 重建二叉树</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输</span><br><span class="line">入前序遍历序列 &#123;1,2,4,7,3,5,6,8&#125; 和中序遍历序列 &#123;4,7,2,1,5,3,8,6&#125;，则重建二叉树并返回。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用递归的思想来求解，首先先序序列中的第一个元素一定是根元素。然后我们去中序遍历中寻找到该元素的位置，找到后该元素的左</span><br><span class="line">边部分就是根节点的左子树，右边部分就是根节点的右子树。因此我们可以分别截取对应的部分进行子树的递归构建。使用这种方式的</span><br><span class="line">时间复杂度为 O(n)，空间复杂度为 O(logn)。</span><br></pre></td></tr></table></figure>

<h4 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5. 用两个栈实现队列"></a>5. 用两个栈实现队列</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">队列的一个基本特点是，元素先进先出。通过两个栈来模拟时，首先我们将两个栈分为栈1和栈2。当执行队列的 push 操作时，直接</span><br><span class="line">将元素 push 进栈1中。当队列执行 pop 操作时，首先判断栈2是否为空，如果不为空则直接 pop 元素。如果栈2为空，则将栈1中</span><br><span class="line">的所有元素 pop 然后 push 到栈2中，然后再执行栈2的 pop 操作。</span><br><span class="line"></span><br><span class="line">扩展：</span><br><span class="line"></span><br><span class="line">当使用两个长度不同的栈来模拟队列时，队列的最大长度为较短栈的长度的两倍。</span><br></pre></td></tr></table></figure>

<h4 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6. 旋转数组的最小数字"></a>6. 旋转数组的最小数字</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的</span><br><span class="line">最小元素。 例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大</span><br><span class="line">小为0，请返回0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值相</span><br><span class="line">    邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。</span><br><span class="line"></span><br><span class="line">（2）二分法</span><br></pre></td></tr></table></figure>
<p>   相关资料可以参考：<br>   <a href="https://www.cnblogs.com/edisonchou/p/4746561.html">《旋转数组的最小数字》</a></p>
<h4 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a>7. 斐波那契数列</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。 n&lt;=39</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">斐波那契数列的规律是，第一项为0，第二项为1，第三项以后的值都等于前面两项的和，因此我们可以通过循环的方式，不断通过叠</span><br><span class="line">加来实现第 n 项值的构建。通过循环而不是递归的方式来实现，时间复杂度降为了 O(n)，空间复杂度为 O(1)。</span><br></pre></td></tr></table></figure>

<h4 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a>8. 跳台阶</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">跳台阶的问题是一个动态规划的问题，由于一次只能够跳1级或者2级，因此跳上 n 级台阶一共有两种方案，一种是从 n-1 跳上，一</span><br><span class="line">种是从 n-2 级跳上，因此 f(n) = f(n-1) + f(n-2)。</span><br><span class="line"></span><br><span class="line">和斐波那契数列类似，不过初始两项的值变为了 1 和 2，后面每项的值等于前面两项的和。</span><br></pre></td></tr></table></figure>

<h4 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a>9. 变态跳台阶</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">变态跳台阶的问题同上一个问题的思考方案是一样的，我们可以得到一个结论是，每一项的值都等于前面所有项的值的和。</span><br><span class="line"></span><br><span class="line">f(1) = 1</span><br><span class="line">f(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。</span><br><span class="line">f(3) = f(3-1) + f(3-2) + f(3-3) </span><br><span class="line">...</span><br><span class="line">f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) </span><br><span class="line"></span><br><span class="line">再次总结可得</span><br><span class="line"></span><br><span class="line">              | 1       ,(n=0 ) </span><br><span class="line">f(n) =        | 1       ,(n=1 )</span><br><span class="line">              | 2*f(n-1),(n&gt;=2)</span><br></pre></td></tr></table></figure>

<h4 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10. 矩形覆盖"></a>10. 矩形覆盖</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共</span><br><span class="line">有多少种方法？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">依旧是斐波那契数列的应用</span><br></pre></td></tr></table></figure>

<h4 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11. 二进制中1的个数"></a>11. 二进制中1的个数</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">一个不为 0 的整数的二进制表示，一定会有一位为1。我们找到最右边的一位1，当我们将整数减去1时，最右边的一位1变为0，它后</span><br><span class="line">面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位1。因此判断一个二进制中1的个数，我们可以判</span><br><span class="line">断这个数可以经历多少次这样的过程。</span><br><span class="line"></span><br><span class="line">如：1100&amp;1011=1000 </span><br></pre></td></tr></table></figure>

<h4 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12. 数值的整数次方"></a>12. 数值的整数次方</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先我们需要判断 exponent 正负和零取值三种情况，根据不同的情况通过递归来实现。 </span><br></pre></td></tr></table></figure>

<h4 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13. 调整数组顺序使奇数位于偶数前面"></a>13. 调整数组顺序使奇数位于偶数前面</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半</span><br><span class="line">部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">由于需要考虑到调整之后的稳定性，因此我们可以使用辅助数组的方式。首先对数组中的元素进行遍历，每遇到一个奇数就将它加入到</span><br><span class="line">奇数辅助数组中，每遇到一个偶数，就将它将入到偶数辅助数组中。最后再将两个数组合并。这一种方法的时间复杂度为 O(n)，空间</span><br><span class="line">复杂度为 O(n)。</span><br></pre></td></tr></table></figure>

<h4 id="14-链表中倒数第-k-个节点"><a href="#14-链表中倒数第-k-个节点" class="headerlink" title="14. 链表中倒数第 k 个节点"></a>14. 链表中倒数第 k 个节点</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，输出该链表中倒数第 k 个结点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用两个指针，先让第一个和第二个指针都指向头结点，然后再让第二个指针走 k-1 步，到达第 k 个节点。然后两个指针同时向后</span><br><span class="line">移动，当第二个指针到达末尾时，第一个指针指向的就是倒数第 k 个节点了。</span><br></pre></td></tr></table></figure>

<h4 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15. 反转链表"></a>15. 反转链表</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，反转链表后，输出链表的所有元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过设置三个变量 pre、current 和 next，分别用来保存前继节点、当前节点和后继结点。从第一个节点开始向后遍历，首先将当</span><br><span class="line">前节点的后继节点保存到 next 中，然后将当前节点的后继节点设置为 pre，然后再将 pre 设置为当前节点，current 设置为 ne</span><br><span class="line">xt 节点，实现下一次循环。</span><br></pre></td></tr></table></figure>

<h4 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16. 合并两个排序的链表"></a>16. 合并两个排序的链表</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过递归的方式，依次将两个链表的元素递归进行对比。</span><br></pre></td></tr></table></figure>

<h4 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17. 树的子结构"></a>17. 树的子结构</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两棵二叉树A、B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构）</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过递归的思想来解决</span><br><span class="line"></span><br><span class="line">第一步首先从树 A 的根节点开始遍历，在左右子树中找到和树 B 根结点的值一样的结点 R 。</span><br><span class="line">第二步两棵树同时从 R 节点和根节点以相同的遍历方式进行遍历，依次比较对应的值是否相同，当树 B 遍历结束时，结束比较。</span><br></pre></td></tr></table></figure>

<h4 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18. 二叉树的镜像"></a>18. 二叉树的镜像</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">操作给定的二叉树，将其变换为源二叉树的镜像。 </span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">从根节点开始遍历，首先通过临时变量保存左子树的引用，然后将根节点的左右子树的引用交换。然后再递归左右节点的子树交换。</span><br></pre></td></tr></table></figure>

<h4 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19. 顺时针打印矩阵"></a>19. 顺时针打印矩阵</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，</span><br><span class="line">例如，如果输入如下矩阵： 1 2 3 4</span><br><span class="line">										 5 6 7 8 </span><br><span class="line">										 9 10 11 12 </span><br><span class="line">										 13 14 15 16 </span><br><span class="line">则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）根据左上角和右下角可以定位出一次要旋转打印的数据。一次旋转打印结束后，往对角分别前进和后退一个单位，可以确定下一</span><br><span class="line">    次需要打印的数据范围。</span><br><span class="line"></span><br><span class="line">（2）使用模拟魔方逆时针解法，每打印一行，则将矩阵逆时针旋转 90 度，打印下一行，依次重复。</span><br></pre></td></tr></table></figure>

<h4 id="20-定义一个栈，实现-min-函数"><a href="#20-定义一个栈，实现-min-函数" class="headerlink" title="20. 定义一个栈，实现 min 函数"></a>20. 定义一个栈，实现 min 函数</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用一个辅助栈，每次将数据压入数据栈时，就把当前栈里面最小的值压入辅助栈当中。这样辅助栈的栈顶数据一直是数据栈中最小</span><br><span class="line">的值。</span><br></pre></td></tr></table></figure>

<h4 id="21-栈的压入弹出"><a href="#21-栈的压入弹出" class="headerlink" title="21. 栈的压入弹出"></a>21. 栈的压入弹出</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如</span><br><span class="line">序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序</span><br><span class="line">列的弹出序列。（注意：这两个序列的长度是相等的）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们可以使用一个辅助栈的方式来实现，首先遍历压栈顺序，依次将元素压入辅助栈中，每次压入元素后我们首先判断该元素是否与出</span><br><span class="line">栈顺序中的此刻位置的元素相等，如果不相等，则将元素继续压栈，如果相等，则将辅助栈中的栈顶元素出栈，出栈后，将出栈顺序中</span><br><span class="line">的位置后移一位继续比较。当压栈顺序遍历完成后，如果辅助栈不为空，则说明该出栈顺序不正确。</span><br></pre></td></tr></table></figure>

<h4 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22. 从上往下打印二叉树"></a>22. 从上往下打印二叉树</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">从上往下打印出二叉树的每个节点，同层节点从左至右打印。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">本质上是二叉树的层序遍历，可以通过队列来实现。首先将根节点入队。然后对队列进行出队操作，每次出队时，将出队元素的左右子</span><br><span class="line">节点依次加入到队列中，直到队列长度变为 0 时，结束遍历。</span><br></pre></td></tr></table></figure>

<h4 id="23-二叉搜索树的后序遍历"><a href="#23-二叉搜索树的后序遍历" class="headerlink" title="23. 二叉搜索树的后序遍历"></a>23. 二叉搜索树的后序遍历</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes，否则输出 No。假设输入的数组的任意两</span><br><span class="line">个数字都互不相同。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">对于一个合法而二叉树的后序遍历来说，最末尾的元素为根元素。该元素前面的元素可以划分为两个部分，一部分为该元素的左子树，</span><br><span class="line">所有元素的值比根元素小，一部分为该元素的右子树，所有的元素的值比该根元素大。并且每一部分都是一个合法的后序序列，因此我</span><br><span class="line">们可以利用这些特点来递归判断。</span><br></pre></td></tr></table></figure>

<h4 id="24-二叉树中和为某一值路径"><a href="#24-二叉树中和为某一值路径" class="headerlink" title="24. 二叉树中和为某一值路径"></a>24. 二叉树中和为某一值路径</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经</span><br><span class="line">过的结点形成一条路径。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过对树进行深度优先遍历，遍历时保存当前节点的值并判断是否和期望值相等，如果遍历到叶节点不符合要求则回退处理。</span><br></pre></td></tr></table></figure>

<h4 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25. 复杂链表的复制"></a>25. 复杂链表的复制</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为</span><br><span class="line">复制后复杂链表的 head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方式，首先对原有链表每个节点进行复制，通过 next 连接起来。然后当链表复制完成之后，再来设置每个节点的 ra</span><br><span class="line">    ndom 指针，这个时候每个节点的 random 的设置都需要从头结点开始遍历，因此时间的复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种方式，首先对原有链表每个节点进行复制，并且使用 Map 以键值对的方式将原有节点和复制节点保存下来。当链表复</span><br><span class="line">    制完成之后，再来设置每个节点的 random 指针，这个时候我们通过 Map 中的键值关系就可以获取到对应的复制节点，因此</span><br><span class="line">    不必再从头结点遍历，将时间的复杂度降低为了 O(n)，但是空间复杂度变为了 O(n)。这是一种以空间换时间的做法。</span><br><span class="line"></span><br><span class="line">（3）第三种方式，首先对原有链表的每个节点进行复制，并将复制后的节点加入到原有节点的后面。当链表复制完成之后，再进行</span><br><span class="line">    random 指针的设置，由于每个节点后面都跟着自己的复制节点，因此我们可以很容易的获取到 random 指向对应的复制节点</span><br><span class="line">    。最后再将链表分离，通过这种方法我们也能够将时间复杂度降低为 O(n)。</span><br></pre></td></tr></table></figure>

<h4 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26. 二叉搜索树与双向链表"></a>26. 二叉搜索树与双向链表</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">需要生成一个排序的双向列表，那么我们应该通过中序遍历的方式来调整树结构，因为只有中序遍历，返回才是一个从小到大的排序</span><br><span class="line">序列。</span><br><span class="line"></span><br><span class="line">基本的思路是我们首先从根节点开始遍历，先将左子树调整为一个双向链表，并将左子树双向链表的末尾元素的指针指向根节点，并</span><br><span class="line">将根节点的左节点指向末尾节点。再将右子树调整为一个双向链表，并将右子树双向链表的首部元素的指针指向根元素，再将根节点</span><br><span class="line">的右节点指向首部节点。通过对左右子树递归调整，因此来实现排序的双向链表的构建。</span><br></pre></td></tr></table></figure>

<h4 id="27-字符串的排列"><a href="#27-字符串的排列" class="headerlink" title="27. 字符串的排列"></a>27. 字符串的排列</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a,b,c 所能排列出来的所有</span><br><span class="line">字符串 abc,acb,bac,bca,cab 和 cba。输入描述：输入一个字符串，长度不超过9（可能有字符重复），字符只包括大小写字母。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们可以把一个字符串看做是两个部分，第一部分为它的第一个字符，第二部分是它后面的所有字符。求整个字符串的一个全排列，可</span><br><span class="line">以看做两步，第一步是求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换。第二步就是求后面所有字符的一</span><br><span class="line">个全排列。因此通过这种方式，我们可以以递归的思路来求出当前字符串的全排列。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="https://wiki.jikexueyuan.com/project/for-offer/question-twenty-eight.html">《字符串的排列》</a></p>
<h4 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28. 数组中出现次数超过一半的数字"></a>28. 数组中出现次数超过一半的数字</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">数组中有一个数字出现的次数超过数组长度的一半。请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。由于数</span><br><span class="line">字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）对数组进行排序，排序后的中位数就是所求数字。这种方法的时间复杂度取决于我们采用的排序方法的时间复杂度，因此最快为</span><br><span class="line">    O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）由于所求数字的数量超过了数组长度的一半，因此排序后的中位数就是所求数字。因此我们可以将问题简化为求一个数组的中</span><br><span class="line">    位数问题。其实数组并不需要全排序，只需要部分排序。我们通过利用快排中的 partition 函数来实现，我们现在数组中随</span><br><span class="line">    机选取一个数字，而后通过 partition 函数返回该数字在数组中的索引 index，如果 index 刚好等于 n/2，则这个数字</span><br><span class="line">    便是数组的中位数，也即是要求的数，如果 index 大于 n/2，则中位数肯定在 index的左边，在左边继续寻找即可，反之</span><br><span class="line">    在右边寻找。这样可以只在 index 的一边寻找，而不用两边都排序，减少了一半排序时间，这种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）由于该数字的出现次数比所有其他数字出现次数的和还要多，因此可以考虑在遍历数组时保存两个值：一个是数组中的一个数</span><br><span class="line">    字，一个是次数。当遍历到下一个数字时，如果下一个数字与之前保存的数字相同，则次数加1，如果不同，则次数减1，如果</span><br><span class="line">    次数为0，则需要保存下一个数字，并把次数设定为1。由于我们要找的数字出现的次数比其他所有数字的出现次数之和还要大，</span><br><span class="line">    则要找的数字肯定是最后一次把次数设为1时对应的数字。该方法的时间复杂度为O(n)，空间复杂度为 O(1)。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/ns_code/article/details/26957383">《出现次数超过一半的数字》</a></p>
<h4 id="29-最小的-K-个数"><a href="#29-最小的-K-个数" class="headerlink" title="29. 最小的 K 个数"></a>29. 最小的 K 个数</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入 n 个整数，找出其中最小的 K 个数。例如输入 4,5,1,6,2,7,3,8 这8个数字，则最小的4个数字是 1,2,3,4 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是首先将数组排序，排序后再取最小的 k 个数。这一种方法的时间复杂度取决于我们选择的排序算法的时间复杂</span><br><span class="line">    度，最好的情况下为 O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是由于我们只需要获得最小的 k 个数，这 k 个数不一定是按序排序的。因此我们可以使用快速排序中的 part</span><br><span class="line">    ition函数来实现。每一次选择一个枢纽值，将数组分为比枢纽值大和比枢纽值小的两个部分，判断枢纽值的位置，如果该枢</span><br><span class="line">    纽值的位置为 k-1 的话，那么枢纽值和它前面的所有数字就是最小的 k 个数。如果枢纽值的位置小于 k-1 的话，假设枢</span><br><span class="line">    纽值的位置为 n-1，那么我们已经找到了前 n 小的数字了，我们就还需要到后半部分去寻找后半部分 k-n 小的值，进行划</span><br><span class="line">    分。当该枢纽值的位置比 k-1大时，说明最小的 k 个值还在左半部分，我们需要继续对左半部分进行划分。这一种方法的平</span><br><span class="line">    均时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）第三种方法是维护一个容量为 k 的最大堆。对数组进行遍历时，如果堆的容量还没有达到 k ，则直接将元素加入到堆中，这</span><br><span class="line">    就相当于我们假设前 k 个数就是最小的 k 个数。对 k 以后的元素遍历时，我们将该元素与堆的最大值进行比较，如果比最</span><br><span class="line">    大值小，那么我们则将最大值与其交换，然后调整堆。如果大于等于堆的最大值，则继续向后遍历，直到数组遍历完成。这一</span><br><span class="line">    种方法的平均时间复杂度为 O(nlogk)。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="https://www.kancloud.cn/kancloud/the-art-of-programming/41579">《寻找最小的 k 个数》</a></p>
<h4 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30. 连续子数组的最大和"></a>30. 连续子数组的最大和</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后，他又发话了:在古老的一维模式识别中，常常需要计</span><br><span class="line">算连续子向量的最大和,当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的</span><br><span class="line">正数会弥补它呢？例如：&#123;6,-3,-2,7,-15,1,2,2&#125;，连续子向量的最大和为8（从第0个开始，到第3个为止）。你会不会被他忽悠</span><br><span class="line">住？（子向量的长度至少是1）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接暴力求解的方式，先以第一个数字为首往后开始叠加，叠加的过程中保存最大的值。然后再以第二个数字为首</span><br><span class="line">    往后开始叠加，并与先前保存的最大的值进行比较。这一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是，首先我们观察一个最大和的连续数组的规律，我们可以发现，子数组一定是以正数开头的，中间包含了正负数。</span><br><span class="line">    因此我们可以从第一个数开始向后叠加，每次保存最大的值。叠加的值如果为负数，则将叠加值初始化为0，因为后面的数加上负</span><br><span class="line">    数只会更小，因此需要寻找下一个正数开始下一个子数组的判断。一直往后判断，直到这个数组遍历完成为止，得到最大的值。</span><br><span class="line">    使用这一种方法的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-one.html">《连续子数组的最大和》</a></p>
<h4 id="31-整数中1出现的次数（待深入理解）"><a href="#31-整数中1出现的次数（待深入理解）" class="headerlink" title="31. 整数中1出现的次数（待深入理解）"></a>31. 整数中1出现的次数（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">求出1~13的整数中1出现的次数，并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、</span><br><span class="line">12、13因此共出现6次，但是对于后面问题他就没辙了。ACMer希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整</span><br><span class="line">数区间中1出现的次数。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接遍历每个数，然后将判断每个数中 1 的个数，一直叠加。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是求出1出现在每位上的次数，然后进行叠加。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="https://blog.csdn.net/yi_Afly/article/details/52012593">《从1到n整数中1出现的次数：O(logn)算法》</a></p>
<h4 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32. 把数组排成最小的数"></a>32. 把数组排成最小的数</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组&#123;3，32，321</span><br><span class="line">&#125;，则打印出这三个数字能排成的最小数字为321323。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）求出数组的全排列，然后对每个排列结果进行比较。</span><br><span class="line"></span><br><span class="line">（2）利用排序算法实现，但是比较时，比较的并不是两个元素的大小，而是两个元素正序拼接和逆序拼接的大小，如果逆序拼接的</span><br><span class="line">    结果更小，则交换两个元素的位置。排序结束后，数组的顺序则为最小数的排列组合顺序。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-three.html">《把数组排成最小的数》</a></p>
<h4 id="33-丑数（待深入理解）"><a href="#33-丑数（待深入理解）" class="headerlink" title="33. 丑数（待深入理解）"></a>33. 丑数（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">把只包含质因子2、3和5的数称作丑数。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求</span><br><span class="line">按从小到大的顺序的第 N 个丑数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）判断一个数是否为丑数，可以判断该数不断除以2，最后余数是否为1。判断该数不断除以3，最后余数是否为1。判断不断除以</span><br><span class="line">    5，最后余数是否为1。在不考虑时间复杂度的情况下，可以依次遍历找到第 N 个丑数。</span><br><span class="line"></span><br><span class="line">（2）使用一个数组来保存已排序好的丑数，后面的丑数由前面生成。</span><br></pre></td></tr></table></figure>

<h4 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34. 第一个只出现一次的字符"></a>34. 第一个只出现一次的字符</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个字符串（1&lt;=字符串长度&lt;=10000，全部由大写字母组成）中找到第一个只出现一次的字符，并返回它的位置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是，从前往后遍历每一个字符。每遍历一个字符，则将字符与后边的所有字符依次比较，判断是否含有相同字符。这</span><br><span class="line">    一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种思路是，首先对字符串进行一次遍历，将字符和字符出现的次数以键值对的形式存储在 Map 结构中。然后第二次遍历时</span><br><span class="line">    ，去 Map 中获取对应字符出现的次数，找到第一个只出现一次的字符。这一种方法的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure>

<h4 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35. 数组中的逆序对"></a>35. 数组中的逆序对</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对</span><br><span class="line">的总数 P。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种思路是直接求解的方式，顺序扫描整个数组。每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果</span><br><span class="line">    后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有 n 个数字。由于每个数字都要和 O(n）个数字作比</span><br><span class="line">    较，因此这个算法的时间复杂度是 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是使用归并排序的方式，通过利用归并排序分解后进行合并排序时，来进行逆序对的统计，这一种方法的时间复杂</span><br><span class="line">    度为 O(nlogn)。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-six.html">《数组中的逆序对》</a></p>
<h4 id="36-两个链表的第一个公共结点"><a href="#36-两个链表的第一个公共结点" class="headerlink" title="36. 两个链表的第一个公共结点"></a>36. 两个链表的第一个公共结点</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个链表，找出它们的第一个公共结点。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法是在第一个链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个链表上顺序遍历每个结点。如果在第二</span><br><span class="line">    个链表上有一个结点和第一个链表上的结点一样，说明两个链表在这个结点上重合，于是就找到了它们的公共结点。如果第一</span><br><span class="line">    个链表的长度为 m，第二个链表的长度为 n。这一种方法的时间复杂度是 O(mn）。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是利用栈的方式，通过观察我们可以发现两个链表的公共节点，都位于链表的尾部，以此我们可以分别使用两个栈</span><br><span class="line">    ，依次将链表元素入栈。然后在两个栈同时将元素出栈，比较出栈的节点，最后一个相同的节点就是我们要找的公共节点。这</span><br><span class="line">    一种方法的时间复杂度为 O(m+n)，空间复杂度为 O(m+n)。</span><br><span class="line"></span><br><span class="line">（3）第三种方式是，首先分别遍历两个链表，得到两个链表的长度。然后得到较长的链表与较短的链表长度的差值。我们使用两个</span><br><span class="line">    指针来分别对两个链表进行遍历，首先将较长链表的指针移动 n 步，n 为两个链表长度的差值，然后两个指针再同时移动，</span><br><span class="line">    判断所指向节点是否为同一节点。这一种方法的时间复杂度为 O(m+n)，相同对于上一种方法不需要额外的空间。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-thirty-seven.html">《两个链表的第一个公共结点》</a></p>
<h4 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37. 数字在排序数组中出现的次数"></a>37. 数字在排序数组中出现的次数</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">统计一个数字：在排序数组中出现的次数。例如输入排序数组｛ 1, 2, 3, 3, 3, 3, 4, 5｝和数字 3 ，由于 3 在这个数组中出</span><br><span class="line">现了 4 次，因此输出 4 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法是直接对数组顺序遍历的方式，通过这种方法来统计数字的出现次数。这种方法的时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（2）第二种方法是使用二分查找的方法，由于数组是排序好的数组，因此相同数字是排列在一起的。统计数字出现的次数，我们需要</span><br><span class="line">    去找到该段数字开始和结束的位置，以此来确定数字出现的次数。因此我们可以使用二分查找的方式来确定该数字的开始和结束</span><br><span class="line">    位置。如果我们第一次我们数组的中间值为 k ，如果 k 值比所求值大的话，那么我们下一次只需要判断前面一部分就行了，如</span><br><span class="line">    果 k值比所求值小的话，那么我们下一次就只需要判断后面一部分就行了。如果 k 值等于所求值的时候，我们则需要判断该值</span><br><span class="line">    是否为开始位置或者结束位置。如果是开始位置，那么我们下一次需要到后半部分去寻找结束位置。如果是结束位置，那么我们</span><br><span class="line">    下一次需要到前半部分去寻找开始位置。如果既不是开始位置也不是结束位置，那么我们就分别到前后两个部分去寻找开始和结</span><br><span class="line">    束位置。这一种方法的平均时间复杂度为 O(logn)。</span><br></pre></td></tr></table></figure>

<h4 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38. 二叉树的深度"></a>38. 二叉树的深度</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深</span><br><span class="line">度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">根节点的深度等于左右深度较大值加一，因此可以通过递归遍历来实现。</span><br></pre></td></tr></table></figure>

<h4 id="39-平衡二叉树"><a href="#39-平衡二叉树" class="headerlink" title="39. 平衡二叉树"></a>39. 平衡二叉树</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一棵二叉树，判断该二叉树是否是平衡二叉树。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）在遍历树的每个结点的时候，调用函数得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过 1 ，那么它</span><br><span class="line">    就是一棵平衡的二叉树。使用这种方法时，节点会被多次遍历，因此会造成效率不高的问题。</span><br><span class="line"></span><br><span class="line">（2）在求一个节点的深度时，同时判断它是否平衡。如果不平衡则直接返回 -1，否则返回树高度。如果一个节点的一个子树的深</span><br><span class="line">    度为-1，那么就直接向上返回 -1 ，该树已经是不平衡的了。通过这种方式确保了节点只能够被访问一遍。</span><br></pre></td></tr></table></figure>

<h4 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40. 数组中只出现一次的数字"></a>40. 数组中只出现一次的数字</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方式是依次遍历数组，记录下数字出现的次数，从而找出两个只出现一次的数字。</span><br><span class="line"></span><br><span class="line">（2）第二种方式，根据位运算的异或的性质，我们可以知道两个相同的数字异或等于0，一个数和 0 异或还是它本身。由于数组中</span><br><span class="line">    的其他数字都是成对出现的，因此我们可以将数组中的所有数依次进行异或运算。如果只有一个数出现一次的话，那么最后剩下</span><br><span class="line">    的就是落单的数字。如果是两个数只出现了一次的话，那么最后剩下的就是这两个数异或的结果。这个结果中的1表示的是 A 和</span><br><span class="line">    B 不同的位。我们取异或结果的第一个1所在的位数，假如是第3位，接着通过比较第三位来将数组分为两组，相同数字一定会</span><br><span class="line">    被分到同一组。分组完成后再按照依次异或的思路，求得剩余数字即为两个只出现一次的数字。</span><br></pre></td></tr></table></figure>

<h4 id="41-和为-S-的连续正数序列"><a href="#41-和为-S-的连续正数序列" class="headerlink" title="41. 和为 S 的连续正数序列"></a>41. 和为 S 的连续正数序列</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">小明很喜欢数学，有一天他在做数学作业时，要求计算出9~16的和，他马上就写出了正确答案是100。但是他并不满足于此，他在想究</span><br><span class="line">竟有多少种连续的正数序列的和为100（至少包括两个数）。没多久，他就得到另一组连续正数和为100的序列：18,19,20,21,22。</span><br><span class="line">现在把问题交给你，你能不能也很快的找出所有和为 S 的连续正数序列？Good Luck!输出描述：输出所有和为S的连续正数序列。序</span><br><span class="line">列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">维护一个正数序列数组，数组中初始只含有值1和2，然后从3依次往后遍历，每遍历到一个元素则将这个元素加入到序列数组中，然后</span><br><span class="line">判断此时序列数组的和。如果序列数组的和大于所求值，则将第一个元素（最小的元素弹出）。如果序列数组的和小于所求值，则继续</span><br><span class="line">往后遍历，将元素加入到序列中继续判断。当序列数组的和等于所求值时，打印出此时的正数序列，然后继续往后遍历，寻找下一个连</span><br><span class="line">续序列，直到数组遍历完成终止。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-one.html">《和为 s 的连续正数序列》</a></p>
<h4 id="42-和为-S-的两个数字"><a href="#42-和为-S-的两个数字" class="headerlink" title="42. 和为 S 的两个数字"></a>42. 和为 S 的两个数字</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个递增排序的数组和一个数字 S，在数组中查找两个数，是的他们的和正好是 S，如果有多对数字的和等于 S，输出两个数</span><br><span class="line">的乘积最小的。输出描述：对应每个测试案例，输出两个数，小的先输出。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先我们通过规律可以发现，和相同的两个数字，两个数字的差值越大，乘积越小。因此我们只需要从数组的首尾开始找到第一对和</span><br><span class="line">为 s 的数字对进行了。因此我们可以使用双指针的方式，左指针初始指向数组的第一个元素，右指针初始指向数组的最后一个元素</span><br><span class="line">。然后首先判断两个指针指向的数字的和是否为 s ，如果为 s ，两个指针指向的数字就是我们需要寻找的数字对。如果两数的和</span><br><span class="line">比 s 小，则将左指针向左移动一位后继续判断。如果两数的和比 s 大，则将右指针向右移动一位后继续判断。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/wuguanglin/p/FindNumbersWithSum.html">《和为 S 的字符串》</a></p>
<h4 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43. 左旋转字符串"></a>43. 左旋转字符串</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的</span><br><span class="line">字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S=”abcXYZdef”，要求输出循环左移3位后的结果，即 “X</span><br><span class="line">YZdefabc”。是不是很简单？OK，搞定它！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">字符串裁剪后拼接</span><br></pre></td></tr></table></figure>

<h4 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44. 翻转单词顺序列"></a>44. 翻转单词顺序列</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有</span><br><span class="line">一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了</span><br><span class="line">，正确的句子应该是“I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过空格将单词分隔，然后将数组反序后，重新拼接为字符串。</span><br></pre></td></tr></table></figure>

<h4 id="45-扑克牌的顺子"><a href="#45-扑克牌的顺子" class="headerlink" title="45. 扑克牌的顺子"></a>45. 扑克牌的顺子</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有2个大王，2个小王（一副牌原本是54张^_^）...他随机从中抽出</span><br><span class="line">了5张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！“红心 A，黑桃3，小王，大王</span><br><span class="line">，方片5”，“Oh My God!”不是顺子..... LL 不高兴了，他想了想，决定大\小王可以看成任何数字，并且 A 看作1，J 为11，</span><br><span class="line">Q 为12，K 为13。上面的5张牌就可以变成“1,2,3,4,5”（大小王分别看作2和4），“So Lucky!”。LL 决定去买体育彩票啦。</span><br><span class="line">现在，要求你使用这幅牌模拟上面的过程，然后告诉我们 LL 的运气如何。为了方便起见，你可以认为大小王是0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先判断5个数字是不是连续的，最直观的方法是把数组排序。值得注意的是，由于 0 可以当成任意数字，我们可以用 0 去补满数</span><br><span class="line">组中的空缺。如果排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，但只要我们有足够的。可以补满这两个数字的空</span><br><span class="line">缺，这个数组实际上还是连续的。</span><br><span class="line"></span><br><span class="line">于是我们需要做 3 件事情：首先把数组排序，再统计数组中 0 的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。如</span><br><span class="line">果空缺的总数小于或者等于 0 的个数，那么这个数组就是连续的：反之则不连续。最后，我们还需要注意一点：如果数组中的非 0</span><br><span class="line">数字重复出现，则该数组不是连续的。换成扑克牌的描述方式就是如果一副牌里含有对子，则不可能是顺子。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-four.html">《扑克牌的顺子》</a></p>
<h4 id="46-圆圈中最后剩下的数字（约瑟夫环问题）"><a href="#46-圆圈中最后剩下的数字（约瑟夫环问题）" class="headerlink" title="46. 圆圈中最后剩下的数字（约瑟夫环问题）"></a>46. 圆圈中最后剩下的数字（约瑟夫环问题）</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">0, 1, … , n-1 这 n 个数字排成一个圈圈，从数字 0 开始每次从圆圏里删除第 m 个数字。求出这个圈圈里剩下的最后一个数</span><br><span class="line">字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）使用环形链表进行模拟。</span><br><span class="line"></span><br><span class="line">（2）根据规律得出（待深入理解）</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-forty-five.html">《圆圈中最后剩下的数字》</a></p>
<h4 id="47-1-2-3-…-n"><a href="#47-1-2-3-…-n" class="headerlink" title="47. 1+2+3+…+n"></a>47. 1+2+3+…+n</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">求 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">由于不能使用循环语句，因此我们可以通过递归来实现。并且由于不能够使用条件判断运算符，我们可以利用 &amp;&amp; 操作符的短路特</span><br><span class="line">性来实现。</span><br></pre></td></tr></table></figure>

<h4 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48. 不用加减乘除做加法"></a>48. 不用加减乘除做加法</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">写一个函数，求两个整数之和，要求在函数体内不得使用 ＋、－、×、÷ 四则运算符号。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过位运算，递归来实现。</span><br></pre></td></tr></table></figure>

<h4 id="49-把字符串转换成整数。"><a href="#49-把字符串转换成整数。" class="headerlink" title="49. 把字符串转换成整数。"></a>49. 把字符串转换成整数。</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。数值为0或者字符串不是一个合法的数值则返回 0。输入描</span><br><span class="line">述：输入一个字符串，包括数字字母符号，可以为空。输出描述：如果是合法的数值表达则返回该数字，否则返回0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先需要进行符号判断，其次我们根据字符串的每位通过减0运算转换为整数和，依次根据位数叠加。</span><br></pre></td></tr></table></figure>

<h4 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50. 数组中重复的数字"></a>50. 数组中重复的数字</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知</span><br><span class="line">道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）首先将数组排序，排序后再进行判断。这一种方法的时间复杂度为 O(nlogn)。</span><br><span class="line"></span><br><span class="line">（2）使用 Map 结构的方式，依次记录下每一个数字出现的次数，从而可以判断是否出现重复数字。这一种方法的时间复杂度为 O</span><br><span class="line">    (n)，空间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">（3）从数组首部开始遍历，每遍历一个数字，则将该数字和它的下标相比较，如果数字和下标不等，则将该数字和它对应下标的值</span><br><span class="line">    交换。如果对应的下标值上已经是正确的值了，那么说明当前元素是一个重复数字。这一种方法相对于上一种方法来说不需要</span><br><span class="line">    额外的内存空间。</span><br></pre></td></tr></table></figure>
<h4 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51. 构建乘积数组"></a>51. 构建乘积数组</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个数组 A[0,1,...,n-1]，请构建一个数组 B[0,1,...,n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A</span><br><span class="line">[i+1]*...*A[n-1]。不能使用除法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）  C[i]=A[0]×A[1]×...×A[i-1]=C[i-1]×A[i-1] </span><br><span class="line"></span><br><span class="line">      D[i]=A[i+1]×...×A[n-1]=D[i+1]×A[i+1] </span><br><span class="line"></span><br><span class="line">      B[i]=C[i]×D[i]</span><br><span class="line"></span><br><span class="line">      将乘积分为前后两个部分，分别循环求出后，再进行相乘。</span><br><span class="line"></span><br><span class="line">（2）上面的方法需要额外的内存空间，我们可以引入中间变量的方式，来降低空间复杂度。（待深入理解）</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="https://zhuanlan.zhihu.com/p/34804711">《构建乘积数组》</a></p>
<h4 id="52-正则表达式的匹配"><a href="#52-正则表达式的匹配" class="headerlink" title="52. 正则表达式的匹配"></a>52. 正则表达式的匹配</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来匹配包括&#x27;.&#x27;和&#x27;*&#x27;的正则表达式。模式中的字符&#x27;.&#x27;表示任意一个字符，而&#x27;*&#x27;表示它前面的字符可以出现任</span><br><span class="line">意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，</span><br><span class="line">但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）状态机思路（待深入理解）</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-three.html">《正则表达式匹配》</a></p>
<h4 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53. 表示数值的字符串"></a>53. 表示数值的字符串</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-</span><br><span class="line">16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。、</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用正则表达式实现</span><br></pre></td></tr></table></figure>

<h4 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54. 字符流中第一个不重复的字符"></a>54. 字符流中第一个不重复的字符</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 &quot;go&quot; 时，第一个只出现一次</span><br><span class="line">的字符是 &quot;g&quot; 。当从该字符流中读出前六个字符 &quot;google&quot; 时，第一个只出现一次的字符是 &quot;l&quot;。 输出描述：如果当前字符流</span><br><span class="line">没有存在出现一次的字符，返回#字符。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">同第 34 题</span><br></pre></td></tr></table></figure>

<h4 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55. 链表中环的入口结点"></a>55. 链表中环的入口结点</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一个链表中包含环，如何找出环的入口结点？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先使用快慢指针的方式我们可以判断链表中是否存在环，当快慢指针相遇时，说明链表中存在环。相遇点一定存在于环中，因此我</span><br><span class="line">们可以从使用一个指针从这个点开始向前移动，每移动一个点，环的长度加一，当指针再次回到这个点的时候，指针走了一圈，因此</span><br><span class="line">通过这个方法我们可以得到链表中的环的长度，我们将它记为 n 。</span><br><span class="line"></span><br><span class="line">然后我们设置两个指针，首先分别指向头结点，然后将一个指针先移动 n 步，然后两个指针再同时移动，当两个指针相遇时，相遇</span><br><span class="line">点就是环的入口节点。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="http://wiki.jikexueyuan.com/project/for-offer/question-fifty-six.html">《链表中环的入口结点》</a><br>   <a href="https://blog.csdn.net/shansusu/article/details/50285735">《《剑指offer》——链表中环的入口结点》</a></p>
<h4 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56. 删除链表中重复的结点"></a>56. 删除链表中重复的结点</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如，链表1-&gt;2-&gt;3-</span><br><span class="line">&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">解决这个问题的第一步是确定删除的参数。当然这个函数需要输入待删除链表的头结点。头结点可能与后面的结点重复，也就是说头</span><br><span class="line">结点也可能被删除，所以在链表头额外添加一个结点。</span><br><span class="line"></span><br><span class="line">接下来我们从头遍历整个链表。如果当前结点的值与下一个结点的值相同，那么它们就是重复的结点，都可以被删除。为了保证删除</span><br><span class="line">之后的链表仍然是相连的而没有中间断开，我们要把当前的前一个结点和后面值比当前结点的值要大的结点相连。我们要确保 prev</span><br><span class="line">要始终与下一个没有重复的结点连接在一起。</span><br></pre></td></tr></table></figure>

<h4 id="57-二叉树的下一个结点"><a href="#57-二叉树的下一个结点" class="headerlink" title="57. 二叉树的下一个结点"></a>57. 二叉树的下一个结点</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，</span><br><span class="line">还有一个指向父节点的指针。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">这个问题我们可以分为三种情况来讨论。</span><br><span class="line"></span><br><span class="line">第一种情况，当前节点含有右子树，这种情况下，中序遍历的下一个节点为该节点右子树的最左子节点。因此我们只要从右子节点</span><br><span class="line">出发，一直沿着左子节点的指针，就能找到下一个节点。</span><br><span class="line"></span><br><span class="line">第二种情况是，当前节点不含有右子树，并且当前节点为父节点的左子节点，这种情况下中序遍历的下一个节点为当前节点的父节</span><br><span class="line">点。</span><br><span class="line"></span><br><span class="line">第三种情况是，当前节点不含有右子树，并且当前节点为父节点的右子节点，这种情况下我们沿着父节点一直向上查找，直到找到</span><br><span class="line">一个节点，该节点为父节点的左子节点。这个左子节点的父节点就是中序遍历的下一个节点。</span><br></pre></td></tr></table></figure>

<h4 id="58-对称二叉树"><a href="#58-对称二叉树" class="headerlink" title="58. 对称二叉树"></a>58. 对称二叉树</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">我们对一颗二叉树进行前序遍历的时候，是先访问左子节点，然后再访问右子节点。因此我们可以定义一种对称的前序遍历的方式</span><br><span class="line">，就是先访问右子节点，然后再访问左子节点。通过比较两种遍历方式最后的结果是否相同，以此来判断该二叉树是否为对称二叉</span><br><span class="line">树。</span><br></pre></td></tr></table></figure>

<h4 id="59-按之字形顺序打印二叉树（待深入理解）"><a href="#59-按之字形顺序打印二叉树（待深入理解）" class="headerlink" title="59. 按之字形顺序打印二叉树（待深入理解）"></a>59. 按之字形顺序打印二叉树（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，即第一行按照</span><br><span class="line">从左到右的顺序打印，第二层按照从右到左顺序打印，第三行再按照从左到右的顺序打印，其他以此类推。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">按之字形顺序打印二叉树需要两个栈。我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。如果当前打印的是奇数层</span><br><span class="line">，则先保存左子结点再保存右子结点到一个栈里；如果当前打印的是偶数层，则先保存右子结点再保存左子结点到第二个栈里。每</span><br><span class="line">一个栈遍历完成后进入下一层循环。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="https://www.cnblogs.com/wuguanglin/p/Print.html">《按之字形顺序打印二叉树》</a></p>
<h4 id="60-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。"><a href="#60-从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。" class="headerlink" title="60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。"></a>60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印一行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">用一个队列来保存将要打印的结点。为了把二叉树的每一行单独打印到一行里，我们需要两个变量：一个变量表示在当前的层中还</span><br><span class="line">没有打印的结点数，另一个变量表示下一次结点的数目。</span><br></pre></td></tr></table></figure>

<h4 id="61-序列化二叉树（待深入理解）"><a href="#61-序列化二叉树（待深入理解）" class="headerlink" title="61. 序列化二叉树（待深入理解）"></a>61. 序列化二叉树（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现两个函数，分别用来序列化和反序列化二叉树。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">数组模拟</span><br></pre></td></tr></table></figure>

<h4 id="62-二叉搜索树的第-K-个节点"><a href="#62-二叉搜索树的第-K-个节点" class="headerlink" title="62. 二叉搜索树的第 K 个节点"></a>62. 二叉搜索树的第 K 个节点</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一颗二叉搜索树，请找出其中的第 k 小的结点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">对一颗树首先进行中序遍历，在遍历的同时记录已经遍历的节点数，当遍历到第 k 个节点时，这个节点即为第 k 大的节点。</span><br></pre></td></tr></table></figure>

<h4 id="63-数据流中的中位数（待深入理解）"><a href="#63-数据流中的中位数（待深入理解）" class="headerlink" title="63. 数据流中的中位数（待深入理解）"></a>63. 数据流中的中位数（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有值排序之后位于中间的数值。如果数据</span><br><span class="line">流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="64-滑动窗口中的最大值（待深入理解）"><a href="#64-滑动窗口中的最大值（待深入理解）" class="headerlink" title="64. 滑动窗口中的最大值（待深入理解）"></a>64. 滑动窗口中的最大值（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组&#123;2,3,4,2,6,2,5,1&#125;及滑动窗口的</span><br><span class="line">大小3，那么一共存在6个滑动窗口，他们的最大值分别为&#123;4,4,6,6,6,5&#125;； 针对数组&#123;2,3,4,2,6,2,5,1&#125;的滑动窗口有以下</span><br><span class="line">6个： &#123;[2,3,4],2,6,2,5,1&#125;， &#123;2,[3,4,2],6,2,5,1&#125;， &#123;2,3,[4,2,6],2,5,1&#125;， &#123;2,3,4,[2,6,2],5,1&#125;， &#123;2</span><br><span class="line">,3,4,2,[6,2,5],1&#125;， &#123;2,3,4,2,6,[2,5,1]&#125;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用队列的方式模拟</span><br></pre></td></tr></table></figure>

<h4 id="65-矩阵中的路径（待深入理解）"><a href="#65-矩阵中的路径（待深入理解）" class="headerlink" title="65. 矩阵中的路径（待深入理解）"></a>65. 矩阵中的路径（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每</span><br><span class="line">一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子</span><br><span class="line">。例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的</span><br><span class="line">第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</span><br></pre></td></tr></table></figure>

<h4 id="66-机器人的运动范围（待深入理解）"><a href="#66-机器人的运动范围（待深入理解）" class="headerlink" title="66. 机器人的运动范围（待深入理解）"></a>66. 机器人的运动范围（待深入理解）</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能</span><br><span class="line">进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是</span><br><span class="line">，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</span><br></pre></td></tr></table></figure>


<p>剑指 offer 相关资料可以参考：<br><a href="https://blog.csdn.net/zzl819954692/article/details/79648054">《剑指 offer 题目练习及思路分析》</a><br><a href="https://www.cnblogs.com/wuguanglin/p/code-interview.html">《JS 版剑指 offer》</a><br><a href="https://wiki.jikexueyuan.com/project/for-offer/">《剑指 Offer 学习心得》</a></p>
<h2 id="相关算法题"><a href="#相关算法题" class="headerlink" title="相关算法题"></a>相关算法题</h2><h4 id="1-明星问题"><a href="#1-明星问题" class="headerlink" title="1. 明星问题"></a>1. 明星问题</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">有 n 个人，其中一个明星和 n-1 个群众，群众都认识明星，明星不认识任何群众，群众和群众之间的认识关系不知道，现有一个</span><br><span class="line">函数 foo(A, B)，若 A 认识 B 返回 true，若 A 不认识 B 返回 false，试设计一种算法找出明星，并给出时间复杂度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）第一种方法我们可以直接使用双层循环遍历的方式，每一个人都和其他人进行判断，如果一个人谁都不认识，那么他就是明星。</span><br><span class="line">    这一种方法的时间复杂度为 O(n^2)。</span><br><span class="line"></span><br><span class="line">（2）上一种方法没有充分利用题目所给的条件，其实我们每一次比较，都可以排除一个人的可能。比如如果 A 认识 B，那么说明</span><br><span class="line">    A 就不会是明星，因此 A 就可以从数组中移除。如果 A 不认识 B，那么说明 B 不可能是明星，因此 B 就可以从数组中移</span><br><span class="line">    除。因此每一次判断都能够减少一个可能性，我们只需要从数组从前往后进行遍历，每次移除一个不可能的人，直到数组中只剩</span><br><span class="line">    一人为止，那么这个人就是明星。这一种方法的时间复杂度为 O(n)。</span><br></pre></td></tr></table></figure>
<p>   详细资料可以参考：<br>   <a href="https://www.nowcoder.com/questionTerminal/fd3caff374c945fb9ea5f107016bcd4f">《一个明星和 n-1 个群众》</a></p>
<h4 id="2-正负数组求和"><a href="#2-正负数组求和" class="headerlink" title="2. 正负数组求和"></a>2. 正负数组求和</h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">有两个数组，一个数组里存放的是正整数，另一个数组里存放的是负整数，都是无序的，现在从两个数组里各拿一个，使得它们的和</span><br><span class="line">最接近零。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）首先我们可以对两个数组分别进行排序，正数数组按从小到大排序，负数数组按从大到小排序。排序完成后我们使用两个指针分</span><br><span class="line">    别指向两个数组的首部，判断两个指针的和。如果和大于0，则负数指针往后移动一个位置，如果和小于0，则正数指针往后移动</span><br><span class="line">    一个位置，每一次记录和的值，和当前保存下来的最小值进行比较。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode配置</title>
    <url>/2021/06/01/20210601-setting.json/</url>
    <content><![CDATA[<p>每次新设备都要搞一下编译器的配置，比如eslint-autoFixOnSave和美化插件啥的，特地全记录下。</p>
<span id="more"></span>

<p>更新一下，最近搞react有点懵。</p>
<p>先mark一篇文章，看了许多，这个是写的比较全面的：<a href="https://juejin.cn/post/6860129883398668296#heading-10">我是这样搭建 React+Typescript项目环境的</a></p>
<p>个人感觉写的挺不错，对我来说prettier那块非常实用。eslint的以后再说吧。</p>
<p><code>setting.json</code>写在<code>.vscod</code>文件夹下只对当前项目生效。</p>
<h3 id="Vue根据项目的-eslintrc-js来格式化代码时，使用下面setting-json配置："><a href="#Vue根据项目的-eslintrc-js来格式化代码时，使用下面setting-json配置：" class="headerlink" title="Vue根据项目的.eslintrc.js来格式化代码时，使用下面setting.json配置："></a>Vue根据项目的<code>.eslintrc.js</code>来格式化代码时，使用下面<code>setting.json</code>配置：</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;stylelint.enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;eslint.validate&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;html&quot;</span><span class="punctuation">,</span> <span class="string">&quot;vue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;javascript&quot;</span><span class="punctuation">,</span> <span class="string">&quot;jsx&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="comment">// &quot;eslint.autoFixOnSave&quot;: true,</span></span><br><span class="line">	<span class="attr">&quot;emmet.syntaxProfiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;vue-html&quot;</span><span class="punctuation">:</span> <span class="string">&quot;html&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;html&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;editor.wordWrapColumn&quot;</span><span class="punctuation">:</span> <span class="number">220</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;editor.codeActionsOnSave&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;source.fixAll.eslint&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="prettier格式化代码："><a href="#prettier格式化代码：" class="headerlink" title="prettier格式化代码："></a>prettier格式化代码：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .prettierrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;trailingComma&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tabWidth&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;endOfLine&quot;</span>: <span class="string">&quot;lf&quot;</span>,</span><br><span class="line">  <span class="string">&quot;printWidth&quot;</span>: <span class="number">120</span>,</span><br><span class="line">  <span class="string">&quot;bracketSpacing&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;arrowParens&quot;</span>: <span class="string">&quot;always&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setting.json</span></span><br><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">  <span class="comment">// 指定哪些文件不参与搜索</span></span><br><span class="line">  <span class="attr">&quot;search.exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;**/node_modules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dist&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;yarn.lock&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[javascript]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[javascriptreact]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[typescript]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[typescriptreact]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[json]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[html]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[markdown]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[css]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[less]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[scss]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>插件列表：</p>
<p>Auto Close Tag</p>
<p>Beautify</p>
<p>Bracket Pair Colorizer</p>
<p>Chinese</p>
<p>ESLint</p>
<p>Git History</p>
<p>GitLens</p>
<p>Live Server</p>
<p>Prettier</p>
<p>TODO Highlight</p>
<p>Vetur</p>
<p>注意在配置settings.json时，有三个<code>srttings.json</code>，一个是工作区(working space settings.json)的，一个是默认(default settings.json)的，一个是IDE(settings.json)的，这个配置适合IDE的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setting.json 更新2021/07/07 新配置了字体等信息</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;eslint.validate&quot;</span>: [<span class="string">&quot;html&quot;</span>, <span class="string">&quot;vue&quot;</span>, <span class="string">&quot;javascript&quot;</span>, <span class="string">&quot;jsx&quot;</span>],</span><br><span class="line">	<span class="string">&quot;editor.wordWrapColumn&quot;</span>: <span class="number">220</span>,</span><br><span class="line">	<span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在编辑器中显示 CodeLens。</span></span><br><span class="line">	<span class="string">&quot;diffEditor.codeLens&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，差异编辑器将忽略前导空格或尾随空格中的更改。</span></span><br><span class="line">	<span class="string">&quot;diffEditor.ignoreTrimWhitespace&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 超时(以毫秒为单位)，之后将取消差异计算。使用0表示没有超时。</span></span><br><span class="line">	<span class="string">&quot;diffEditor.maxComputationTime&quot;</span>: <span class="number">5000</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制差异编辑器是否为添加/删除的更改显示 +/- 指示符号。</span></span><br><span class="line">	<span class="string">&quot;diffEditor.renderIndicators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制差异编辑器的显示方式是并排还是内联。</span></span><br><span class="line">	<span class="string">&quot;diffEditor.renderSideBySide&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否应在遇到提交字符时接受建议。例如，在 JavaScript 中，半角分号 (`;`) 可以为提交字符，能够在接受建议的同时键入该字符。</span></span><br><span class="line">	<span class="string">&quot;editor.acceptSuggestionOnCommitCharacter&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制除了 `Tab` 键以外， `Enter` 键是否同样可以接受建议。这能减少“插入新行”和“接受建议”命令之间的歧义。</span></span><br><span class="line">	<span class="comment">//  - on</span></span><br><span class="line">	<span class="comment">//  - smart: 仅当建议包含文本改动时才可使用 `Enter` 键进行接受。</span></span><br><span class="line">	<span class="comment">//  - off</span></span><br><span class="line">	<span class="string">&quot;editor.acceptSuggestionOnEnter&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器中可由屏幕阅读器读取的行数。警告: 对于大于默认值的数字，这会影响性能。</span></span><br><span class="line">	<span class="string">&quot;editor.accessibilityPageSize&quot;</span>: <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否应在对屏幕阅读器进行了优化的模式下运行。设置为“开”将禁用自动换行。</span></span><br><span class="line">	<span class="comment">//  - auto: 编辑器将使用平台 API 以检测是否附加了屏幕阅读器。</span></span><br><span class="line">	<span class="comment">//  - on: 编辑器将针对与屏幕阅读器搭配使用进行永久优化。将禁用自动换行。</span></span><br><span class="line">	<span class="comment">//  - off: 编辑器将不再对屏幕阅读器的使用进行优化。</span></span><br><span class="line">	<span class="string">&quot;editor.accessibilitySupport&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否在左括号后自动插入右括号。</span></span><br><span class="line">	<span class="comment">//  - always</span></span><br><span class="line">	<span class="comment">//  - languageDefined: 使用语言配置确定何时自动闭合括号。</span></span><br><span class="line">	<span class="comment">//  - beforeWhitespace: 仅当光标位于空白字符左侧时，才自动闭合括号。</span></span><br><span class="line">	<span class="comment">//  - never</span></span><br><span class="line">	<span class="string">&quot;editor.autoClosingBrackets&quot;</span>: <span class="string">&quot;languageDefined&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否应改写右引号或右括号。</span></span><br><span class="line">	<span class="comment">//  - always</span></span><br><span class="line">	<span class="comment">//  - auto: 仅在自动插入时才改写右引号或右括号。</span></span><br><span class="line">	<span class="comment">//  - never</span></span><br><span class="line">	<span class="string">&quot;editor.autoClosingOvertype&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否在左引号后自动插入右引号。</span></span><br><span class="line">	<span class="comment">//  - always</span></span><br><span class="line">	<span class="comment">//  - languageDefined: 使用语言配置确定何时自动闭合引号。</span></span><br><span class="line">	<span class="comment">//  - beforeWhitespace: 仅当光标位于空白字符左侧时，才自动闭合引号。</span></span><br><span class="line">	<span class="comment">//  - never</span></span><br><span class="line">	<span class="string">&quot;editor.autoClosingQuotes&quot;</span>: <span class="string">&quot;languageDefined&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否应在用户键入、粘贴、移动或缩进行时自动调整缩进。</span></span><br><span class="line">	<span class="comment">//  - none: 编辑器不会自动插入缩进。</span></span><br><span class="line">	<span class="comment">//  - keep: 编辑器将保留当前行的缩进。</span></span><br><span class="line">	<span class="comment">//  - brackets: 编辑器将保留当前行的缩进并遵循语言定义的括号。</span></span><br><span class="line">	<span class="comment">//  - advanced: 编辑器将保留当前行的缩进、使用语言定义的括号并调用语言定义的特定 onEnterRules。</span></span><br><span class="line">	<span class="comment">//  - full: 编辑器将保留当前行的缩进，使用语言定义的括号，调用由语言定义的特殊输入规则，并遵循由语言定义的缩进规则。</span></span><br><span class="line">	<span class="string">&quot;editor.autoIndent&quot;</span>: <span class="string">&quot;full&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在键入引号或方括号时，编辑器是否应自动将所选内容括起来。</span></span><br><span class="line">	<span class="comment">//  - languageDefined: 使用语言配置确定何时自动包住所选内容。</span></span><br><span class="line">	<span class="comment">//  - quotes: 使用引号而非括号来包住所选内容。</span></span><br><span class="line">	<span class="comment">//  - brackets: 使用括号而非引号来包住所选内容。</span></span><br><span class="line">	<span class="comment">//  - never</span></span><br><span class="line">	<span class="string">&quot;editor.autoSurround&quot;</span>: <span class="string">&quot;languageDefined&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在保存时运行的代码操作类型。</span></span><br><span class="line">	<span class="comment">// &quot;editor.codeActionsOnSave&quot;: &#123;</span></span><br><span class="line">	<span class="comment">// 	&quot;source.fixAll.eslint&quot;: true</span></span><br><span class="line">	<span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在编辑器中显示 CodeLens。</span></span><br><span class="line">	<span class="string">&quot;editor.codeLens&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否显示内联颜色修饰器和颜色选取器。</span></span><br><span class="line">	<span class="string">&quot;editor.colorDecorators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用使用鼠标和键进行列选择。</span></span><br><span class="line">	<span class="string">&quot;editor.columnSelection&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在对行注释执行切换、添加或删除操作时，是否应忽略空行。</span></span><br><span class="line">	<span class="string">&quot;editor.comments.ignoreEmptyLines&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在注释时是否插入空格字符。</span></span><br><span class="line">	<span class="string">&quot;editor.comments.insertSpace&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在复制时是否同时复制语法高亮。</span></span><br><span class="line">	<span class="string">&quot;editor.copyWithSyntaxHighlighting&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制光标的动画样式。</span></span><br><span class="line">	<span class="string">&quot;editor.cursorBlinking&quot;</span>: <span class="string">&quot;blink&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否启用平滑插入动画。</span></span><br><span class="line">	<span class="string">&quot;editor.cursorSmoothCaretAnimation&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制光标样式。</span></span><br><span class="line">	<span class="string">&quot;editor.cursorStyle&quot;</span>: <span class="string">&quot;line&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制光标周围可见的前置行和尾随行的最小数目。在其他一些编辑器中称为 &quot;scrollOff&quot; 或 &quot;scrollOffset&quot;。</span></span><br><span class="line">	<span class="string">&quot;editor.cursorSurroundingLines&quot;</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制何时应强制执行&quot;光标环绕行&quot;。</span></span><br><span class="line">	<span class="comment">//  - default: 仅当通过键盘或 API 触发时，才会强制执行&quot;光标环绕行&quot;。</span></span><br><span class="line">	<span class="comment">//  - all: 始终强制执行 &quot;cursorSurroundingLines&quot;</span></span><br><span class="line">	<span class="string">&quot;editor.cursorSurroundingLinesStyle&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当 `editor.cursorStyle` 设置为 `line` 时，控制光标的宽度。</span></span><br><span class="line">	<span class="string">&quot;editor.cursorWidth&quot;</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个默认格式化程序, 该格式化程序优先于所有其他格式化程序设置。必须是提供格式化程序的扩展的标识符。</span></span><br><span class="line">	<span class="comment">//  - null: 没有</span></span><br><span class="line">	<span class="comment">//  - vscode.configuration-editing: 在配置文件 (如设置、启动和扩展推荐文件) 中提供高级 IntelliSense、自动修复等功能</span></span><br><span class="line">	<span class="comment">//  - vscode.css-language-features: 为 CSS、LESS 和 SCSS 文件提供丰富的语言支持。</span></span><br><span class="line">	<span class="comment">//  - vscode.debug-auto-launch: 当 node-debug 扩展未启用时提供自动附加的辅助程序。</span></span><br><span class="line">	<span class="comment">//  - vscode.debug-server-ready: 如果正在调试的服务器已准备就绪，在浏览器中打开 URI。</span></span><br><span class="line">	<span class="comment">//  - vscode.emmet: 适用于 VS Code 的 Emmet 支持</span></span><br><span class="line">	<span class="comment">//  - vscode.extension-editing: 在创建扩展时提供 linting 功能。</span></span><br><span class="line">	<span class="comment">//  - vscode.git: Git 源代码管理集成</span></span><br><span class="line">	<span class="comment">//  - vscode.git-ui: Git SCM UI 集成</span></span><br><span class="line">	<span class="comment">//  - vscode.github: GitHub</span></span><br><span class="line">	<span class="comment">//  - vscode.github-authentication: GitHub 身份验证提供程序</span></span><br><span class="line">	<span class="comment">//  - vscode.grunt: Extension to add Grunt capabilities to VS Code.</span></span><br><span class="line">	<span class="comment">//  - vscode.gulp: 向 VSCode 提供 Gulp 功能的扩展。</span></span><br><span class="line">	<span class="comment">//  - vscode.html-language-features: 为 HTML 和 Handlebar 文件提供丰富的语言支持</span></span><br><span class="line">	<span class="comment">//  - vscode.image-preview: 提供 VS Code的内置图像预览</span></span><br><span class="line">	<span class="comment">//  - vscode.jake: 向 VS Code 提供 Jake 功能的扩展。</span></span><br><span class="line">	<span class="comment">//  - vscode.json-language-features: 为 JSON 文件提供丰富的语言支持</span></span><br><span class="line">	<span class="comment">//  - vscode.markdown-language-features: 为 Markdown 提供丰富的语言支持。</span></span><br><span class="line">	<span class="comment">//  - vscode.merge-conflict: 为内联合并冲突提供高亮和命令。</span></span><br><span class="line">	<span class="comment">//  - vscode.microsoft-authentication: Microsoft 身份验证提供程序</span></span><br><span class="line">	<span class="comment">//  - ms-vscode.js-debug: An extension for debugging Node.js programs and Chrome.</span></span><br><span class="line">	<span class="comment">//  - ms-vscode.js-debug-companion: Companion extension to js-debug that provides capability for remote debugging</span></span><br><span class="line">	<span class="comment">//  - ms-vscode.node-debug: Node.js 调试支持(低于 8.0 版本)</span></span><br><span class="line">	<span class="comment">//  - ms-vscode.node-debug2: Node.js 调试支持</span></span><br><span class="line">	<span class="comment">//  - ms-vscode.references-view: Reference Search results as separate, stable view in the sidebar</span></span><br><span class="line">	<span class="comment">//  - ms-vscode.vscode-js-profile-table: Text visualizer for profiles taken from the JavaScript debugger</span></span><br><span class="line">	<span class="comment">//  - vscode.npm: 为 npm 脚本提供任务支持的扩展。</span></span><br><span class="line">	<span class="comment">//  - vscode.php-language-features: 为 PHP 文件提供丰富的语言支持。</span></span><br><span class="line">	<span class="comment">//  - vscode.python: 在 Python 文件中提供语法高亮、括号匹配和折叠功能。</span></span><br><span class="line">	<span class="comment">//  - vscode.search-result: 为选项卡搜索结果中提供语法突出显示和语言功能。</span></span><br><span class="line">	<span class="comment">//  - vscode.typescript-language-features: 为 JavaScript 和 TypeScript 提供丰富的语言支持。</span></span><br><span class="line">	<span class="comment">//  - CoenraadS.bracket-pair-colorizer: A customizable extension for colorizing matching brackets</span></span><br><span class="line">	<span class="comment">//  - dbaeumer.vscode-eslint: Integrates ESLint JavaScript into VS Code.</span></span><br><span class="line">	<span class="comment">//  - esbenp.prettier-vscode: Code formatter using prettier</span></span><br><span class="line">	<span class="comment">//  - formulahendry.auto-close-tag: Automatically add HTML/XML close tag, same as Visual Studio IDE or Sublime Text</span></span><br><span class="line">	<span class="comment">//  - HookyQR.beautify: Beautify code in place for VS Code</span></span><br><span class="line">	<span class="comment">//  - octref.vetur: Vue tooling for VS Code</span></span><br><span class="line">	<span class="comment">//  - ritwickdey.LiveServer: Launch a development local Server with live reload feature for static &amp; dynamic pages</span></span><br><span class="line">	<span class="comment">//  - wayou.vscode-todo-highlight: highlight TODOs, FIXMEs, and any keywords, annotations...</span></span><br><span class="line">	<span class="string">&quot;editor.defaultFormatter&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制&quot;转到定义&quot;鼠标手势是否始终打开预览小部件。</span></span><br><span class="line">	<span class="string">&quot;editor.definitionLinkOpensInPeek&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在打开文件时，基于文件内容自动检测 `editor.tabSize#` 和 `#editor.insertSpaces`。</span></span><br><span class="line">	<span class="string">&quot;editor.detectIndentation&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在编辑器中是否允许通过拖放来移动选中内容。</span></span><br><span class="line">	<span class="string">&quot;editor.dragAndDrop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在没有选择内容时进行复制是否复制当前行。</span></span><br><span class="line">	<span class="string">&quot;editor.emptySelectionClipboard&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按下&quot;Alt&quot;时滚动速度倍增。</span></span><br><span class="line">	<span class="string">&quot;editor.fastScrollSensitivity&quot;</span>: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制 &quot;查找小部件&quot; 是否应在编辑器顶部添加额外的行。如果为 true, 则可以在 &quot;查找小工具&quot; 可见时滚动到第一行之外。</span></span><br><span class="line">	<span class="string">&quot;editor.find.addExtraSpaceOnTop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在所选内容中自动开启查找的条件。</span></span><br><span class="line">	<span class="comment">//  - never: 切勿自动打开“选择中查找”(默认)</span></span><br><span class="line">	<span class="comment">//  - always: 始终自动打开“在选择中查找”</span></span><br><span class="line">	<span class="comment">//  - multiline: 选择多行内容时，自动打开“在选择中查找”。</span></span><br><span class="line">	<span class="string">&quot;editor.find.autoFindInSelection&quot;</span>: <span class="string">&quot;never&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在键入时光标是否应跳转以查找匹配项。</span></span><br><span class="line">	<span class="string">&quot;editor.find.cursorMoveOnType&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在找不到其他匹配项时，是否自动从开头(或结尾)重新开始搜索。</span></span><br><span class="line">	<span class="string">&quot;editor.find.loop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否将编辑器选中内容作为搜索词填入到查找小组件中。</span></span><br><span class="line">	<span class="string">&quot;editor.find.seedSearchStringFromSelection&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否启用了代码折叠。</span></span><br><span class="line">	<span class="string">&quot;editor.folding&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否应突出显示折叠范围。</span></span><br><span class="line">	<span class="string">&quot;editor.foldingHighlight&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制计算折叠范围的策略。</span></span><br><span class="line">	<span class="comment">//  - auto: 使用特定于语言的折叠策略(如果可用)，否则使用基于缩进的策略。</span></span><br><span class="line">	<span class="comment">//  - indentation: 使用基于缩进的折叠策略。</span></span><br><span class="line">	<span class="string">&quot;editor.foldingStrategy&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制字体系列。</span></span><br><span class="line">	<span class="comment">// &quot;editor.fontFamily&quot;: &quot;Consolas, &#x27;Courier New&#x27;, monospace&quot;,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置字体连字或字体功能。</span></span><br><span class="line">	<span class="comment">// &quot;editor.fontLigatures&quot;: false,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制字体大小(像素)。</span></span><br><span class="line">	<span class="comment">// &quot;editor.fontSize&quot;: 14,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制字体粗细。接受关键字“正常”和“加粗”，或者接受介于 1 至 1000 之间的数字。</span></span><br><span class="line">	<span class="string">&quot;editor.fontWeight&quot;</span>: <span class="string">&quot;normal&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否自动格式化粘贴的内容。格式化程序必须可用，并且能针对文档中的某一范围进行格式化。</span></span><br><span class="line">	<span class="string">&quot;editor.formatOnPaste&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在保存时格式化文件。格式化程序必须可用，延迟后文件不能保存，并且编辑器不能关闭。</span></span><br><span class="line">	<span class="string">&quot;editor.formatOnSave&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在保存时设置格式是设置整个文件格式还是仅设置修改内容的格式。仅当 &quot;#editor.formatOnSave#&quot; 为 &quot;true&quot; 时应用。</span></span><br><span class="line">	<span class="comment">//  - file: 设置整个文件的格式。</span></span><br><span class="line">	<span class="comment">//  - modifications: 格式修改(需要源代码管理)。</span></span><br><span class="line">	<span class="string">&quot;editor.formatOnSaveMode&quot;</span>: <span class="string">&quot;file&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器在键入一行后是否自动格式化该行。</span></span><br><span class="line">	<span class="string">&quot;editor.formatOnType&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否应呈现垂直字形边距。字形边距最常用于调试。</span></span><br><span class="line">	<span class="string">&quot;editor.glyphMargin&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当&quot;转到声明&quot;的结果为当前位置时将要执行的替代命令的 ID。</span></span><br><span class="line">	<span class="string">&quot;editor.gotoLocation.alternativeDeclarationCommand&quot;</span>: <span class="string">&quot;editor.action.goToReferences&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当&quot;转到定义&quot;的结果为当前位置时将要执行的替代命令的 ID。</span></span><br><span class="line">	<span class="string">&quot;editor.gotoLocation.alternativeDefinitionCommand&quot;</span>: <span class="string">&quot;editor.action.goToReferences&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当&quot;转到实现&quot;的结果为当前位置时将要执行的替代命令的 ID。</span></span><br><span class="line">	<span class="string">&quot;editor.gotoLocation.alternativeImplementationCommand&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当&quot;转到引用&quot;的结果是当前位置时正在执行的替代命令 ID。</span></span><br><span class="line">	<span class="string">&quot;editor.gotoLocation.alternativeReferenceCommand&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当&quot;转到类型定义&quot;的结果是当前位置时正在执行的备用命令 ID。</span></span><br><span class="line">	<span class="string">&quot;editor.gotoLocation.alternativeTypeDefinitionCommand&quot;</span>: <span class="string">&quot;editor.action.goToReferences&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此设置已弃用，请改用单独的设置，如&quot;editor.editor.gotoLocation.multipleDefinitions&quot;或&quot;editor.editor.gotoLocation.multipleImplementations&quot;。</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="string">&quot;editor.gotoLocation.multiple&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制存在多个目标位置时&quot;转到声明&quot;命令的行为。</span></span><br><span class="line">	<span class="comment">//  - peek: 显示结果的预览视图 (默认值)</span></span><br><span class="line">	<span class="comment">//  - gotoAndPeek: 转到主结果并显示预览视图</span></span><br><span class="line">	<span class="comment">//  - goto: 转到主结果，并对其他人启用防偷窥导航</span></span><br><span class="line">	<span class="string">&quot;editor.gotoLocation.multipleDeclarations&quot;</span>: <span class="string">&quot;peek&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制存在多个目标位置时&quot;转到定义&quot;命令的行为。</span></span><br><span class="line">	<span class="comment">//  - peek: 显示结果的预览视图 (默认值)</span></span><br><span class="line">	<span class="comment">//  - gotoAndPeek: 转到主结果并显示预览视图</span></span><br><span class="line">	<span class="comment">//  - goto: 转到主结果，并对其他人启用防偷窥导航</span></span><br><span class="line">	<span class="string">&quot;editor.gotoLocation.multipleDefinitions&quot;</span>: <span class="string">&quot;peek&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制存在多个目标位置时&quot;转到实现&quot;命令的行为。</span></span><br><span class="line">	<span class="comment">//  - peek: 显示结果的预览视图 (默认值)</span></span><br><span class="line">	<span class="comment">//  - gotoAndPeek: 转到主结果并显示预览视图</span></span><br><span class="line">	<span class="comment">//  - goto: 转到主结果，并对其他人启用防偷窥导航</span></span><br><span class="line">	<span class="string">&quot;editor.gotoLocation.multipleImplementations&quot;</span>: <span class="string">&quot;peek&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制存在多个目标位置时&quot;转到引用&quot;命令的行为。</span></span><br><span class="line">	<span class="comment">//  - peek: 显示结果的预览视图 (默认值)</span></span><br><span class="line">	<span class="comment">//  - gotoAndPeek: 转到主结果并显示预览视图</span></span><br><span class="line">	<span class="comment">//  - goto: 转到主结果，并对其他人启用防偷窥导航</span></span><br><span class="line">	<span class="string">&quot;editor.gotoLocation.multipleReferences&quot;</span>: <span class="string">&quot;peek&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制存在多个目标位置时&quot;转到类型定义&quot;命令的行为。</span></span><br><span class="line">	<span class="comment">//  - peek: 显示结果的预览视图 (默认值)</span></span><br><span class="line">	<span class="comment">//  - gotoAndPeek: 转到主结果并显示预览视图</span></span><br><span class="line">	<span class="comment">//  - goto: 转到主结果，并对其他人启用防偷窥导航</span></span><br><span class="line">	<span class="string">&quot;editor.gotoLocation.multipleTypeDefinitions&quot;</span>: <span class="string">&quot;peek&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在概览标尺中隐藏光标。</span></span><br><span class="line">	<span class="string">&quot;editor.hideCursorInOverviewRuler&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否突出显示编辑器中活动的缩进参考线。</span></span><br><span class="line">	<span class="string">&quot;editor.highlightActiveIndentGuide&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制显示悬停提示前的等待时间 (毫秒)。</span></span><br><span class="line">	<span class="string">&quot;editor.hover.delay&quot;</span>: <span class="number">300</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否显示悬停提示。</span></span><br><span class="line">	<span class="string">&quot;editor.hover.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制当鼠标移动到悬停提示上时，其是否保持可见。</span></span><br><span class="line">	<span class="string">&quot;editor.hover.sticky&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按 `Tab` 键时插入空格。该设置在 `editor.detectIndentation` 启用时根据文件内容可能会被覆盖。</span></span><br><span class="line">	<span class="string">&quot;editor.insertSpaces&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对大型文件进行特殊处理，禁用某些内存密集型功能。</span></span><br><span class="line">	<span class="string">&quot;editor.largeFileOptimizations&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制字母间距(像素)。</span></span><br><span class="line">	<span class="string">&quot;editor.letterSpacing&quot;</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在编辑器中启用代码操作小灯泡提示。</span></span><br><span class="line">	<span class="string">&quot;editor.lightbulb.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制行高。为 0 时则通过字体大小自动计算。</span></span><br><span class="line">	<span class="string">&quot;editor.lineHeight&quot;</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制行号的显示。</span></span><br><span class="line">	<span class="comment">//  - off: 不显示行号。</span></span><br><span class="line">	<span class="comment">//  - on: 将行号显示为绝对行数。</span></span><br><span class="line">	<span class="comment">//  - relative: 将行号显示为与光标相隔的行数。</span></span><br><span class="line">	<span class="comment">//  - interval: 每 10 行显示一次行号。</span></span><br><span class="line">	<span class="string">&quot;editor.lineNumbers&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在编辑器中检测链接并使其可被点击。</span></span><br><span class="line">	<span class="string">&quot;editor.links&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 突出显示匹配的括号。</span></span><br><span class="line">	<span class="string">&quot;editor.matchBrackets&quot;</span>: <span class="string">&quot;always&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由于性能原因，超过这个长度的行将不会被标记</span></span><br><span class="line">	<span class="string">&quot;editor.maxTokenizationLineLength&quot;</span>: <span class="number">20000</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否显示缩略图。</span></span><br><span class="line">	<span class="string">&quot;editor.minimap.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 限制缩略图的宽度，控制其最多显示的列数。</span></span><br><span class="line">	<span class="string">&quot;editor.minimap.maxColumn&quot;</span>: <span class="number">120</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 渲染每行的实际字符，而不是色块。</span></span><br><span class="line">	<span class="string">&quot;editor.minimap.renderCharacters&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在迷你地图中绘制的内容比例: 1、2 或 3。</span></span><br><span class="line">	<span class="string">&quot;editor.minimap.scale&quot;</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制何时显示迷你地图滑块。</span></span><br><span class="line">	<span class="string">&quot;editor.minimap.showSlider&quot;</span>: <span class="string">&quot;mouseover&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在哪一侧显示缩略图。</span></span><br><span class="line">	<span class="string">&quot;editor.minimap.side&quot;</span>: <span class="string">&quot;right&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制迷你地图的大小。</span></span><br><span class="line">	<span class="comment">//  - proportional: 迷你地图的大小与编辑器内容相同(并且可能滚动)。</span></span><br><span class="line">	<span class="comment">//  - fill: 迷你地图将根据需要拉伸或缩小以填充编辑器的高度(不滚动)。</span></span><br><span class="line">	<span class="comment">//  - fit: 迷你地图将根据需要缩小，永远不会大于编辑器(不滚动)。</span></span><br><span class="line">	<span class="string">&quot;editor.minimap.size&quot;</span>: <span class="string">&quot;proportional&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对鼠标滚轮滚动事件的 `deltaX` 和 `deltaY` 乘上的系数。</span></span><br><span class="line">	<span class="string">&quot;editor.mouseWheelScrollSensitivity&quot;</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按住 `Ctrl` 键并滚动鼠标滚轮时对编辑器字体大小进行缩放。</span></span><br><span class="line">	<span class="string">&quot;editor.mouseWheelZoom&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当多个光标重叠时进行合并。</span></span><br><span class="line">	<span class="string">&quot;editor.multiCursorMergeOverlapping&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在通过鼠标添加多个光标时使用的修改键。“转到定义”和“打开链接”功能所需的鼠标动作将会相应调整，不与多光标修改键冲突。[阅读详细信息](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier)。</span></span><br><span class="line">	<span class="comment">//  - ctrlCmd: 映射为 `Ctrl` (Windows 和 Linux) 或 `Command` (macOS)。</span></span><br><span class="line">	<span class="comment">//  - alt: 映射为 `Alt` (Windows 和 Linux) 或 `Option` (macOS)。</span></span><br><span class="line">	<span class="string">&quot;editor.multiCursorModifier&quot;</span>: <span class="string">&quot;alt&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制粘贴时粘贴文本的行计数与光标计数相匹配。</span></span><br><span class="line">	<span class="comment">//  - spread: 每个光标粘贴一行文本。</span></span><br><span class="line">	<span class="comment">//  - full: 每个光标粘贴全文。</span></span><br><span class="line">	<span class="string">&quot;editor.multiCursorPaste&quot;</span>: <span class="string">&quot;spread&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否突出显示语义符号的匹配项。</span></span><br><span class="line">	<span class="string">&quot;editor.occurrencesHighlight&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在概览标尺周围绘制边框。</span></span><br><span class="line">	<span class="string">&quot;editor.overviewRulerBorder&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器的底边和最后一行之间的间距量。</span></span><br><span class="line">	<span class="string">&quot;editor.padding.bottom&quot;</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器的顶边和第一行之间的间距量。</span></span><br><span class="line">	<span class="string">&quot;editor.padding.top&quot;</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制参数提示菜单在到达列表末尾时进行循环还是关闭。</span></span><br><span class="line">	<span class="string">&quot;editor.parameterHints.cycle&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在输入时显示含有参数文档和类型信息的小面板。</span></span><br><span class="line">	<span class="string">&quot;editor.parameterHints.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是将焦点放在内联编辑器上还是放在预览小部件中的树上。</span></span><br><span class="line">	<span class="comment">//  - tree: 打开速览时聚焦树</span></span><br><span class="line">	<span class="comment">//  - editor: 打开预览时将焦点放在编辑器上</span></span><br><span class="line">	<span class="string">&quot;editor.peekWidgetDefaultFocus&quot;</span>: <span class="string">&quot;tree&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在键入时自动显示建议。</span></span><br><span class="line">	<span class="string">&quot;editor.quickSuggestions&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;other&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;comments&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="string">&quot;strings&quot;</span>: <span class="literal">false</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制显示快速建议前的等待时间 (毫秒)。</span></span><br><span class="line">	<span class="string">&quot;editor.quickSuggestionsDelay&quot;</span>: <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用重命名之前预览更改的功能</span></span><br><span class="line">	<span class="string">&quot;editor.rename.enablePreview&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在编辑器中输入时自动重命名。</span></span><br><span class="line">	<span class="string">&quot;editor.renameOnType&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否显示控制字符。</span></span><br><span class="line">	<span class="string">&quot;editor.renderControlCharacters&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当文件以换行符结束时, 呈现最后一行的行号。</span></span><br><span class="line">	<span class="string">&quot;editor.renderFinalNewline&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否显示缩进参考线。</span></span><br><span class="line">	<span class="string">&quot;editor.renderIndentGuides&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器的当前行进行高亮显示的方式。</span></span><br><span class="line">	<span class="comment">//  - none</span></span><br><span class="line">	<span class="comment">//  - gutter</span></span><br><span class="line">	<span class="comment">//  - line</span></span><br><span class="line">	<span class="comment">//  - all: 同时突出显示导航线和当前行。</span></span><br><span class="line">	<span class="string">&quot;editor.renderLineHighlight&quot;</span>: <span class="string">&quot;line&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否仅在焦点在编辑器时突出显示当前行</span></span><br><span class="line">	<span class="string">&quot;editor.renderLineHighlightOnlyWhenFocus&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器在空白字符上显示符号的方式。</span></span><br><span class="line">	<span class="comment">//  - none</span></span><br><span class="line">	<span class="comment">//  - boundary: 呈现空格字符(字词之间的单个空格除外)。</span></span><br><span class="line">	<span class="comment">//  - selection: 仅在选定文本上呈现空白字符。</span></span><br><span class="line">	<span class="comment">//  - trailing: 仅呈现尾随空格字符</span></span><br><span class="line">	<span class="comment">//  - all</span></span><br><span class="line">	<span class="string">&quot;editor.renderWhitespace&quot;</span>: <span class="string">&quot;selection&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制选区是否有圆角。</span></span><br><span class="line">	<span class="string">&quot;editor.roundedSelection&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在一定数量的等宽字符后显示垂直标尺。输入多个值，显示多个标尺。若数组为空，则不绘制标尺。</span></span><br><span class="line">	<span class="string">&quot;editor.rulers&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器水平滚动时可以超过范围的字符数。</span></span><br><span class="line">	<span class="string">&quot;editor.scrollBeyondLastColumn&quot;</span>: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否可以滚动到最后一行之后。</span></span><br><span class="line">	<span class="string">&quot;editor.scrollBeyondLastLine&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同时垂直和水平滚动时，仅沿主轴滚动。在触控板上垂直滚动时，可防止水平漂移。</span></span><br><span class="line">	<span class="string">&quot;editor.scrollPredominantAxis&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否应突出显示与所选内容类似的匹配项。</span></span><br><span class="line">	<span class="string">&quot;editor.selectionHighlight&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否为支持它的语言显示语义突出显示。</span></span><br><span class="line">	<span class="comment">//  - true: 对所有颜色主题启用语义突出显示。</span></span><br><span class="line">	<span class="comment">//  - false: 对所有颜色主题禁用语义突出显示。</span></span><br><span class="line">	<span class="comment">//  - configuredByTheme: 语义突出显示是由当前颜色主题的 &quot;semanticHighlighting&quot; 设置配置的。</span></span><br><span class="line">	<span class="string">&quot;editor.semanticHighlighting.enabled&quot;</span>: <span class="string">&quot;configuredByTheme&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从当前所选颜色主题重写编辑器语义标记颜色和样式。</span></span><br><span class="line">	<span class="string">&quot;editor.semanticTokenColorCustomizations&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制加删除线被弃用的变量。</span></span><br><span class="line">	<span class="string">&quot;editor.showDeprecated&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制何时显示行号槽上的折叠控件。</span></span><br><span class="line">	<span class="comment">//  - always: 始终显示折叠控件。</span></span><br><span class="line">	<span class="comment">//  - mouseover: 仅在鼠标位于装订线上方时显示折叠控件。</span></span><br><span class="line">	<span class="string">&quot;editor.showFoldingControls&quot;</span>: <span class="string">&quot;mouseover&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否淡化未使用的代码。</span></span><br><span class="line">	<span class="string">&quot;editor.showUnused&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器是否在滚动时使用动画。</span></span><br><span class="line">	<span class="string">&quot;editor.smoothScrolling&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制代码片段是否与其他建议一起显示及其排列的位置。</span></span><br><span class="line">	<span class="comment">//  - top: 在其他建议上方显示代码片段建议。</span></span><br><span class="line">	<span class="comment">//  - bottom: 在其他建议下方显示代码片段建议。</span></span><br><span class="line">	<span class="comment">//  - inline: 在其他建议中穿插显示代码片段建议。</span></span><br><span class="line">	<span class="comment">//  - none: 不显示代码片段建议。</span></span><br><span class="line">	<span class="string">&quot;editor.snippetSuggestions&quot;</span>: <span class="string">&quot;inline&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在速览编辑器中，即使双击其中的内容或者按 `Esc` 键，也保持其打开状态。</span></span><br><span class="line">	<span class="string">&quot;editor.stablePeek&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此设置已弃用，请改用单独的设置，如&quot;editor.suggest.showKeywords&quot;或&quot;editor.suggest.showSnippets&quot;。</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="string">&quot;editor.suggest.filteredTypes&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制对建议的筛选和排序是否考虑小的拼写错误。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.filterGraceful&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制接受补全时是否覆盖单词。请注意，这取决于扩展选择使用此功能。</span></span><br><span class="line">	<span class="comment">//  - insert: 插入建议而不覆盖光标右侧的文本。</span></span><br><span class="line">	<span class="comment">//  - replace: 插入建议并覆盖光标右侧的文本。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.insertMode&quot;</span>: <span class="string">&quot;insert&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制排序时是否提高靠近光标的词语的优先级。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.localityBonus&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在显示滚动条之前 IntelliSense 将显示的建议数 (最多 15个)。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.maxVisibleSuggestions&quot;</span>: <span class="number">12</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在多个工作区和窗口间共享记忆的建议选项(需要 `editor.suggestSelection`)。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.shareSuggestSelections&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“类”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showClasses&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“颜色”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showColors&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“常量”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showConstants&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“构造函数”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showConstructors&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“自定义颜色”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showCustomcolors&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示 &quot;enumMember&quot; 建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showEnumMembers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“枚举”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showEnums&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“事件”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showEvents&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“字段”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showFields&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“文件”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showFiles&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“文件夹”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showFolders&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“函数”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showFunctions&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在建议中显示或隐藏图标。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showIcons&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“接口”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showInterfaces&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示&quot;问题&quot;建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showIssues&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“关键字”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showKeywords&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“方法”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showMethods&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“模块”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showModules&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“操作符”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showOperators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“属性”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showProperties&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“参考”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showReferences&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“片段”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showSnippets&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“结构”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showStructs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示 &quot;typeParameter&quot; 建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showTypeParameters&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“单位”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showUnits&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示&quot;用户&quot;建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showUsers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“值”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showValues&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“变量”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showVariables&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，IntelliSense 将显示“文本”建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.showWords&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制活动代码段是否阻止快速建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.snippetsPreventQuickSuggestions&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制建议小部件底部的状态栏的可见性。</span></span><br><span class="line">	<span class="string">&quot;editor.suggest.statusBar.visible&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 建议小部件的字号。如果设置为 `0`，则使用 `editor.fontSize` 的值。</span></span><br><span class="line">	<span class="string">&quot;editor.suggestFontSize&quot;</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 建议小部件的行高。如果设置为 `0`，则使用 `editor.lineHeight` 的值。</span></span><br><span class="line">	<span class="string">&quot;editor.suggestLineHeight&quot;</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在键入触发字符后是否自动显示建议。</span></span><br><span class="line">	<span class="string">&quot;editor.suggestOnTriggerCharacters&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在建议列表中如何预先选择建议。</span></span><br><span class="line">	<span class="comment">//  - first: 始终选择第一个建议。</span></span><br><span class="line">	<span class="comment">//  - recentlyUsed: 选择最近的建议，除非进一步键入选择其他项。例如 `console. -&gt; console.log`，因为最近补全过 `log`。</span></span><br><span class="line">	<span class="comment">//  - recentlyUsedByPrefix: 根据之前补全过的建议的前缀来进行选择。例如，`co -&gt; console`、`con -&gt; const`。</span></span><br><span class="line">	<span class="string">&quot;editor.suggestSelection&quot;</span>: <span class="string">&quot;recentlyUsed&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用 Tab 补全。</span></span><br><span class="line">	<span class="comment">//  - on: 在按下 Tab 键时进行 Tab 补全，将插入最佳匹配建议。</span></span><br><span class="line">	<span class="comment">//  - off: 禁用 Tab 补全。</span></span><br><span class="line">	<span class="comment">//  - onlySnippets: 在前缀匹配时进行 Tab 补全。在 &quot;quickSuggestions&quot; 未启用时体验最好。</span></span><br><span class="line">	<span class="string">&quot;editor.tabCompletion&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一个制表符等于的空格数。在 `editor.detectIndentation` 启用时，根据文件内容，该设置可能会被覆盖。</span></span><br><span class="line">	<span class="string">&quot;editor.tabSize&quot;</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 替代当前所选颜色主题中的编辑器语法颜色和字形。</span></span><br><span class="line">	<span class="string">&quot;editor.tokenColorCustomizations&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 改为使用 `editor.semanticTokenColorCustomizations`。</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="string">&quot;editor.tokenColorCustomizationsExperimental&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除自动插入的尾随空白符号。</span></span><br><span class="line">	<span class="string">&quot;editor.trimAutoWhitespace&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制单击已折叠的行后面的空内容是否会展开该行。</span></span><br><span class="line">	<span class="string">&quot;editor.unfoldOnClickAfterEndOfLine&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除可能导致问题的异常行终止符。</span></span><br><span class="line">	<span class="comment">//  - auto: 忽略异常的行终止符。</span></span><br><span class="line">	<span class="comment">//  - off: 提示删除异常的行终止符。</span></span><br><span class="line">	<span class="comment">//  - prompt: 自动删除异常的行终止符。</span></span><br><span class="line">	<span class="string">&quot;editor.unusualLineTerminators&quot;</span>: <span class="string">&quot;prompt&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据制表位插入和删除空格。</span></span><br><span class="line">	<span class="string">&quot;editor.useTabStops&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否根据文档中的文字计算自动完成列表。</span></span><br><span class="line">	<span class="string">&quot;editor.wordBasedSuggestions&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行单词相关的导航或操作时作为单词分隔符的字符。</span></span><br><span class="line">	<span class="string">&quot;editor.wordSeparators&quot;</span>: <span class="string">&quot;`~!@#$%^&amp;*()-=+[&#123;]&#125;\\|;:&#x27;\&quot;,.&lt;&gt;/?&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制折行的方式。</span></span><br><span class="line">	<span class="comment">//  - off: 永不换行。</span></span><br><span class="line">	<span class="comment">//  - on: 将在视区宽度处换行。</span></span><br><span class="line">	<span class="comment">//  - wordWrapColumn: 在 `editor.wordWrapColumn` 处折行。</span></span><br><span class="line">	<span class="comment">//  - bounded: 在视区宽度和 `editor.wordWrapColumn` 中的较小值处折行。</span></span><br><span class="line">	<span class="string">&quot;editor.wordWrap&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 `editor.wordWrap` 为 `wordWrapColumn` 或 `bounded` 时，控制编辑器的折行列。</span></span><br><span class="line">	<span class="comment">// &quot;editor.wordWrapColumn&quot;: 80,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制折行的缩进。</span></span><br><span class="line">	<span class="comment">//  - none: 没有缩进。折行从第 1 列开始。</span></span><br><span class="line">	<span class="comment">//  - same: 折行的缩进量与其父级相同。</span></span><br><span class="line">	<span class="comment">//  - indent: 折行的缩进量比其父级多 1。</span></span><br><span class="line">	<span class="comment">//  - deepIndent: 折行的缩进量比其父级多 2。</span></span><br><span class="line">	<span class="string">&quot;editor.wrappingIndent&quot;</span>: <span class="string">&quot;same&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制计算包裹点的算法。</span></span><br><span class="line">	<span class="comment">//  - simple: 假定所有字符的宽度相同。这是一种快速算法，适用于等宽字体和某些字形宽度相等的文字(如拉丁字符)。</span></span><br><span class="line">	<span class="comment">//  - advanced: 将包装点计算委托给浏览器。这是一个缓慢算法，可能会导致大型文件被冻结，但它在所有情况下都正常工作。</span></span><br><span class="line">	<span class="string">&quot;editor.wrappingStrategy&quot;</span>: <span class="string">&quot;simple&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在“源代码管理”视图中始终显示内联操作。</span></span><br><span class="line">	<span class="string">&quot;scm.alwaysShowActions&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制存储库是否应始终在 SCM 视图中可见。</span></span><br><span class="line">	<span class="string">&quot;scm.alwaysShowRepositories&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制 SCM 视图在打开文件时是否应自动显示和选择文件。</span></span><br><span class="line">	<span class="string">&quot;scm.autoReveal&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制活动栏上源代码管理图标上的计数锁屏提醒。</span></span><br><span class="line">	<span class="comment">//  - all: 显示所有源代码管理提供程序计数锁屏提醒的总和。</span></span><br><span class="line">	<span class="comment">//  - focused: 显示焦点源控制提供程序的计数标记。</span></span><br><span class="line">	<span class="comment">//  - off: 禁用源代码管理计数徽章。</span></span><br><span class="line">	<span class="string">&quot;scm.countBadge&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制默认的源代码管理存储库视图模式。</span></span><br><span class="line">	<span class="comment">//  - tree: 将存储库更改显示为树。</span></span><br><span class="line">	<span class="comment">//  - list: 将存储库更改显示为列表。</span></span><br><span class="line">	<span class="string">&quot;scm.defaultViewMode&quot;</span>: <span class="string">&quot;list&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器中差异的显示效果。</span></span><br><span class="line">	<span class="comment">//  - all: 显示所有可用位置中的差异装饰。</span></span><br><span class="line">	<span class="comment">//  - gutter: 仅在编辑器行号槽中显示差异装饰。</span></span><br><span class="line">	<span class="comment">//  - overview: 仅在概览标尺中显示差异装饰。</span></span><br><span class="line">	<span class="comment">//  - minimap: 仅在缩略图中显示差异装饰。</span></span><br><span class="line">	<span class="comment">//  - none: 不要显示差异装饰。</span></span><br><span class="line">	<span class="string">&quot;scm.diffDecorations&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制行号槽中源代码管理差异装饰器的可见性。</span></span><br><span class="line">	<span class="comment">//  - always: 始终显示行号槽中的差异装饰器。</span></span><br><span class="line">	<span class="comment">//  - hover: 仅在悬停时显示行号槽中的差异装饰器。</span></span><br><span class="line">	<span class="string">&quot;scm.diffDecorationsGutterVisibility&quot;</span>: <span class="string">&quot;always&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制装订线中差异修饰的宽度(px)(已添加或已修改)。</span></span><br><span class="line">	<span class="string">&quot;scm.diffDecorationsGutterWidth&quot;</span>: <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制输入消息的字体。将 `default` 用于工作台用户界面字体系列，将 `editor` 用于 `editor.fontFamily` 的值，或者使用自定义字体系列。</span></span><br><span class="line">	<span class="string">&quot;scm.inputFontFamily&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制源代码管理提供程序标头的计数锁屏提醒。仅在有多个提供程序时才显示这些标头。</span></span><br><span class="line">	<span class="comment">//  - hidden: 隐藏源代码管理提供程序计数锁屏提醒。</span></span><br><span class="line">	<span class="comment">//  - auto: 仅显示非零时源代码管理提供程序的计数锁屏提醒。</span></span><br><span class="line">	<span class="comment">//  - visible: 显示源代码管理提供程序计数锁屏提醒。</span></span><br><span class="line">	<span class="string">&quot;scm.providerCountBadge&quot;</span>: <span class="string">&quot;hidden&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在“源代码管理存储库”部分中可见的存储库数。设置为 &quot;0&quot;, 以便能够手动调整视图的大小。</span></span><br><span class="line">	<span class="string">&quot;scm.repositories.visible&quot;</span>: <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个默认内核提供程序，该提供程序优先于所有其他内核提供程序设置。必须是提供内核提供程序的扩展的标识符。</span></span><br><span class="line">	<span class="string">&quot;notebook.kernelProviderAssociations&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在工作台中单击活动栏图标时出现的行为。</span></span><br><span class="line">	<span class="comment">//  - toggle: 如果单击的项已可见，则隐藏边栏。</span></span><br><span class="line">	<span class="comment">//  - focus: 如果单击的项已可见，则将焦点放在边栏上。</span></span><br><span class="line">	<span class="string">&quot;workbench.activityBar.iconClickBehavior&quot;</span>: <span class="string">&quot;toggle&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制工作台中活动栏的可见性。</span></span><br><span class="line">	<span class="string">&quot;workbench.activityBar.visible&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 覆盖当前所选颜色主题的颜色。</span></span><br><span class="line">	<span class="string">&quot;workbench.colorCustomizations&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定用在工作台中的颜色主题。</span></span><br><span class="line">	<span class="string">&quot;workbench.colorTheme&quot;</span>: <span class="string">&quot;Default Dark+&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制命令面板中保留最近使用命令的数量。设置为 0 时禁用命令历史功能。</span></span><br><span class="line">	<span class="string">&quot;workbench.commandPalette.history&quot;</span>: <span class="number">50</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当再次打开命令面板时，控制是否恢复上一次输入的内容。</span></span><br><span class="line">	<span class="string">&quot;workbench.commandPalette.preserveInput&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果在居中布局中打开了超过一组编辑器，控制是否自动将宽度调整为最大宽度值。当回到只打开了一组编辑器的状态，将自动将宽度调整为原始的居中宽度值。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.centeredLayoutAutoResize&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器组中最后一个选项卡关闭时这个空组的行为。若启用，将自动关闭空组。若禁用，空组仍将保留在网格布局中。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.closeEmptyGroups&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当文件被其他进程删除或重命名时，控制是否自动关闭在这个期间内打开了此文件的编辑器。若禁用此项，在这种情况下将保留编辑器。请注意，若从应用内部进行删除，将始终关闭编辑器，并且为了保护您的数据，已更新文件始终不会关闭。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.closeOnFileDelete&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制打开的编辑器是否显示为预览。在将预览编辑器显式设置为保持打开状态(例如，通过双击或编辑)前，可重用预览编辑器，其字体样式为斜体。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.enablePreview&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制通过 Quick Open 打开的编辑器是否显示为预览。在将预览编辑器显式设置为保持打开状态(例如，通过双击或编辑)前，可重用预览编辑器。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.enablePreviewFromQuickOpen&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否按最常使用的顺序或从左到右的顺序关闭选项卡。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.focusRecentEditorAfterClose&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在已修改的(脏)编辑器选项卡上绘制上边框。当 &quot;#workbench.editor.showTabs#&quot; 为 false 时，将忽略此值。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.highlightModifiedTabs&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器标签的格式。</span></span><br><span class="line">	<span class="comment">//  - default: 显示文件名。当启用选项卡且在同一组内有两个相同名称的文件时，将添加每个文件路径中可以用于区分的部分。在选项卡被禁用且编辑器活动时，将显示相对于工作区文件夹的路径。</span></span><br><span class="line">	<span class="comment">//  - short: 在文件的目录名之后显示文件名。</span></span><br><span class="line">	<span class="comment">//  - medium: 在文件相对当前工作区文件夹的路径之后显示文件名。</span></span><br><span class="line">	<span class="comment">//  - long: 在文件的绝对路径之后显示文件名。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.labelFormat&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否应限制打开的编辑器的数量。启用后，不脏的最近较少使用的编辑器将关闭，以便为新打开的编辑器腾出空间。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.limit.enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制最大打开的编辑器的限制是否应应用于每个编辑器组或所有编辑器组。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.limit.perEditorGroup&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制打开编辑器的最大数量。使用 &quot;#workbench.editor.limit.perEditorGroup#&quot; 设置控制每个编辑器组或跨所有组的限制。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.limit.value&quot;</span>: <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用鼠标按钮 4 和鼠标按钮 5 (如果提供)在打开的文件之间导航。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.mouseBackForwardToNavigate&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器打开的位置。选择 `left` 或 `right` 可分别在当前活动编辑器的左侧或右侧打开。选择 `first` (最前) 或 `last` (最后) 打开的位置与当前活动编辑器无关。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.openPositioning&quot;</span>: <span class="string">&quot;right&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器在并排打开时 (比如从资源管理器) 出现的默认位置。默认在当前活动编辑器右侧打开。若更改为 `down`，则在当前活动编辑器下方打开。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.openSideBySideDirection&quot;</span>: <span class="string">&quot;right&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制固定的编辑器选项卡的大小。固定的选项卡排在所有打开的选项卡的开头，并且在取消固定之前，通常不会关闭。当 &quot;#workbench.editor.showTabs#&quot; 为 &quot;false&quot; 时，将忽略此值。</span></span><br><span class="line">	<span class="comment">//  - normal: 固定的选项卡会继承未固定的选项卡的外观。</span></span><br><span class="line">	<span class="comment">//  - compact: 固定的选项卡将以紧凑形式显示，其中只包含图标或编辑器名称的第一个字母。</span></span><br><span class="line">	<span class="comment">//  - shrink: 固定的选项卡缩小至紧凑的固定大小，显示编辑器名称的各部分。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.pinnedTabSizing&quot;</span>: <span class="string">&quot;normal&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在重新打开已关闭的文本编辑器时，还原最后一个视图的状态 (如滚动位置)。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.restoreViewState&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在打开的任何可见组中显示编辑器。如果禁用，编辑器将优先在当前活动的编辑器组中打开。如果启用，将会显示在已打开的编辑器，而不是在当前活动的编辑器组中再次打开。请注意，有些情况下会忽略此设置，例如，强制编辑器在特定组中打开或当前活动组的一侧时。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.revealIfOpen&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在滚动到选项卡上方时是否打开这些选项卡。默认情况下，选项卡仅在鼠标滚动时呈现，但不打开。可通过在滚动时按住 Shift 键来更改滚动期间的此行为。当 &quot;#workbench.editor.showTabs#&quot; 设置为 &quot;false&quot; 时，将忽略此值。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.scrollToSwitchTabs&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在打开的编辑器中显示图标。这要求同时启用文件图标主题。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.showIcons&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制打开的编辑器是否显示在选项卡中。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.showTabs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拆分编辑器组时控制编辑器组大小。</span></span><br><span class="line">	<span class="comment">//  - distribute: 将所有编辑器组拆分为相等的部分。</span></span><br><span class="line">	<span class="comment">//  - split: 将活动编辑器组拆分为相等的部分。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.splitSizing&quot;</span>: <span class="string">&quot;distribute&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器的选项卡关闭按钮的位置，或者在设置为“关”时禁用它们。当 &quot;#workbench.editor.showTabs#&quot; 为 &quot;false&quot; 时，将忽略此值。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.tabCloseButton&quot;</span>: <span class="string">&quot;right&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器选项卡的大小调整。当 &quot;#workbench.editor.showTabs#&quot; 设置为 &quot;false&quot; 时，将忽略此值。</span></span><br><span class="line">	<span class="comment">//  - fit: 始终将标签页保持足够大，能够完全显示编辑器标签。</span></span><br><span class="line">	<span class="comment">//  - shrink: 在不能同时显示所有选项卡时，允许选项卡缩小。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.tabSizing&quot;</span>: <span class="string">&quot;fit&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制编辑器标题区域中用于选项卡和面包屑的滚动条的高度。</span></span><br><span class="line">	<span class="comment">//  - default: 默认大小。</span></span><br><span class="line">	<span class="comment">//  - large: 增加大小，以便更轻松地通过鼠标抓取</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.titleScrollbarSizing&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制无标题编辑器的标签格式。</span></span><br><span class="line">	<span class="comment">//  - content: 无标题文件的名称派生自其第一行的内容，除非它有关联的文件路径。如果行为空或不包含单词字符，它将回退到名称。</span></span><br><span class="line">	<span class="comment">//  - name: 无标题文件的名称不是从文件的内容派生的。</span></span><br><span class="line">	<span class="string">&quot;workbench.editor.untitled.labelFormat&quot;</span>: <span class="string">&quot;content&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要用于特定文件类型的编辑器。</span></span><br><span class="line">	<span class="string">&quot;workbench.editorAssociations&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 Microsoft 联机服务中获取要进行的实验。</span></span><br><span class="line">	<span class="string">&quot;workbench.enableExperiments&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定工作台中使用的文件图标主题；若指定为 &quot;null&quot;，则不显示任何文件图标。</span></span><br><span class="line">	<span class="comment">//  - null: 无文件图标</span></span><br><span class="line">	<span class="comment">//  - vs-minimal</span></span><br><span class="line">	<span class="comment">//  - vs-seti</span></span><br><span class="line">	<span class="string">&quot;workbench.iconTheme&quot;</span>: <span class="string">&quot;vs-seti&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制列表和树中的键盘导航是否仅通过键入自动触发。如果设置为 `false` ，键盘导航只在执行 `list.toggleKeyboardNavigation` 命令时触发，您可以为该命令指定键盘快捷方式。</span></span><br><span class="line">	<span class="string">&quot;workbench.list.automaticKeyboardNavigation&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制列表和树是否支持工作台中的水平滚动。警告: 打开此设置影响会影响性能。</span></span><br><span class="line">	<span class="string">&quot;workbench.list.horizontalScrolling&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制工作台中的列表和树的键盘导航样式。它可为“简单”、“突出显示”或“筛选”。</span></span><br><span class="line">	<span class="comment">//  - simple: 简单键盘导航聚焦与键盘输入相匹配的元素。仅对前缀进行匹配。</span></span><br><span class="line">	<span class="comment">//  - highlight: 高亮键盘导航会突出显示与键盘输入相匹配的元素。进一步向上和向下导航将仅遍历突出显示的元素。</span></span><br><span class="line">	<span class="comment">//  - filter: 筛选器键盘导航将筛选出并隐藏与键盘输入不匹配的所有元素。</span></span><br><span class="line">	<span class="string">&quot;workbench.list.keyboardNavigation&quot;</span>: <span class="string">&quot;highlight&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在通过鼠标多选树和列表条目时使用的修改键 (例如“资源管理器”、“打开的编辑器”和“源代码管理”视图)。“在侧边打开”功能所需的鼠标动作 (若可用) 将会相应调整，不与多选修改键冲突。</span></span><br><span class="line">	<span class="comment">//  - ctrlCmd: 映射为 `Ctrl` (Windows 和 Linux) 或 `Command` (macOS)。</span></span><br><span class="line">	<span class="comment">//  - alt: 映射为 `Alt` (Windows 和 Linux) 或 `Option` (macOS)。</span></span><br><span class="line">	<span class="string">&quot;workbench.list.multiSelectModifier&quot;</span>: <span class="string">&quot;ctrlCmd&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在树和列表中怎样使用鼠标来展开子项(若支持)。对于树中的父节点，此设置将控制是使用单击还是双击来展开。注意，某些不适用于此设置的树或列表可能会忽略此项。 </span></span><br><span class="line">	<span class="string">&quot;workbench.list.openMode&quot;</span>: <span class="string">&quot;singleClick&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制列表和树是否具有平滑滚动。</span></span><br><span class="line">	<span class="string">&quot;workbench.list.smoothScrolling&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制面板的默认位置(终端、调试控制台、输出、问题)。它可以显示在工作台的底部、右侧或左侧。</span></span><br><span class="line">	<span class="string">&quot;workbench.panel.defaultLocation&quot;</span>: <span class="string">&quot;bottom&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制面板是否以最大化方式打开。它可以始终以最大化方式打开、永不以最大化方式打开或以关闭前的最后一个状态打开。</span></span><br><span class="line">	<span class="comment">//  - always: 始终以最大化方式打开面板。</span></span><br><span class="line">	<span class="comment">//  - never: 永不以最大化方式打开面板。面板将以非最大化方式打开。</span></span><br><span class="line">	<span class="comment">//  - preserve: 以关闭面板前的状态打开面板。</span></span><br><span class="line">	<span class="string">&quot;workbench.panel.opensMaximized&quot;</span>: <span class="string">&quot;preserve&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定启用了 `window.autoDetectColorScheme` 时深色操作系统外观的首选颜色主题。</span></span><br><span class="line">	<span class="string">&quot;workbench.preferredDarkColorTheme&quot;</span>: <span class="string">&quot;Default Dark+&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定启用了 `window.autoDetectHighContrast` 时在高对比度模式下使用的首选颜色主题。</span></span><br><span class="line">	<span class="string">&quot;workbench.preferredHighContrastColorTheme&quot;</span>: <span class="string">&quot;Default High Contrast&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定启用了 `window.autoDetectColorScheme` 时浅色操作系统外观的首选颜色主题。</span></span><br><span class="line">	<span class="string">&quot;workbench.preferredLightColorTheme&quot;</span>: <span class="string">&quot;Default Light+&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定使用的产品图标主题。</span></span><br><span class="line">	<span class="comment">//  - Default: 默认</span></span><br><span class="line">	<span class="string">&quot;workbench.productIconTheme&quot;</span>: <span class="string">&quot;Default&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制 Quick Open 是否在其失去焦点时自动关闭。</span></span><br><span class="line">	<span class="string">&quot;workbench.quickOpen.closeOnFocusLost&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在打开 Quick Open 视图时，控制是否自动恢复上一次输入的值。</span></span><br><span class="line">	<span class="string">&quot;workbench.quickOpen.preserveInput&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制视图/编辑器之间拖动区域的反馈区域大小(以像素为单位)。如果你认为很难使用鼠标调整视图的大小，请将该值调大。</span></span><br><span class="line">	<span class="string">&quot;workbench.sash.size&quot;</span>: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置默认使用的设置编辑器。</span></span><br><span class="line">	<span class="comment">//  - ui: 使用设置 ui 编辑器。</span></span><br><span class="line">	<span class="comment">//  - json: 使用 json 文件编辑器。</span></span><br><span class="line">	<span class="string">&quot;workbench.settings.editor&quot;</span>: <span class="string">&quot;ui&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在设置中启用自然语言搜索。自然语言搜索由 Microsoft 联机服务提供。</span></span><br><span class="line">	<span class="string">&quot;workbench.settings.enableNaturalLanguageSearch&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在打开按键绑定设置时是否同时打开显示所有默认按键绑定的编辑器。</span></span><br><span class="line">	<span class="string">&quot;workbench.settings.openDefaultKeybindings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在打开设置时是否同时打开显示所有默认设置的编辑器。</span></span><br><span class="line">	<span class="string">&quot;workbench.settings.openDefaultSettings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制设置编辑器的目录在搜索时的行为。</span></span><br><span class="line">	<span class="comment">//  - hide: 在搜索时隐藏目录。</span></span><br><span class="line">	<span class="comment">//  - filter: 筛选目录为仅显示含有匹配设置的类别。单击一个类别将仅显示该类别的结果。</span></span><br><span class="line">	<span class="string">&quot;workbench.settings.settingsSearchTocBehavior&quot;</span>: <span class="string">&quot;filter&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在将设置编辑为 json 时是否使用拆分 json 编辑器。</span></span><br><span class="line">	<span class="string">&quot;workbench.settings.useSplitJSON&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制侧边栏和活动栏的位置。它们可以显示在工作台的左侧或右侧。</span></span><br><span class="line">	<span class="string">&quot;workbench.sideBar.location&quot;</span>: <span class="string">&quot;left&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在没有从上一会话中恢复出信息的情况下，控制启动时显示的编辑器。</span></span><br><span class="line">	<span class="comment">//  - none: 在启动时不打开编辑器。</span></span><br><span class="line">	<span class="comment">//  - welcomePage: 打开欢迎页面 (默认)。</span></span><br><span class="line">	<span class="comment">//  - readme: 打开包含一个自述文件的文件夹时, 打开自述文件, 否则回退到 &quot;欢迎页面&quot;。</span></span><br><span class="line">	<span class="comment">//  - newUntitledFile: 打开新的无标题文件 (仅在打开空工作区时适用)。</span></span><br><span class="line">	<span class="comment">//  - welcomePageInEmptyWorkbench: 在打开空工作区时打开欢迎页面。</span></span><br><span class="line">	<span class="string">&quot;workbench.startupEditor&quot;</span>: <span class="string">&quot;welcomePage&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制工作台底部状态栏的可见性。</span></span><br><span class="line">	<span class="string">&quot;workbench.statusBar.visible&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，当没有打开编辑器时将显示水印提示。</span></span><br><span class="line">	<span class="string">&quot;workbench.tips.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制树缩进(以像素为单位)。</span></span><br><span class="line">	<span class="string">&quot;workbench.tree.indent&quot;</span>: <span class="number">8</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制树是否应呈现缩进参考线。</span></span><br><span class="line">	<span class="string">&quot;workbench.tree.renderIndentGuides&quot;</span>: <span class="string">&quot;onHover&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否显示视图头部的操作项。视图头部操作项可以一直，或是仅当聚焦到和悬停在视图上时显示。</span></span><br><span class="line">	<span class="string">&quot;workbench.view.alwaysShowHeaderActions&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果设置，则根据操作系统外观自动切换到首选颜色主题。</span></span><br><span class="line">	<span class="string">&quot;window.autoDetectColorScheme&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果已启用，并且操作系统正在使用高对比度主题，则将自动更改为高对比度主题。</span></span><br><span class="line">	<span class="string">&quot;window.autoDetectHighContrast&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在关闭最后一个编辑器时是否关闭整个窗口。此设置仅适用于没有显示文件夹的窗口。</span></span><br><span class="line">	<span class="string">&quot;window.closeWhenEmpty&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否通过按 Alt 键聚焦菜单栏。此设置对使用 Alt 键切换菜单栏没有任何影响。</span></span><br><span class="line">	<span class="string">&quot;window.customMenuBarAltFocus&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调整对话框窗口的外观。</span></span><br><span class="line">	<span class="string">&quot;window.dialogStyle&quot;</span>: <span class="string">&quot;native&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果启用, 双击标题栏中的应用程序图标将关闭窗口, 并且该窗口无法通过图标拖动。此设置仅在 &quot;#window.titleBarStyle#&quot; 设置为 &quot;custom&quot; 时生效。</span></span><br><span class="line">	<span class="string">&quot;window.doubleClickIconToClose&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否可通过 Alt 键快捷键打开主菜单。如果禁用助记符，则可将这些 Alt 键快捷键绑定到编辑器命令。</span></span><br><span class="line">	<span class="string">&quot;window.enableMenuBarMnemonics&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制菜单栏的可见性。“切换”设置表示隐藏菜单栏，按一次 Alt 键则将显示此菜单栏。默认情况下，除非窗口为全屏，否则菜单栏可见。</span></span><br><span class="line">	<span class="comment">//  - default: 菜单仅在全屏模式下隐藏。</span></span><br><span class="line">	<span class="comment">//  - visible: 菜单始终可见，即使处于全屏模式下。</span></span><br><span class="line">	<span class="comment">//  - toggle: 菜单隐藏，但可以通过 Alt 键显示。</span></span><br><span class="line">	<span class="comment">//  - hidden: 菜单始终隐藏。</span></span><br><span class="line">	<span class="comment">//  - compact: 菜单在侧边栏中显示为一个紧凑的按钮。当 &quot;#window.titleBarStyle#&quot; 为 &quot;native&quot; 时，将忽略此值。</span></span><br><span class="line">	<span class="string">&quot;window.menuBarVisibility&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在已有窗口时新开窗口的尺寸。请注意，此设置对第一个打开的窗口无效。第一个窗口将始终恢复关闭前的大小和位置。</span></span><br><span class="line">	<span class="comment">//  - default: 在屏幕中心打开新窗口。</span></span><br><span class="line">	<span class="comment">//  - inherit: 以与上一个活动窗口相同的尺寸打开新窗口。</span></span><br><span class="line">	<span class="comment">//  - offset: 打开与上次活动窗口具有相同尺寸的新窗口，并带有偏移位置。</span></span><br><span class="line">	<span class="comment">//  - maximized: 打开最大化的新窗口。</span></span><br><span class="line">	<span class="comment">//  - fullscreen: 在全屏模式下打开新窗口。</span></span><br><span class="line">	<span class="string">&quot;window.newWindowDimensions&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否应在新窗口中打开文件。</span></span><br><span class="line">	<span class="comment">// 请注意，此设置可能会被忽略(例如，在使用 `--new-window` 或 `--reuse-window` 命令行选项时)。</span></span><br><span class="line">	<span class="comment">//  - on: 在新窗口中打开文件。</span></span><br><span class="line">	<span class="comment">//  - off: 在文件所在文件夹的已有窗口中或在上一个活动窗口中打开文件。</span></span><br><span class="line">	<span class="comment">//  - default: 在新窗口中打开文件，除非文件从应用程序内进行选取 (例如，通过“文件”菜单)。</span></span><br><span class="line">	<span class="string">&quot;window.openFilesInNewWindow&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制文件夹是应在新窗口中打开，还是应替换上次处于活动状态的窗口。</span></span><br><span class="line">	<span class="comment">// 请注意，此设置可能会被忽略(例如，在使用 `--new-window` 或 `--reuse-window` 命令行选项时)。</span></span><br><span class="line">	<span class="comment">//  - on: 在新窗口中打开文件夹。</span></span><br><span class="line">	<span class="comment">//  - off: 文件夹将替换上一个活动窗口。</span></span><br><span class="line">	<span class="comment">//  - default: 在新窗口中打开文件夹，除非文件夹从应用程序内进行选取 (例如，通过“文件”菜单)。</span></span><br><span class="line">	<span class="string">&quot;window.openFoldersInNewWindow&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在启动不带参数的第二个实例时是应该打开一个新的空窗口，还是应由上一个运行的实例获得焦点。</span></span><br><span class="line">	<span class="comment">// 请注意，此设置可能会被忽略(例如，在使用 `--new-window` 或 `--reuse-window` 命令行选项时)。</span></span><br><span class="line">	<span class="comment">//  - on: 打开一个新的空窗口。</span></span><br><span class="line">	<span class="comment">//  - off: 聚焦到上一活动的运行实例。</span></span><br><span class="line">	<span class="string">&quot;window.openWithoutArgumentsInNewWindow&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若窗口在处于全屏模式时退出，控制其在恢复时是否还原到全屏模式。</span></span><br><span class="line">	<span class="string">&quot;window.restoreFullscreen&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制窗口在重启后再次打开的方式。</span></span><br><span class="line">	<span class="comment">//  - all: 重新打开所有窗口。</span></span><br><span class="line">	<span class="comment">//  - folders: 重新打开所有文件夹。空工作区将不会被恢复。</span></span><br><span class="line">	<span class="comment">//  - one: 重新打开上一个活动窗口。</span></span><br><span class="line">	<span class="comment">//  - none: 永远不重新打开窗口。总是以一个空窗口启动。</span></span><br><span class="line">	<span class="string">&quot;window.restoreWindows&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据活动编辑器控制窗口标题。变量是根据上下文替换的:</span></span><br><span class="line">	<span class="comment">// - &quot;$&#123;activeEditorShort&#125;&quot;: 文件名 (例如 myFile.txt)。</span></span><br><span class="line">	<span class="comment">// - &quot;$&#123;activeEditorMedium&#125;&quot;: 相对于工作区文件夹的文件路径 (例如, myFolder/myFileFolder/myFile.txt)。</span></span><br><span class="line">	<span class="comment">// - &quot;$&#123;activeEditorLong&#125;&quot;: 文件的完整路径 (例如 /Users/Development/myFolder/myFileFolder/myFile.txt)。</span></span><br><span class="line">	<span class="comment">// - &quot;$&#123;activeFolderShort&#125;&quot;: 文件所在的文件夹名称 (例如, myFileFolder)。</span></span><br><span class="line">	<span class="comment">// - &quot;$&#123;activeFolderMedium&#125;&quot;: 相对于工作区文件夹的、包含文件的文件夹的路径, (例如 myFolder/myFileFolder)。</span></span><br><span class="line">	<span class="comment">// - &quot;$&#123;activeFolderLong&#125;&quot;: 文件所在文件夹的完整路径 (例如 /Users/Development/myFolder/myFileFolder)。</span></span><br><span class="line">	<span class="comment">// - &quot;$&#123;folderName&#125;&quot;: 文件所在工作区文件夹的名称 (例如 myFolder)。</span></span><br><span class="line">	<span class="comment">// - &quot;$&#123;folderpath&#125;&quot;: 文件所在工作区文件夹的路径 (例如 /Users/Development/myFolder)。</span></span><br><span class="line">	<span class="comment">// - &quot;$&#123;rootName&#125;&quot;: 工作区的名称 (例如, myFolder 或 myWorkspace)。</span></span><br><span class="line">	<span class="comment">// - &quot;$&#123;rootPath&#125;&quot;: 工作区的文件路径 (例如 /Users/Development/myWorkspace)。</span></span><br><span class="line">	<span class="comment">// - &quot;$&#123;appName&#125;&quot;: 例如 VS Code。</span></span><br><span class="line">	<span class="comment">// - “$&#123;remoteName&#125;”: 例如 SSH</span></span><br><span class="line">	<span class="comment">// - &quot;$&#123;dirty&#125;&quot;: 表示活动编辑器为脏的脏指示器。</span></span><br><span class="line">	<span class="comment">// - &quot;$&#123;separator&#125;&quot;: 一种条件分隔符 (&quot;-&quot;), 仅在被包含值或静态文本的变量包围时显示。</span></span><br><span class="line">	<span class="string">&quot;window.title&quot;</span>: <span class="string">&quot;$&#123;dirty&#125;$&#123;activeEditorShort&#125;$&#123;separator&#125;$&#123;rootName&#125;$&#123;separator&#125;$&#123;appName&#125;&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调整窗口标题栏的外观。在 Linux 和 Windows 上，此设置也会影响应用程序和上下文菜单的外观。更改需要完全重新启动才能应用。</span></span><br><span class="line">	<span class="string">&quot;window.titleBarStyle&quot;</span>: <span class="string">&quot;custom&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &quot;window.title&quot; 使用的分隔符。</span></span><br><span class="line">	<span class="string">&quot;window.titleSeparator&quot;</span>: <span class="string">&quot; - &quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调整窗口的缩放级别。原始大小是 0，每次递增(例如 1)或递减(例如 -1)表示放大或缩小 20%。也可以输入小数以便以更精细的粒度调整缩放级别。</span></span><br><span class="line">	<span class="string">&quot;window.zoomLevel&quot;</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在打开禅模式时是否启用居中布局。</span></span><br><span class="line">	<span class="string">&quot;zenMode.centerLayout&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在打开禅模式时是否将工作台切换到全屏。</span></span><br><span class="line">	<span class="string">&quot;zenMode.fullScreen&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在打开禅模式时是否隐藏工作台左侧或右侧的活动栏。</span></span><br><span class="line">	<span class="string">&quot;zenMode.hideActivityBar&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在打开禅模式时是否隐藏编辑器行号。</span></span><br><span class="line">	<span class="string">&quot;zenMode.hideLineNumbers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在打开禅模式时是否隐藏工作台底部的状态栏。</span></span><br><span class="line">	<span class="string">&quot;zenMode.hideStatusBar&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在打开禅模式时是否隐藏工作台选项卡。</span></span><br><span class="line">	<span class="string">&quot;zenMode.hideTabs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若窗口在处于禅模式时退出，控制其在恢复时是否还原到禅模式。</span></span><br><span class="line">	<span class="string">&quot;zenMode.restore&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在禅宗模式下是否显示通知。如果为 true，则只会弹出错误通知。</span></span><br><span class="line">	<span class="string">&quot;zenMode.silentNotifications&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制截屏模式键盘的字体大小(以像素为单位)。</span></span><br><span class="line">	<span class="string">&quot;screencastMode.fontSize&quot;</span>: <span class="number">56</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制截屏模式下键盘覆盖显示的时长(以毫秒为单位)。</span></span><br><span class="line">	<span class="string">&quot;screencastMode.keyboardOverlayTimeout&quot;</span>: <span class="number">800</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制截屏视频模式下鼠标指示器的十六进制(#RGB、#RGBA、#RRGGBB 或 #RRGGBBAA)的颜色。</span></span><br><span class="line">	<span class="string">&quot;screencastMode.mouseIndicatorColor&quot;</span>: <span class="string">&quot;#FF0000&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制截屏模式下鼠标光标的大小(以像素为单位)。</span></span><br><span class="line">	<span class="string">&quot;screencastMode.mouseIndicatorSize&quot;</span>: <span class="number">20</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 仅在截屏模式下显示键盘快捷方式。</span></span><br><span class="line">	<span class="string">&quot;screencastMode.onlyKeyboardShortcuts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制截屏模式叠加的垂直偏移,从底部作为工作台高度的百分比。</span></span><br><span class="line">	<span class="string">&quot;screencastMode.verticalOffset&quot;</span>: <span class="number">20</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置语言的文件关联 (如: `&quot;*.extension&quot;: &quot;html&quot;`)。这些关联的优先级高于已安装语言的默认关联。</span></span><br><span class="line">	<span class="string">&quot;files.associations&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;*.cjson&quot;</span>: <span class="string">&quot;jsonc&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*.wxss&quot;</span>: <span class="string">&quot;css&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*.wxs&quot;</span>: <span class="string">&quot;javascript&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，将在文件打开时尝试猜测字符集编码。可以按语言对此项进行配置。</span></span><br><span class="line">	<span class="string">&quot;files.autoGuessEncoding&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制自动保存未保存的编辑器。有关自动保存的详细信息，请参阅[此处](https://code.visualstudio.com/docs/editor/codebasics#_save-auto-save)。</span></span><br><span class="line">	<span class="comment">//  - off: 未保存的编辑器永远不会自动保存。</span></span><br><span class="line">	<span class="comment">//  - afterDelay: 将在配置的 &quot;#files.autoSaveDelay#&quot; 后自动保存未保存的编辑器。</span></span><br><span class="line">	<span class="comment">//  - onFocusChange: 当编辑器失去焦点时，将自动保存未保存的编辑器。</span></span><br><span class="line">	<span class="comment">//  - onWindowChange: 当窗口失去焦点时，将自动保存未保存的编辑器。</span></span><br><span class="line">	<span class="string">&quot;files.autoSave&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制自动保存未保存的编辑器之前经过的延迟(以毫秒为单位)。仅当 `files.autoSave` 设置为`afterDelay`时才适用。</span></span><br><span class="line">	<span class="string">&quot;files.autoSaveDelay&quot;</span>: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配给新文件的默认语言模式。如果配置为&quot;$&#123;activeEditorLanguage&#125;&quot;，将使用当前活动文本编辑器的语言模式(如果有)。</span></span><br><span class="line">	<span class="string">&quot;files.defaultLanguage&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在删除文件或文件夹时，将它们移动到操作系统的“废纸篓”中 (Windows 为“回收站”)。禁用此设置将永久删除文件或文件夹。</span></span><br><span class="line">	<span class="string">&quot;files.enableTrash&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在读取和写入文件时使用的默认字符集编码。可以按语言对此项进行配置。</span></span><br><span class="line">	<span class="comment">//  - utf8: UTF-8</span></span><br><span class="line">	<span class="comment">//  - utf8bom: UTF-8 with BOM</span></span><br><span class="line">	<span class="comment">//  - utf16le: UTF-16 LE</span></span><br><span class="line">	<span class="comment">//  - utf16be: UTF-16 BE</span></span><br><span class="line">	<span class="comment">//  - windows1252: Western (Windows 1252)</span></span><br><span class="line">	<span class="comment">//  - iso88591: Western (ISO 8859-1)</span></span><br><span class="line">	<span class="comment">//  - iso88593: Western (ISO 8859-3)</span></span><br><span class="line">	<span class="comment">//  - iso885915: Western (ISO 8859-15)</span></span><br><span class="line">	<span class="comment">//  - macroman: Western (Mac Roman)</span></span><br><span class="line">	<span class="comment">//  - cp437: DOS (CP 437)</span></span><br><span class="line">	<span class="comment">//  - windows1256: Arabic (Windows 1256)</span></span><br><span class="line">	<span class="comment">//  - iso88596: Arabic (ISO 8859-6)</span></span><br><span class="line">	<span class="comment">//  - windows1257: Baltic (Windows 1257)</span></span><br><span class="line">	<span class="comment">//  - iso88594: Baltic (ISO 8859-4)</span></span><br><span class="line">	<span class="comment">//  - iso885914: Celtic (ISO 8859-14)</span></span><br><span class="line">	<span class="comment">//  - windows1250: Central European (Windows 1250)</span></span><br><span class="line">	<span class="comment">//  - iso88592: Central European (ISO 8859-2)</span></span><br><span class="line">	<span class="comment">//  - cp852: Central European (CP 852)</span></span><br><span class="line">	<span class="comment">//  - windows1251: Cyrillic (Windows 1251)</span></span><br><span class="line">	<span class="comment">//  - cp866: Cyrillic (CP 866)</span></span><br><span class="line">	<span class="comment">//  - iso88595: Cyrillic (ISO 8859-5)</span></span><br><span class="line">	<span class="comment">//  - koi8r: Cyrillic (KOI8-R)</span></span><br><span class="line">	<span class="comment">//  - koi8u: Cyrillic (KOI8-U)</span></span><br><span class="line">	<span class="comment">//  - iso885913: Estonian (ISO 8859-13)</span></span><br><span class="line">	<span class="comment">//  - windows1253: Greek (Windows 1253)</span></span><br><span class="line">	<span class="comment">//  - iso88597: Greek (ISO 8859-7)</span></span><br><span class="line">	<span class="comment">//  - windows1255: Hebrew (Windows 1255)</span></span><br><span class="line">	<span class="comment">//  - iso88598: Hebrew (ISO 8859-8)</span></span><br><span class="line">	<span class="comment">//  - iso885910: Nordic (ISO 8859-10)</span></span><br><span class="line">	<span class="comment">//  - iso885916: Romanian (ISO 8859-16)</span></span><br><span class="line">	<span class="comment">//  - windows1254: Turkish (Windows 1254)</span></span><br><span class="line">	<span class="comment">//  - iso88599: Turkish (ISO 8859-9)</span></span><br><span class="line">	<span class="comment">//  - windows1258: Vietnamese (Windows 1258)</span></span><br><span class="line">	<span class="comment">//  - gbk: Simplified Chinese (GBK)</span></span><br><span class="line">	<span class="comment">//  - gb18030: Simplified Chinese (GB18030)</span></span><br><span class="line">	<span class="comment">//  - cp950: Traditional Chinese (Big5)</span></span><br><span class="line">	<span class="comment">//  - big5hkscs: Traditional Chinese (Big5-HKSCS)</span></span><br><span class="line">	<span class="comment">//  - shiftjis: Japanese (Shift JIS)</span></span><br><span class="line">	<span class="comment">//  - eucjp: Japanese (EUC-JP)</span></span><br><span class="line">	<span class="comment">//  - euckr: Korean (EUC-KR)</span></span><br><span class="line">	<span class="comment">//  - windows874: Thai (Windows 874)</span></span><br><span class="line">	<span class="comment">//  - iso885911: Latin/Thai (ISO 8859-11)</span></span><br><span class="line">	<span class="comment">//  - koi8ru: Cyrillic (KOI8-RU)</span></span><br><span class="line">	<span class="comment">//  - koi8t: Tajik (KOI8-T)</span></span><br><span class="line">	<span class="comment">//  - gb2312: Simplified Chinese (GB 2312)</span></span><br><span class="line">	<span class="comment">//  - cp865: Nordic DOS (CP 865)</span></span><br><span class="line">	<span class="comment">//  - cp850: Western European DOS (CP 850)</span></span><br><span class="line">	<span class="string">&quot;files.encoding&quot;</span>: <span class="string">&quot;utf8&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认行尾字符。</span></span><br><span class="line">	<span class="comment">//  - \n: LF</span></span><br><span class="line">	<span class="comment">//  - \r\n: CRLF</span></span><br><span class="line">	<span class="comment">//  - auto: 使用具体操作系统规定的行末字符。</span></span><br><span class="line">	<span class="string">&quot;files.eol&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置用于排除文件和文件夹的 glob 模式。例如，文件资源管理器根据此设置决定要显示或隐藏的文件和文件夹。请参阅 `search.exclude` 设置以定义特定于搜索的排除。在[此处](https://code.visualstudio.com/docs/editor/codebasics#_advanced-search-options)详细了解 glob 模式。</span></span><br><span class="line">	<span class="string">&quot;files.exclude&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;**/.git&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;**/.svn&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;**/.hg&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;**/CVS&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;**/.DS_Store&quot;</span>: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在会话间记住未保存的文件，以允许在退出编辑器时跳过保存提示。</span></span><br><span class="line">	<span class="comment">//  - off: 禁用热退出。尝试关闭带有已更新文件的窗口时，将显示提示。</span></span><br><span class="line">	<span class="comment">//  - onExit: 触发 &quot;workbench.action.quit&quot; 命令(命令面板、键绑定、菜单)或在 Windows/Linux 上关闭最后一个窗口时，将触发热退出。所有未打开文件夹的窗口都将在下次启动时恢复。可通过“文件”&gt;“打开最近使用的文件”&gt;“更多...”，访问包含未保存的文件的工作区列表。</span></span><br><span class="line">	<span class="comment">//  - onExitAndWindowClose: 触发 &quot;workbench.action.quit&quot; 命令(命令面板、键绑定、菜单)或在 Windows/Linux 上关闭最后一个窗口时将触发热退出，还将对已打开文件夹的所有窗口触发热退出(无论是否是最后一个窗口)。所有未打开文件夹的窗口将在下次启动时恢复。可通过“文件”&gt;“打开最近使用的文件”&gt;“更多…”，访问包含未保存的文件的工作区列表。</span></span><br><span class="line">	<span class="string">&quot;files.hotExit&quot;</span>: <span class="string">&quot;onExit&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，保存文件时在文件末尾插入一个最终新行。</span></span><br><span class="line">	<span class="string">&quot;files.insertFinalNewline&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在打开大型文件时，控制 VS Code 可在重启后使用的内存。在命令行中指定 `--max-memory=新的大小` 参数可达到相同效果。</span></span><br><span class="line">	<span class="string">&quot;files.maxMemoryForLargeFilesMB&quot;</span>: <span class="number">4096</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 超时(以毫秒为单位)后，将取消创建、重命名和删除的文件参与者。使用&quot;0&quot;禁用参与者。</span></span><br><span class="line">	<span class="string">&quot;files.participants.timeout&quot;</span>: <span class="number">5000</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新打开文件后，还原撤消堆栈。</span></span><br><span class="line">	<span class="string">&quot;files.restoreUndoStack&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当文件保存到磁盘上并被另一个程序更改时，可能会发生保存冲突。 为了防止数据丢失，要求用户将编辑器中的更改与磁盘上的版本进行比较。 仅当经常遇到保存冲突错误时，才应更改此设置；如果不谨慎使用，可能会导致数据丢失。</span></span><br><span class="line">	<span class="comment">//  - askUser: 将拒绝保存并请求手动解决保存冲突。</span></span><br><span class="line">	<span class="comment">//  - overwriteFileOnDisk: 将通过在编辑器中用更改覆盖磁盘上的文件来解决保存冲突。</span></span><br><span class="line">	<span class="string">&quot;files.saveConflictResolution&quot;</span>: <span class="string">&quot;askUser&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用简单文件对话框。启用时，简单文件对话框将替换系统文件对话框。</span></span><br><span class="line">	<span class="string">&quot;files.simpleDialog.enable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，保存文件时将删除在最终新行后的所有新行。</span></span><br><span class="line">	<span class="string">&quot;files.trimFinalNewlines&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，将在保存文件时删除文件末尾的空格。</span></span><br><span class="line">	<span class="string">&quot;files.trimTrailingWhitespace&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置文件路径的 glob 模式以从文件监视排除。模式必须在绝对路径上匹配(例如 ** 前缀或完整路径需正确匹配)。更改此设置需要重启。如果在启动时遇到 Code 消耗大量 CPU 时间，则可以排除大型文件夹以减少初始加载。</span></span><br><span class="line">	<span class="string">&quot;files.watcherExclude&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;**/.git/objects/**&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;**/.git/subtree-cache/**&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;**/node_modules/*/**&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;**/.hg/store/**&quot;</span>: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制资源管理器是否在打开文件时自动显示并选择。</span></span><br><span class="line">	<span class="comment">//  - true: 将显示和选择文件。</span></span><br><span class="line">	<span class="comment">//  - false: 不会显示和选择文件。</span></span><br><span class="line">	<span class="comment">//  - focusNoScroll: 文件不会滚动到视图中，但仍会获得焦点。</span></span><br><span class="line">	<span class="string">&quot;explorer.autoReveal&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制资源管理器是否应以紧凑形式呈现文件夹。在这种形式中，单个子文件夹将被压缩在组合的树元素中。例如，对 Java 包结构很有用。</span></span><br><span class="line">	<span class="string">&quot;explorer.compactFolders&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制资源管理器是否在把文件删除到废纸篓时进行确认。</span></span><br><span class="line">	<span class="string">&quot;explorer.confirmDelete&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在资源管理器内拖放移动文件或文件夹时是否进行确认。</span></span><br><span class="line">	<span class="string">&quot;explorer.confirmDragAndDrop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制文件修饰是否应使用徽章。</span></span><br><span class="line">	<span class="string">&quot;explorer.decorations.badges&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制文件修饰是否应使用颜色。</span></span><br><span class="line">	<span class="string">&quot;explorer.decorations.colors&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制资源管理器是否允许通过拖放移动文件和文件夹。</span></span><br><span class="line">	<span class="string">&quot;explorer.enableDragAndDrop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择在粘贴同名文件(夹)时要使用的重命名方式。</span></span><br><span class="line">	<span class="comment">//  - simple: 在重复名称的末尾附加单词“copy”，后面可能跟一个数字</span></span><br><span class="line">	<span class="comment">//  - smart: 在重复名称的末尾添加一个数字。如果某个号码已经是名称的一部分，请尝试增加该号码</span></span><br><span class="line">	<span class="string">&quot;explorer.incrementalNaming&quot;</span>: <span class="string">&quot;simple&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在“打开的编辑器”窗格中显示的编辑器数量。</span></span><br><span class="line">	<span class="string">&quot;explorer.openEditors.visible&quot;</span>: <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制文件和文件夹在资源管理器中的排列顺序。</span></span><br><span class="line">	<span class="comment">//  - default: 按名称的字母顺序排列文件和文件夹。文件夹显示在文件前。</span></span><br><span class="line">	<span class="comment">//  - mixed: 按名称的字母顺序排列文件和文件夹。两者穿插显示。</span></span><br><span class="line">	<span class="comment">//  - filesFirst: 按名称的字母顺序排列文件和文件夹。文件显示在文件夹前。</span></span><br><span class="line">	<span class="comment">//  - type: 按扩展名的字母顺序排列文件和文件夹。文件夹显示在文件前。</span></span><br><span class="line">	<span class="comment">//  - modified: 按最后修改日期降序排列文件和文件夹。文件夹显示在文件前。</span></span><br><span class="line">	<span class="string">&quot;explorer.sortOrder&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在搜索视图中控制操作栏的位置。</span></span><br><span class="line">	<span class="comment">//  - auto: 当搜索视图较窄时将操作栏置于右侧，当搜索视图较宽时，将它紧接在内容之后。</span></span><br><span class="line">	<span class="comment">//  - right: 始终将操作栏放置在右侧。</span></span><br><span class="line">	<span class="string">&quot;search.actionsPosition&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是折叠还是展开搜索结果。</span></span><br><span class="line">	<span class="comment">//  - auto: 结果少于10个的文件将被展开。其他的则被折叠。</span></span><br><span class="line">	<span class="comment">//  - alwaysCollapse</span></span><br><span class="line">	<span class="comment">//  - alwaysExpand</span></span><br><span class="line">	<span class="string">&quot;search.collapseResults&quot;</span>: <span class="string">&quot;alwaysExpand&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置glob模式以在全文本搜索和快速打开中排除文件和文件夹。从“＃files.exclude＃”设置继承所有glob模式。在[此处](https://code.visualstudio.com/docs/editor/codebasics#_advanced-search-options)了解更多关于glob模式的信息</span></span><br><span class="line">	<span class="string">&quot;search.exclude&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;**/node_modules&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;**/bower_components&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;**/*.code-search&quot;</span>: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在搜索中跟踪符号链接。</span></span><br><span class="line">	<span class="string">&quot;search.followSymlinks&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，搜索服务进程将保持活动状态，而不是在一个小时不活动后关闭。这将使文件搜索缓存保留在内存中。</span></span><br><span class="line">	<span class="string">&quot;search.maintainFileSearchCache&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在快速打开中筛选时编辑器历史记录的排序顺序。</span></span><br><span class="line">	<span class="comment">//  - default: 历史记录条目按与筛选值的相关性排序。首先显示更相关的条目。</span></span><br><span class="line">	<span class="comment">//  - recency: 历史记录条目按最近时间排序。首先显示最近打开的条目。</span></span><br><span class="line">	<span class="string">&quot;search.quickOpen.history.filterSortOrder&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否在 Quick Open 的文件结果中包含最近打开的文件。</span></span><br><span class="line">	<span class="string">&quot;search.quickOpen.includeHistory&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制 Quick Open 文件结果中是否包括全局符号搜索的结果。</span></span><br><span class="line">	<span class="string">&quot;search.quickOpen.includeSymbols&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建新的搜索编辑器时要使用的周围上下文行的默认数目。如果使用 &quot;#search.searchEditor.reusePriorSearchConfiguration#&quot;，则可将它设置为 &quot;null&quot; (空)，以使用搜索编辑器之前的配置。</span></span><br><span class="line">	<span class="string">&quot;search.searchEditor.defaultNumberOfContextLines&quot;</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置在搜索编辑器中双击结果的效果。</span></span><br><span class="line">	<span class="comment">//  - selectWord: 双击选择光标下的单词。</span></span><br><span class="line">	<span class="comment">//  - goToLocation: 双击将在活动编辑器组中打开结果。</span></span><br><span class="line">	<span class="comment">//  - openLocationToSide: 双击将在编辑器组中的结果打开到一边，如果尚不存在，则创建一个结果。</span></span><br><span class="line">	<span class="string">&quot;search.searchEditor.doubleClickBehaviour&quot;</span>: <span class="string">&quot;goToLocation&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，新的搜索编辑器将重用以前打开的搜索编辑器的包含、排除和标志</span></span><br><span class="line">	<span class="string">&quot;search.searchEditor.reusePriorSearchConfiguration&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在键入时搜索所有文件。</span></span><br><span class="line">	<span class="string">&quot;search.searchOnType&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用&quot;#search.searchOnType&quot;后，控制键入的字符与开始搜索之间的超时(以毫秒为单位)。禁用&quot;搜索.searchOnType&quot;时无效。</span></span><br><span class="line">	<span class="string">&quot;search.searchOnTypeDebouncePeriod&quot;</span>: <span class="number">300</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 聚焦搜索视图时，将工作区搜索查询更新为编辑器的所选文本。单击时或触发 `workbench.views.search.focus` 命令时会发生此情况。</span></span><br><span class="line">	<span class="string">&quot;search.seedOnFocus&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当活动编辑器没有选定内容时，从离光标最近的字词开始进行种子设定搜索。</span></span><br><span class="line">	<span class="string">&quot;search.seedWithNearestWord&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否显示搜索结果所在的行号。</span></span><br><span class="line">	<span class="string">&quot;search.showLineNumbers&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若搜索词全为小写，则不区分大小写进行搜索，否则区分大小写进行搜索。</span></span><br><span class="line">	<span class="string">&quot;search.smartCase&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制搜索结果的排序顺序。</span></span><br><span class="line">	<span class="comment">//  - default: 结果按文件夹和文件名按字母顺序排序。</span></span><br><span class="line">	<span class="comment">//  - fileNames: 结果按文件名排序，忽略文件夹顺序，按字母顺序排列。</span></span><br><span class="line">	<span class="comment">//  - type: 结果按文件扩展名的字母顺序排序。</span></span><br><span class="line">	<span class="comment">//  - modified: 结果按文件的最后修改日期按降序排序。</span></span><br><span class="line">	<span class="comment">//  - countDescending: 结果按每个文件的计数降序排序。</span></span><br><span class="line">	<span class="comment">//  - countAscending: 结果按每个文件的计数以升序排序。</span></span><br><span class="line">	<span class="string">&quot;search.sortOrder&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在搜索文件时是否使用全局 `.gitignore` 和 `.ignore` 文件。</span></span><br><span class="line">	<span class="string">&quot;search.useGlobalIgnoreFiles&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在搜索文件时是否使用 `.gitignore` 和 `.ignore` 文件。</span></span><br><span class="line">	<span class="string">&quot;search.useIgnoreFiles&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 弃用。当使用仅 PCRE2 支持的正则表达式功能时，将自动使用 PCRE2。</span></span><br><span class="line">	<span class="comment">// 是否在文本搜索中使用 pcre2 正则表达式引擎。这允许使用一些高级正则表达式功能, 如前瞻和反向引用。但是, 并非所有 pcre2 功能都受支持-仅支持 javascript 也支持的功能。</span></span><br><span class="line">	<span class="string">&quot;search.usePCRE2&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在选择或替换匹配项时是否打开“替换预览”视图。</span></span><br><span class="line">	<span class="string">&quot;search.useReplacePreview&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 已弃用。请考虑使用 &quot;search.usePCRE2&quot; 获取对高级正则表达式功能的支持。</span></span><br><span class="line">	<span class="comment">// 此设置已被弃用，将回退到 &quot;search.usePCRE2&quot;。</span></span><br><span class="line">	<span class="string">&quot;search.useRipgrep&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此设置已弃用，请改用“update.mode”。</span></span><br><span class="line">	<span class="comment">// 配置是否接收自动更新。更改后需要重新启动。更新是从微软在线服务获取的。</span></span><br><span class="line">	<span class="string">&quot;update.channel&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用在 Windows 上后台下载和安装新的 VS Code 版本</span></span><br><span class="line">	<span class="string">&quot;update.enableWindowsBackgroundUpdates&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置是否接收自动更新。更改后需要重新启动。更新是从微软在线服务获取的。</span></span><br><span class="line">	<span class="comment">//  - none: 禁用更新。</span></span><br><span class="line">	<span class="comment">//  - manual: 禁用自动后台更新检查。如果手动检查更新，更新将可用。</span></span><br><span class="line">	<span class="comment">//  - start: 仅在启动时检查更新。禁用自动后台更新检查。</span></span><br><span class="line">	<span class="comment">//  - default: 启用自动更新检查。代码将定期自动检查更新。</span></span><br><span class="line">	<span class="string">&quot;update.mode&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在更新后显示发行说明。发行说明将从 Microsoft 联机服务中获取。</span></span><br><span class="line">	<span class="string">&quot;update.showReleaseNotes&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 要使用的代理设置。如果未设置，则将从 &quot;http_proxy&quot; 和 &quot;https_proxy&quot; 环境变量中继承。</span></span><br><span class="line">	<span class="string">&quot;http.proxy&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 要作为每个网络请求的 &quot;Proxy-Authorization&quot; 标头发送的值。</span></span><br><span class="line">	<span class="string">&quot;http.proxyAuthorization&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否根据提供的 CA 列表验证代理服务器证书。</span></span><br><span class="line">	<span class="string">&quot;http.proxyStrictSSL&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对扩展使用代理支持。</span></span><br><span class="line">	<span class="comment">//  - off: 禁用对扩展的代理支持。</span></span><br><span class="line">	<span class="comment">//  - on: 为扩展启用代理支持。</span></span><br><span class="line">	<span class="comment">//  - override: 为扩展启用代理支持，覆盖请求选项。</span></span><br><span class="line">	<span class="string">&quot;http.proxySupport&quot;</span>: <span class="string">&quot;override&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否应从操作系统加载 CA 证书。(在 Windows 和 macOS 上, 关闭此窗口后需要重新加载窗口)。</span></span><br><span class="line">	<span class="string">&quot;http.systemCertificates&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 允许在任何文件中设置断点。</span></span><br><span class="line">	<span class="string">&quot;debug.allowBreakpointsEverywhere&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制调试控制台是否应在调试会话结束时自动关闭。</span></span><br><span class="line">	<span class="string">&quot;debug.console.closeOnEnd&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制调试控制台中的字体系列。</span></span><br><span class="line">	<span class="comment">// &quot;debug.console.fontFamily&quot;: &quot;default&quot;,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制调试控制台中的字体大小(以像素为单位)。</span></span><br><span class="line">	<span class="comment">// &quot;debug.console.fontSize&quot;: 14,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制调试控制台是否应建议以前键入的输入。</span></span><br><span class="line">	<span class="string">&quot;debug.console.historySuggestions&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置调试控制台中的行高(以像素为单位)。使用 0 来计算从字体大小开始的行高。</span></span><br><span class="line">	<span class="string">&quot;debug.console.lineHeight&quot;</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否应在调试控制台中换行。</span></span><br><span class="line">	<span class="string">&quot;debug.console.wordWrap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制当调试器中断时，工作台窗口是否应获得焦点。</span></span><br><span class="line">	<span class="string">&quot;debug.focusWindowOnBreak&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当处于调试过程中时，在编辑器中内联显示变量值。</span></span><br><span class="line">	<span class="string">&quot;debug.inlineValues&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制何时打开内部调试控制台。</span></span><br><span class="line">	<span class="string">&quot;debug.internalConsoleOptions&quot;</span>: <span class="string">&quot;openOnFirstSessionStart&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在运行预启动任务后遇到错误时应该怎么做。</span></span><br><span class="line">	<span class="comment">//  - debugAnyway: 忽略任务错误并开始调试。</span></span><br><span class="line">	<span class="comment">//  - showErrors: 显示问题视图且不开始调试。</span></span><br><span class="line">	<span class="comment">//  - prompt: 提示用户。</span></span><br><span class="line">	<span class="comment">//  - abort: 取消调试。</span></span><br><span class="line">	<span class="string">&quot;debug.onTaskErrors&quot;</span>: <span class="string">&quot;prompt&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制何时打开“调试”视图。</span></span><br><span class="line">	<span class="string">&quot;debug.openDebug&quot;</span>: <span class="string">&quot;openOnFirstSessionStart&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在调试会话结束时自动打开资源管理器视图。</span></span><br><span class="line">	<span class="string">&quot;debug.openExplorerOnEnd&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制断点是否应显示在概览标尺中。</span></span><br><span class="line">	<span class="string">&quot;debug.showBreakpointsInOverviewRuler&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制调试时是否应在编辑器中显示内联断点候选修饰。</span></span><br><span class="line">	<span class="string">&quot;debug.showInlineBreakpointCandidates&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制何时显示调试状态栏。</span></span><br><span class="line">	<span class="comment">//  - never: 在状态栏中不再显示调试</span></span><br><span class="line">	<span class="comment">//  - always: 始终在状态栏中显示调试</span></span><br><span class="line">	<span class="comment">//  - onFirstSessionStart: 仅于第一次启动调试后在状态栏中显示调试</span></span><br><span class="line">	<span class="string">&quot;debug.showInStatusBar&quot;</span>: <span class="string">&quot;onFirstSessionStart&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制调试子会话是否显示在调试工具栏中。当此设置为 false 时, 子会话上的 stop 命令也将停止父会话。</span></span><br><span class="line">	<span class="string">&quot;debug.showSubSessionsInToolBar&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制调试工具栏的位置。可在所有视图中“浮动”、在调试视图中“停靠”，也可“隐藏”。</span></span><br><span class="line">	<span class="string">&quot;debug.toolBarLocation&quot;</span>: <span class="string">&quot;floating&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 全局调试启动配置。应当作为跨工作区共享的 \&quot;launch.json\&quot; 的替代方法。</span></span><br><span class="line">	<span class="string">&quot;launch&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;configurations&quot;</span>: [],</span><br><span class="line">		<span class="string">&quot;compounds&quot;</span>: []</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制评论面板应何时打开。</span></span><br><span class="line">	<span class="string">&quot;comments.openPanel&quot;</span>: <span class="string">&quot;openOnSessionStartWithComments&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用 HTML 标记的自动关闭。</span></span><br><span class="line">	<span class="string">&quot;html.autoClosingTags&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一个相对文件路径列表，这些路径指向采用[自定义数据格式](https://github.com/Microsoft/vscode-html-languageservice/blob/master/docs/customData.md)的 JSON 文件。</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// VS Code 在启动时加载自定义数据，从而增强它对你在 JSON 文件中指定的自定义 HTML 标记、属性和属性值的 HTML 支持。</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// 文件路径与工作区相对，且仅考虑工作区文件夹设置。</span></span><br><span class="line">	<span class="string">&quot;html.customData&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记列表(用逗号隔开)，其中内容不应重新格式化。&quot;null&quot; 默认为 &quot;pre&quot; 标记。</span></span><br><span class="line">	<span class="string">&quot;html.format.contentUnformatted&quot;</span>: <span class="string">&quot;pre,code,textarea&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用默认 HTML 格式化程序。</span></span><br><span class="line">	<span class="string">&quot;html.format.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以新行结束。</span></span><br><span class="line">	<span class="string">&quot;html.format.endWithNewline&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以逗号分隔的标记列表，其中的标记之前将有额外新行。若为 `null`，默认包含 `&quot;head, body, /html&quot;`。</span></span><br><span class="line">	<span class="string">&quot;html.format.extraLiners&quot;</span>: <span class="string">&quot;head, body, /html&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对 `&#123;&#123;#foo&#125;&#125;` 和 `&#123;&#123;/foo&#125;&#125;` 进行格式化与缩进。</span></span><br><span class="line">	<span class="string">&quot;html.format.indentHandlebars&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缩进 &quot;&lt;head&gt;&quot; 和 &quot;&lt;body&gt;&quot; 部分。</span></span><br><span class="line">	<span class="string">&quot;html.format.indentInnerHtml&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保留在一个区块中的换行符的最大数量。若为 `null`，则没有限制。</span></span><br><span class="line">	<span class="string">&quot;html.format.maxPreserveNewLines&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否保留元素前已有的换行符。仅适用于元素前，不适用于标记内或文本。</span></span><br><span class="line">	<span class="string">&quot;html.format.preserveNewLines&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以逗号分隔的标记列表，其中的内容不会被重新格式化。若为 `null`，默认包含所有列于 https://www.w3.org/TR/html5/dom.html#phrasing-content 的标记。</span></span><br><span class="line">	<span class="string">&quot;html.format.unformatted&quot;</span>: <span class="string">&quot;wbr&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对属性进行换行。</span></span><br><span class="line">	<span class="comment">//  - auto: 仅在超出行长度时才对属性进行换行。</span></span><br><span class="line">	<span class="comment">//  - force: 对除第一个属性外的其他每个属性进行换行。</span></span><br><span class="line">	<span class="comment">//  - force-aligned: 对除第一个属性外的其他每个属性进行换行，并保持对齐。</span></span><br><span class="line">	<span class="comment">//  - force-expand-multiline: 对每个属性进行换行。</span></span><br><span class="line">	<span class="comment">//  - aligned-multiple: 当超出折行长度时，将属性进行垂直对齐。</span></span><br><span class="line">	<span class="comment">//  - preserve: 保留属性的包装</span></span><br><span class="line">	<span class="comment">//  - preserve-aligned: 保留属性的包装，但对齐。</span></span><br><span class="line">	<span class="string">&quot;html.format.wrapAttributes&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每行最大字符数(0 = 禁用)。</span></span><br><span class="line">	<span class="string">&quot;html.format.wrapLineLength&quot;</span>: <span class="number">120</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 已弃用，请改用 &quot;editor.renameOnType&quot;。</span></span><br><span class="line">	<span class="comment">// 在匹配的 HTML 标记上启用/禁用镜像光标。</span></span><br><span class="line">	<span class="string">&quot;html.mirrorCursorOnMatchingTag&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置内置 HTML 语言支持是否建议 HTML5 标记、属性和值。</span></span><br><span class="line">	<span class="string">&quot;html.suggest.html5&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 跟踪 VS Code 与 HTML 语言服务器之间的通信。</span></span><br><span class="line">	<span class="string">&quot;html.trace.server&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置内置的 HTML 语言支持是否对嵌入的脚本进行验证。</span></span><br><span class="line">	<span class="string">&quot;html.validate.scripts&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置内置 HTML 语言支持是否对嵌入的样式进行验证。</span></span><br><span class="line">	<span class="string">&quot;html.validate.styles&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 已弃用设置 &quot;json.colorDecorators.enable&quot;，请改用 &quot;editor.colorDecorators&quot;。</span></span><br><span class="line">	<span class="comment">// 启用或禁用颜色修饰器</span></span><br><span class="line">	<span class="string">&quot;json.colorDecorators.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用默认 JSON 格式化程序。</span></span><br><span class="line">	<span class="string">&quot;json.format.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算的大纲符号和折叠区域的最大数量(因性能原因而受限)。</span></span><br><span class="line">	<span class="string">&quot;json.maxItemsComputed&quot;</span>: <span class="number">5000</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，可以从 http 和 https 位置提取 JSON 架构。</span></span><br><span class="line">	<span class="string">&quot;json.schemaDownload.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将架构关联到当前项目中的 JSON 文件</span></span><br><span class="line">	<span class="string">&quot;json.schemas&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 跟踪 VS Code 和 JSON 语言服务器之间的通信。</span></span><br><span class="line">	<span class="string">&quot;json.trace.server&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制应在何处打开markdown文件中的链接。</span></span><br><span class="line">	<span class="comment">//  - currentGroup: 打开活动编辑器组中的链接。</span></span><br><span class="line">	<span class="comment">//  - beside: 打开活动编辑器旁边的链接。</span></span><br><span class="line">	<span class="string">&quot;markdown.links.openLocation&quot;</span>: <span class="string">&quot;currentGroup&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置换行符在 Markdown 预览中的呈现方式。如果将其设置为 &quot;true&quot;，则将为段落内的新行创建一个 &lt;br&gt;。</span></span><br><span class="line">	<span class="string">&quot;markdown.preview.breaks&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 Markdown 预览中双击切换到编辑器。</span></span><br><span class="line">	<span class="string">&quot;markdown.preview.doubleClickToSwitchToEditor&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制 Markdown 预览中使用的字体系列。</span></span><br><span class="line">	<span class="comment">// &quot;markdown.preview.fontFamily&quot;: &quot;-apple-system, BlinkMacSystemFont, &#x27;Segoe WPC&#x27;, &#x27;Segoe UI&#x27;, system-ui, &#x27;Ubuntu&#x27;, &#x27;Droid Sans&#x27;, sans-serif&quot;,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制 Markdown 预览中使用的字号(以像素为单位)。</span></span><br><span class="line">	<span class="comment">// &quot;markdown.preview.fontSize&quot;: 14,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制 Markdown 预览中使用的行高。此数值与字号相关。</span></span><br><span class="line">	<span class="string">&quot;markdown.preview.lineHeight&quot;</span>: <span class="number">1.6</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 Markdown 预览中启用或禁用将类似 URL 的文本转换为链接。</span></span><br><span class="line">	<span class="string">&quot;markdown.preview.linkify&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 Markdown 预览中标记当前的编辑器选定内容。</span></span><br><span class="line">	<span class="string">&quot;markdown.preview.markEditorSelection&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制如何打开markdown预览中其他markdown文件的链接。</span></span><br><span class="line">	<span class="comment">//  - inPreview: 尝试在 Markdown 预览中打开链接</span></span><br><span class="line">	<span class="comment">//  - inEditor: 尝试在编辑器中打开链接</span></span><br><span class="line">	<span class="string">&quot;markdown.preview.openMarkdownLinks&quot;</span>: <span class="string">&quot;inPreview&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 滚动 Markdown 预览时，更新其编辑器视图。</span></span><br><span class="line">	<span class="string">&quot;markdown.preview.scrollEditorWithPreview&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 滚动 Markdown 编辑器时，更新其预览视图。</span></span><br><span class="line">	<span class="string">&quot;markdown.preview.scrollPreviewWithEditor&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 要在 Markdown 预览中使用的 CSS 样式表的 URL 或本地路径列表。相对路径被解释为相对于资源管理器中打开的文件夹。如果没有任何打开的文件夹，则会被解释为相对于 Markdown 文件的位置。所有的 &quot;\&quot; 需写为 &quot;\\&quot;。</span></span><br><span class="line">	<span class="string">&quot;markdown.styles&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对 Markdown 扩展启用调试日志记录。</span></span><br><span class="line">	<span class="string">&quot;markdown.trace&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否启用内置 PHP 语言建议。支持对 PHP 全局变量和变量进行建议。</span></span><br><span class="line">	<span class="string">&quot;php.suggest.basic&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用内置的 PHP 验证。</span></span><br><span class="line">	<span class="string">&quot;php.validate.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指向 PHP 可执行文件。</span></span><br><span class="line">	<span class="string">&quot;php.validate.executablePath&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不管 linter 是在 save 还是在 type 上运行。</span></span><br><span class="line">	<span class="string">&quot;php.validate.run&quot;</span>: <span class="string">&quot;onSave&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用 JSX 标记的自动关闭。</span></span><br><span class="line">	<span class="string">&quot;javascript.autoClosingTags&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用 JavaScript 格式化程序。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义逗号分隔符后面的空格处理。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.insertSpaceAfterCommaDelimiter&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义构造函数关键字后面的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.insertSpaceAfterConstructor&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义匿名函数的函数关键字后面的空格处理。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.insertSpaceAfterFunctionKeywordForAnonymousFunctions&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义控制流语句中关键字后面的空格处理。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.insertSpaceAfterKeywordsInControlFlowStatements&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义 JSX 表达式括号中左括号后和右括号前的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义非空大括号中左括号后和右括号前的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义非空中括号的左括号后和右括号前的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义非空小括号的左括号后和右括号前的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义模板字符串括号中左括号后和右括号前的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义 for 语句中分号之后的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.insertSpaceAfterSemicolonInForStatements&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义二进制运算符后面的空格处理</span></span><br><span class="line">	<span class="string">&quot;javascript.format.insertSpaceBeforeAndAfterBinaryOperators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义函数参数括号前的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义控制块的左括号是否放置在新的一行。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.placeOpenBraceOnNewLineForControlBlocks&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义函数的左大括号是否放置在新的一行。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.placeOpenBraceOnNewLineForFunctions&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义非必要分号的处理方式。要求在工作区内使用 TypeScript 3.7 或更高版本。</span></span><br><span class="line">	<span class="comment">//  - ignore: 不要插入或删除任何分号。</span></span><br><span class="line">	<span class="comment">//  - insert: 在语句末尾插入分号。</span></span><br><span class="line">	<span class="comment">//  - remove: 删除不必要的分号。</span></span><br><span class="line">	<span class="string">&quot;javascript.format.semicolons&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用 JavaScript 文件的语义检查。若有 jsconfig.json 或 tsconfig.json 文件，将覆盖此设置。</span></span><br><span class="line">	<span class="string">&quot;javascript.implicitProjectConfig.checkJs&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对不属于任何工程的 JavaScript 文件启用或禁用 `experimentalDecorators` 设置。若有 jsconfig.json 或 tsconfig.json 文件，将覆盖此设置。</span></span><br><span class="line">	<span class="string">&quot;javascript.implicitProjectConfig.experimentalDecorators&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动 import 语句中路径的首选样式。</span></span><br><span class="line">	<span class="comment">//  - auto: 自动选择导入路径样式。如果配置了 &quot;baseUrl&quot;，并且相对路径的段少于非相对导入，则首选相对导入。</span></span><br><span class="line">	<span class="comment">//  - relative: 相对于文件位置。</span></span><br><span class="line">	<span class="comment">//  - non-relative: 根据 `jsconfig.json` 或 `tsconfig.json` 中配置的 `baseUrl` 。</span></span><br><span class="line">	<span class="string">&quot;javascript.preferences.importModuleSpecifier&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动导入的首选路径结尾。</span></span><br><span class="line">	<span class="comment">//  - auto: 使用项目设置选择默认值。</span></span><br><span class="line">	<span class="comment">//  - minimal: 将 &quot;./component/index.js&quot; 缩短为 &quot;./component&quot;。</span></span><br><span class="line">	<span class="comment">//  - index: 将 &quot;./component/index.js&quot; 缩短为 &quot;./component/index&quot;。</span></span><br><span class="line">	<span class="comment">//  - js: 不要缩短路径结尾;包括&quot;.js&quot;扩展名。</span></span><br><span class="line">	<span class="string">&quot;javascript.preferences.importModuleSpecifierEnding&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于快速修复的首选引用样式: `single` (单引号)、`double` (双引号) 或 `auto` (从已有 import 语句中推测引号类型)。</span></span><br><span class="line">	<span class="string">&quot;javascript.preferences.quoteStyle&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 &quot;typescript.preferences.renameShorthandProperties&quot; 已被弃用，取而代之的是 &quot;typescript.preferences.useAliasesForRenames&quot;</span></span><br><span class="line">	<span class="comment">// 允许/禁止在重命名期间向对象速记属性引入别名。需要在工作区中使用 TypeScript 3.4 或更高版本。</span></span><br><span class="line">	<span class="string">&quot;javascript.preferences.renameShorthandProperties&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 允许/禁止在重命名期间向对象速记属性引入别名。需要在工作区中使用 TypeScript 3.4 或更高版本。</span></span><br><span class="line">	<span class="string">&quot;javascript.preferences.useAliasesForRenames&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用在 JavaScript 文件中引用 CodeLens。</span></span><br><span class="line">	<span class="string">&quot;javascript.referencesCodeLens.enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用在 JavaScript 文件中对所有函数的 CodeLens 引用。</span></span><br><span class="line">	<span class="string">&quot;javascript.referencesCodeLens.showOnAllFunctions&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用自动导入建议。</span></span><br><span class="line">	<span class="string">&quot;javascript.suggest.autoImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 完成函数的参数签名。</span></span><br><span class="line">	<span class="string">&quot;javascript.suggest.completeFunctionCalls&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用对完成 JSDoc 注释的建议。</span></span><br><span class="line">	<span class="string">&quot;javascript.suggest.completeJSDocs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用自动完成建议。</span></span><br><span class="line">	<span class="string">&quot;javascript.suggest.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用显示可能未定义的值的完成情况，这些值会插入可选的链式调用。需要启用 TS 3.7+ 和严格的空检查。</span></span><br><span class="line">	<span class="string">&quot;javascript.suggest.includeAutomaticOptionalChainCompletions&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用在 JavaScript 建议中包含文件中的唯一名称。请注意，在使用`@ts-check`或`checkJs`进行语义检查的 JavaScript 代码中，名称建议始终处于禁用状态。</span></span><br><span class="line">	<span class="string">&quot;javascript.suggest.names&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 import 语句和 require 调用中，启用或禁用路径建议。</span></span><br><span class="line">	<span class="string">&quot;javascript.suggest.paths&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用编辑器中 JavaScript 文件的建议诊断。</span></span><br><span class="line">	<span class="string">&quot;javascript.suggestionActions.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用在 VS Code 中重命名或移动文件时自动更新导入路径的功能。</span></span><br><span class="line">	<span class="comment">//  - prompt: 在每次重命名时进行提示。</span></span><br><span class="line">	<span class="comment">//  - always: 始终自动更新路径。</span></span><br><span class="line">	<span class="comment">//  - never: 一律不要重命名路径，也不要提示。</span></span><br><span class="line">	<span class="string">&quot;javascript.updateImportsOnFileMove.enabled&quot;</span>: <span class="string">&quot;prompt&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用 JavaScript 验证。</span></span><br><span class="line">	<span class="string">&quot;javascript.validate.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用 JSX 标记的自动关闭。</span></span><br><span class="line">	<span class="string">&quot;typescript.autoClosingTags&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查是否安装了 NPM 以自动获取类型。</span></span><br><span class="line">	<span class="string">&quot;typescript.check.npmIsInstalled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 禁用自动类型获取。自动类型获取从 npm 提取 `@types` 包，提高对于外部库的 IntelliSense 能力。</span></span><br><span class="line">	<span class="string">&quot;typescript.disableAutomaticTypeAcquisition&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 允许提示用户对 Intellisense 使用在工作区中配置的 TypeScript 版本。</span></span><br><span class="line">	<span class="string">&quot;typescript.enablePromptUseWorkspaceTsdk&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用默认 TypeScript 格式化程序。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义逗号分隔符后面的空格处理。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.insertSpaceAfterCommaDelimiter&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义构造函数关键字后面的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.insertSpaceAfterConstructor&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义匿名函数的函数关键字后面的空格处理。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.insertSpaceAfterFunctionKeywordForAnonymousFunctions&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义控制流语句中关键字后面的空格处理。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.insertSpaceAfterKeywordsInControlFlowStatements&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义 JSX 表达式括号中左括号后和右括号前的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义非空大括号中左括号后和右括号前的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义非空中括号的左括号后和右括号前的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义非空小括号的左括号后和右括号前的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义模板字符串括号中左括号后和右括号前的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义 for 语句中分号之后的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.insertSpaceAfterSemicolonInForStatements&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义 TypeScript 中类型断言后的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.insertSpaceAfterTypeAssertion&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义二进制运算符后面的空格处理</span></span><br><span class="line">	<span class="string">&quot;typescript.format.insertSpaceBeforeAndAfterBinaryOperators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义函数参数括号前的空格处理方式。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.insertSpaceBeforeFunctionParenthesis&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义控制块的左括号是否放置在新的一行。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.placeOpenBraceOnNewLineForControlBlocks&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义函数的左大括号是否放置在新的一行。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.placeOpenBraceOnNewLineForFunctions&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义非必要分号的处理方式。要求在工作区内使用 TypeScript 3.7 或更高版本。</span></span><br><span class="line">	<span class="comment">//  - ignore: 不要插入或删除任何分号。</span></span><br><span class="line">	<span class="comment">//  - insert: 在语句末尾插入分号。</span></span><br><span class="line">	<span class="comment">//  - remove: 删除不必要的分号。</span></span><br><span class="line">	<span class="string">&quot;typescript.format.semicolons&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用实现 CodeLens。此 CodeLens 显示接口的实现。</span></span><br><span class="line">	<span class="string">&quot;typescript.implementationsCodeLens.enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置在报告 JavaScript 和 TypeScript 的错误时使用的区域设置。默认 (`null`) 使用 VS Code 的区域设置。</span></span><br><span class="line">	<span class="string">&quot;typescript.locale&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定用于自动获取类型的 NPM 可执行文件的路径。</span></span><br><span class="line">	<span class="string">&quot;typescript.npm&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动 import 语句中路径的首选样式。</span></span><br><span class="line">	<span class="comment">//  - auto: 自动选择导入路径样式。如果配置了 &quot;baseUrl&quot;，并且相对路径的段少于非相对导入，则首选相对导入。</span></span><br><span class="line">	<span class="comment">//  - relative: 相对于文件位置。</span></span><br><span class="line">	<span class="comment">//  - non-relative: 根据 `jsconfig.json` 或 `tsconfig.json` 中配置的 `baseUrl` 。</span></span><br><span class="line">	<span class="string">&quot;typescript.preferences.importModuleSpecifier&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动导入的首选路径结尾。</span></span><br><span class="line">	<span class="comment">//  - auto: 使用项目设置选择默认值。</span></span><br><span class="line">	<span class="comment">//  - minimal: 将 &quot;./component/index.js&quot; 缩短为 &quot;./component&quot;。</span></span><br><span class="line">	<span class="comment">//  - index: 将 &quot;./component/index.js&quot; 缩短为 &quot;./component/index&quot;。</span></span><br><span class="line">	<span class="comment">//  - js: 不要缩短路径结尾;包括&quot;.js&quot;扩展名。</span></span><br><span class="line">	<span class="string">&quot;typescript.preferences.importModuleSpecifierEnding&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 允许/禁止在 &quot;package.json&quot; 依赖项中搜索可用的自动导入。</span></span><br><span class="line">	<span class="comment">//  - auto: 根据预估的性能影响搜索依赖项。</span></span><br><span class="line">	<span class="comment">//  - on: 始终搜索依赖项。</span></span><br><span class="line">	<span class="comment">//  - off: 从不搜索依赖项。</span></span><br><span class="line">	<span class="string">&quot;typescript.preferences.includePackageJsonAutoImports&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于快速修复的首选引用样式: `single` (单引号)、`double` (双引号) 或 `auto` (从已有 import 语句中推测引号类型)。</span></span><br><span class="line">	<span class="string">&quot;typescript.preferences.quoteStyle&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 &quot;typescript.preferences.renameShorthandProperties&quot; 已被弃用，取而代之的是 &quot;typescript.preferences.useAliasesForRenames&quot;</span></span><br><span class="line">	<span class="comment">// 允许/禁止在重命名期间向对象速记属性引入别名。需要在工作区中使用 TypeScript 3.4 或更高版本。</span></span><br><span class="line">	<span class="string">&quot;typescript.preferences.renameShorthandProperties&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 允许/禁止在重命名期间向对象速记属性引入别名。需要在工作区中使用 TypeScript 3.4 或更高版本。</span></span><br><span class="line">	<span class="string">&quot;typescript.preferences.useAliasesForRenames&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 TypeScript 文件中启用或禁用引用 CodeLens。</span></span><br><span class="line">	<span class="string">&quot;typescript.referencesCodeLens.enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用在 TypeScript 文件中的所有函数上引用 CodeLens。</span></span><br><span class="line">	<span class="string">&quot;typescript.referencesCodeLens.showOnAllFunctions&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将风格检查的问题报告为警告。</span></span><br><span class="line">	<span class="string">&quot;typescript.reportStyleChecksAsWarnings&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用自动导入建议。</span></span><br><span class="line">	<span class="string">&quot;typescript.suggest.autoImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 完成函数的参数签名。</span></span><br><span class="line">	<span class="string">&quot;typescript.suggest.completeFunctionCalls&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用对完成 JSDoc 注释的建议。</span></span><br><span class="line">	<span class="string">&quot;typescript.suggest.completeJSDocs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用自动完成建议。</span></span><br><span class="line">	<span class="string">&quot;typescript.suggest.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用显示可能未定义的值的完成情况，这些值会插入可选的链式调用。需要启用 TS 3.7+ 和严格的空检查。</span></span><br><span class="line">	<span class="string">&quot;typescript.suggest.includeAutomaticOptionalChainCompletions&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 import 语句和 require 调用中，启用或禁用路径建议。</span></span><br><span class="line">	<span class="string">&quot;typescript.suggest.paths&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用编辑器中 TypeScript 文件的建议诊断。</span></span><br><span class="line">	<span class="string">&quot;typescript.suggestionActions.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用偶尔出现的有关 JavaScript 和 TypeScript 的调查，帮助我们改善 VS Code 对两者的支持。</span></span><br><span class="line">	<span class="string">&quot;typescript.surveys.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制对 tsc 任务的自动检测。</span></span><br><span class="line">	<span class="comment">//  - on: 同时创建生成和监视任务。</span></span><br><span class="line">	<span class="comment">//  - off: 禁用此功能。</span></span><br><span class="line">	<span class="comment">//  - build: 仅创建单次运行编译任务。</span></span><br><span class="line">	<span class="comment">//  - watch: 仅创建编译和监视任务。</span></span><br><span class="line">	<span class="string">&quot;typescript.tsc.autoDetect&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定 TypeScript 安装下用于 IntelliSense 的 tsserver 和 lib*.d.ts 文件的文件夹路径，例如: `./node_modules/typescript/lib`。</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// - 当指定为用户设置时，`typescript.tsdk` 中的 TypeScript 版本会自动替换内置的 TypeScript 版本。</span></span><br><span class="line">	<span class="comment">// - 当指定为工作区设置时，`typescript.tsdk` 允许通过 `TypeScript: Select TypeScript version` 命令切换为对 IntelliSense 使用 TypeScript 的该工作区版本。</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// 有关管理 TypeScript 版本的更多详细信息，请参阅 [TypeScript文档](https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-newer-typescript-versions)。</span></span><br><span class="line">	<span class="string">&quot;typescript.tsdk&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (实验性)启用项目范围的错误报告。</span></span><br><span class="line">	<span class="string">&quot;typescript.tsserver.experimental.enableProjectDiagnostics&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 TS 服务器的日志保存到一个文件。此日志可用于诊断 TS 服务器问题。日志可能包含你的项目中的文件路径、源代码和其他可能敏感的信息。</span></span><br><span class="line">	<span class="string">&quot;typescript.tsserver.log&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置要分配给 TypeScript 服务器进程的最大内存量(MB)</span></span><br><span class="line">	<span class="string">&quot;typescript.tsserver.maxTsServerMemory&quot;</span>: <span class="number">3072</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 其他用于搜索 TypeScript 语言服务插件的路径。</span></span><br><span class="line">	<span class="string">&quot;typescript.tsserver.pluginPaths&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对发送到 TS 服务器的消息启用跟踪。此跟踪信息可用于诊断 TS 服务器问题。 跟踪信息可能包含你的项目中的文件路径、源代码和其他可能敏感的信息。</span></span><br><span class="line">	<span class="string">&quot;typescript.tsserver.trace&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 允许/禁止生成单独的 TypeScript 服务器，该服务器可更快地响应与语法相关的操作，例如计算折叠或计算文档符号。需要在工作区中使用 TypeScript 3.4.0 或更高版本。</span></span><br><span class="line">	<span class="string">&quot;typescript.tsserver.useSeparateSyntaxServer&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置应使用哪些监视策略来跟踪文件和目录。需要在工作区中使用 TypeScript 3.8+。</span></span><br><span class="line">	<span class="string">&quot;typescript.tsserver.watchOptions&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用在 VS Code 中重命名或移动文件时自动更新导入路径的功能。</span></span><br><span class="line">	<span class="comment">//  - prompt: 在每次重命名时进行提示。</span></span><br><span class="line">	<span class="comment">//  - always: 始终自动更新路径。</span></span><br><span class="line">	<span class="comment">//  - never: 一律不要重命名路径，也不要提示。</span></span><br><span class="line">	<span class="string">&quot;typescript.updateImportsOnFileMove.enabled&quot;</span>: <span class="string">&quot;prompt&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用 TypeScript 验证。</span></span><br><span class="line">	<span class="string">&quot;typescript.validate.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过[转到工作区中的符号](https://code.visualstudio.com/docs/editor/editingevolved#_open-symbol-by-name)来控制搜索的具体文件。</span></span><br><span class="line">	<span class="comment">//  - allOpenProjects: 在所有打开的 JavaScript 或 TypeScript 项目中搜索符号。需要在工作区中使用 TypeScript 3.9 或更高版本。</span></span><br><span class="line">	<span class="comment">//  - currentProject: 仅在当前 JavaScript 或 TypeScript 项目中搜索符号。</span></span><br><span class="line">	<span class="string">&quot;typescript.workspaceSymbols.scope&quot;</span>: <span class="string">&quot;allOpenProjects&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 补全CSS属性时在行尾插入分号</span></span><br><span class="line">	<span class="string">&quot;css.completion.completePropertyWithSemicolon&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认情况下，VS Code 在选择 CSS 属性后触发属性值完成。使用此设置可禁用此行为。</span></span><br><span class="line">	<span class="string">&quot;css.completion.triggerPropertyValueCompletion&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一个相对文件路径列表，这些路径指向采用[自定义数据格式](https://github.com/Microsoft/vscode-css-languageservice/blob/master/docs/customData.md)的 JSON 文件。</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// VS Code 在启动时加载自定义数据，从而增强它对你在 JSON 文件中指定的自定义 CSS 属性、at 指令、伪类和伪元素的 CSS 支持。</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// 这些文件路径与工作区相对，且只考虑工作区文件夹设置。</span></span><br><span class="line">	<span class="string">&quot;css.customData&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 参数数目无效。</span></span><br><span class="line">	<span class="string">&quot;css.lint.argumentsInColorFunction&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在使用 `padding` 或 `border` 时，不要使用 `width` 或 `height`。</span></span><br><span class="line">	<span class="string">&quot;css.lint.boxModel&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用厂商特定的前缀时，同时添加所有其他厂商特定的属性。</span></span><br><span class="line">	<span class="string">&quot;css.lint.compatibleVendorPrefixes&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不要使用重复的样式定义。</span></span><br><span class="line">	<span class="string">&quot;css.lint.duplicateProperties&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不要使用空规则集。</span></span><br><span class="line">	<span class="string">&quot;css.lint.emptyRules&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 避免使用 `float`。浮动会使 CSS 变得脆弱。即使只更改了一部分布局，也很容易造成破坏。</span></span><br><span class="line">	<span class="string">&quot;css.lint.float&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// `@font-face` 规则必须定义 `src` 和 `font-family` 属性。</span></span><br><span class="line">	<span class="string">&quot;css.lint.fontFaceProperties&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 十六进制颜色必须由三个或六个十六进制数字组成。</span></span><br><span class="line">	<span class="string">&quot;css.lint.hexColorLength&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择器不应包含 ID，因为这些规则与 HTML 的耦合过于紧密。</span></span><br><span class="line">	<span class="string">&quot;css.lint.idSelector&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 仅在需要支持 IE7 及更低版本时，才需要 IE hack。</span></span><br><span class="line">	<span class="string">&quot;css.lint.ieHack&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 避免使用 `!important`。它表明整个 CSS 的优先级已经失去控制且需要进行重构。</span></span><br><span class="line">	<span class="string">&quot;css.lint.important&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// import 语句没有并行加载。</span></span><br><span class="line">	<span class="string">&quot;css.lint.importStatement&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由于 `display` 属性值，属性被忽略。例如，使用 `display: inline` 时，`width`、`height`、`margin-top`、`margin-bottom` 和 `float` 属性将不起作用。</span></span><br><span class="line">	<span class="string">&quot;css.lint.propertyIgnoredDueToDisplay&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通配选择符 (`*`) 的运行效率低。</span></span><br><span class="line">	<span class="string">&quot;css.lint.universalSelector&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未知的 @ 规则。</span></span><br><span class="line">	<span class="string">&quot;css.lint.unknownAtRules&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未知的属性。</span></span><br><span class="line">	<span class="string">&quot;css.lint.unknownProperties&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未知的供应商特定属性。</span></span><br><span class="line">	<span class="string">&quot;css.lint.unknownVendorSpecificProperties&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不根据 &quot;unknownProperties&quot; 规则进行验证的属性列表。</span></span><br><span class="line">	<span class="string">&quot;css.lint.validProperties&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用厂商特定的前缀时，同时添加标准属性。</span></span><br><span class="line">	<span class="string">&quot;css.lint.vendorPrefix&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 零不需要单位。</span></span><br><span class="line">	<span class="string">&quot;css.lint.zeroUnits&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 跟踪 VS Code 与 CSS 语言服务器之间的通信。</span></span><br><span class="line">	<span class="string">&quot;css.trace.server&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用所有验证。</span></span><br><span class="line">	<span class="string">&quot;css.validate&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 补全CSS属性时在行尾插入分号</span></span><br><span class="line">	<span class="string">&quot;less.completion.completePropertyWithSemicolon&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认情况下，VS Code 在选择 CSS 属性后触发属性值完成。使用此设置可禁用此行为。</span></span><br><span class="line">	<span class="string">&quot;less.completion.triggerPropertyValueCompletion&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 参数数目无效。</span></span><br><span class="line">	<span class="string">&quot;less.lint.argumentsInColorFunction&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在使用 `padding` 或 `border` 时，不要使用 `width` 或 `height`。</span></span><br><span class="line">	<span class="string">&quot;less.lint.boxModel&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用厂商特定的前缀时，同时添加所有其他厂商特定的属性。</span></span><br><span class="line">	<span class="string">&quot;less.lint.compatibleVendorPrefixes&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不要使用重复的样式定义。</span></span><br><span class="line">	<span class="string">&quot;less.lint.duplicateProperties&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不要使用空规则集。</span></span><br><span class="line">	<span class="string">&quot;less.lint.emptyRules&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 避免使用 `float`。浮动会使 CSS 变得脆弱。即使只更改了一部分布局，也很容易造成破坏。</span></span><br><span class="line">	<span class="string">&quot;less.lint.float&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// `@font-face` 规则必须定义 `src` 和 `font-family` 属性。</span></span><br><span class="line">	<span class="string">&quot;less.lint.fontFaceProperties&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 十六进制颜色必须由三个或六个十六进制数字组成。</span></span><br><span class="line">	<span class="string">&quot;less.lint.hexColorLength&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择器不应包含 ID，因为这些规则与 HTML 的耦合过于紧密。</span></span><br><span class="line">	<span class="string">&quot;less.lint.idSelector&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 仅在需要支持 IE7 及更低版本时，才需要 IE hack。</span></span><br><span class="line">	<span class="string">&quot;less.lint.ieHack&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 避免使用 `!important`。它表明整个 CSS 的优先级已经失去控制且需要进行重构。</span></span><br><span class="line">	<span class="string">&quot;less.lint.important&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// import 语句没有并行加载。</span></span><br><span class="line">	<span class="string">&quot;less.lint.importStatement&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由于 `display` 属性值，属性被忽略。例如，使用 `display: inline` 时，`width`、`height`、`margin-top`、`margin-bottom` 和 `float` 属性将不起作用。</span></span><br><span class="line">	<span class="string">&quot;less.lint.propertyIgnoredDueToDisplay&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通配选择符 (`*`) 的运行效率低。</span></span><br><span class="line">	<span class="string">&quot;less.lint.universalSelector&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未知的 @ 规则。</span></span><br><span class="line">	<span class="string">&quot;less.lint.unknownAtRules&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未知的属性。</span></span><br><span class="line">	<span class="string">&quot;less.lint.unknownProperties&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未知的供应商特定属性。</span></span><br><span class="line">	<span class="string">&quot;less.lint.unknownVendorSpecificProperties&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不根据 &quot;unknownProperties&quot; 规则进行验证的属性列表。</span></span><br><span class="line">	<span class="string">&quot;less.lint.validProperties&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用厂商特定的前缀时，同时添加标准属性。</span></span><br><span class="line">	<span class="string">&quot;less.lint.vendorPrefix&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 零不需要单位。</span></span><br><span class="line">	<span class="string">&quot;less.lint.zeroUnits&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用所有验证。</span></span><br><span class="line">	<span class="string">&quot;less.validate&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 补全CSS属性时在行尾插入分号</span></span><br><span class="line">	<span class="string">&quot;scss.completion.completePropertyWithSemicolon&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认情况下，VS Code 在选择 CSS 属性后触发属性值完成。使用此设置可禁用此行为。</span></span><br><span class="line">	<span class="string">&quot;scss.completion.triggerPropertyValueCompletion&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 参数数目无效。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.argumentsInColorFunction&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在使用 `padding` 或 `border` 时，不要使用 `width` 或 `height`。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.boxModel&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用厂商特定的前缀时，同时添加所有其他厂商特定的属性。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.compatibleVendorPrefixes&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不要使用重复的样式定义。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.duplicateProperties&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不要使用空规则集。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.emptyRules&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 避免使用 `float`。浮动会使 CSS 变得脆弱。即使只更改了一部分布局，也很容易造成破坏。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.float&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// `@font-face` 规则必须定义 `src` 和 `font-family` 属性。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.fontFaceProperties&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 十六进制颜色必须由三个或六个十六进制数字组成。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.hexColorLength&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择器不应包含 ID，因为这些规则与 HTML 的耦合过于紧密。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.idSelector&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 仅在需要支持 IE7 及更低版本时，才需要 IE hack。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.ieHack&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 避免使用 `!important`。它表明整个 CSS 的优先级已经失去控制且需要进行重构。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.important&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// import 语句没有并行加载。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.importStatement&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由于 `display` 属性值，属性被忽略。例如，使用 `display: inline` 时，`width`、`height`、`margin-top`、`margin-bottom` 和 `float` 属性将不起作用。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.propertyIgnoredDueToDisplay&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通配选择符 (`*`) 的运行效率低。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.universalSelector&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未知的 @ 规则。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.unknownAtRules&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未知的属性。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.unknownProperties&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未知的供应商特定属性。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.unknownVendorSpecificProperties&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不根据 &quot;unknownProperties&quot; 规则进行验证的属性列表。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.validProperties&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用厂商特定的前缀时，同时添加标准属性。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.vendorPrefix&quot;</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 零不需要单位。</span></span><br><span class="line">	<span class="string">&quot;scss.lint.zeroUnits&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用或禁用所有验证。</span></span><br><span class="line">	<span class="string">&quot;scss.validate&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，将自动检查扩展更新。若扩展存在更新，将在“扩展”视图中将其标记为过时扩展。更新将从 Microsoft 联机服务中获取。</span></span><br><span class="line">	<span class="string">&quot;extensions.autoCheckUpdates&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，将自动安装扩展更新。更新将从 Microsoft 联机服务中获取。</span></span><br><span class="line">	<span class="string">&quot;extensions.autoUpdate&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，将在离开“扩展”视图时，自动关闭扩展详细信息页面。</span></span><br><span class="line">	<span class="string">&quot;extensions.closeExtensionDetailsOnViewChange&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当此处列出扩展名时，该扩展名处理URI时将不会显示确认提示。</span></span><br><span class="line">	<span class="string">&quot;extensions.confirmedUriHandlerExtensionIds&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，将不会显示扩展建议的通知。</span></span><br><span class="line">	<span class="string">&quot;extensions.ignoreRecommendations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，除非用户特别进行请求，将不会获取或显示推荐。某些推荐将从 Microsoft 联机服务中获取。</span></span><br><span class="line">	<span class="string">&quot;extensions.showRecommendationsOnlyOnDemand&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用 Web Worker 扩展主机。</span></span><br><span class="line">	<span class="string">&quot;extensions.webWorker&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同步时要忽略的扩展列表。扩展的标识符始终为 &quot;$&#123;publisher&#125;.$&#123;name&#125;&quot;。例如: &quot;vscode.csharp&quot;。</span></span><br><span class="line">	<span class="string">&quot;settingsSync.ignoredExtensions&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置在同步时要忽略的设置。</span></span><br><span class="line">	<span class="string">&quot;settingsSync.ignoredSettings&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为每个平台同步键绑定。</span></span><br><span class="line">	<span class="string">&quot;settingsSync.keybindingsPerPlatform&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在输出视图中启用或禁用「智能滚动」。「智能滚动」会自动在你点击输出视图时锁定滚动，并在你点击最后一行时解锁滚动。</span></span><br><span class="line">	<span class="string">&quot;output.smartScroll.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 应在何处显示单元格工具栏，或是否隐藏它。</span></span><br><span class="line">	<span class="string">&quot;notebook.cellToolbarLocation&quot;</span>: <span class="string">&quot;right&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否对笔记本使用增强的文本差异编辑器。</span></span><br><span class="line">	<span class="string">&quot;notebook.diff.enablePreview&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出项 mime 类型的优先级列表</span></span><br><span class="line">	<span class="string">&quot;notebook.displayOrder&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否应显示单元格状态栏。</span></span><br><span class="line">	<span class="string">&quot;notebook.showCellStatusBar&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否允许在终端中同时按下键绑定。请注意，如果设置为 true 且击键导致同时按键，则将绕过 `terminal.integrated.commandsToSkipShell`；如果想要按 Ctrl+K 转到 shell (而不是 VS Code)，则将此项设置为 false 尤其有用。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.allowChords&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否允许使用菜单栏助记符(如 Alt+F)来触发“打开菜单栏”。请注意，这将导致在设为 true 时，所有 Alt 按键都将跳过 shell。此设置在 macOS 不起作用。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.allowMnemonics&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一个路径，设置后将替代 `terminal.integrated.shell.linux`，并忽略与自动化相关的终端使用情况(例如任务和调试)的 `shellArgs` 个值。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.automationShell.linux&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一个路径，设置后将替代 `terminal.integrated.shell.osx`，并忽略与自动化相关的终端使用情况(例如任务和调试)的 `shellArgs` 个值。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.automationShell.osx&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一个路径，设置后将替代 `terminal.integrated.shell.windows`，并忽略与自动化相关的终端使用情况(例如任务和调试)的 `shellArgs` 值。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.automationShell.windows&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一组命令 ID，其键绑定将不发送至 shell，而是始终由 VS Code 进行处理。这样的话，通常由 shell 使用的键绑定的行为可如同焦点未在终端上时的行为一样，例如按 “Ctrl+P” 来启动“快速打开”。</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// &amp;nbsp;</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// 默认跳过多项命令。要替代默认值并转而将相关命令的键绑定传递给 shell，请添加以 “-” 字符为前缀的命令。例如，添加 “-workbench.action.quickOpen” 可使 “Ctrl+P”到达 shell。</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// &amp;nbsp;</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// 在设置编辑器中查看时，下面的默认跳过命令列表会被截断。要查看完整列表，请[打开默认设置 JSON](command:workbench.action.openRawDefaultSettings“打开默认设置(JSON)”)，然后从下面的列表中搜索第一个命令。</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// &amp;nbsp;</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// 默认跳过的命令:</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// - editor.action.toggleTabFocusMode</span></span><br><span class="line">	<span class="comment">// - workbench.action.debug.continue</span></span><br><span class="line">	<span class="comment">// - workbench.action.debug.pause</span></span><br><span class="line">	<span class="comment">// - workbench.action.debug.restart</span></span><br><span class="line">	<span class="comment">// - workbench.action.debug.run</span></span><br><span class="line">	<span class="comment">// - workbench.action.debug.start</span></span><br><span class="line">	<span class="comment">// - workbench.action.debug.stepInto</span></span><br><span class="line">	<span class="comment">// - workbench.action.debug.stepOut</span></span><br><span class="line">	<span class="comment">// - workbench.action.debug.stepOver</span></span><br><span class="line">	<span class="comment">// - workbench.action.debug.stop</span></span><br><span class="line">	<span class="comment">// - workbench.action.firstEditorInGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.focusActiveEditorGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.focusEighthEditorGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.focusFifthEditorGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.focusFirstEditorGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.focusFourthEditorGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.focusLastEditorGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.focusNextPart</span></span><br><span class="line">	<span class="comment">// - workbench.action.focusPreviousPart</span></span><br><span class="line">	<span class="comment">// - workbench.action.focusSecondEditorGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.focusSeventhEditorGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.focusSixthEditorGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.focusThirdEditorGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.lastEditorInGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.navigateDown</span></span><br><span class="line">	<span class="comment">// - workbench.action.navigateLeft</span></span><br><span class="line">	<span class="comment">// - workbench.action.navigateRight</span></span><br><span class="line">	<span class="comment">// - workbench.action.navigateUp</span></span><br><span class="line">	<span class="comment">// - workbench.action.nextEditor</span></span><br><span class="line">	<span class="comment">// - workbench.action.nextEditorInGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.nextPanelView</span></span><br><span class="line">	<span class="comment">// - workbench.action.nextSideBarView</span></span><br><span class="line">	<span class="comment">// - workbench.action.openNextRecentlyUsedEditor</span></span><br><span class="line">	<span class="comment">// - workbench.action.openNextRecentlyUsedEditorInGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.openPreviousRecentlyUsedEditor</span></span><br><span class="line">	<span class="comment">// - workbench.action.openPreviousRecentlyUsedEditorInGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.previousEditor</span></span><br><span class="line">	<span class="comment">// - workbench.action.previousEditorInGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.previousPanelView</span></span><br><span class="line">	<span class="comment">// - workbench.action.previousSideBarView</span></span><br><span class="line">	<span class="comment">// - workbench.action.quickOpen</span></span><br><span class="line">	<span class="comment">// - workbench.action.quickOpenLeastRecentlyUsedEditor</span></span><br><span class="line">	<span class="comment">// - workbench.action.quickOpenLeastRecentlyUsedEditorInGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.quickOpenPreviousEditor</span></span><br><span class="line">	<span class="comment">// - workbench.action.quickOpenPreviousRecentlyUsedEditor</span></span><br><span class="line">	<span class="comment">// - workbench.action.quickOpenPreviousRecentlyUsedEditorInGroup</span></span><br><span class="line">	<span class="comment">// - workbench.action.quickOpenView</span></span><br><span class="line">	<span class="comment">// - workbench.action.showCommands</span></span><br><span class="line">	<span class="comment">// - workbench.action.tasks.build</span></span><br><span class="line">	<span class="comment">// - workbench.action.tasks.reRunTask</span></span><br><span class="line">	<span class="comment">// - workbench.action.tasks.restartTask</span></span><br><span class="line">	<span class="comment">// - workbench.action.tasks.runTask</span></span><br><span class="line">	<span class="comment">// - workbench.action.tasks.showLog</span></span><br><span class="line">	<span class="comment">// - workbench.action.tasks.showTasks</span></span><br><span class="line">	<span class="comment">// - workbench.action.tasks.terminate</span></span><br><span class="line">	<span class="comment">// - workbench.action.tasks.test</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.clear</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.clearSelection</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.copySelection</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.deleteToLineStart</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.deleteWordLeft</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.deleteWordRight</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.findNext</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.findPrevious</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focus</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusAtIndex1</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusAtIndex2</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusAtIndex3</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusAtIndex4</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusAtIndex5</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusAtIndex6</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusAtIndex7</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusAtIndex8</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusAtIndex9</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusFind</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusNext</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusNextPane</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusPrevious</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.focusPreviousPane</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.hideFind</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.kill</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.moveToLineEnd</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.moveToLineStart</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.navigationModeExit</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.navigationModeFocusNext</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.navigationModeFocusPrevious</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.new</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.newInActiveWorkspace</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.paste</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.resizePaneDown</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.resizePaneLeft</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.resizePaneRight</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.resizePaneUp</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.runActiveFile</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.runSelectedText</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.scrollDown</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.scrollDownPage</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.scrollToBottom</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.scrollToNextCommand</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.scrollToPreviousCommand</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.scrollToTop</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.scrollUp</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.scrollUpPage</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.selectAll</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.selectToNextCommand</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.selectToNextLine</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.selectToPreviousCommand</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.selectToPreviousLine</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.sendSequence</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.split</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.splitInActiveWorkspace</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.toggleFindCaseSensitive</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.toggleFindRegex</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.toggleFindWholeWord</span></span><br><span class="line">	<span class="comment">// - workbench.action.terminal.toggleTerminal</span></span><br><span class="line">	<span class="comment">// - workbench.action.toggleFullScreen</span></span><br><span class="line">	<span class="comment">// - workbench.action.toggleMaximizedPanel</span></span><br><span class="line">	<span class="comment">// - workbench.action.togglePanel</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.commandsToSkipShell&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在存在活动终端会话的情况下是否要在退出时进行确认。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.confirmOnExit&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否将在终端中选定的文本复制到剪贴板。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.copyOnSelection&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制终端光标是否闪烁。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.cursorBlinking&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制终端光标的样式。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.cursorStyle&quot;</span>: <span class="string">&quot;block&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在 &quot;#terminal.integrated.cursorStyle#&quot; 设置为 &quot;line&quot; 时光标的宽度。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.cursorWidth&quot;</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将在其中启动终端的显式起始路径，它用作 shell 进程的当前工作目录(cwd)。如果根目录不是方便的 cwd，此路径在工作区设置中可能十分有用。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.cwd&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否检测 &quot;$LANG&quot; 环境变量并将其设置为符合 UTF-8 的选项，因为 VS Code 的终端仅支持来自 shell 的 UTF-8 编码数据。</span></span><br><span class="line">	<span class="comment">//  - auto: 如果现有变量不存在或不以 &quot;&#x27;.UTF-8&#x27;&quot; 结尾，则设置 &quot;$LANG&quot; 环境变量。</span></span><br><span class="line">	<span class="comment">//  - off: 请勿设置 &quot;$LANG&quot; 环境变量。</span></span><br><span class="line">	<span class="comment">//  - on: 始终设置 &quot;$LANG&quot; 环境变量。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.detectLocale&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制终端中的加粗文本是否始终使用 &quot;bright&quot; ANSI 颜色变量。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.drawBoldTextInBrightColors&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否启用终端铃声。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.enableBell&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否在终端中启用文件链接。尤其是在处理网络驱动器时，链接会变慢，因为每个文件链接都会根据文件系统进行验证。更改此项将仅在新的终端中生效。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.enableFileLinks&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具有环境变量的对象，这些变量将添加到 Linux 上的终端要使用的 VS Code 进程。如果设置为 &quot;null&quot;，则删除环境变量。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.env.linux&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具有环境变量的对象，这些变量将添加到 macOS 中的终端要使用的 VS Code 进程。如果设置为 &quot;null&quot;，则删除环境变量。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.env.osx&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 具有环境变量的对象，这些变量将添加到将由 Windows 上的终端使用的 VS Code 进程。设置为 &quot;null&quot; 以删除环境变量。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.env.windows&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否在每个终端上显示环境更改指示器，该指示器解释了使是否已进行扩展或想要对终端环境进行更改。</span></span><br><span class="line">	<span class="comment">//  - off: 禁用指示器。</span></span><br><span class="line">	<span class="comment">//  - on: 启用指示器。</span></span><br><span class="line">	<span class="comment">//  - warnonly: 仅当终端环境为“已过时”时，仅显示警告指示器，而不是显示指出终端环境已由扩展修改的信息指示器。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.environmentChangesIndicator&quot;</span>: <span class="string">&quot;warnonly&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一项实验性设置，旨在通过改进检测链接的时间以及使用编辑器启用共享链接检测，来改进终端中的链接检测。此设置当前只支持 Web 链接。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.experimentalLinkProvider&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一项实验性设置，它将对下拉标题使用终端标题事件。此设置仅应用于新终端。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.experimentalUseTitleEvent&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按 &quot;Alt&quot; 时的滚动速度加倍。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.fastScrollSensitivity&quot;</span>: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制终端的字体系列，它默认为 &quot;#editor.fontFamily#&quot; 的值。</span></span><br><span class="line">	<span class="comment">// &quot;terminal.integrated.fontFamily&quot;: &quot;&quot;,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制终端的字号(以像素为单位)。</span></span><br><span class="line">	<span class="comment">// &quot;terminal.integrated.fontSize&quot;: 14,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 要在终端中用于非粗体文本的字体粗细。接受“正常”和“加粗”这两个关键字，或接受 1-1000 之间的数字。</span></span><br><span class="line">	<span class="comment">// &quot;terminal.integrated.fontWeight&quot;: &quot;normal&quot;,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 要在终端中用于粗体文本的字体粗细。接受“正常”和“加粗”这两个关键字，或接受 1-1000 之间的数字。</span></span><br><span class="line">	<span class="comment">// &quot;terminal.integrated.fontWeightBold&quot;: &quot;bold&quot;,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新的 shell 是否应从 VS Code 继承其环境。Windows 上不支持此设置。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.inheritEnv&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制终端的字母间距，这是一个整数值，表示要在字符之间增加的额外像素量。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.letterSpacing&quot;</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制终端的行高，此数字乘以终端字号等于实际行高(以像素为单位)。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.lineHeight&quot;</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在 macOS 上使用 Option+单击时是否强制选择内容。这将强制进行常规(行)选择并禁止使用列选择模式。这样，可使用常规终端选择进行复制粘贴，例如在 tmux 中启用鼠标模式时。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.macOptionClickForcesSelection&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否将选项键视为 macOS 中的终端上的元键。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.macOptionIsMeta&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置每个单元格的前景色时，将改为尝试符合指定的对比度比率。示例值:</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// - 1: 默认值，不执行任何操作。</span></span><br><span class="line">	<span class="comment">// - 4.5: [符合 WCAG AA 标准(最低)](https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html)。</span></span><br><span class="line">	<span class="comment">// - 7: [符合 WCAG AAA 标准(增强)](https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast7.html).</span></span><br><span class="line">	<span class="comment">// - 21: 黑底白字或白底黑字。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.minimumContrastRatio&quot;</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 要在鼠标滚轮滚动事件的 &quot;deltaY&quot; 上使用的乘数。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.mouseWheelScrollSensitivity&quot;</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制如何呈现终端。</span></span><br><span class="line">	<span class="comment">//  - auto: 让 VS Code 猜测要使用的呈现器。</span></span><br><span class="line">	<span class="comment">//  - canvas: 使用标准 GPU/基于画布的呈现器。</span></span><br><span class="line">	<span class="comment">//  - dom: 使用基于回退 DOM 的呈现器。</span></span><br><span class="line">	<span class="comment">//  - experimentalWebgl: 使用实验性的基于 webgl 的呈现器。请注意，存在一些[已知问题](https://github.com/xtermjs/xterm.js/issues?q=is%3Aopen+is%3Aissue+label%3Aarea%2Faddon%2Fwebgl)，并且仅对新终端启用此设置(不像其他呈现器那样可热插拔)。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.rendererType&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制终端如何回应右键单击操作。</span></span><br><span class="line">	<span class="comment">//  - default: 显示上下文菜单。</span></span><br><span class="line">	<span class="comment">//  - copyPaste: 当有选定内容时复制，否则粘贴。</span></span><br><span class="line">	<span class="comment">//  - paste: 右键单击时粘贴。</span></span><br><span class="line">	<span class="comment">//  - selectWord: 选择光标下方的字词并显示上下文菜单。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.rightClickBehavior&quot;</span>: <span class="string">&quot;copyPaste&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制终端在其缓冲区中保留的最大行数。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.scrollback&quot;</span>: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 终端在 Linux 上使用的 shell 的路径(默认: /bin/bash)。[详细了解如何配置 shell](https://code.visualstudio.com/docs/editor/integrated-terminal#_configuration)。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.shell.linux&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 终端在 macOS 上使用的 shell 的路径(默认: /bin/bash)。[详细了解如何配置 shell](https://code.visualstudio.com/docs/editor/integrated-terminal#_configuration)。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.shell.osx&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 终端在 Windows 上使用的 shell 的路径(默认: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe)。[详细了解如何配置 shell](https://code.visualstudio.com/docs/editor/integrated-terminal#_configuration)。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.shell.windows&quot;</span>: <span class="string">&quot;C:\\Program Files\\Git\\bin\\bash.exe&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 Linux 终端上时要使用的命令行参数。[详细了解如何配置 shell](https://code.visualstudio.com/docs/editor/integrated-terminal#_configuration)。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.shellArgs.linux&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 macOS 终端上时要使用的命令行参数。[详细了解如何配置 shell](https://code.visualstudio.com/docs/editor/integrated-terminal#_configuration)。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.shellArgs.osx&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;-l&quot;</span></span><br><span class="line">	],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 Windows 终端上时要使用的命令行参数。[详细了解如何配置 shell](https://code.visualstudio.com/docs/editor/integrated-terminal#_configuration)。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.shellArgs.windows&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在退出代码为非零时是否显示“终端进程已终止且显示退出代码”警报。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.showExitAlert&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制拆分终端开始时使用的工作目录。</span></span><br><span class="line">	<span class="comment">//  - workspaceRoot: 新的拆分终端将使用工作区根作为工作目录。在多根工作区中，提供了要使用根文件夹的选项。</span></span><br><span class="line">	<span class="comment">//  - initial: 新的拆分终端将使用父终端开始时使用的工作目录。</span></span><br><span class="line">	<span class="comment">//  - inherited: 在 macOS 和 Linux 上，新的拆分终端将使用父终端的工作目录。在 Windows 上，这与初始行为相同。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.splitCwd&quot;</span>: <span class="string">&quot;inherited&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在计算终端中字符的宽度时要使用的 unicode 版本。如果你遇到表情符号或其他宽字符，而这些宽字符占用的空格或退格量不正确或删除的空间太多或太少，则你可能需要尝试调整此设置。</span></span><br><span class="line">	<span class="comment">//  - 6: unicode 的版本 6，该版本较旧，在较旧的系统中效果更好。</span></span><br><span class="line">	<span class="comment">//  - 11: unicode 的版本 11，版本可在使用新式版本 unicode 的新式系统上提供更好的支持。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.unicodeVersion&quot;</span>: <span class="string">&quot;11&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否使用 ConPTY 进行 Windows 终端进程通信(需要 Windows 10 内部版本号 18309+)。如果此设置为 false，将使用 Winpty。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.windowsEnableConpty&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一个字符串，其中包含双击选择 Word 功能而被视为单词分隔符的所有字符。</span></span><br><span class="line">	<span class="string">&quot;terminal.integrated.wordSeparators&quot;</span>: <span class="string">&quot; ()[]&#123;&#125;&#x27;,\&quot;`─&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制为所有任务提供程序扩展启用&quot;提供任务&quot;。如果&quot;任务: 运行任务&quot;命令速度较慢，则禁用任务提供程序的自动检测可能会提供帮助。单个扩展还可以提供禁用自动检测的设置。</span></span><br><span class="line">	<span class="string">&quot;task.autoDetect&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置在运行任务时是否显示问题匹配器提示。设置为&quot;true&quot;从不提示，或使用任务类型的字典仅关闭特定任务类型的提示。</span></span><br><span class="line">	<span class="string">&quot;task.problemMatchers.neverPrompt&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否显示在“运行任务”等任务快速选取中具有详细信息的任务的详细信息。</span></span><br><span class="line">	<span class="string">&quot;task.quickOpen.detail&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制任务快速打开对话框中跟踪的最近项目数。</span></span><br><span class="line">	<span class="string">&quot;task.quickOpen.history&quot;</span>: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使 Tasks: Run Task 命令使用速度较慢的“全部显示”行为，而不是使用任务按提供程序进行分组的速度更快的双层选取器。</span></span><br><span class="line">	<span class="string">&quot;task.quickOpen.showAll&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制当只有一个任务要选取时是否跳过任务快速选取。</span></span><br><span class="line">	<span class="string">&quot;task.quickOpen.skip&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在运行任务前保存所有未保存的编辑器。</span></span><br><span class="line">	<span class="comment">//  - always: 运行前始终保存所有编辑器。</span></span><br><span class="line">	<span class="comment">//  - never: 运行前绝不保存编辑器。</span></span><br><span class="line">	<span class="comment">//  - prompt: 提示在运行前是否保存编辑器。</span></span><br><span class="line">	<span class="string">&quot;task.saveBeforeRun&quot;</span>: <span class="string">&quot;always&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置当提供程序速度较慢时是否显示警告</span></span><br><span class="line">	<span class="string">&quot;task.slowProviderWarning&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义要启动的终端类型。</span></span><br><span class="line">	<span class="comment">//  - integrated: 使用 VS Code 的集成终端。</span></span><br><span class="line">	<span class="comment">//  - external: 使用设定的外部终端。</span></span><br><span class="line">	<span class="string">&quot;terminal.explorerKind&quot;</span>: <span class="string">&quot;integrated&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义要在 Linux 上运行的终端。</span></span><br><span class="line">	<span class="string">&quot;terminal.external.linuxExec&quot;</span>: <span class="string">&quot;xterm&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义在 macOS 上运行的终端应用程序。</span></span><br><span class="line">	<span class="string">&quot;terminal.external.osxExec&quot;</span>: <span class="string">&quot;Terminal.app&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义要在 Windows 上运行的终端。</span></span><br><span class="line">	<span class="string">&quot;terminal.external.windowsExec&quot;</span>: <span class="string">&quot;C:\\Windows\\System32\\cmd.exe&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在打开文件时，控制是否在“问题”视图中对其进行定位。</span></span><br><span class="line">	<span class="string">&quot;problems.autoReveal&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在文件和文件夹上显示错误和警告。</span></span><br><span class="line">	<span class="string">&quot;problems.decorations.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，状态栏中将显示当前问题。</span></span><br><span class="line">	<span class="string">&quot;problems.showCurrentInStatus&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用/禁用导航路径。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否及如何在“导航路径”视图中显示文件路径。</span></span><br><span class="line">	<span class="comment">//  - on: 在导航路径视图中显示文件路径。</span></span><br><span class="line">	<span class="comment">//  - off: 不在导航路径视图中显示文件路径。</span></span><br><span class="line">	<span class="comment">//  - last: 在导航路径视图中仅显示文件路径的最后一个元素。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.filePath&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用图标渲染面包屑导航项。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.icons&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“数组”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showArrays&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“布尔”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showBooleans&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏显示“类”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showClasses&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“常量”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showConstants&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹符将显示“构造函数”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showConstructors&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示 &quot;enumMember&quot; 符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showEnumMembers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“枚举”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showEnums&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“事件”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showEvents&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“字段”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showFields&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“文件”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showFiles&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“函数”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showFunctions&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“接口”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showInterfaces&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“键”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showKeys&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“方法”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showMethods&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“模块”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showModules&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“命名空间”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showNamespaces&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示 &quot;null&quot; 符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showNull&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“数字”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showNumbers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“对象”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showObjects&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“运算符”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showOperators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“包”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showPackages&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“属性”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showProperties&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“字符串”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showStrings&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“结构”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showStructs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示 &quot;typeParameter&quot; 符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showTypeParameters&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，痕迹导航栏将显示“变量”符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.showVariables&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否及如何在“导航路径”视图中显示符号。</span></span><br><span class="line">	<span class="comment">//  - on: 在“导航路径”视图中显示所有符号。</span></span><br><span class="line">	<span class="comment">//  - off: 不在导航路径视图中显示符号。</span></span><br><span class="line">	<span class="comment">//  - last: 在导航路径视图中仅显示当前符号。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.symbolPath&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制“导航路径”大纲视图中符号的排序方式。</span></span><br><span class="line">	<span class="comment">//  - position: 以文件位置顺序显示符号大纲。</span></span><br><span class="line">	<span class="comment">//  - name: 以字母顺序显示符号大纲。</span></span><br><span class="line">	<span class="comment">//  - type: 以符号类型顺序显示符号大纲。</span></span><br><span class="line">	<span class="string">&quot;breadcrumbs.symbolSortOrder&quot;</span>: <span class="string">&quot;position&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将故障报告发送到 Microsoft 联机服务。</span></span><br><span class="line">	<span class="comment">// 此选项在重启后才能生效。</span></span><br><span class="line">	<span class="string">&quot;telemetry.enableCrashReporter&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将使用数据和错误发送到 Microsoft 联机服务。</span></span><br><span class="line">	<span class="string">&quot;telemetry.enableTelemetry&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示大纲元素的图标。</span></span><br><span class="line">	<span class="string">&quot;outline.icons&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对错误和警告使用徽章。</span></span><br><span class="line">	<span class="string">&quot;outline.problems.badges&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对错误和警告添加颜色。</span></span><br><span class="line">	<span class="string">&quot;outline.problems.colors&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示大纲元素上的错误和警告。</span></span><br><span class="line">	<span class="string">&quot;outline.problems.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“数组”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showArrays&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“布尔”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showBooleans&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“类”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showClasses&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“常量”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showConstants&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用大纲时，大纲将显示“构造函数”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showConstructors&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“枚举成员”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showEnumMembers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“枚举”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showEnums&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“事件”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showEvents&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用时，大纲将显示“字段”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showFields&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“文件”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showFiles&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用时，大纲将显示“函数”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showFunctions&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“接口”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showInterfaces&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“键”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showKeys&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“方法”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showMethods&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“模块”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showModules&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“命名空间”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showNamespaces&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示 &quot;null&quot; 符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showNull&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“数字”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showNumbers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“对象”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showObjects&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用时，大纲显示“运算符”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showOperators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“包”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showPackages&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“属性”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showProperties&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“字符串”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showStrings&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“结构”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showStructs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示 &quot;typeParameter&quot; 符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showTypeParameters&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，大纲将显示“变量”符号。</span></span><br><span class="line">	<span class="string">&quot;outline.showVariables&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实验性: 应从时间线视图中排除的时间线源数组</span></span><br><span class="line">	<span class="string">&quot;timeline.excludeSources&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实验性。控制在滚动到列表结尾时，时间线视图是否将加载下一页的项目</span></span><br><span class="line">	<span class="string">&quot;timeline.pageOnScroll&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认情况下以及在加载更多项目时在时间线视图中显示的项目数。如果设置为 &quot;null&quot; (默认值)，则将根据时间线视图的可见区域自动选择一个页面大小</span></span><br><span class="line">	<span class="string">&quot;timeline.pageSize&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [css] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[css]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.suggest.insertMode&quot;</span>: <span class="string">&quot;replace&quot;</span>,</span><br><span class="line">		<span class="string">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [dockerfile] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[dockerfile]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.quickSuggestions&quot;</span>: &#123;</span><br><span class="line">				<span class="string">&quot;strings&quot;</span>: <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [git-commit] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[git-commit]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.rulers&quot;</span>: [</span><br><span class="line">				<span class="number">72</span></span><br><span class="line">		],</span><br><span class="line">		<span class="string">&quot;workbench.editor.restoreViewState&quot;</span>: <span class="literal">false</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [git-rebase] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[git-rebase]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;workbench.editor.restoreViewState&quot;</span>: <span class="literal">false</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [go] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[go]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.insertSpaces&quot;</span>: <span class="literal">false</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [handlebars] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[handlebars]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.suggest.insertMode&quot;</span>: <span class="string">&quot;replace&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [html] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[html]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.suggest.insertMode&quot;</span>: <span class="string">&quot;replace&quot;</span>,</span><br><span class="line">		<span class="string">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [json] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[json]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.quickSuggestions&quot;</span>: &#123;</span><br><span class="line">				<span class="string">&quot;strings&quot;</span>: <span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;editor.suggest.insertMode&quot;</span>: <span class="string">&quot;replace&quot;</span>,</span><br><span class="line">		<span class="string">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [jsonc] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[jsonc]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.quickSuggestions&quot;</span>: &#123;</span><br><span class="line">				<span class="string">&quot;strings&quot;</span>: <span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;editor.suggest.insertMode&quot;</span>: <span class="string">&quot;replace&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [less] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[less]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.suggest.insertMode&quot;</span>: <span class="string">&quot;replace&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [makefile] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[makefile]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.insertSpaces&quot;</span>: <span class="literal">false</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [markdown] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[markdown]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.wordWrap&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line">		<span class="string">&quot;editor.quickSuggestions&quot;</span>: <span class="literal">false</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [scss] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[scss]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.suggest.insertMode&quot;</span>: <span class="string">&quot;replace&quot;</span>,</span><br><span class="line">		<span class="string">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [search-result] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[search-result]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.lineNumbers&quot;</span>: <span class="string">&quot;off&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [shellscript] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[shellscript]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;files.eol&quot;</span>: <span class="string">&quot;\n&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置要为 [yaml] 语言替代的设置。</span></span><br><span class="line">	<span class="string">&quot;[yaml]&quot;</span>:  &#123;</span><br><span class="line">		<span class="string">&quot;editor.insertSpaces&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;editor.tabSize&quot;</span>: <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;editor.autoIndent&quot;</span>: <span class="string">&quot;advanced&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，扩展将本地下载并安装在远程上。</span></span><br><span class="line">	<span class="string">&quot;remote.downloadExtensionsLocally&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 覆盖扩展的类型。&quot;ui&quot; 扩展在本地计算机上安装和运行，而 &quot;workspace&quot; 扩展则在远程计算机上运行。通过使用此设置重写扩展的默认类型，可指定是否应在本地或远程安装和启用该扩展。</span></span><br><span class="line">	<span class="string">&quot;remote.extensionKind&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;pub.name&quot;</span>: [</span><br><span class="line">			<span class="string">&quot;ui&quot;</span></span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 还原您在工作区中转发的端口。</span></span><br><span class="line">	<span class="string">&quot;remote.restoreForwardedPorts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不应展开 Emmet 缩写的语言数组。</span></span><br><span class="line">	<span class="string">&quot;emmet.excludeLanguages&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;markdown&quot;</span></span><br><span class="line">	],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指向包含 Emmet 配置文件与代码片段的文件夹路径。</span></span><br><span class="line">	<span class="string">&quot;emmet.extensionsPath&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在默认不受支持的语言中启用 Emmet 缩写。在此语言和 emmet 支持的语言之间添加映射。</span></span><br><span class="line">	<span class="comment">//  例如: `&#123;&quot;vue-html&quot;: &quot;html&quot;, &quot;javascript&quot;: &quot;javascriptreact&quot;&#125;`</span></span><br><span class="line">	<span class="string">&quot;emmet.includeLanguages&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;wxml&quot;</span>: <span class="string">&quot;html&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当设置为 `false` 时，将分析整个文件并确定当前位置能否展开 Emmet 缩写。当设置为 `true` 时，将仅在 CSS/SCSS/LESS 文件中分析当前位置周围的内容。</span></span><br><span class="line">	<span class="string">&quot;emmet.optimizeStylesheetParsing&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于修改 Emmet 某些操作和解析程序的行为的首选项。</span></span><br><span class="line">	<span class="string">&quot;emmet.preferences&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将可能的 Emmet 缩写作为建议进行显示。当在样式表中或 emmet.showExpandedAbbreviation 设置为 `&quot;never&quot;` 时不适用。</span></span><br><span class="line">	<span class="string">&quot;emmet.showAbbreviationSuggestions&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以建议的形式显示展开的 Emmet 缩写。</span></span><br><span class="line">	<span class="comment">// 选项 `&quot;inMarkupAndStylesheetFilesOnly&quot;` 适用于 html、haml、jade、slim、xml、xsl、css、scss、sass、less 和 stylus。</span></span><br><span class="line">	<span class="comment">// 无论 markup/css 如何，选项 `&quot;always&quot;` 都适用于文件的所有部分。</span></span><br><span class="line">	<span class="string">&quot;emmet.showExpandedAbbreviation&quot;</span>: <span class="string">&quot;always&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若为 `true`，Emmet 建议将显示为代码片段。可以在 `editor.snippetSuggestions` 设置中排列其顺序。</span></span><br><span class="line">	<span class="string">&quot;emmet.showSuggestionsAsSnippets&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为指定的语法定义配置文件或使用带有特定规则的配置文件。</span></span><br><span class="line">	<span class="string">&quot;emmet.syntaxProfiles&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，按下 TAB 键，将展开 Emmet 缩写。</span></span><br><span class="line">	<span class="string">&quot;emmet.triggerExpansionOnTab&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于 Emmet 代码片段的变量</span></span><br><span class="line">	<span class="string">&quot;emmet.variables&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否启用强制推送 (不论 force 还是 force-with-lease)。</span></span><br><span class="line">	<span class="string">&quot;git.allowForcePush&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否允许没有运行 pre-commit 和 commit-msg 挂钩的提交。</span></span><br><span class="line">	<span class="string">&quot;git.allowNoVerifyCommit&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 始终显示“暂存的更改”资源组。</span></span><br><span class="line">	<span class="string">&quot;git.alwaysShowStagedChangesResourceGroup&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制所有提交的 signoff 标志。</span></span><br><span class="line">	<span class="string">&quot;git.alwaysSignOff&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用时，提交将自动从当前Git存储库的默认远程获取。</span></span><br><span class="line">	<span class="string">&quot;git.autofetch&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在启用 &quot;git.autofetch&quot; 情况下每次自动 git fetch 之间的间隔时间(以秒为单位)。</span></span><br><span class="line">	<span class="string">&quot;git.autofetchPeriod&quot;</span>: <span class="number">180</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否启用自动刷新。</span></span><br><span class="line">	<span class="string">&quot;git.autorefresh&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置何时自动检测存储库。</span></span><br><span class="line">	<span class="comment">//  - true: 扫描当前打开文件夹与当前打开文件所在文件夹的子文件夹。</span></span><br><span class="line">	<span class="comment">//  - false: 禁止自动扫描存储库。</span></span><br><span class="line">	<span class="comment">//  - subFolders: 扫描当前打开文件夹的子文件夹。</span></span><br><span class="line">	<span class="comment">//  - openEditors: 扫描当前打开文件的父文件夹。</span></span><br><span class="line">	<span class="string">&quot;git.autoRepositoryDetection&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在拉取前暂存所有更改，在成功拉取后还原这些更改。</span></span><br><span class="line">	<span class="string">&quot;git.autoStash&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制分支的排列顺序。</span></span><br><span class="line">	<span class="string">&quot;git.branchSortOrder&quot;</span>: <span class="string">&quot;committerdate&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于验证新分支名称的正则表达式。</span></span><br><span class="line">	<span class="string">&quot;git.branchValidationRegex&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在新分支名称中替换空白字符的字符。</span></span><br><span class="line">	<span class="string">&quot;git.branchWhitespaceChar&quot;</span>: <span class="string">&quot;-&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在运行“推送到...”功能时列出的分支类型。</span></span><br><span class="line">	<span class="comment">//  - all: 显示全部参考文献。</span></span><br><span class="line">	<span class="comment">//  - local: 只显示本地分支。</span></span><br><span class="line">	<span class="comment">//  - tags: 仅显示标记。</span></span><br><span class="line">	<span class="comment">//  - remote: 仅显示远程分支。</span></span><br><span class="line">	<span class="string">&quot;git.checkoutType&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 始终确认为 &quot;Git: Commit Empty&quot; 命令创建空提交。</span></span><br><span class="line">	<span class="string">&quot;git.confirmEmptyCommits&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在强制推送前是否进行确认。</span></span><br><span class="line">	<span class="string">&quot;git.confirmForcePush&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否要求在未验证的情况下提交之前进行确认。</span></span><br><span class="line">	<span class="string">&quot;git.confirmNoVerifyCommit&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同步 Git 存储库前请先进行确认。</span></span><br><span class="line">	<span class="string">&quot;git.confirmSync&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制 Git 计数徽章。</span></span><br><span class="line">	<span class="comment">//  - all: 对所有更改计数。</span></span><br><span class="line">	<span class="comment">//  - tracked: 仅对跟踪的更改计数。</span></span><br><span class="line">	<span class="comment">//  - off: 关闭计数器。</span></span><br><span class="line">	<span class="string">&quot;git.countBadge&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制 Git 是否在资源管理器和“打开的编辑器”视图中添加颜色和小标。</span></span><br><span class="line">	<span class="string">&quot;git.decorations.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 克隆 Git 存储库的默认位置。</span></span><br><span class="line">	<span class="string">&quot;git.defaultCloneDirectory&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否自动检测 Git 子模块。</span></span><br><span class="line">	<span class="string">&quot;git.detectSubmodules&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制可检测到的 Git 子模块的限制。</span></span><br><span class="line">	<span class="string">&quot;git.detectSubmodulesLimit&quot;</span>: <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 GPG 或 x.509 启用提交签名。</span></span><br><span class="line">	<span class="string">&quot;git.enableCommitSigning&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否启用 Git。</span></span><br><span class="line">	<span class="string">&quot;git.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在没有暂存的更改时提交所有更改。</span></span><br><span class="line">	<span class="string">&quot;git.enableSmartCommit&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制Git Sync命令是否出现在状态栏中。</span></span><br><span class="line">	<span class="string">&quot;git.enableStatusBarSync&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用后，在拉取时获取所有分支。否则，仅获取当前。</span></span><br><span class="line">	<span class="string">&quot;git.fetchOnPull&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This setting is now deprecated, please use `github.gitAuthentication` instead.</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="string">&quot;git.githubAuthentication&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 要忽略的 Git 存储库列表。</span></span><br><span class="line">	<span class="string">&quot;git.ignoredRepositories&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 忽略“旧版 Git”警告。</span></span><br><span class="line">	<span class="string">&quot;git.ignoreLegacyWarning&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 忽略“存储库中存在大量更改”的警告。</span></span><br><span class="line">	<span class="string">&quot;git.ignoreLimitWarning&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 忽略“缺失 Git”的警告。</span></span><br><span class="line">	<span class="string">&quot;git.ignoreMissingGitWarning&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 Windows 上安装了 Git 2.25 - 2.26，则忽略警告。</span></span><br><span class="line">	<span class="string">&quot;git.ignoreWindowsGit27Warning&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制何时显示提交消息输入验证。</span></span><br><span class="line">	<span class="string">&quot;git.inputValidation&quot;</span>: <span class="string">&quot;warn&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制显示提交消息长度警告的长度阈值。</span></span><br><span class="line">	<span class="string">&quot;git.inputValidationLength&quot;</span>: <span class="number">72</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制显示警告的提交消息主题长度阈值。请取消设置它以继承 &quot;config.inputValidationLength&quot; 的值。</span></span><br><span class="line">	<span class="string">&quot;git.inputValidationSubjectLength&quot;</span>: <span class="number">50</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制单击更改时是否应打开差异编辑器。否则将打开常规编辑器。</span></span><br><span class="line">	<span class="string">&quot;git.openDiffOnClick&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Git 可执行文件的路径和文件名，例如 &quot;C:\Program Files\Git\bin\git.exe&quot; (Windows)。这也可以是一个包含多个要查找的路径的字符串值数组。</span></span><br><span class="line">	<span class="string">&quot;git.path&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 成功提交后运行 git 命令。</span></span><br><span class="line">	<span class="comment">//  - none: 提交后不要运行任何命令。</span></span><br><span class="line">	<span class="comment">//  - push: 成功提交后运行&#x27;Git Push&#x27;。</span></span><br><span class="line">	<span class="comment">//  - sync: 成功提交后运行&#x27;Git Sync&#x27;。</span></span><br><span class="line">	<span class="string">&quot;git.postCommitCommand&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制 Git 是否在提交之前检查未保存的文件。</span></span><br><span class="line">	<span class="comment">//  - always: 检查是否有任何未保存的文件。</span></span><br><span class="line">	<span class="comment">//  - staged: 只检查未保存的已暂存文件。</span></span><br><span class="line">	<span class="comment">//  - never: 禁用此检查。</span></span><br><span class="line">	<span class="string">&quot;git.promptToSaveFilesBeforeCommit&quot;</span>: <span class="string">&quot;always&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拉取时提取所有标签。</span></span><br><span class="line">	<span class="string">&quot;git.pullTags&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在运行“同步”命令时，强制 Git 使用“变基”。</span></span><br><span class="line">	<span class="string">&quot;git.rebaseWhenSync&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在其中搜索 Git 存储库的路径的列表。</span></span><br><span class="line">	<span class="string">&quot;git.scanRepositories&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在 Git 源控制面板中显示提交输入。</span></span><br><span class="line">	<span class="string">&quot;git.showCommitInput&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在 Git 更改视图中显示内联“打开文件”操作。</span></span><br><span class="line">	<span class="string">&quot;git.showInlineOpenFileAction&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制 Git 操作是否显示进度提示。</span></span><br><span class="line">	<span class="string">&quot;git.showProgress&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在推送成功时是否显示通知。</span></span><br><span class="line">	<span class="string">&quot;git.showPushSuccessNotification&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制哪些更改由Smart Commit自动暂存。</span></span><br><span class="line">	<span class="comment">//  - all: 自动暂存所有更改。</span></span><br><span class="line">	<span class="comment">//  - tracked: 仅自动暂存跟踪的更改。</span></span><br><span class="line">	<span class="string">&quot;git.smartCommitChanges&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 建议启用智能提交(在无暂存更改时提交所有更改)。</span></span><br><span class="line">	<span class="string">&quot;git.suggestSmartCommit&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制在运行同步操作时是否出现通知，允许用户取消操作。</span></span><br><span class="line">	<span class="string">&quot;git.supportCancellation&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否使 VS Code 成为集成终端中产生的 git 进程的身份验证处理程序。请注意: 需要重启终端才能选择此设置中的更改。</span></span><br><span class="line">	<span class="string">&quot;git.terminalAuthentication&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制未跟踪的更改的行为。</span></span><br><span class="line">	<span class="comment">//  - mixed: 所有更改，无论是跟踪的还是未跟踪的，都会一起出现并表现出相同的行为。</span></span><br><span class="line">	<span class="comment">//  - separate: 未跟踪的更改单独显示在“源代码管理”视图中。它们也被排除在几个操作之外。</span></span><br><span class="line">	<span class="comment">//  - hidden: 未跟踪的更改被隐藏，并从多个操作中排除。</span></span><br><span class="line">	<span class="string">&quot;git.untrackedChanges&quot;</span>: <span class="string">&quot;mixed&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否使用更安全的 force-with-lease 进行强制推送。</span></span><br><span class="line">	<span class="string">&quot;git.useForcePushWithLease&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否在 VS Code 中为 git 命令启用自动 GitHub 身份验证。</span></span><br><span class="line">	<span class="string">&quot;github.gitAuthentication&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否自动检测 Grunt 任务。默认开启。</span></span><br><span class="line">	<span class="string">&quot;grunt.autoDetect&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否自动检测 Gulp 任务。默认开启。</span></span><br><span class="line">	<span class="string">&quot;gulp.autoDetect&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否自动检测 Jake 任务。默认开启。</span></span><br><span class="line">	<span class="string">&quot;jake.autoDetect&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否在解决合并冲突后自动转到下一个合并冲突。</span></span><br><span class="line">	<span class="string">&quot;merge-conflict.autoNavigateNextConflict.enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为编辑器中的合并冲突区域创建 CodeLens。</span></span><br><span class="line">	<span class="string">&quot;merge-conflict.codeLens.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为编辑器中的合并冲突区域创建提示小标。</span></span><br><span class="line">	<span class="string">&quot;merge-conflict.decorators.enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控件在比较合并冲突中的更改时应在何处打开差异视图。</span></span><br><span class="line">	<span class="comment">//  - Current: 在当前的编辑器组中打开差异视图。</span></span><br><span class="line">	<span class="comment">//  - Beside: 在当前编辑器组旁边打开差异视图。</span></span><br><span class="line">	<span class="comment">//  - Below: 在当前编辑器组下方打开差异视图。</span></span><br><span class="line">	<span class="string">&quot;merge-conflict.diffViewPosition&quot;</span>: <span class="string">&quot;Current&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configures which processes to automatically attach and debug when `debug.node.autoAttach` is on. A Node process launched with the `--inspect` flag will always be attached to, regardless of this setting.</span></span><br><span class="line">	<span class="comment">//  - always: Auto attach to every Node.js process launched in the terminal.</span></span><br><span class="line">	<span class="comment">//  - smart: Auto attach when running scripts that aren&#x27;t in a node_modules folder.</span></span><br><span class="line">	<span class="comment">//  - onlyWithFlag: Only auto attach when the `--inspect` is given.</span></span><br><span class="line">	<span class="comment">//  - disabled: Auto attach is disabled and not shown in status bar.</span></span><br><span class="line">	<span class="string">&quot;debug.javascript.autoAttachFilter&quot;</span>: <span class="string">&quot;disabled&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configures glob patterns for determining when to attach in &quot;smart&quot; `debug.javascript.autoAttachFilter` mode. `$KNOWN_TOOLS$` is replaced with a list of names of common test and code runners. [Read more on the VS Code docs](https://code.visualstudio.com/docs/nodejs/nodejs-debugging#_auto-attach-smart-patterns).</span></span><br><span class="line">	<span class="string">&quot;debug.javascript.autoAttachSmartPattern&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;!**/&#123;node_modules,npm-global,.yarn&#125;/**&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/$KNOWN_TOOLS$/**&quot;</span></span><br><span class="line">	],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configures whether property getters will be expanded automatically. If this is false, the getter will appear as `get propertyName` and will only be evaluated when you click on it.</span></span><br><span class="line">	<span class="string">&quot;debug.javascript.autoExpandGetters&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When debugging a remote web app, configures whether to automatically tunnel the remote server to your local machine.</span></span><br><span class="line">	<span class="string">&quot;debug.javascript.automaticallyTunnelRemoteServer&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether to stop when conditional breakpoints throw an error. Note: your launch.json `type` must be prefixed with `pwa-` to use this, such as `pwa-node`.</span></span><br><span class="line">	<span class="string">&quot;debug.javascript.breakOnConditionalError&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Where a &quot;Run&quot; and &quot;Debug&quot; code lens should be shown in your npm scripts. It may be on &quot;all&quot;, scripts, on &quot;top&quot; of the script section, or &quot;never&quot;.</span></span><br><span class="line">	<span class="string">&quot;debug.javascript.codelens.npmScripts&quot;</span>: <span class="string">&quot;top&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Options used when debugging open links clicked from inside the JavaScript Debug Terminal. Can be set to &quot;off&quot; to disable this behavior, or &quot;always&quot; to enable debugging in all terminals.</span></span><br><span class="line">	<span class="string">&quot;debug.javascript.debugByLinkOptions&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Default options used when debugging a process through the `Debug: Attach to Node.js Process` command</span></span><br><span class="line">	<span class="string">&quot;debug.javascript.pickAndAttachOptions&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether to suggest pretty printing JavaScript code that looks minified when you step into it.</span></span><br><span class="line">	<span class="string">&quot;debug.javascript.suggestPrettyPrinting&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Default launch options for the JavaScript debug terminal and npm scripts.</span></span><br><span class="line">	<span class="string">&quot;debug.javascript.terminalOptions&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configures whether sourcemapped file where the original file can&#x27;t be read will automatically be unmapped. If this is false (default), a prompt is shown.</span></span><br><span class="line">	<span class="string">&quot;debug.javascript.unmapMissingSources&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use the new in-preview JavaScript debugger for Node.js and Chrome.</span></span><br><span class="line">	<span class="string">&quot;debug.javascript.usePreview&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This setting is deprecated - please use `debug.javascript.usePreview` instead</span></span><br><span class="line">	<span class="comment">// [实验性]控制是否将&quot;extensionHost&quot;类型的启动配置委托给 js-debug 扩展。</span></span><br><span class="line">	<span class="string">&quot;debug.extensionHost.useV3&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制使用 &quot;useWSL&quot; 属性时是否显示警告。</span></span><br><span class="line">	<span class="string">&quot;debug.node.showUseWslIsDeprecatedWarning&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This setting is deprecated - please use `debug.javascript.usePreview` instead</span></span><br><span class="line">	<span class="comment">// [实验性]控制是否将&quot;node&quot;类型的启动配置委托给 js-debug 扩展。</span></span><br><span class="line">	<span class="string">&quot;debug.node.useV3&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Controls whether &#x27;Peek References&#x27; or &#x27;Find References&#x27; is invoked when selecting code lens references</span></span><br><span class="line">	<span class="comment">//  - peek: Show references in peek editor.</span></span><br><span class="line">	<span class="comment">//  - view: Show references in separate view.</span></span><br><span class="line">	<span class="string">&quot;references.preferredLocation&quot;</span>: <span class="string">&quot;peek&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制是否自动检测 npm 脚本。</span></span><br><span class="line">	<span class="string">&quot;npm.autoDetect&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从资源管理器上下文菜单中启用运行文件夹中包含的 NPM 脚本。</span></span><br><span class="line">	<span class="string">&quot;npm.enableRunFromFolder&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The NPM Script Explorer is now available in &#x27;Views&#x27; menu in the Explorer in all folders.</span></span><br><span class="line">	<span class="comment">// 在没有顶级 &quot;package.json&quot; 文件时，为 npm 脚本启用资源管理器视图。</span></span><br><span class="line">	<span class="string">&quot;npm.enableScriptExplorer&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置应从自动脚本检测中排除的文件夹的 glob 模式。</span></span><br><span class="line">	<span class="string">&quot;npm.exclude&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 https://registry.npmjs.org 和 https://registry.bower.io 获取数据，以提供自动补全和 npm 依赖项上的悬停功能信息。</span></span><br><span class="line">	<span class="string">&quot;npm.fetchOnlinePackageInfo&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于运行脚本的程序包管理器。</span></span><br><span class="line">	<span class="string">&quot;npm.packageManager&quot;</span>: <span class="string">&quot;npm&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 `--silent` 选项运行 npm 命令。</span></span><br><span class="line">	<span class="string">&quot;npm.runSilent&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// npm 脚本资源管理器中使用的默认单击操作: &quot;打开&quot;或&quot;运行&quot;，默认值为&quot;打开&quot;。</span></span><br><span class="line">	<span class="string">&quot;npm.scriptExplorerAction&quot;</span>: <span class="string">&quot;open&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CSS for the active scope. Use &#123;color&#125; to match the bracket color. The string types listed at https://code.visualstudio.com/docs/extensionAPI/vscode-api#DecorationRenderOptions can be used</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.activeScopeCSS&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;borderStyle : solid&quot;</span>,</span><br><span class="line">		<span class="string">&quot;borderWidth : 1px&quot;</span>,</span><br><span class="line">		<span class="string">&quot;borderColor : &#123;color&#125;; opacity: 0.5&quot;</span></span><br><span class="line">	],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Should different brackets share a color group (Consecutive), or use their own color group (Independent)</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.colorMode&quot;</span>: <span class="string">&quot;Consecutive&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Define paired characters and their shared color group</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.consecutivePairColors&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;()&quot;</span>,</span><br><span class="line">		<span class="string">&quot;[]&quot;</span>,</span><br><span class="line">		<span class="string">&quot;&#123;&#125;&quot;</span>,</span><br><span class="line">		[</span><br><span class="line">			<span class="string">&quot;Gold&quot;</span>,</span><br><span class="line">			<span class="string">&quot;Orchid&quot;</span>,</span><br><span class="line">			<span class="string">&quot;LightSkyBlue&quot;</span></span><br><span class="line">		],</span><br><span class="line">		<span class="string">&quot;Red&quot;</span></span><br><span class="line">	],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Don&#x27;t colorize files of these languages</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.excludedLanguages&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Should opening brackets iterate the color cycle even if they are not nested</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.forceIterationColorCycle&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ensure that an opening brackets color does not match a previous brackets color</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.forceUniqueOpeningColor&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Should the active scope brackets always be highlighted? Recommended to disable editor.matchBrackets if using this feature.</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.highlightActiveScope&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Define paired characters and their color groups</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.independentPairColors&quot;</span>: [</span><br><span class="line">		[</span><br><span class="line">			<span class="string">&quot;()&quot;</span>,</span><br><span class="line">			[</span><br><span class="line">				<span class="string">&quot;Gold&quot;</span>,</span><br><span class="line">				<span class="string">&quot;Orchid&quot;</span>,</span><br><span class="line">				<span class="string">&quot;LightSkyBlue&quot;</span></span><br><span class="line">			],</span><br><span class="line">			<span class="string">&quot;Red&quot;</span></span><br><span class="line">		],</span><br><span class="line">		[</span><br><span class="line">			<span class="string">&quot;[]&quot;</span>,</span><br><span class="line">			[</span><br><span class="line">				<span class="string">&quot;Gold&quot;</span>,</span><br><span class="line">				<span class="string">&quot;Orchid&quot;</span>,</span><br><span class="line">				<span class="string">&quot;LightSkyBlue&quot;</span></span><br><span class="line">			],</span><br><span class="line">			<span class="string">&quot;Red&quot;</span></span><br><span class="line">		],</span><br><span class="line">		[</span><br><span class="line">			<span class="string">&quot;&#123;&#125;&quot;</span>,</span><br><span class="line">			[</span><br><span class="line">				<span class="string">&quot;Gold&quot;</span>,</span><br><span class="line">				<span class="string">&quot;Orchid&quot;</span>,</span><br><span class="line">				<span class="string">&quot;LightSkyBlue&quot;</span></span><br><span class="line">			],</span><br><span class="line">			<span class="string">&quot;Red&quot;</span></span><br><span class="line">		]</span><br><span class="line">	],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Show active bracket scope in ruler?</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.rulerPosition&quot;</span>: <span class="string">&quot;Center&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CSS for the scope line. Use &#123;color&#125; to match the bracket color. The string types listed at https://code.visualstudio.com/docs/extensionAPI/vscode-api#DecorationRenderOptions can be used</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.scopeLineCSS&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;borderStyle : solid&quot;</span>,</span><br><span class="line">		<span class="string">&quot;borderWidth : 1px&quot;</span>,</span><br><span class="line">		<span class="string">&quot;borderColor : &#123;color&#125;; opacity: 0.5&quot;</span></span><br><span class="line">	],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// True: Scope Line will start from the ending bracket position. False: Scope Line will always be at column 0</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.scopeLineRelativePosition&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Show active bracket scope in gutter?</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.showBracketsInGutter&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Show active bracket scope in ruler?</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.showBracketsInRuler&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Show a horizontal line to create a block around the active bracket scope?</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.showHorizontalScopeLine&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Show a vertical line on the left side of the editor representing the active bracket scope?</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.showVerticalScopeLine&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// How long the user should idle for, before the document is colorized. Set to 0 to disable</span></span><br><span class="line">	<span class="string">&quot;bracketPairColorizer.timeOut&quot;</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Always show the ESlint status bar item.</span></span><br><span class="line">	<span class="string">&quot;eslint.alwaysShowStatus&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The setting is deprecated. Use editor.codeActionsOnSave instead with a source.fixAll.eslint member.</span></span><br><span class="line">	<span class="comment">// Turns auto fix on save on or off.</span></span><br><span class="line">	<span class="string">&quot;eslint.autoFixOnSave&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="string">&quot;eslint.codeAction.disableRuleComment&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;location&quot;</span>: <span class="string">&quot;separateLine&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="string">&quot;eslint.codeAction.showDocumentation&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;enable&quot;</span>: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Specifies the code action mode. Possible values are &#x27;all&#x27; and &#x27;problems&#x27;.</span></span><br><span class="line">	<span class="comment">//  - all: Fixes all possible problems in the file. This option might take some time.</span></span><br><span class="line">	<span class="comment">//  - problems: Only fixes reported problems that have non overlapping textual edits. This options runs a lot faster.</span></span><br><span class="line">	<span class="string">&quot;eslint.codeActionsOnSave.mode&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enables ESLint debug mode (same as --debug on the command line)</span></span><br><span class="line">	<span class="string">&quot;eslint.debug&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This setting is deprecated. Disable ESLint using the extensions viewlet.</span></span><br><span class="line">	<span class="comment">// Controls whether eslint is enabled or not.</span></span><br><span class="line">	<span class="string">&quot;eslint.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enables ESLint as a formatter.</span></span><br><span class="line">	<span class="string">&quot;eslint.format.enable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Controls whether a task for linting the whole workspace will be available.</span></span><br><span class="line">	<span class="string">&quot;eslint.lintTask.enable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Command line options applied when running the task for linting the whole workspace (see https://eslint.org/docs/user-guide/command-line-interface).</span></span><br><span class="line">	<span class="string">&quot;eslint.lintTask.options&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether ESlint should migrate auto fix on save settings.</span></span><br><span class="line">	<span class="string">&quot;eslint.migration.2_x&quot;</span>: <span class="string">&quot;on&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The value of NODE_ENV to use when running eslint tasks.</span></span><br><span class="line">	<span class="string">&quot;eslint.nodeEnv&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A path added to NODE_PATH when resolving the eslint module.</span></span><br><span class="line">	<span class="string">&quot;eslint.nodePath&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether ESLint should issue a warning on ignored files.</span></span><br><span class="line">	<span class="string">&quot;eslint.onIgnoredFiles&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The eslint options object to provide args normally passed to eslint when executed from a command line (see http://eslint.org/docs/developer-guide/nodejs-api#cliengine).</span></span><br><span class="line">	<span class="string">&quot;eslint.options&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The package manager you use to install node modules.</span></span><br><span class="line">	<span class="string">&quot;eslint.packageManager&quot;</span>: <span class="string">&quot;npm&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// An array of language ids for which the extension should probe if support is installed.</span></span><br><span class="line">	<span class="string">&quot;eslint.probe&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">		<span class="string">&quot;javascriptreact&quot;</span>,</span><br><span class="line">		<span class="string">&quot;typescript&quot;</span>,</span><br><span class="line">		<span class="string">&quot;typescriptreact&quot;</span>,</span><br><span class="line">		<span class="string">&quot;html&quot;</span>,</span><br><span class="line">		<span class="string">&quot;vue&quot;</span>,</span><br><span class="line">		<span class="string">&quot;markdown&quot;</span></span><br><span class="line">	],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This option is deprecated. Use eslint.lintTask.enable instead.</span></span><br><span class="line">	<span class="comment">// Controls whether a task for linting the whole workspace will be available.</span></span><br><span class="line">	<span class="string">&quot;eslint.provideLintTask&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Turns on quiet mode, which ignores warnings.</span></span><br><span class="line">	<span class="string">&quot;eslint.quiet&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run the linter on save (onSave) or on type (onType)</span></span><br><span class="line">	<span class="string">&quot;eslint.run&quot;</span>: <span class="string">&quot;onType&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The location of the node binary to run ESLint under.</span></span><br><span class="line">	<span class="string">&quot;eslint.runtime&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Traces the communication between VSCode and the eslint linter service.</span></span><br><span class="line">	<span class="string">&quot;eslint.trace.server&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// An array of language ids which should be validated by ESLint. If not installed ESLint will show an error.</span></span><br><span class="line">	<span class="comment">// &quot;eslint.validate&quot;: [],</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="string">&quot;eslint.workingDirectories&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当箭头函数仅有一个参数时加上括号</span></span><br><span class="line">	<span class="string">&quot;prettier.arrowParens&quot;</span>: <span class="string">&quot;always&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 控制对象字面量的空格输出</span></span><br><span class="line">	<span class="string">&quot;prettier.bracketSpacing&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Path to the prettier configuration file</span></span><br><span class="line">	<span class="string">&quot;prettier.configPath&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于禁用此扩展的语言ID列表</span></span><br><span class="line">	<span class="string">&quot;prettier.disableLanguages&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A list of [glob patterns](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) to register Prettier formatter</span></span><br><span class="line">	<span class="string">&quot;prettier.documentSelectors&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Control whether Prettier formats quoted code embedded in the file.</span></span><br><span class="line">	<span class="string">&quot;prettier.embeddedLanguageFormatting&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Controls whether prettier is enabled or not.</span></span><br><span class="line">	<span class="string">&quot;prettier.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定 prettier 的换行符</span></span><br><span class="line">	<span class="string">&quot;prettier.endOfLine&quot;</span>: <span class="string">&quot;lf&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定HTML文件的全局空白区域敏感度。</span></span><br><span class="line">	<span class="comment">// 有效选项：</span></span><br><span class="line">	<span class="comment">//  &#x27;css&#x27; - 尊重CSS显示属性的默认值。 </span></span><br><span class="line">	<span class="comment">//  &#x27;strict&#x27; - 空格被认为是敏感的。 </span></span><br><span class="line">	<span class="comment">//  &#x27;ignore&#x27; - 空格被认为是不敏感的。</span></span><br><span class="line">	<span class="string">&quot;prettier.htmlWhitespaceSensitivity&quot;</span>: <span class="string">&quot;css&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// .prettierignore或类似文件的路径</span></span><br><span class="line">	<span class="string">&quot;prettier.ignorePath&quot;</span>: <span class="string">&quot;.prettierignore&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prettier can insert a special @format marker at the top of files specifying that the file has been formatted with prettier. This works well when used in tandem with the `--require-pragma` option. If there is already a docblock at the top of the file then this option will add a newline to it with the @format marker.</span></span><br><span class="line">	<span class="string">&quot;prettier.insertPragma&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果为 true，则将多行jsx元素的 `&gt;` 放在最后一行的末尾，而不是单独放在下一行</span></span><br><span class="line">	<span class="string">&quot;prettier.jsxBracketSameLine&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在JSX中使用单引号而不是双引号</span></span><br><span class="line">	<span class="string">&quot;prettier.jsxSingleQuote&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The package manager you use to install node modules.</span></span><br><span class="line">	<span class="string">&quot;prettier.packageManager&quot;</span>: <span class="string">&quot;npm&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Path to the prettier module</span></span><br><span class="line">	<span class="string">&quot;prettier.prettierPath&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定每行代码的最佳长度， 如果超出长度则换行。</span></span><br><span class="line">	<span class="string">&quot;prettier.printWidth&quot;</span>: <span class="number">80</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// （Markdown）将散文包含在多行中</span></span><br><span class="line">	<span class="string">&quot;prettier.proseWrap&quot;</span>: <span class="string">&quot;preserve&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Change when properties in objects are quoted</span></span><br><span class="line">	<span class="string">&quot;prettier.quoteProps&quot;</span>: <span class="string">&quot;as-needed&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 需要 prettier configuration 来格式化</span></span><br><span class="line">	<span class="string">&quot;prettier.requireConfig&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file. This is very useful when gradually transitioning large, unformatted codebases to prettier.</span></span><br><span class="line">	<span class="string">&quot;prettier.requirePragma&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When enabled, this extension will attempt to use global npm or yarn modules if local modules cannot be resolved.</span></span><br><span class="line">	<span class="comment">// &gt; _This setting can have a negative performance impact, particularly on Windows when you have attached network drives. Only enable this if you must use global modules._</span></span><br><span class="line">	<span class="string">&quot;prettier.resolveGlobalModules&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否在每行末尾添加分号</span></span><br><span class="line">	<span class="string">&quot;prettier.semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果为 true，将使用单引号而不是双引号</span></span><br><span class="line">	<span class="string">&quot;prettier.singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每个制表符占用的空格数</span></span><br><span class="line">	<span class="string">&quot;prettier.tabWidth&quot;</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尽可能控制尾随逗号的输出。</span></span><br><span class="line">	<span class="comment">// 有效选项：</span></span><br><span class="line">	<span class="comment">// &#x27;无&#x27; - 无尾随逗号</span></span><br><span class="line">	<span class="comment">// &#x27; es5&#x27; - 在ES5中有效的尾随逗号（对象，数组等）</span></span><br><span class="line">	<span class="comment">//  &#x27;all&#x27; - 尾随逗号 尽可能（函数参数）</span></span><br><span class="line">	<span class="string">&quot;prettier.trailingComma&quot;</span>: <span class="string">&quot;es5&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether or not to take `.editorconfig` into account when parsing configuration. See the [prettier.resolveConfig](https://prettier.io/docs/en/api.html) docs for details.</span></span><br><span class="line">	<span class="string">&quot;prettier.useEditorConfig&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用制表符（tab）缩进</span></span><br><span class="line">	<span class="string">&quot;prettier.useTabs&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether or not to indent the code inside `&lt;script&gt;` and `&lt;style&gt;` tags in Vue files. Some people (like the creator of Vue) don’t indent to save an indentation level, but this might break code folding in your editor.</span></span><br><span class="line">	<span class="string">&quot;prettier.vueIndentScriptAndStyle&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If true, this extension will process files in node_modules</span></span><br><span class="line">	<span class="string">&quot;prettier.withNodeModules&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the languages that the extension will be activated.  e.g. [&quot;html&quot;,&quot;xml&quot;,&quot;php&quot;]. Use [&quot;*&quot;] to activate for all languages.</span></span><br><span class="line">	<span class="string">&quot;auto-close-tag.activationOnLanguage&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;xml&quot;</span>,</span><br><span class="line">		<span class="string">&quot;php&quot;</span>,</span><br><span class="line">		<span class="string">&quot;blade&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ejs&quot;</span>,</span><br><span class="line">		<span class="string">&quot;jinja&quot;</span>,</span><br><span class="line">		<span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">		<span class="string">&quot;javascriptreact&quot;</span>,</span><br><span class="line">		<span class="string">&quot;typescript&quot;</span>,</span><br><span class="line">		<span class="string">&quot;typescriptreact&quot;</span>,</span><br><span class="line">		<span class="string">&quot;plaintext&quot;</span>,</span><br><span class="line">		<span class="string">&quot;markdown&quot;</span>,</span><br><span class="line">		<span class="string">&quot;vue&quot;</span>,</span><br><span class="line">		<span class="string">&quot;liquid&quot;</span>,</span><br><span class="line">		<span class="string">&quot;erb&quot;</span>,</span><br><span class="line">		<span class="string">&quot;lang-cfml&quot;</span>,</span><br><span class="line">		<span class="string">&quot;cfml&quot;</span>,</span><br><span class="line">		<span class="string">&quot;HTML (EEx)&quot;</span>,</span><br><span class="line">		<span class="string">&quot;HTML (Eex)&quot;</span>,</span><br><span class="line">		<span class="string">&quot;plist&quot;</span></span><br><span class="line">	],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the languages where the extension will be disabled.  e.g. [&quot;html&quot;,&quot;xml&quot;,&quot;php&quot;].</span></span><br><span class="line">	<span class="string">&quot;auto-close-tag.disableOnLanguage&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether to close self-closing tag automatically</span></span><br><span class="line">	<span class="string">&quot;auto-close-tag.enableAutoCloseSelfClosingTag&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether to insert close tag automatically</span></span><br><span class="line">	<span class="string">&quot;auto-close-tag.enableAutoCloseTag&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the tag list that would not be auto closed.</span></span><br><span class="line">	<span class="string">&quot;auto-close-tag.excludedTags&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;area&quot;</span>,</span><br><span class="line">		<span class="string">&quot;base&quot;</span>,</span><br><span class="line">		<span class="string">&quot;br&quot;</span>,</span><br><span class="line">		<span class="string">&quot;col&quot;</span>,</span><br><span class="line">		<span class="string">&quot;command&quot;</span>,</span><br><span class="line">		<span class="string">&quot;embed&quot;</span>,</span><br><span class="line">		<span class="string">&quot;hr&quot;</span>,</span><br><span class="line">		<span class="string">&quot;img&quot;</span>,</span><br><span class="line">		<span class="string">&quot;input&quot;</span>,</span><br><span class="line">		<span class="string">&quot;keygen&quot;</span>,</span><br><span class="line">		<span class="string">&quot;link&quot;</span>,</span><br><span class="line">		<span class="string">&quot;meta&quot;</span>,</span><br><span class="line">		<span class="string">&quot;param&quot;</span>,</span><br><span class="line">		<span class="string">&quot;source&quot;</span>,</span><br><span class="line">		<span class="string">&quot;track&quot;</span>,</span><br><span class="line">		<span class="string">&quot;wbr&quot;</span></span><br><span class="line">	],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enable both Visual Studio and Sublime Text mode</span></span><br><span class="line">	<span class="string">&quot;auto-close-tag.fullMode&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Auto close tag when &lt;/ is typed, same as Sublime Text 3</span></span><br><span class="line">	<span class="string">&quot;auto-close-tag.SublimeText3Mode&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A path to a file, or an object containing the configuration options for js-beautify. If the .jsbeautifyrc file exists in project root, it overrides this configuration.</span></span><br><span class="line">	<span class="string">&quot;beautify.config&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// List of paths to ignore when using VS Code format command, including format on save. Uses glob pattern matching.</span></span><br><span class="line">	<span class="string">&quot;beautify.ignore&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Link file types to the beautifier type</span></span><br><span class="line">	<span class="string">&quot;beautify.language&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;js&quot;</span>: &#123;</span><br><span class="line">			<span class="string">&quot;type&quot;</span>: [</span><br><span class="line">				<span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">				<span class="string">&quot;json&quot;</span>,</span><br><span class="line">				<span class="string">&quot;jsonc&quot;</span></span><br><span class="line">			],</span><br><span class="line">			<span class="string">&quot;filename&quot;</span>: [</span><br><span class="line">				<span class="string">&quot;.jshintrc&quot;</span>,</span><br><span class="line">				<span class="string">&quot;.jsbeautifyrc&quot;</span></span><br><span class="line">			]</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;css&quot;</span>: [</span><br><span class="line">			<span class="string">&quot;css&quot;</span>,</span><br><span class="line">			<span class="string">&quot;less&quot;</span>,</span><br><span class="line">			<span class="string">&quot;scss&quot;</span></span><br><span class="line">		],</span><br><span class="line">		<span class="string">&quot;html&quot;</span>: [</span><br><span class="line">			<span class="string">&quot;htm&quot;</span>,</span><br><span class="line">			<span class="string">&quot;html&quot;</span></span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Include completion for module export and auto import them</span></span><br><span class="line">	<span class="string">&quot;vetur.completion.autoImport&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Where Vetur source Scaffold Snippets from and how to indicate them. Set a source to &quot;&quot; to disable it.</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// - workspace: `&lt;WORKSPACE&gt;/.vscode/vetur/snippets`.</span></span><br><span class="line">	<span class="comment">// - user: `&lt;USER-DATA-DIR&gt;/User/snippets/vetur`.</span></span><br><span class="line">	<span class="comment">// - vetur: Bundled in Vetur.</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// The default is:</span></span><br><span class="line">	<span class="comment">// ```</span></span><br><span class="line">	<span class="comment">// &quot;vetur.completion.scaffoldSnippetSources&quot;: &#123;</span></span><br><span class="line">	<span class="comment">//   &quot;workspace&quot;: &quot;💼&quot;,</span></span><br><span class="line">	<span class="comment">//   &quot;user&quot;: &quot;🗒️&quot;,</span></span><br><span class="line">	<span class="comment">//   &quot;vetur&quot;: &quot;✌&quot;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// ```</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// Alternatively, you can do:</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// ```</span></span><br><span class="line">	<span class="comment">// &quot;vetur.completion.scaffoldSnippetSources&quot;: &#123;</span></span><br><span class="line">	<span class="comment">//   &quot;workspace&quot;: &quot;(W)&quot;,</span></span><br><span class="line">	<span class="comment">//   &quot;user&quot;: &quot;(U)&quot;,</span></span><br><span class="line">	<span class="comment">//   &quot;vetur&quot;: &quot;(V)&quot;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// ```</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// Read more: https://vuejs.github.io/vetur/snippet.html.</span></span><br><span class="line">	<span class="string">&quot;vetur.completion.scaffoldSnippetSources&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;workspace&quot;</span>: <span class="string">&quot;💼&quot;</span>,</span><br><span class="line">		<span class="string">&quot;user&quot;</span>: <span class="string">&quot;🗒️&quot;</span>,</span><br><span class="line">		<span class="string">&quot;vetur&quot;</span>: <span class="string">&quot;✌&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Casing conversion for tag completion</span></span><br><span class="line">	<span class="comment">//  - initial: use the key in `components: &#123;...&#125;` as is for tag completion and do not force any casing</span></span><br><span class="line">	<span class="comment">//  - kebab: kebab-case completion for &lt;my-tag&gt;</span></span><br><span class="line">	<span class="string">&quot;vetur.completion.tagCasing&quot;</span>: <span class="string">&quot;kebab&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Log level for VLS</span></span><br><span class="line">	<span class="comment">//  - INFO: Only log info messages. This is the default.</span></span><br><span class="line">	<span class="comment">//  - DE<span class="doctag">BUG:</span> Log info and debug messages.</span></span><br><span class="line">	<span class="string">&quot;vetur.dev.logLevel&quot;</span>: <span class="string">&quot;INFO&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Path to vls for Vetur developers. There are two ways of using it. </span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">// 1. Clone vuejs/vetur from GitHub, build it and point it to the ABSOLUTE path of `/server`.</span></span><br><span class="line">	<span class="comment">// 2. `yarn global add vls` and point Vetur to the installed location (`yarn global dir` + node_modules/vls)</span></span><br><span class="line">	<span class="string">&quot;vetur.dev.vlsPath&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The port that VLS listens to. Can be used for attaching to the VLS Node process for debugging / profiling.</span></span><br><span class="line">	<span class="string">&quot;vetur.dev.vlsPort&quot;</span>: -<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enable template interpolation service that offers hover / definition / references in Vue interpolations.</span></span><br><span class="line">	<span class="string">&quot;vetur.experimental.templateInterpolationService&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Default formatter for &lt;style&gt; region</span></span><br><span class="line">	<span class="comment">//  - none: disable formatting</span></span><br><span class="line">	<span class="comment">//  - prettier: css formatter using css parser from prettier</span></span><br><span class="line">	<span class="string">&quot;vetur.format.defaultFormatter.css&quot;</span>: <span class="string">&quot;prettier&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Default formatter for &lt;template&gt; region</span></span><br><span class="line">	<span class="comment">//  - none: disable formatting</span></span><br><span class="line">	<span class="comment">//  - prettyhtml: 🚧 [DEPRECATED] prettyhtml</span></span><br><span class="line">	<span class="comment">//  - js-beautify-html: html formatter of js-beautify</span></span><br><span class="line">	<span class="comment">//  - prettier: prettier</span></span><br><span class="line">	<span class="string">&quot;vetur.format.defaultFormatter.html&quot;</span>: <span class="string">&quot;prettier&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Default formatter for &lt;script&gt; region</span></span><br><span class="line">	<span class="comment">//  - none: disable formatting</span></span><br><span class="line">	<span class="comment">//  - prettier: js formatter from prettier</span></span><br><span class="line">	<span class="comment">//  - prettier-eslint: prettier-eslint</span></span><br><span class="line">	<span class="comment">//  - vscode-typescript: js formatter from TypeScript</span></span><br><span class="line">	<span class="string">&quot;vetur.format.defaultFormatter.js&quot;</span>: <span class="string">&quot;prettier&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Default formatter for &lt;style lang=&#x27;less&#x27;&gt; region</span></span><br><span class="line">	<span class="comment">//  - none: disable formatting</span></span><br><span class="line">	<span class="comment">//  - prettier: less formatter using postcss parser from prettier</span></span><br><span class="line">	<span class="string">&quot;vetur.format.defaultFormatter.less&quot;</span>: <span class="string">&quot;prettier&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Default formatter for &lt;style lang=&#x27;postcss&#x27;&gt; region</span></span><br><span class="line">	<span class="comment">//  - none: disable formatting</span></span><br><span class="line">	<span class="comment">//  - prettier: postcss formatter using css parser from prettier</span></span><br><span class="line">	<span class="string">&quot;vetur.format.defaultFormatter.postcss&quot;</span>: <span class="string">&quot;prettier&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Default formatter for &lt;template lang=&#x27;pug&#x27;&gt; region</span></span><br><span class="line">	<span class="comment">//  - none: disable formatting</span></span><br><span class="line">	<span class="comment">//  - prettier: prettier</span></span><br><span class="line">	<span class="string">&quot;vetur.format.defaultFormatter.pug&quot;</span>: <span class="string">&quot;prettier&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Default formatter for &lt;style lang=&#x27;sass&#x27;&gt; region</span></span><br><span class="line">	<span class="comment">//  - none: disable formatting</span></span><br><span class="line">	<span class="comment">//  - sass-formatter: sass formatter</span></span><br><span class="line">	<span class="string">&quot;vetur.format.defaultFormatter.sass&quot;</span>: <span class="string">&quot;sass-formatter&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Default formatter for &lt;style lang=&#x27;scss&#x27;&gt; region</span></span><br><span class="line">	<span class="comment">//  - none: disable formatting</span></span><br><span class="line">	<span class="comment">//  - prettier: scss formatter using scss parser from prettier</span></span><br><span class="line">	<span class="string">&quot;vetur.format.defaultFormatter.scss&quot;</span>: <span class="string">&quot;prettier&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Default formatter for &lt;style lang=&#x27;stylus&#x27;&gt; region</span></span><br><span class="line">	<span class="comment">//  - none: disable formatting</span></span><br><span class="line">	<span class="comment">//  - stylus-supremacy: stylus formatter from stylus-supremacy</span></span><br><span class="line">	<span class="string">&quot;vetur.format.defaultFormatter.stylus&quot;</span>: <span class="string">&quot;stylus-supremacy&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Default formatter for &lt;script&gt; region</span></span><br><span class="line">	<span class="comment">//  - none: disable formatting</span></span><br><span class="line">	<span class="comment">//  - prettier: ts formatter using typescript parser from prettier</span></span><br><span class="line">	<span class="comment">//  - prettier-tslint: ts formatter from TypeScript</span></span><br><span class="line">	<span class="string">&quot;vetur.format.defaultFormatter.ts&quot;</span>: <span class="string">&quot;prettier&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Options for all default formatters</span></span><br><span class="line">	<span class="string">&quot;vetur.format.defaultFormatterOptions&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;js-beautify-html&quot;</span>: &#123;</span><br><span class="line">			<span class="string">&quot;wrap_attributes&quot;</span>: <span class="string">&quot;force-expand-multiline&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;prettyhtml&quot;</span>: &#123;</span><br><span class="line">			<span class="string">&quot;printWidth&quot;</span>: <span class="number">100</span>,</span><br><span class="line">			<span class="string">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">			<span class="string">&quot;wrapAttributes&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">			<span class="string">&quot;sortAttributes&quot;</span>: <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enable/disable the Vetur document formatter.</span></span><br><span class="line">	<span class="string">&quot;vetur.format.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Number of spaces per indentation level. Inherited by all formatters.</span></span><br><span class="line">	<span class="string">&quot;vetur.format.options.tabSize&quot;</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use tabs for indentation. Inherited by all formatters.</span></span><br><span class="line">	<span class="string">&quot;vetur.format.options.useTabs&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether to have initial indent for &lt;script&gt; region</span></span><br><span class="line">	<span class="string">&quot;vetur.format.scriptInitialIndent&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether to have initial indent for &lt;style&gt; region</span></span><br><span class="line">	<span class="string">&quot;vetur.format.styleInitialIndent&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mapping from custom block tag name to language name. Used for generating grammar to support syntax highlighting for custom blocks.</span></span><br><span class="line">	<span class="string">&quot;vetur.grammar.customBlocks&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;docs&quot;</span>: <span class="string">&quot;md&quot;</span>,</span><br><span class="line">		<span class="string">&quot;i18n&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether to enable codeActions</span></span><br><span class="line">	<span class="string">&quot;vetur.languageFeatures.codeActions&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Traces the communication between VS Code and Vue Language Server.</span></span><br><span class="line">	<span class="string">&quot;vetur.trace.server&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use dependencies from workspace. Currently only for TypeScript.</span></span><br><span class="line">	<span class="string">&quot;vetur.useWorkspaceDependencies&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate interpolations in &lt;template&gt; region using TypeScript language service</span></span><br><span class="line">	<span class="string">&quot;vetur.validation.interpolation&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate js/ts in &lt;script&gt;</span></span><br><span class="line">	<span class="string">&quot;vetur.validation.script&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate css/scss/less/postcss in &lt;style&gt;</span></span><br><span class="line">	<span class="string">&quot;vetur.validation.style&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate vue-html in &lt;template&gt; using eslint-plugin-vue</span></span><br><span class="line">	<span class="string">&quot;vetur.validation.template&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate props usage in &lt;template&gt; region. Show error/warning for not passing declared props to child components and show error for passing wrongly typed interpolation expressions</span></span><br><span class="line">	<span class="string">&quot;vetur.validation.templateProps&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Note: If it is not Null, It will override CustomBrowser and ChromeDebuggingAttachment settings.</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">//  Examples : </span></span><br><span class="line">	<span class="comment">// chrome --incognito --headless --remote-debugging-port=9222 </span></span><br><span class="line">	<span class="comment">//  C:\\Program Files\\Firefox Developer Edition\\firefox.exe --private-window</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.AdvanceCustomBrowserCmdLine&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enable Chrome Debugging Attachment to Live Server at Debuging Port 9222.</span></span><br><span class="line">	<span class="comment">//  <span class="doctag">NOTE:</span> You have to install &#x27;Debugger for Chrome&#x27; </span></span><br><span class="line">	<span class="comment">// If the value is true, Select &#x27;Attach to Chrome&#x27; from Debug Window to start debugging. </span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">//  CAUTION: If it is true, &#x27;Launch Chrome against localhost&#x27; may not work.</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.ChromeDebuggingAttachment&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Specify custom browser settings for Live Server. </span></span><br><span class="line">	<span class="comment">// By Default it will open your default favorite browser.</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.CustomBrowser&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// To disable information pop up messages.</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.donotShowInfoMsg&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// To turn off prompt warning message if body or head or other supporting tag is missing in your HTML.</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.donotVerifyTags&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When set, serve this file (server root relative) for every 404 (useful for single-page applications)</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.file&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// By Default Live Server inject CSS changes without full reloading of browser. You can change this behviour by making this setting as `true`</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.fullReload&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// To switch between localhost or 127.0.0.1 or anything else. Default is 127.0.0.1</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.host&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Setup https configuration</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.https&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;enable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="string">&quot;cert&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">		<span class="string">&quot;key&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">		<span class="string">&quot;passphrase&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// To ignore specific file changes</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.ignoreFiles&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;.vscode/**&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/*.scss&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/*.sass&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/*.ts&quot;</span></span><br><span class="line">	],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mount a directory to a route. Such as [[&#x27;/components&#x27;, &#x27;./node_modules&#x27;]]</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.mount&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This the entry point of server when you&#x27;re in multiroot workspace</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.multiRootWorkspaceName&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If it is true live server will start without browser opened.</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.NoBrowser&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set Custom Port Number of Live Server. Set 0 if you want random port.</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.port&quot;</span>: <span class="number">5500</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// To Setup Proxy</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.proxy&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;enable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="string">&quot;baseUri&quot;</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">		<span class="string">&quot;proxyUri&quot;</span>: <span class="string">&quot;http://127.0.0.1:80&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set Custom root of Live Server. </span></span><br><span class="line">	<span class="comment">// To change root the the server to sub folder of workspace, use &#x27;/&#x27; and relative path from workspace. </span></span><br><span class="line">	<span class="comment">// Example: /subfolder1/subfolder2</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.root&quot;</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Change this to false if you don&#x27;t want the button to show in the statusbar</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.showOnStatusbar&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Open in Browser Preview inside VS Code, instead of default browser</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.useBrowserPreview&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use local IP as host</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.useLocalIp&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You have to install a browser extension. That will be works for your dynamic pages (like PHP).</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.useWebExt&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Delay before live reloading. Value in milliseconds. Default is 100</span></span><br><span class="line">	<span class="string">&quot;liveServer.settings.wait&quot;</span>: <span class="number">100</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Default style for all customized keywords</span></span><br><span class="line">	<span class="string">&quot;todohighlight.defaultStyle&quot;</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Glob pattern that defines files and folders to exclude while listing annotations.</span></span><br><span class="line">	<span class="string">&quot;todohighlight.exclude&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;**/node_modules/**&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/bower_components/**&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/dist/**&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/build/**&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/.vscode/**&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/.github/**&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/_output/**&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/*.min.*&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/*.map&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/.next/**&quot;</span></span><br><span class="line">	],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Glob patterns that defines the files to search for. Only include files you need, DO NOT USE `&#123;**/*.*&#125;` for both permormance and avoiding binary files reason.</span></span><br><span class="line">	<span class="string">&quot;todohighlight.include&quot;</span>: [</span><br><span class="line">		<span class="string">&quot;**/*.js&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/*.jsx&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/*.ts&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/*.tsx&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/*.html&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/*.php&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/*.css&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**/*.scss&quot;</span></span><br><span class="line">	],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Specify whether the keywords are case sensitive or not</span></span><br><span class="line">	<span class="string">&quot;todohighlight.isCaseSensitive&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enable or disable the highlight</span></span><br><span class="line">	<span class="string">&quot;todohighlight.isEnable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Customize keywords and colors. Any css color identifier is valid.</span></span><br><span class="line">	<span class="string">&quot;todohighlight.keywords&quot;</span>: [],</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Specify keywords via RegExp instead of `todohighlight.keywords` one by one. NOTE that if this presents, `todohighlight.keywords` will be ignored. And REMEMBER to escapse the back slash if there&#x27;s any in your regexp (using \\ instead of single back slash)</span></span><br><span class="line">	<span class="string">&quot;todohighlight.keywordsPattern&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Max files for searching</span></span><br><span class="line">	<span class="string">&quot;todohighlight.maxFilesForSearch&quot;</span>: <span class="number">5120</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the file path within the output channel not clickable, set this to true to toggle the path patten between `&lt;path&gt;#&lt;line&gt;` and `&lt;path&gt;:&lt;line&gt;:&lt;column&gt;`</span></span><br><span class="line">	<span class="string">&quot;todohighlight.toggleURI&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="string">&quot;[vue]&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;[javascript]&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;minapp-vscode.disableAutoConfig&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2022/10/19/20221019-JavaScript/</url>
    <content><![CDATA[<h2 id="JavaScript-面试知识点总结"><a href="#JavaScript-面试知识点总结" class="headerlink" title="JavaScript 面试知识点总结"></a>JavaScript 面试知识点总结</h2><p>本部分主要是笔者在复习 JavaScript 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#1-%E4%BB%8B%E7%BB%8D-js-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1. 介绍 js 的基本数据类型。</a></li>
<li><a href="#2-javascript-%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E4%BD%A0%E8%83%BD%E7%94%BB%E4%B8%80%E4%B8%8B%E4%BB%96%E4%BB%AC%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%E5%90%97">2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</a></li>
<li><a href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB">3. 什么是堆？什么是栈？它们之间有什么区别和联系？</a></li>
<li>[4. 内部属性 [[Class]] 是什么？](#4-内部属性-class-是什么)</li>
<li><a href="#5-%E4%BB%8B%E7%BB%8D-js-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1">5. 介绍 js 有哪些内置对象？</a></li>
<li><a href="#6-undefined-%E4%B8%8E-undeclared-%E7%9A%84%E5%8C%BA%E5%88%AB">6. undefined 与 undeclared 的区别？</a></li>
<li><a href="#7-null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB">7. null 和 undefined 的区别？</a></li>
<li><a href="#8-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AE%89%E5%85%A8%E7%9A%84-undefined-%E5%80%BC">8. 如何获取安全的 undefined 值？</a></li>
<li><a href="#9-%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99-javascript-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83">9. 说几条写 JavaScript 的基本规范？</a></li>
<li><a href="#10-javascript-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9">10. JavaScript 原型，原型链？ 有什么特点？</a></li>
<li><a href="#11-js-%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95">11. js 获取原型的方法？</a></li>
<li><a href="#12-%E5%9C%A8-js-%E4%B8%AD%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F">12. 在 js 中不同进制数字的表示方式</a></li>
<li><a href="#13-js-%E4%B8%AD%E6%95%B4%E6%95%B0%E7%9A%84%E5%AE%89%E5%85%A8%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91">13. js 中整数的安全范围是多少？</a></li>
<li><a href="#14-typeof-nan-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88">14. typeof NaN 的结果是什么？</a></li>
<li><a href="#15-isnan-%E5%92%8C-numberisnan-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB">15. isNaN 和 Number.isNaN 函数的区别？</a></li>
<li><a href="#16-array-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E5%80%BC%E6%97%B6%E7%9A%84%E8%A1%A8%E7%8E%B0">16. Array 构造函数只有一个参数值时的表现？</a></li>
<li><a href="#17-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">17. 其他值到字符串的转换规则？</a></li>
<li><a href="#18-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E6%95%B0%E5%AD%97%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">18. 其他值到数字值的转换规则？</a></li>
<li><a href="#19-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">19. 其他值到布尔类型的值的转换规则？</a></li>
<li><a href="#20--%E5%92%8C--%E7%9A%84-valueof-%E5%92%8C-tostring-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88">20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</a></li>
<li><a href="#21-%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%87%E5%80%BC%E5%AF%B9%E8%B1%A1">21. 什么是假值对象？</a></li>
<li><a href="#22--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8">22. ~ 操作符的作用？</a></li>
<li><a href="#23-%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E5%92%8C%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E7%9A%84%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%83%BD%E6%98%AF%E6%95%B0%E5%AD%97%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</a></li>
<li><a href="#24--%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5">24. 操作符什么时候用于字符串的拼接？</a></li>
<li><a href="#25-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E5%B8%83%E5%B0%94%E5%80%BC%E7%9A%84%E9%9A%90%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">25. 什么情况下会发生布尔值的隐式强制类型转换？</a></li>
<li><a href="#26--%E5%92%8C--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">26. || 和 &amp;&amp; 操作符的返回值？</a></li>
<li><a href="#27-symbol-%E5%80%BC%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">27. Symbol 值的强制类型转换？</a></li>
<li><a href="#28--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">28. == 操作符的强制类型转换规则？</a></li>
<li><a href="#29-%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BE%8B%E5%A6%82-123b">29. 如何将字符串转化为数字，例如 ‘12.3b’?</a></li>
<li><a href="#30-%E5%A6%82%E4%BD%95%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E7%82%B9%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%95%B0%E6%AF%8F%E4%B8%89%E4%BD%8D%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%80%97%E5%8F%B7%E5%A6%821200000011%E8%BD%AC%E5%8C%96%E4%B8%BA1200000011">30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</a></li>
<li><a href="#31-%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">31. 常用正则表达式</a></li>
<li><a href="#32-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95">32. 生成随机数的各种方法？</a></li>
<li><a href="#33-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F">33. 如何实现数组的随机排序？</a></li>
<li><a href="#34-javascript-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">34. javascript 创建对象的几种方式？</a></li>
<li><a href="#35-javascript-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">35. JavaScript 继承的几种实现方式？</a></li>
<li><a href="#36-%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0">36. 寄生式组合继承的实现？</a></li>
<li><a href="#37-javascript-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">37. Javascript 的作用域链？</a></li>
<li><a href="#38-%E8%B0%88%E8%B0%88-this-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3">38. 谈谈 This 对象的理解。</a></li>
<li><a href="#39-eval-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84">39. eval 是做什么的？</a></li>
<li><a href="#40-%E4%BB%80%E4%B9%88%E6%98%AF-dom-%E5%92%8C-bom">40. 什么是 DOM 和 BOM？</a></li>
<li><a href="#41-%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%99%A8%E5%87%BD%E6%95%B0">41. 写一个通用的事件侦听器函数。</a></li>
<li><a href="#42-%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88ie-%E4%B8%8E%E7%81%AB%E7%8B%90%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1">42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</a></li>
<li><a href="#43-%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88">43. 三种事件模型是什么？</a></li>
<li><a href="#44-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%98%AF%E4%BB%80%E4%B9%88">44. 事件委托是什么？</a></li>
<li><a href="#45-1-2-3mapparseint-%E7%AD%94%E6%A1%88%E6%98%AF%E5%A4%9A%E5%B0%91">45. [“1”, “2”, “3”].map(parseInt) 答案是多少？</a></li>
<li><a href="#46-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%83">46. 什么是闭包，为什么要用它？</a></li>
<li><a href="#47-javascript-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84-use-strict-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D--%E4%BD%BF%E7%94%A8%E5%AE%83%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</a></li>
<li><a href="#48-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%B1%BB">48. 如何判断一个对象是否属于某个类？</a></li>
<li><a href="#49-instanceof-%E7%9A%84%E4%BD%9C%E7%94%A8">49. instanceof 的作用？</a></li>
<li><a href="#50-new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0">50. new 操作符具体干了什么呢？如何实现？</a></li>
<li><a href="#51-javascript%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%9F%A5%E6%89%BE%E6%97%B6%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E5%8E%BB%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%9E%8B%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AF">51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</a></li>
<li><a href="#52-%E5%AF%B9%E4%BA%8E-json-%E7%9A%84%E4%BA%86%E8%A7%A3">52. 对于 JSON 的了解？</a></li>
<li><a href="#53-foreachcallfunctionaastyleoutline1px-solid-mathrandom124tostring16-%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E6%80%9D%E5%90%97">53. <code>[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)</code> 能解释一下这段代码的意思吗？</a></li>
<li><a href="#54-js-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">54. js 延迟加载的方式有哪些？</a></li>
<li><a href="#55-ajax-%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAajax">55. Ajax 是什么? 如何创建一个 Ajax？</a></li>
<li><a href="#56-%E8%B0%88%E4%B8%80%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">56. 谈一谈浏览器的缓存机制？</a></li>
<li><a href="#57-ajax-%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">57. Ajax 解决浏览器缓存问题？</a></li>
<li><a href="#58-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB">58. 同步和异步的区别？</a></li>
<li><a href="#59-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96">59. 什么是浏览器的同源政策？</a></li>
<li><a href="#60-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">60. 如何解决跨域问题？</a></li>
<li><a href="#61-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E6%97%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-cookie">61. 服务器代理转发时，该如何处理 cookie？</a></li>
<li><a href="#62-%E7%AE%80%E5%8D%95%E8%B0%88%E4%B8%80%E4%B8%8B-cookie-">62. 简单谈一下 cookie ？</a></li>
<li><a href="#63-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%80%8E%E4%B9%88%E5%81%9A">63. 模块化开发怎么做？</a></li>
<li><a href="#64-js-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83">64. js 的几种模块规范？</a></li>
<li><a href="#65-amd-%E5%92%8C-cmd-%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB">65. AMD 和 CMD 规范的区别？</a></li>
<li><a href="#66-es6-%E6%A8%A1%E5%9D%97%E4%B8%8E-commonjs-%E6%A8%A1%E5%9D%97amdcmd-%E7%9A%84%E5%B7%AE%E5%BC%82">66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</a></li>
<li><a href="#67-requirejs-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A4%9A%E6%AC%A1%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%A6%82%E4%BD%95-%E7%BC%93%E5%AD%98%E7%9A%84">67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</a></li>
<li><a href="#68-js-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E8%BD%AE%E5%AD%90%E6%80%8E%E4%B9%88%E9%80%A0%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8">68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</a></li>
<li><a href="#69-ecmascript6-%E6%80%8E%E4%B9%88%E5%86%99-class%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0-class-%E8%BF%99%E7%A7%8D%E4%B8%9C%E8%A5%BF">69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</a></li>
<li><a href="#70-documenwrite-%E5%92%8C-innerhtml-%E7%9A%84%E5%8C%BA%E5%88%AB">70. documen.write 和 innerHTML 的区别？</a></li>
<li><a href="#71-dom-%E6%93%8D%E4%BD%9C%E6%80%8E%E6%A0%B7%E6%B7%BB%E5%8A%A0%E7%A7%BB%E9%99%A4%E7%A7%BB%E5%8A%A8%E5%A4%8D%E5%88%B6%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9">71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</a></li>
<li><a href="#72-innerhtml-%E4%B8%8E-outerhtml-%E7%9A%84%E5%8C%BA%E5%88%AB">72. innerHTML 与 outerHTML 的区别？</a></li>
<li><a href="#73-call-%E5%92%8C-apply-%E7%9A%84%E5%8C%BA%E5%88%AB">73. .call() 和 .apply() 的区别？</a></li>
<li><a href="#74-javascript-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89">74. JavaScript 类数组对象的定义？</a></li>
<li><a href="#75-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B">75. 数组和对象有哪些原生方法，列举一下？</a></li>
<li><a href="#76-%E6%95%B0%E7%BB%84%E7%9A%84-fill-%E6%96%B9%E6%B3%95">76. 数组的 fill 方法？</a></li>
<li><a href="#77--%E7%9A%84%E9%95%BF%E5%BA%A6">77. [,,,] 的长度？</a></li>
<li><a href="#78-javascript-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87">78. JavaScript 中的作用域与变量声明提升？</a></li>
<li><a href="#79-%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84-javascript-">79. 如何编写高性能的 Javascript ？</a></li>
<li><a href="#80-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-v8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">80. 简单介绍一下 V8 引擎的垃圾回收机制</a></li>
<li><a href="#81-%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">81. 哪些操作会造成内存泄漏？</a></li>
<li><a href="#82-%E9%9C%80%E6%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9C%E4%B8%8D%E4%BC%9A%E6%95%B4%E9%A1%B5%E5%88%B7%E6%96%B0%E7%9A%84%E7%BD%91%E7%AB%99%E5%B9%B6%E4%B8%94%E8%83%BD%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80%E6%97%B6%E6%AD%A3%E7%A1%AE%E5%93%8D%E5%BA%94%E7%BB%99%E5%87%BA%E4%BD%A0%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</a></li>
<li><a href="#83-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%84%9A%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%98%E6%98%AF-node-%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%98%BF%E9%87%8C">83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</a></li>
<li><a href="#84-%E6%8A%8A-script-%E6%A0%87%E7%AD%BE%E6%94%BE%E5%9C%A8%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%9C%80%E5%BA%95%E9%83%A8%E7%9A%84-body-%E5%B0%81%E9%97%AD%E4%B9%8B%E5%89%8D%E5%92%8C%E5%B0%81%E9%97%AD%E4%B9%8B%E5%90%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%AE%83%E4%BB%AC">84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</a></li>
<li><a href="#85-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%89%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E6%98%AF%E5%A4%9A%E4%B9%85%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E5%BB%B6%E6%97%B6">85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</a></li>
<li><a href="#86-%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9">86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</a></li>
<li><a href="#87-%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%B9%88-%E7%9F%A5%E9%81%93-bdd-tdd-unit-test-%E4%B9%88-%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95%E4%BD%A0%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E4%B9%88mocha-sinon-jasmin-qunit">87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</a></li>
<li><a href="#88-%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC%E7%89%88%E6%9C%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F">88. 检测浏览器版本版本有哪些方式？</a></li>
<li><a href="#89-%E4%BB%80%E4%B9%88%E6%98%AF-polyfill-">89. 什么是 Polyfill ？</a></li>
<li><a href="#90-%E4%BD%BF%E7%94%A8-js-%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D">90. 使用 JS 实现获取文件扩展名？</a></li>
<li><a href="#91-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-js-%E7%9A%84%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96">91. 介绍一下 js 的节流与防抖？</a></li>
<li><a href="#92-objectis-%E4%B8%8E%E5%8E%9F%E6%9D%A5%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6--%E7%9A%84%E5%8C%BA%E5%88%AB">92. Object.is() 与原来的比较操作符 “===”、“==” 的区别？</a></li>
<li><a href="#93-escapeencodeuriencodeuricomponent-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">93. escape,encodeURI,encodeURIComponent 有什么区别？</a></li>
<li><a href="#94-unicode-%E5%92%8C-utf-8-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">94. Unicode 和 UTF-8 之间的关系？</a></li>
<li><a href="#95-js-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%98%AF%E4%BB%80%E4%B9%88">95. js 的事件循环是什么？</a></li>
<li><a href="#96-js-%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0">96. js 中的深浅拷贝实现？</a></li>
<li><a href="#97-%E6%89%8B%E5%86%99-callapply-%E5%8F%8A-bind-%E5%87%BD%E6%95%B0">97. 手写 call、apply 及 bind 函数</a></li>
<li><a href="#98-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0">98. 函数柯里化的实现</a></li>
<li><a href="#99-%E4%B8%BA%E4%BB%80%E4%B9%88-01--02--03%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98">99. 为什么 0.1 0.2 != 0.3？如何解决这个问题？</a></li>
<li><a href="#100-%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81%E7%9A%84%E4%BB%8B%E7%BB%8D">100. 原码、反码和补码的介绍</a></li>
<li><a href="#101-toprecision-%E5%92%8C-tofixed-%E5%92%8C-mathround-%E7%9A%84%E5%8C%BA%E5%88%AB">101. toPrecision 和 toFixed 和 Math.round 的区别？</a></li>
<li><a href="#102-%E4%BB%80%E4%B9%88%E6%98%AF-xss-%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-xss-%E6%94%BB%E5%87%BB">102. 什么是 XSS 攻击？如何防范 XSS 攻击？</a></li>
<li><a href="#103-%E4%BB%80%E4%B9%88%E6%98%AF-csp">103. 什么是 CSP？</a></li>
<li><a href="#104-%E4%BB%80%E4%B9%88%E6%98%AF-csrf-%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-csrf-%E6%94%BB%E5%87%BB">104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</a></li>
<li><a href="#105-%E4%BB%80%E4%B9%88%E6%98%AF-samesite-cookie-%E5%B1%9E%E6%80%A7">105. 什么是 Samesite Cookie 属性？</a></li>
<li><a href="#106-%E4%BB%80%E4%B9%88%E6%98%AF%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81">106. 什么是点击劫持？如何防范点击劫持？</a></li>
<li><a href="#107-sql-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">107. SQL 注入攻击？</a></li>
<li><a href="#108-%E4%BB%80%E4%B9%88%E6%98%AF-mvvm%E6%AF%94%E4%B9%8B-mvc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF-mvp-">108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</a></li>
<li><a href="#109-vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86">109. vue 双向数据绑定原理？</a></li>
<li><a href="#110-objectdefineproperty-%E4%BB%8B%E7%BB%8D">110. Object.defineProperty 介绍？</a></li>
<li><a href="#111-%E4%BD%BF%E7%94%A8-objectdefineproperty-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9">111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</a></li>
<li><a href="#112-%E4%BB%80%E4%B9%88%E6%98%AF-virtual-dom%E4%B8%BA%E4%BB%80%E4%B9%88-virtual-dom-%E6%AF%94%E5%8E%9F%E7%94%9F-dom-%E5%BF%AB">112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</a></li>
<li><a href="#113-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA-dom-%E6%A0%91%E7%9A%84%E5%B7%AE%E5%BC%82">113. 如何比较两个 DOM 树的差异？</a></li>
<li><a href="#114-%E4%BB%80%E4%B9%88%E6%98%AF-requestanimationframe-">114. 什么是 requestAnimationFrame ？</a></li>
<li><a href="#115-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-webpack-%E7%9A%84%E7%9C%8B%E6%B3%95">115. 谈谈你对 webpack 的看法</a></li>
<li><a href="#116-offsetwidthoffsetheightclientwidthclientheight-%E4%B8%8E-scrollwidthscrollheight-%E7%9A%84%E5%8C%BA%E5%88%AB">116. offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</a></li>
<li><a href="#117-%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">117. 谈一谈你理解的函数式编程？</a></li>
<li><a href="#118-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">118. 异步编程的实现方式？</a></li>
<li><a href="#119-js-%E5%8A%A8%E7%94%BB%E4%B8%8E-css-%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0">119. Js 动画与 CSS 动画区别及相应实现</a></li>
<li><a href="#120-get-%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA">120. get 请求传参长度的误区</a></li>
<li><a href="#121-url-%E5%92%8C-uri-%E7%9A%84%E5%8C%BA%E5%88%AB">121. URL 和 URI 的区别？</a></li>
<li><a href="#122-get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E5%9C%A8%E7%BC%93%E5%AD%98%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB">122. get 和 post 请求在缓存方面的区别</a></li>
<li><a href="#123-%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD">123. 图片的懒加载和预加载</a></li>
<li><a href="#124-mouseover-%E5%92%8C-mouseenter-%E7%9A%84%E5%8C%BA%E5%88%AB">124. mouseover 和 mouseenter 的区别？</a></li>
<li><a href="#125-js-%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0">125. js 拖拽功能的实现</a></li>
<li><a href="#126-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-settimeout-%E5%AE%9E%E7%8E%B0-setinterval%E6%80%8E%E4%B9%88%E6%A8%A1%E6%8B%9F">126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</a></li>
<li><a href="#127-let-%E5%92%8C-const-%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9">127. let 和 const 的注意点？</a></li>
<li><a href="#128-%E4%BB%80%E4%B9%88%E6%98%AF-rest-%E5%8F%82%E6%95%B0">128. 什么是 rest 参数？</a></li>
<li><a href="#129-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BD%BF%E7%94%A8%E5%B0%BE%E8%B0%83%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84">129. 什么是尾调用，使用尾调用有什么好处？</a></li>
<li><a href="#130-symbol-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9">130. Symbol 类型的注意点？</a></li>
<li><a href="#131-set-%E5%92%8C-weakset-%E7%BB%93%E6%9E%84">131. Set 和 WeakSet 结构？</a></li>
<li><a href="#132-map-%E5%92%8C-weakmap-%E7%BB%93%E6%9E%84">132. Map 和 WeakMap 结构？</a></li>
<li><a href="#133-%E4%BB%80%E4%B9%88%E6%98%AF-proxy-">133. 什么是 Proxy ？</a></li>
<li><a href="#134-reflect-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9B%AE%E7%9A%84">134. Reflect 对象创建目的？</a></li>
<li><a href="#135-require-%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F">135. require 模块引入的查找方式？</a></li>
<li><a href="#136-%E4%BB%80%E4%B9%88%E6%98%AF-promise-%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%98%AF-promisesa-%E8%A7%84%E8%8C%83">136. 什么是 Promise 对象，什么是 Promises/A 规范？</a></li>
<li><a href="#137-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-promise">137. 手写一个 Promise</a></li>
<li><a href="#138-%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F">138. 如何检测浏览器所支持的最小字体大小？</a></li>
<li><a href="#139-%E6%80%8E%E4%B9%88%E5%81%9A-js-%E4%BB%A3%E7%A0%81-error-%E7%BB%9F%E8%AE%A1">139. 怎么做 JS 代码 Error 统计？</a></li>
<li><a href="#140-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">140. 单例模式模式是什么？</a></li>
<li><a href="#141-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">141. 策略模式是什么？</a></li>
<li><a href="#142-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">142. 代理模式是什么？</a></li>
<li><a href="#143-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">143. 中介者模式是什么？</a></li>
<li><a href="#144-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">144. 适配器模式是什么？</a></li>
<li><a href="#145-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C">145. 观察者模式和发布订阅模式有什么不同？</a></li>
<li><a href="#146-vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88">146. Vue 的生命周期是什么？</a></li>
<li><a href="#147-vue-%E7%9A%84%E5%90%84%E4%B8%AA%E7%94%9F%E5%91%BD%E9%98%B6%E6%AE%B5%E6%98%AF%E4%BB%80%E4%B9%88">147. Vue 的各个生命阶段是什么？</a></li>
<li><a href="#148-vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F">148. Vue 组件间的参数传递方式？</a></li>
<li><a href="#149-computed-%E5%92%8C-watch-%E7%9A%84%E5%B7%AE%E5%BC%82">149. computed 和 watch 的差异？</a></li>
<li><a href="#150-vue-router-%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0">150. vue-router 中的导航钩子函数</a></li>
<li><a href="#151-route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB">151. $route 和 $router 的区别？</a></li>
<li><a href="#152-vue-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6">152. vue 常用的修饰符？</a></li>
<li><a href="#153-vue%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8">153. vue 中 key 值的作用？</a></li>
<li><a href="#154-computed-%E5%92%8C-watch-%E5%8C%BA%E5%88%AB">154. computed 和 watch 区别？</a></li>
<li><a href="#155-keep-alive-%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">155. keep-alive 组件有什么作用？</a></li>
<li><a href="#156-vue-%E4%B8%AD-mixin-%E5%92%8C-mixins-%E5%8C%BA%E5%88%AB">156. vue 中 mixin 和 mixins 区别？</a></li>
<li><a href="#157-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D-content-type-">157. 开发中常用的几种 Content-Type ？</a></li>
<li><a href="#158-%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA-javascript-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0">158. 如何封装一个 javascript 的类型判断函数？</a></li>
<li><a href="#159-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1">159. 如何判断一个对象是否为空对象？</a></li>
<li><a href="#160-%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0-1234">160. 使用闭包实现每隔一秒打印 1,2,3,4</a></li>
<li><a href="#161-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-jsonp">161. 手写一个 jsonp</a></li>
<li><a href="#162-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">162. 手写一个观察者模式？</a></li>
<li><a href="#163-eventemitter-%E5%AE%9E%E7%8E%B0">163. EventEmitter 实现</a></li>
<li><a href="#164-%E4%B8%80%E9%81%93%E5%B8%B8%E8%A2%AB%E4%BA%BA%E8%BD%BB%E8%A7%86%E7%9A%84%E5%89%8D%E7%AB%AFjs%E9%9D%A2%E8%AF%95%E9%A2%98">164. 一道常被人轻视的前端 JS 面试题</a></li>
<li><a href="#165-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%97%B6%E9%97%B4%E4%BB%80%E4%B9%88%E6%98%AF-performance-api">165. 如何确定页面的可用性时间，什么是 Performance API？</a></li>
<li><a href="#166-js-%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">166. js 中的命名规则</a></li>
<li><a href="#167-js-%E8%AF%AD%E5%8F%A5%E6%9C%AB%E5%B0%BE%E5%88%86%E5%8F%B7%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5">167. js 语句末尾分号是否可以省略？</a></li>
<li><a href="#168-objectassign">168. Object.assign()</a></li>
<li><a href="#169-mathceil-%E5%92%8C-mathfloor">169. Math.ceil 和 Math.floor</a></li>
<li><a href="#170-js-for-%E5%BE%AA%E7%8E%AF%E6%B3%A8%E6%84%8F%E7%82%B9">170. js for 循环注意点</a></li>
<li><a href="#171-%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E5%81%87%E8%AE%BE%E6%9C%89100000%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%BF%99%E4%B8%AA%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E">171. 一个列表，假设有 100000 个数据，这个该怎么办？</a></li>
<li><a href="#172-js-%E4%B8%AD%E5%80%92%E8%AE%A1%E6%97%B6%E7%9A%84%E7%BA%A0%E5%81%8F%E5%AE%9E%E7%8E%B0">172. js 中倒计时的纠偏实现？</a></li>
<li><a href="#173-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F">173. 进程间通信的方式？</a></li>
<li><a href="#174-%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%B8%80%E7%AF%87%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%95%E8%AF%8D">174. 如何查找一篇英文文章中出现频率最高的单词？</a></li>
<li><a href="#175-elegetelementsbyclassname%E5%92%8Celequeryselectorall%E7%9A%84%E5%8C%BA%E5%88%AB">175. ele.getElementsByClassName和ele.querySelectorAll的区别？</a></li>
</ul>
<h4 id="1-介绍-js-的基本数据类型。"><a href="#1-介绍-js-的基本数据类型。" class="headerlink" title="1. 介绍 js 的基本数据类型。"></a>1. 介绍 js 的基本数据类型。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js 一共有五种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。</span><br><span class="line">Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。</span><br><span class="line">BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</span><br></pre></td></tr></table></figure>

<h4 id="2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h4><p>涉及知识点：</p>
<ul>
<li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li>
<li>堆：引用数据类型（对象、数组和函数）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两种类型的区别是：存储位置不同。</span><br><span class="line">原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class="line"></span><br><span class="line">引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在</span><br><span class="line">栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实</span><br><span class="line">体。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。</span><br><span class="line"></span><br><span class="line">基本数据类型....（参考1）</span><br><span class="line"></span><br><span class="line">复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。</span><br><span class="line"></span><br><span class="line">两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中</span><br><span class="line">保存对应的指针来获取堆中的值。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/lxcao/article/details/52749421">《JavaScript 有几种类型的值？》</a><br><a href="https://blog.csdn.net/jiangjuanjaun/article/details/80327342">《JavaScript 有几种类型的值？能否画一下它们的内存图；》</a></p>
<h4 id="3-什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#3-什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="3. 什么是堆？什么是栈？它们之间有什么区别和联系？"></a>3. 什么是堆？什么是栈？它们之间有什么区别和联系？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">堆和栈的概念存在于数据结构中和操作系统内存中。</span><br><span class="line"></span><br><span class="line">在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全</span><br><span class="line">二叉树是堆的一种实现方式。</span><br><span class="line"></span><br><span class="line">在操作系统中，内存被分为栈区和堆区。</span><br><span class="line"></span><br><span class="line">栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</span><br><span class="line"></span><br><span class="line">堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19729973">《什么是堆？什么是栈？他们之间有什么区别和联系？》</a></p>
<h4 id="4-内部属性-Class-是什么？"><a href="#4-内部属性-Class-是什么？" class="headerlink" title="4. 内部属性 [[Class]] 是什么？"></a>4. 内部属性 [[Class]] 是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所有 typeof 返回值为 &quot;object&quot; 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非</span><br><span class="line">传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如：</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call( [1,2,3] );</span><br><span class="line">// &quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call( /regex-literal/i );</span><br><span class="line">// &quot;[object RegExp]&quot;</span><br><span class="line"></span><br><span class="line">// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签</span><br><span class="line">// 默认情况类的[[Class]]返回[object Object]</span><br><span class="line">class Class1 &#123;&#125;</span><br><span class="line">Object.prototype.toString.call(new Class1()); // &quot;[object Object]&quot;</span><br><span class="line">// 需要定制[[Class]]</span><br><span class="line">class Class2 &#123;</span><br><span class="line">  get [Symbol.toStringTag]() &#123;</span><br><span class="line">    return &quot;Class2&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.prototype.toString.call(new Class2()); // &quot;[object Class2]&quot;</span><br></pre></td></tr></table></figure>

<h4 id="5-介绍-js-有哪些内置对象？"><a href="#5-介绍-js-有哪些内置对象？" class="headerlink" title="5. 介绍 js 有哪些内置对象？"></a>5. 介绍 js 有哪些内置对象？</h4><p>涉及知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在</span><br><span class="line">全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</span><br><span class="line"></span><br><span class="line">标准内置对象的分类</span><br><span class="line"></span><br><span class="line">（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</span><br><span class="line"></span><br><span class="line">例如 Infinity、NaN、undefined、null 字面量</span><br><span class="line"></span><br><span class="line">（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</span><br><span class="line"></span><br><span class="line">例如 eval()、parseFloat()、parseInt() 等</span><br><span class="line"></span><br><span class="line">（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</span><br><span class="line"></span><br><span class="line">例如 Object、Function、Boolean、Symbol、Error 等</span><br><span class="line"></span><br><span class="line">（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</span><br><span class="line"></span><br><span class="line">例如 Number、Math、Date</span><br><span class="line"></span><br><span class="line">（5）字符串，用来表示和操作字符串的对象。</span><br><span class="line"></span><br><span class="line">例如 String、RegExp</span><br><span class="line"></span><br><span class="line">（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</span><br><span class="line"></span><br><span class="line">（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</span><br><span class="line"></span><br><span class="line">例如 Map、Set、WeakMap、WeakSet</span><br><span class="line"></span><br><span class="line">（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。</span><br><span class="line"></span><br><span class="line">例如 SIMD 等</span><br><span class="line"></span><br><span class="line">（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</span><br><span class="line"></span><br><span class="line">例如 JSON 等</span><br><span class="line"></span><br><span class="line">（10）控制抽象对象</span><br><span class="line"></span><br><span class="line">例如 Promise、Generator 等</span><br><span class="line"></span><br><span class="line">（11）反射</span><br><span class="line"></span><br><span class="line">例如 Reflect、Proxy</span><br><span class="line"></span><br><span class="line">（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。</span><br><span class="line"></span><br><span class="line">例如 Intl、Intl.Collator 等</span><br><span class="line"></span><br><span class="line">（13）WebAssembly</span><br><span class="line"></span><br><span class="line">（14）其他</span><br><span class="line"></span><br><span class="line">例如 arguments</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函</span><br><span class="line">数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构</span><br><span class="line">造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">《标准内置对象的分类》</a><br><a href="https://segmentfault.com/a/1190000011467723#articleHeader24">《JS 所有内置对象属性和方法汇总》</a></p>
<h4 id="6-undefined-与-undeclared-的区别？"><a href="#6-undefined-与-undeclared-的区别？" class="headerlink" title="6. undefined 与 undeclared 的区别？"></a>6. undefined 与 undeclared 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。</span><br><span class="line"></span><br><span class="line">对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ</span><br><span class="line">eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 &quot;undefined&quot;。</span><br></pre></td></tr></table></figure>

<h4 id="7-null-和-undefined-的区别？"><a href="#7-null-和-undefined-的区别？" class="headerlink" title="7. null 和 undefined 的区别？"></a>7. null 和 undefined 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</span><br><span class="line"></span><br><span class="line">undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null</span><br><span class="line">主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class="line"></span><br><span class="line">undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它</span><br><span class="line">会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</span><br><span class="line"></span><br><span class="line">当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等</span><br><span class="line">号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bundefined%E4%B8%8Enull.html">《JavaScript 深入理解之 undefined 与 null》</a></p>
<h4 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。</span><br><span class="line"></span><br><span class="line">表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。</span><br><span class="line"></span><br><span class="line">按惯例我们用 void 0 来获得 undefined。</span><br></pre></td></tr></table></figure>

<h4 id="9-说几条写-JavaScript-的基本规范？"><a href="#9-说几条写-JavaScript-的基本规范？" class="headerlink" title="9. 说几条写 JavaScript 的基本规范？"></a>9. 说几条写 JavaScript 的基本规范？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在平常项目开发中，我们遵守一些这样的基本规范，比如说：</span><br><span class="line"></span><br><span class="line">（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时</span><br><span class="line">    如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。</span><br><span class="line"></span><br><span class="line">（2）代码中出现地址、时间等字符串时需要使用常量代替。</span><br><span class="line"></span><br><span class="line">（3）在进行比较的时候吧，尽量使用&#x27;===&#x27;, &#x27;!==&#x27;代替&#x27;==&#x27;, &#x27;!=&#x27;。</span><br><span class="line"></span><br><span class="line">（4）不要在内置对象的原型上添加方法，如 Array, Date。</span><br><span class="line"></span><br><span class="line">（5）switch 语句必须带有 default 分支。</span><br><span class="line"></span><br><span class="line">（6）for 循环必须使用大括号。</span><br><span class="line"></span><br><span class="line">（7）if 语句必须使用大括号。</span><br></pre></td></tr></table></figure>

<h4 id="10-JavaScript-原型，原型链？-有什么特点？"><a href="#10-JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="10. JavaScript 原型，原型链？ 有什么特点？"></a>10. JavaScript 原型，原型链？ 有什么特点？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对</span><br><span class="line">象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部</span><br><span class="line">将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们</span><br><span class="line">是不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来让我们访问这个属性，但是我们最好不要使用这</span><br><span class="line">个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对</span><br><span class="line">象的原型。</span><br><span class="line"></span><br><span class="line">当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又</span><br><span class="line">会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就</span><br><span class="line">是我们新建的对象为什么能够使用 toString() 等方法的原因。</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line">JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与</span><br><span class="line">之相关的对象也会继承这一改变。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html">《JavaScript 深入理解之原型与原型链》</a></p>
<h4 id="11-js-获取原型的方法？"><a href="#11-js-获取原型的方法？" class="headerlink" title="11. js 获取原型的方法？"></a>11. js 获取原型的方法？</h4><ul>
<li>p.__proto__</li>
<li>p.constructor.prototype</li>
<li>Object.getPrototypeOf(p)</li>
</ul>
<h4 id="12-在-js-中不同进制数字的表示方式"><a href="#12-在-js-中不同进制数字的表示方式" class="headerlink" title="12. 在 js 中不同进制数字的表示方式"></a>12. 在 js 中不同进制数字的表示方式</h4><ul>
<li><p>以 0X、0x 开头的表示为十六进制。</p>
</li>
<li><p>以 0、0O、0o 开头的表示为八进制。</p>
</li>
<li><p>以 0B、0b 开头的表示为二进制格式。</p>
</li>
</ul>
<h4 id="13-js-中整数的安全范围是多少？"><a href="#13-js-中整数的安全范围是多少？" class="headerlink" title="13. js 中整数的安全范围是多少？"></a>13. js 中整数的安全范围是多少？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1，</span><br><span class="line">即9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中</span><br><span class="line">被定义为 Number.MIN_SAFE_INTEGER。</span><br><span class="line"></span><br><span class="line">如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次</span><br><span class="line">计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数</span><br><span class="line">来判断。</span><br></pre></td></tr></table></figure>

<h4 id="14-typeof-NaN-的结果是什么？"><a href="#14-typeof-NaN-的结果是什么？" class="headerlink" title="14. typeof NaN 的结果是什么？"></a>14. typeof NaN 的结果是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出</span><br><span class="line">数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</span><br><span class="line"></span><br><span class="line">typeof NaN; // &quot;number&quot;</span><br><span class="line"></span><br><span class="line">NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN</span><br><span class="line">为 true。</span><br></pre></td></tr></table></figure>

<h4 id="15-isNaN-和-Number-isNaN-函数的区别？"><a href="#15-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="15. isNaN 和 Number.isNaN 函数的区别？"></a>15. isNaN 和 Number.isNaN 函数的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会</span><br><span class="line">返回 true ，会影响 NaN 的判断。</span><br><span class="line"></span><br><span class="line">函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为</span><br><span class="line">准确。</span><br></pre></td></tr></table></figure>

<h4 id="16-Array-构造函数只有一个参数值时的表现？"><a href="#16-Array-构造函数只有一个参数值时的表现？" class="headerlink" title="16. Array 构造函数只有一个参数值时的表现？"></a>16. Array 构造函数只有一个参数值时的表现？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样</span><br><span class="line">创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。</span><br><span class="line"></span><br><span class="line">构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。</span><br></pre></td></tr></table></figure>

<h4 id="17-其他值到字符串的转换规则？"><a href="#17-其他值到字符串的转换规则？" class="headerlink" title="17. 其他值到字符串的转换规则？"></a>17. 其他值到字符串的转换规则？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">规范的 9.8 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。</span><br><span class="line"></span><br><span class="line">（1）Null 和 Undefined 类型 ，null 转换为 &quot;null&quot;，undefined 转换为 &quot;undefined&quot;，</span><br><span class="line"></span><br><span class="line">（2）Boolean 类型，true 转换为 &quot;true&quot;，false 转换为 &quot;false&quot;。</span><br><span class="line"></span><br><span class="line">（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</span><br><span class="line"></span><br><span class="line">（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</span><br><span class="line"></span><br><span class="line">（5）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）</span><br><span class="line">    来返回内部属性 [[Class]] 的值，如&quot;[object Object]&quot;。如果对象有自己的 toString() 方法，字符串化时就会</span><br><span class="line">    调用该方法并使用其返回值。</span><br></pre></td></tr></table></figure>

<h4 id="18-其他值到数字值的转换规则？"><a href="#18-其他值到数字值的转换规则？" class="headerlink" title="18. 其他值到数字值的转换规则？"></a>18. 其他值到数字值的转换规则？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber。</span><br><span class="line"></span><br><span class="line">（1）Undefined 类型的值转换为 NaN。</span><br><span class="line"></span><br><span class="line">（2）Null 类型的值转换为 0。</span><br><span class="line"></span><br><span class="line">（3）Boolean 类型的值，true 转换为 1，false 转换为 0。</span><br><span class="line"></span><br><span class="line">（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</span><br><span class="line"></span><br><span class="line">（5）Symbol 类型的值不能转换为数字，会报错。</span><br><span class="line"></span><br><span class="line">（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</span><br><span class="line"></span><br><span class="line">为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</span><br><span class="line"></span><br><span class="line">如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</span><br></pre></td></tr></table></figure>

<h4 id="19-其他值到布尔类型的值的转换规则？"><a href="#19-其他值到布尔类型的值的转换规则？" class="headerlink" title="19. 其他值到布尔类型的值的转换规则？"></a>19. 其他值到布尔类型的值的转换规则？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。</span><br><span class="line"></span><br><span class="line">以下这些是假值：</span><br><span class="line">• undefined</span><br><span class="line">• null</span><br><span class="line">• false</span><br><span class="line">• +0、-0 和 NaN</span><br><span class="line">• &quot;&quot;</span><br><span class="line"></span><br><span class="line">假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</span><br></pre></td></tr></table></figure>

<h4 id="20-和-的-valueOf-和-toString-的结果是什么？"><a href="#20-和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="20. {} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="21-什么是假值对象？"><a href="#21-什么是假值对象？" class="headerlink" title="21. 什么是假值对象？"></a>21. 什么是假值对象？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和</span><br><span class="line">普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它</span><br><span class="line">是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。</span><br></pre></td></tr></table></figure>

<h4 id="22-操作符的作用？"><a href="#22-操作符的作用？" class="headerlink" title="22. ~ 操作符的作用？"></a>22. ~ 操作符的作用？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。</span><br><span class="line"></span><br><span class="line">~x 大致等同于 -(x+1)。</span><br></pre></td></tr></table></figure>

<h4 id="23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"><a href="#23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？" class="headerlink" title="23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"></a>23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Nu</span><br><span class="line">mber ()）不允许出现非数字字符，否则会失败并返回 NaN。</span><br></pre></td></tr></table></figure>

<h4 id="24-操作符什么时候用于字符串的拼接？"><a href="#24-操作符什么时候用于字符串的拼接？" class="headerlink" title="24. + 操作符什么时候用于字符串的拼接？"></a>24. <code>+</code> 操作符什么时候用于字符串的拼接？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其</span><br><span class="line">中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以</span><br><span class="line">数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</span><br><span class="line"></span><br><span class="line">简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字</span><br><span class="line">加法。</span><br><span class="line"></span><br><span class="line">那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</span><br></pre></td></tr></table></figure>

<h4 id="25-什么情况下会发生布尔值的隐式强制类型转换？"><a href="#25-什么情况下会发生布尔值的隐式强制类型转换？" class="headerlink" title="25. 什么情况下会发生布尔值的隐式强制类型转换？"></a>25. 什么情况下会发生布尔值的隐式强制类型转换？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1） if (..) 语句中的条件判断表达式。</span><br><span class="line">（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</span><br><span class="line">（3） while (..) 和 do..while(..) 循环中的条件判断表达式。</span><br><span class="line">（4） ? : 中的条件判断表达式。</span><br><span class="line">（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</span><br></pre></td></tr></table></figure>

<h4 id="26-和-amp-amp-操作符的返回值？"><a href="#26-和-amp-amp-操作符的返回值？" class="headerlink" title="26. || 和 &amp;&amp; 操作符的返回值？"></a>26. || 和 &amp;&amp; 操作符的返回值？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件</span><br><span class="line">判断。</span><br><span class="line"></span><br><span class="line">对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</span><br><span class="line"></span><br><span class="line">&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</span><br><span class="line"></span><br><span class="line">|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</span><br></pre></td></tr></table></figure>

<h4 id="27-Symbol-值的强制类型转换？"><a href="#27-Symbol-值的强制类型转换？" class="headerlink" title="27. Symbol 值的强制类型转换？"></a>27. Symbol 值的强制类型转换？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。</span><br><span class="line"></span><br><span class="line">Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果</span><br><span class="line">都是 true ）。</span><br></pre></td></tr></table></figure>

<h4 id="28-操作符的强制类型转换规则？"><a href="#28-操作符的强制类型转换规则？" class="headerlink" title="28. == 操作符的强制类型转换规则？"></a>28. == 操作符的强制类型转换规则？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。</span><br><span class="line"></span><br><span class="line">（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。</span><br><span class="line"></span><br><span class="line">（3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。</span><br><span class="line"></span><br><span class="line">（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。</span><br><span class="line"></span><br><span class="line">（5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。</span><br><span class="line"></span><br><span class="line">（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.jeffjade.com/2015/08/28/2015-09-02-js-string-compare/">《JavaScript 字符串间的比较》</a></p>
<h4 id="29-如何将字符串转化为数字，例如-‘12-3b’"><a href="#29-如何将字符串转化为数字，例如-‘12-3b’" class="headerlink" title="29. 如何将字符串转化为数字，例如 ‘12.3b’?"></a>29. 如何将字符串转化为数字，例如 ‘12.3b’?</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。</span><br><span class="line"></span><br><span class="line">（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</span><br><span class="line"></span><br><span class="line">（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。</span><br><span class="line"></span><br><span class="line">（4）使用 + 操作符的隐式转换，前提是所包含的字符串不包含不合法字符。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/m0_38099607/article/details/72638678">《详解 JS 中 Number()、parseInt() 和 parseFloat() 的区别》</a></p>
<h4 id="30-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』"><a href="#30-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』" class="headerlink" title="30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?"></a>30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> number &amp;&amp; number.<span class="title function_">replace</span>(<span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">format1</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Intl</span>.<span class="title class_">NumberFormat</span>().<span class="title function_">format</span>(number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">format2</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> number.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;en&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="31-常用正则表达式"><a href="#31-常用正则表达式" class="headerlink" title="31. 常用正则表达式"></a>31. 常用正则表达式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）匹配 qq 号</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）手机号码正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）用户名正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://caibaojian.com/form-regexp.html">《前端表单验证常用的 15 个 JS 正则表达式》</a><br><a href="https://www.jianshu.com/p/1cb5229325a7">《JS 常用正则汇总》</a></p>
<h4 id="32-生成随机数的各种方法？"><a href="#32-生成随机数的各种方法？" class="headerlink" title="32. 生成随机数的各种方法？"></a>32. 生成随机数的各种方法？</h4><p><a href="http://www.hangge.com/blog/cache/detail_1872.html">《JS - 生成随机数的方法汇总（不同范围、类型的随机数）》</a></p>
<h4 id="33-如何实现数组的随机排序？"><a href="#33-如何实现数组的随机排序？" class="headerlink" title="33. 如何实现数组的随机排序？"></a>33. 如何实现数组的随机排序？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomSort</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）随机从原数组抽取一个元素，加入到新数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (arr.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * arr.<span class="property">length</span>);</span><br><span class="line">    result.<span class="title function_">push</span>(arr[randomIndex]);</span><br><span class="line">    arr.<span class="title function_">splice</span>(randomIndex, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）随机交换数组内的元素（洗牌算法类似）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index,</span><br><span class="line">    randomIndex,</span><br><span class="line">    temp,</span><br><span class="line">    len = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">    randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (len - index)) + index;</span><br><span class="line"></span><br><span class="line">    temp = arr[index];</span><br><span class="line">    arr[index] = arr[randomIndex];</span><br><span class="line">    arr[randomIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length - <span class="number">1</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (length - index)) + index;</span><br><span class="line"></span><br><span class="line">    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/#top">《Fisher and Yates 的原始版》</a><br><a href="https://www.zhihu.com/question/32303195">《javascript 实现数组随机排序?》</a><br><a href="https://www.w3cplus.com/javascript/how-to-randomize-shuffle-a-javascript-array.html">《JavaScript 学习笔记：数组随机排序》</a></p>
<h4 id="34-javascript-创建对象的几种方式？"><a href="#34-javascript-创建对象的几种方式？" class="headerlink" title="34. javascript 创建对象的几种方式？"></a>34. javascript 创建对象的几种方式？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js</span><br><span class="line">和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象</span><br><span class="line">创建方式，我了解到的方式有这么几种：</span><br><span class="line"></span><br><span class="line">（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</span><br><span class="line"></span><br><span class="line">（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</span><br><span class="line"></span><br><span class="line">（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</span><br><span class="line"></span><br><span class="line">（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</span><br><span class="line"></span><br><span class="line">（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</span><br><span class="line"></span><br><span class="line">（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</span><br><span class="line"></span><br><span class="line">嗯我目前了解到的就是这么几种方式。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html">《JavaScript 深入理解之对象创建》</a></p>
<h4 id="35-JavaScript-继承的几种实现方式？"><a href="#35-JavaScript-继承的几种实现方式？" class="headerlink" title="35. JavaScript 继承的几种实现方式？"></a>35. JavaScript 继承的几种实现方式？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我了解的 js 中实现继承的几种方式有：</span><br><span class="line"></span><br><span class="line">（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</span><br><span class="line"></span><br><span class="line">（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</span><br><span class="line"></span><br><span class="line">（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</span><br><span class="line"></span><br><span class="line">（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</span><br><span class="line"></span><br><span class="line">（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E7%BB%A7%E6%89%BF.html">《JavaScript 深入理解之继承》</a></p>
<h4 id="36-寄生式组合继承的实现？"><a href="#36-寄生式组合继承的实现？" class="headerlink" title="36. 寄生式组合继承的实现？"></a>36. 寄生式组合继承的实现？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, grade</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">grade</span> = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayMyGrade</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My grade is &quot;</span> + <span class="variable language_">this</span>.<span class="property">grade</span> + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="37-Javascript-的作用域链？"><a href="#37-Javascript-的作用域链？" class="headerlink" title="37. Javascript 的作用域链？"></a>37. Javascript 的作用域链？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和</span><br><span class="line">函数。</span><br><span class="line"></span><br><span class="line">作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前</span><br><span class="line">端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</span><br><span class="line"></span><br><span class="line">当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</span><br><span class="line"></span><br><span class="line">作用域链的创建过程跟执行上下文的建立有关....</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html">《JavaScript 深入理解之作用域链》</a></p>
<h4 id="38-谈谈-This-对象的理解。"><a href="#38-谈谈-This-对象的理解。" class="headerlink" title="38. 谈谈 This 对象的理解。"></a>38. 谈谈 This 对象的理解。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模</span><br><span class="line">式来判断。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</p>
</li>
<li><p>2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</p>
</li>
<li><p>3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</p>
</li>
<li><p>4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后</span><br><span class="line">是函数调用模式。</span><br></pre></td></tr></table></figure>

<p><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bthis%E8%AF%A6%E8%A7%A3.html">《JavaScript 深入理解之 this 详解》</a></p>
<h4 id="39-eval-是做什么的？"><a href="#39-eval-是做什么的？" class="headerlink" title="39. eval 是做什么的？"></a>39. eval 是做什么的？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">它的功能是把对应的字符串解析成 JS 代码并运行。</span><br><span class="line"></span><br><span class="line">应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval">《eval()》</a></p>
<h4 id="40-什么是-DOM-和-BOM？"><a href="#40-什么是-DOM-和-BOM？" class="headerlink" title="40. 什么是 DOM 和 BOM？"></a>40. 什么是 DOM 和 BOM？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</span><br><span class="line"></span><br><span class="line">BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM</span><br><span class="line">的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）</span><br><span class="line">对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati</span><br><span class="line">on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对</span><br><span class="line">象的子对象。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/33453164">《DOM, DOCUMENT, BOM, WINDOW 有什么区别?》</a><br><a href="http://www.w3school.com.cn/jsref/dom_obj_window.asp">《Window 对象》</a><br><a href="https://www.zhihu.com/question/20724662">《DOM 与 BOM 分别是什么，有何关联？》</a><br><a href="https://segmentfault.com/a/1190000000654274#articleHeader21">《JavaScript 学习总结（三）BOM 和 DOM 详解》</a></p>
<h4 id="41-写一个通用的事件侦听器函数。"><a href="#41-写一个通用的事件侦听器函数。" class="headerlink" title="41. 写一个通用的事件侦听器函数。"></a>41. 写一个通用的事件侦听器函数。</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventUtils</span> = &#123;</span><br><span class="line">  <span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></span><br><span class="line">  <span class="comment">// 添加事件</span></span><br><span class="line">  <span class="attr">addEvent</span>: <span class="keyword">function</span>(<span class="params">element, type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">      element.<span class="title function_">addEventListener</span>(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">      element.<span class="title function_">attachEvent</span>(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除事件</span></span><br><span class="line">  <span class="attr">removeEvent</span>: <span class="keyword">function</span>(<span class="params">element, type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">removeEventListener</span>) &#123;</span><br><span class="line">      element.<span class="title function_">removeEventListener</span>(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">detachEvent</span>) &#123;</span><br><span class="line">      element.<span class="title function_">detachEvent</span>(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取事件目标</span></span><br><span class="line">  <span class="attr">getTarget</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> event.<span class="property">target</span> || event.<span class="property">srcElement</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span></span><br><span class="line">  <span class="attr">getEvent</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> event || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span></span><br><span class="line">  <span class="attr">stopPropagation</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">stopPropagation</span>) &#123;</span><br><span class="line">      event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.<span class="property">cancelBubble</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消事件的默认行为</span></span><br><span class="line">  <span class="attr">preventDefault</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">preventDefault</span>) &#123;</span><br><span class="line">      event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.<span class="property">returnValue</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader6">《JS 事件模型》</a></p>
<h4 id="42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h4><ul>
<li><p>1.事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p>
</li>
<li><p>2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。</p>
</li>
<li><p>3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true;</p>
</li>
</ul>
<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/lvdabao/p/3265870.html">《Javascript 事件模型系列（一）事件及事件的三种模型》</a><br><a href="https://blog.csdn.net/wuseyukui/article/details/13771493">《Javascript 事件模型：事件捕获和事件冒泡》</a></p>
<h4 id="43-三种事件模型是什么？"><a href="#43-三种事件模型是什么？" class="headerlink" title="43. 三种事件模型是什么？"></a>43. 三种事件模型是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</span><br><span class="line"></span><br><span class="line">第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实</span><br><span class="line">现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</span><br><span class="line"></span><br><span class="line">第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</span><br><span class="line"></span><br><span class="line">第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/u013217071/article/details/77613706">《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》</a></p>
<h4 id="44-事件委托是什么？"><a href="#44-事件委托是什么？" class="headerlink" title="44. 事件委托是什么？"></a>44. 事件委托是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到</span><br><span class="line">目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</span><br><span class="line"></span><br><span class="line">使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/26536815">《JavaScript 事件委托详解》</a></p>
<h4 id="45-“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#45-“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="45. [“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>45. [“1”, “2”, “3”].map(parseInt) 答案是多少？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 &quot;1-0&quot;, &quot;2-1&quot;, &quot;3-2&quot;</span><br><span class="line"></span><br><span class="line">因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/justjavac/article/details/19473199">《为什么 [“1”, “2”, “3”].map(parseInt) 返回 [1,NaN,NaN]？》</a></p>
<h4 id="46-什么是闭包，为什么要用它？"><a href="#46-什么是闭包，为什么要用它？" class="headerlink" title="46. 什么是闭包，为什么要用它？"></a>46. 什么是闭包，为什么要用它？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以</span><br><span class="line">访问到当前函数的局部变量。</span><br><span class="line"></span><br><span class="line">闭包有两个常用的用途。</span><br><span class="line"></span><br><span class="line">闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外</span><br><span class="line">部访问到函数内部的变量，可以使用这种方法来创建私有变量。</span><br><span class="line"></span><br><span class="line">函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以</span><br><span class="line">这个变量对象不会被回收。</span><br><span class="line"></span><br><span class="line">其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E9%97%AD%E5%8C%85.html">《JavaScript 深入理解之闭包》</a></p>
<h4 id="47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？"><a href="#47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？"></a>47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。</span><br><span class="line"></span><br><span class="line">设立&quot;严格模式&quot;的目的，主要有以下几个：</span><br></pre></td></tr></table></figure>

<ul>
<li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的 Javascript 做好铺垫。</li>
</ul>
<p>区别：</p>
<ul>
<li>1.禁止使用 with 语句。</li>
<li>2.禁止 this 关键字指向全局对象。</li>
<li>3.对象不能有重名的属性。</li>
</ul>
<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使</span><br><span class="line">用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一</span><br><span class="line">些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。</span><br><span class="line">我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html">《Javascript 严格模式详解》</a></p>
<h4 id="48-如何判断一个对象是否属于某个类？"><a href="#48-如何判断一个对象是否属于某个类？" class="headerlink" title="48. 如何判断一个对象是否属于某个类？"></a>48. 如何判断一个对象是否属于某个类？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</span><br><span class="line"></span><br><span class="line">第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</span><br><span class="line"></span><br><span class="line">第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的</span><br><span class="line">[[Class]] 属性来进行判断。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/haitunmin/article/details/78418522">《js 判断一个对象是否属于某一类》</a></p>
<h4 id="49-instanceof-的作用？"><a href="#49-instanceof-的作用？" class="headerlink" title="49. instanceof 的作用？"></a>49. instanceof 的作用？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</span></span><br><span class="line"><span class="comment">// 实现：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left), <span class="comment">// 获取对象的原型</span></span><br><span class="line">    prototype = right.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">《instanceof》</a></p>
<h4 id="50-new-操作符具体干了什么呢？如何实现？"><a href="#50-new-操作符具体干了什么呢？如何实现？" class="headerlink" title="50. new 操作符具体干了什么呢？如何实现？"></a>50. new 操作符具体干了什么呢？如何实现？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （1）首先创建了一个新的空对象</span></span><br><span class="line"><span class="comment">// （2）设置原型，将对象的原型设置为函数的 prototype 对象。</span></span><br><span class="line"><span class="comment">// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</span></span><br><span class="line"><span class="comment">// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>,</span><br><span class="line">    constructor = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数判断</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> constructor !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = constructor.<span class="title function_">apply</span>(newObject, <span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag =</span><br><span class="line">    result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="comment">// objectFactory(构造函数, 初始化参数);</span></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000008576048">《new 操作符具体干了什么？》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/13">《JavaScript 深入之 new 的模拟实现》</a></p>
<h4 id="51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hasOwnProperty</span><br><span class="line"></span><br><span class="line">所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和</span><br><span class="line">in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">《Object.prototype.hasOwnProperty()》</a></p>
<h4 id="52-对于-JSON-的了解？"><a href="#52-对于-JSON-的了解？" class="headerlink" title="52. 对于 JSON 的了解？"></a>52. 对于 JSON 的了解？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON 是一种数据交换格式，基于文本，优于轻量，用于交换数据。</span><br><span class="line"></span><br><span class="line">JSON 可以表示数字、布尔值、字符串、null、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与</span><br><span class="line">值的映射）。</span><br><span class="line"></span><br><span class="line">JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</span><br><span class="line"></span><br><span class="line">在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</span><br><span class="line"></span><br><span class="line">因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</span><br><span class="line"></span><br><span class="line">在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。</span><br><span class="line"></span><br><span class="line">另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://my.oschina.net/u/3284240/blog/874368">《深入了解 JavaScript 中的 JSON 》</a></p>
<h4 id="53-forEach-call-quot-quot-function-a-a-style-outline-quot-1px-solid-quot-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？"><a href="#53-forEach-call-quot-quot-function-a-a-style-outline-quot-1px-solid-quot-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？" class="headerlink" title="53. [].forEach.call($$(&quot;*&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？"></a>53. <code>[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)</code> 能解释一下这段代码的意思吗？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。</span><br><span class="line"></span><br><span class="line">（2）循环遍历 DOM 元素</span><br><span class="line"></span><br><span class="line">（3）给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。</span><br><span class="line"></span><br><span class="line">（4）生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://2008winstar.iteye.com/blog/2128290">《通过一行代码学 JavaScript》</a></p>
<h4 id="54-js-延迟加载的方式有哪些？"><a href="#54-js-延迟加载的方式有哪些？" class="headerlink" title="54. js 延迟加载的方式有哪些？"></a>54. js 延迟加载的方式有哪些？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</span><br></pre></td></tr></table></figure>

<p>一般有以下几种方式：</p>
<ul>
<li>defer 属性</li>
<li>async 属性</li>
<li>动态创建 DOM 方式</li>
<li>使用 setTimeout 延迟方法</li>
<li>让 JS 最后加载</li>
</ul>
<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</span><br><span class="line"></span><br><span class="line">我了解到的几种方式是：</span><br><span class="line"></span><br><span class="line">第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br><span class="line"></span><br><span class="line">第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class="line"></span><br><span class="line">第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class="line"></span><br><span class="line">第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/meijory/article/details/76389762">《JS 延迟加载的几种方式》</a><br><a href="http://www.w3school.com.cn/html5/att_script_async.asp">《HTML 5 <code>&lt;script&gt;</code> <code>async</code> 属性》</a></p>
<h4 id="55-Ajax-是什么-如何创建一个-Ajax？"><a href="#55-Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="55. Ajax 是什么? 如何创建一个 Ajax？"></a>55. Ajax 是什么? 如何创建一个 Ajax？</h4><p>相关知识点：</p>
<p>2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的<br>异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p>
<p>具体来说，AJAX 包括以下几个步骤。</p>
<ul>
<li>1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li>
<li>2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li>
<li>3.设置响应 HTTP 请求状态变化的函数</li>
<li>4.发送 HTTP 请求</li>
<li>5.获取异步调用返回的数据</li>
<li>6.使用 JavaScript 和 DOM 实现局部刷新</li>
</ul>
<p>一般实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">SERVER_URL</span> = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="variable constant_">SERVER_URL</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise 封装实现：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。</span><br><span class="line"></span><br><span class="line">创建一个 ajax 有这样几个步骤</span><br><span class="line"></span><br><span class="line">首先是创建一个 XMLHttpRequest 对象。</span><br><span class="line"></span><br><span class="line">然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</span><br><span class="line"></span><br><span class="line">在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。</span><br><span class="line"></span><br><span class="line">当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://wangdoc.com/javascript/bom/xmlhttprequest.html">《XMLHttpRequest 对象》</a><br><a href="https://juejin.im/post/5acde23c5188255cb32e7e76">《从 ajax 到 fetch、axios》</a><br><a href="https://juejin.im/post/5c160937f265da61180199b2">《Fetch 入门》</a><br><a href="https://segmentfault.com/a/1190000003810652">《传统 Ajax 已死，Fetch 永生》</a></p>
<h4 id="56-谈一谈浏览器的缓存机制？"><a href="#56-谈一谈浏览器的缓存机制？" class="headerlink" title="56. 谈一谈浏览器的缓存机制？"></a>56. 谈一谈浏览器的缓存机制？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。</span><br><span class="line"></span><br><span class="line">web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。</span><br><span class="line"></span><br><span class="line">使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</span><br><span class="line"></span><br><span class="line">服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</span><br><span class="line"></span><br><span class="line">Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，</span><br><span class="line">它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间</span><br><span class="line">的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires</span><br><span class="line">来说，这种方式更加有效一些。常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 n</span><br><span class="line">o-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。</span><br><span class="line"></span><br><span class="line">一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。</span><br><span class="line"></span><br><span class="line">使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。</span><br><span class="line">如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。</span><br><span class="line"></span><br><span class="line">服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，</span><br><span class="line">这样会造成缓存命中的不准确。</span><br><span class="line"></span><br><span class="line">因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</span><br><span class="line"></span><br><span class="line">当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</span><br><span class="line"></span><br><span class="line">强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000012573337">《浅谈浏览器缓存》</a><br><a href="https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-3">《前端优化：浏览器缓存技术介绍》</a><br><a href="https://www.web-tinker.com/article/21221.html">《请求头中的 Cache-Control》</a><br><a href="https://juejin.im/post/5c2d6c9ae51d450cf4195a08">《Cache-Control 字段值详解》</a></p>
<h4 id="57-Ajax-解决浏览器缓存问题？"><a href="#57-Ajax-解决浏览器缓存问题？" class="headerlink" title="57. Ajax 解决浏览器缓存问题？"></a>57. Ajax 解决浏览器缓存问题？</h4><ul>
<li><p>1.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。</p>
</li>
<li><p>2.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。</p>
</li>
<li><p>3.在 URL 后面加上一个随机数： “fresh=” + Math.random();。</p>
</li>
<li><p>4.在 URL 后面加上时间戳：”nowtime=” + new Date().getTime();。</p>
</li>
<li><p>5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。</p>
</li>
</ul>
<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/cwzqianduan/p/8632009.html">《Ajax 中浏览器的缓存问题解决方法》</a><br><a href="https://segmentfault.com/a/1190000012573337">《浅谈浏览器缓存》</a></p>
<h4 id="58-同步和异步的区别？"><a href="#58-同步和异步的区别？" class="headerlink" title="58. 同步和异步的区别？"></a>58. 同步和异步的区别？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。  </span><br><span class="line"></span><br><span class="line">异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 </span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返</span><br><span class="line">回为止再继续向下执行。</span><br><span class="line"></span><br><span class="line">异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等</span><br><span class="line">待消息的返回，当消息返回时系统再通知进程进行处理。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/tennysonsky/article/details/45111623">《同步和异步的区别》</a></p>
<h4 id="59-什么是浏览器的同源政策？"><a href="#59-什么是浏览器的同源政策？" class="headerlink" title="59. 什么是浏览器的同源政策？"></a>59. 什么是浏览器的同源政策？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个</span><br><span class="line">域的协议、域名、端口号必须相同，否则则不属于同一个域。</span><br><span class="line"></span><br><span class="line">同源政策主要限制了三个方面</span><br><span class="line"></span><br><span class="line">第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</span><br><span class="line"></span><br><span class="line">第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</span><br><span class="line"></span><br><span class="line">第三个是当前域下 ajax 无法发送跨域请求。</span><br><span class="line"></span><br><span class="line">同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者</span><br><span class="line">script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</span><br></pre></td></tr></table></figure>

<h4 id="60-如何解决跨域问题？"><a href="#60-如何解决跨域问题？" class="headerlink" title="60. 如何解决跨域问题？"></a>60. 如何解决跨域问题？</h4><p>相关知识点：</p>
<ul>
<li><ol>
<li>通过 jsonp 跨域</li>
</ol>
</li>
<li><ol start="2">
<li>document.domain + iframe 跨域</li>
</ol>
</li>
<li><ol start="3">
<li>location.hash + iframe</li>
</ol>
</li>
<li><ol start="4">
<li>window.name + iframe 跨域</li>
</ol>
</li>
<li><ol start="5">
<li>postMessage 跨域</li>
</ol>
</li>
<li><ol start="6">
<li>跨域资源共享（CORS)</li>
</ol>
</li>
<li><ol start="7">
<li>nginx 代理跨域</li>
</ol>
</li>
<li><ol start="8">
<li>nodejs 中间件代理跨域</li>
</ol>
</li>
<li><ol start="9">
<li>WebSocket 协议跨域</li>
</ol>
</li>
</ul>
<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决跨域的方法我们可以根据我们想要实现的目的来划分。</span><br><span class="line"></span><br><span class="line">首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。</span><br><span class="line"></span><br><span class="line">（1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。</span><br><span class="line"></span><br><span class="line">如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。</span><br><span class="line"></span><br><span class="line">（2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。</span><br><span class="line"></span><br><span class="line">（3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。</span><br><span class="line"></span><br><span class="line">（4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。</span><br><span class="line"></span><br><span class="line">如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。</span><br><span class="line"></span><br><span class="line">（5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。</span><br><span class="line"></span><br><span class="line">（6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是&quot;跨域资源共享&quot;。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。</span><br><span class="line"></span><br><span class="line">非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</span><br><span class="line"></span><br><span class="line">（7）使用 websocket 协议，这个协议没有同源限制。</span><br><span class="line"></span><br><span class="line">（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000011145364">《前端常见跨域解决方案（全）》</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">《浏览器同源政策及其规避方法》</a><br><a href="https://juejin.im/entry/59feae9df265da43094488f6">《跨域，你需要知道的全在这里》</a><br><a href="https://www.zhihu.com/question/31592553">《为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？》</a></p>
<h4 id="61-服务器代理转发时，该如何处理-cookie？"><a href="#61-服务器代理转发时，该如何处理-cookie？" class="headerlink" title="61. 服务器代理转发时，该如何处理 cookie？"></a>61. 服务器代理转发时，该如何处理 cookie？</h4><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/5eab0f83e3b4">《深入浅出 Nginx》</a></p>
<h4 id="62-简单谈一下-cookie-？"><a href="#62-简单谈一下-cookie-？" class="headerlink" title="62. 简单谈一下 cookie ？"></a>62. 简单谈一下 cookie ？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。</span><br><span class="line"></span><br><span class="line">服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了9个属性值 name、value、expires、domain、path、secure、HttpOnly、SameSite、Priority。其中 name 和 value 分别是 cookie 的名字和值。expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。SameSite 属性用来限制第三方 cookie，可以有效防止 CSRF 攻击，从而减少安全风险。Priority 是 chrome 的提案，定义了三种优先级，当 cookie 数量超出时低优先级的 cookie 会被优先清除。</span><br><span class="line"></span><br><span class="line">在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">《HTTP cookies》 </a><br><a href="https://segmentfault.com/a/1190000004556040">《聊一聊 cookie》 </a></p>
<h4 id="63-模块化开发怎么做？"><a href="#63-模块化开发怎么做？" class="headerlink" title="63. 模块化开发怎么做？"></a>63. 模块化开发怎么做？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念</span><br><span class="line">，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</span><br><span class="line"></span><br><span class="line">由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污</span><br><span class="line">染，并且模块间没有联系。</span><br><span class="line"></span><br><span class="line">后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所</span><br><span class="line">有的所有的模块成员，外部代码可以修改内部属性的值。</span><br><span class="line"></span><br><span class="line">现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5ab378c46fb9a028ce7b824f">《浅谈模块化开发》</a><br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">《Javascript 模块化编程（一）：模块的写法》</a><br><a href="https://juejin.im/post/5aaa37c8f265da23945f365c">《前端模块化：CommonJS，AMD，CMD，ES6》</a><br><a href="http://es6.ruanyifeng.com/#docs/module">《Module 的语法》</a></p>
<h4 id="64-js-的几种模块规范？"><a href="#64-js-的几种模块规范？" class="headerlink" title="64. js 的几种模块规范？"></a>64. js 的几种模块规范？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js 中现在比较成熟的有四种模块加载方案。</span><br><span class="line"></span><br><span class="line">第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是</span><br><span class="line">服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式</span><br><span class="line">加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class="line"></span><br><span class="line">第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定</span><br><span class="line">义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</span><br><span class="line"></span><br><span class="line">第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js</span><br><span class="line">的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考60</span><br><span class="line"></span><br><span class="line">第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。</span><br></pre></td></tr></table></figure>

<h4 id="65-AMD-和-CMD-规范的区别？"><a href="#65-AMD-和-CMD-规范的区别？" class="headerlink" title="65. AMD 和 CMD 规范的区别？"></a>65. AMD 和 CMD 规范的区别？</h4><p>它们之间的主要区别有两个方面。</p>
<p>（1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇<br>就近依赖，只有在用到某个模块的时候再去 require。</p>
<p>（2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于<br>模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD<br>在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句<br>的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&quot;./a&quot;</span>, <span class="string">&quot;./b&quot;</span>], <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5a422b036fb9a045211ef789">《前端模块化，AMD 与 CMD 的区别》</a></p>
<h4 id="66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><a href="#66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。" class="headerlink" title="66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。"></a>66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h4><ul>
<li><p>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p>
</li>
<li><p>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
</li>
</ul>
<h4 id="67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://github.com/HRFE/blog/issues/10">《requireJS 的用法和原理分析》</a><br><a href="https://zhuanlan.zhihu.com/p/55039478">《requireJS 的核心原理是什么？》</a><br><a href="https://www.cnblogs.com/dong-xu/p/7160919.html">《从 RequireJs 源码剖析脚本加载原理》</a><br><a href="https://www.jianshu.com/p/5a39535909e4">《requireJS 原理分析》</a></p>
<h4 id="68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"><a href="#68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？" class="headerlink" title="68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"></a>68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</h4><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21157540">《JS 模块加载器加载原理是怎么样的？》</a></p>
<h4 id="69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><a href="#69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西" class="headerlink" title="69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?"></a>69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。</span><br><span class="line"></span><br><span class="line">在 class 中添加的方法，其实是添加在类的原型上的。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/29789315">《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》</a><br><a href="http://es6.ruanyifeng.com/#docs/class">《Class 的基本语法》</a></p>
<h4 id="70-documen-write-和-innerHTML-的区别？"><a href="#70-documen-write-和-innerHTML-的区别？" class="headerlink" title="70. documen.write 和 innerHTML 的区别？"></a>70. documen.write 和 innerHTML 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.write 的内容会代替整个文档内容，会重写整个页面。</span><br><span class="line"></span><br><span class="line">innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.nowcoder.com/questionTerminal/2c5d8105b2694d85b06eff85e871cf50">《简述 document.write 和 innerHTML 的区别。》</a></p>
<h4 id="71-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#71-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h4><p>（1）创建新节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">createDocumentFragment</span>(node);</span><br><span class="line"><span class="title function_">createElement</span>(node);</span><br><span class="line"><span class="title function_">createTextNode</span>(text);</span><br></pre></td></tr></table></figure>

<p>（2）添加、移除、替换、插入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">appendChild</span>(node)</span><br><span class="line"><span class="title function_">removeChild</span>(node)</span><br><span class="line"><span class="title function_">replaceChild</span>(<span class="keyword">new</span>,old)</span><br><span class="line"><span class="title function_">insertBefore</span>(<span class="keyword">new</span>,old)</span><br></pre></td></tr></table></figure>

<p>（3）查找</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getElementById</span>();</span><br><span class="line"><span class="title function_">getElementsByName</span>();</span><br><span class="line"><span class="title function_">getElementsByTagName</span>();</span><br><span class="line"><span class="title function_">getElementsByClassName</span>();</span><br><span class="line"><span class="title function_">querySelector</span>();</span><br><span class="line"><span class="title function_">querySelectorAll</span>();</span><br></pre></td></tr></table></figure>

<p>（4）属性操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getAttribute</span>(key);</span><br><span class="line"><span class="title function_">setAttribute</span>(key, value);</span><br><span class="line"><span class="title function_">hasAttribute</span>(key);</span><br><span class="line"><span class="title function_">removeAttribute</span>(key);</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction#DOM_interfaces">《DOM 概述》</a><br><a href="https://harttle.land/2015/10/01/javascript-dom-api.html">《原生 JavaScript 的 DOM 操作汇总》</a><br><a href="https://microzz.com/2017/04/06/jsdom/">《原生 JS 中 DOM 节点相关 API 合集》</a></p>
<h4 id="72-innerHTML-与-outerHTML-的区别？"><a href="#72-innerHTML-与-outerHTML-的区别？" class="headerlink" title="72. innerHTML 与 outerHTML 的区别？"></a>72. innerHTML 与 outerHTML 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于这样一个 HTML 元素：&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;。</span><br><span class="line"></span><br><span class="line">innerHTML：内部 HTML，content&lt;br/&gt;；</span><br><span class="line">outerHTML：外部 HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;；</span><br><span class="line">innerText：内部文本，content ；</span><br><span class="line">outerText：内部文本，content ；</span><br></pre></td></tr></table></figure>

<h4 id="73-call-和-apply-的区别？"><a href="#73-call-和-apply-的区别？" class="headerlink" title="73. .call() 和 .apply() 的区别？"></a>73. .call() 和 .apply() 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">它们的作用一模一样，区别仅在于传入参数的形式的不同。</span><br><span class="line"></span><br><span class="line">apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</span><br><span class="line"></span><br><span class="line">call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/entry/58d0a7b22f301e007e5a15ae">《apply、call 的区别和用途》</a></p>
<h4 id="74-JavaScript-类数组对象的定义？"><a href="#74-JavaScript-类数组对象的定义？" class="headerlink" title="74. JavaScript 类数组对象的定义？"></a>74. JavaScript 类数组对象的定义？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。</span><br><span class="line"></span><br><span class="line">常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length</span><br><span class="line">属性值，代表可接收的参数个数。</span><br></pre></td></tr></table></figure>

<p>常见的类数组转换为数组的方法有这样几种：</p>
<p>（1）通过 call 调用数组的 slice 方法来实现转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike);</span><br></pre></td></tr></table></figure>

<p>（2）通过 call 调用数组的 splice 方法来实现转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">splice</span>.<span class="title function_">call</span>(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>（3）通过 apply 调用数组的 concat 方法来实现转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], arrayLike);</span><br></pre></td></tr></table></figure>

<p>（4）通过 Array.from 方法来实现转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike);</span><br></pre></td></tr></table></figure>

<p>详细的资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/14">《JavaScript 深入之类数组对象与 arguments》</a><br><a href="https://segmentfault.com/a/1190000000415572">《javascript 类数组》</a><br><a href="https://blog.lxxyx.cn/2016/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E7%B1%BB%E6%95%B0%E7%BB%84/">《深入理解 JavaScript 类数组》</a></p>
<h4 id="75-数组和对象有哪些原生方法，列举一下？"><a href="#75-数组和对象有哪些原生方法，列举一下？" class="headerlink" title="75. 数组和对象有哪些原生方法，列举一下？"></a>75. 数组和对象有哪些原生方法，列举一下？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</span><br><span class="line"></span><br><span class="line">数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</span><br><span class="line"></span><br><span class="line">数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</span><br><span class="line"></span><br><span class="line">数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</span><br><span class="line"></span><br><span class="line">数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</span><br><span class="line"></span><br><span class="line">数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</span><br><span class="line"></span><br><span class="line">数组归并方法 reduce() 和 reduceRight() 方法</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BArray%E8%AF%A6%E8%A7%A3.html">《JavaScript 深入理解之 Array 类型详解》</a></p>
<h4 id="76-数组的-fill-方法？"><a href="#76-数组的-fill-方法？" class="headerlink" title="76. 数组的 fill 方法？"></a>76. 数组的 fill 方法？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</span><br><span class="line">fill 方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">《Array.prototype.fill()》</a></p>
<h4 id="77-的长度？"><a href="#77-的长度？" class="headerlink" title="77. [,,,] 的长度？"></a>77. [,,,] 的长度？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</span><br><span class="line"></span><br><span class="line">JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAS</span><br><span class="line">cript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。</span><br><span class="line"></span><br><span class="line">如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数</span><br><span class="line">量。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Trailing_commas">《尾后逗号》</a></p>
<h4 id="78-JavaScript-中的作用域与变量声明提升？"><a href="#78-JavaScript-中的作用域与变量声明提升？" class="headerlink" title="78. JavaScript 中的作用域与变量声明提升？"></a>78. JavaScript 中的作用域与变量声明提升？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。</span><br><span class="line"></span><br><span class="line">造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html">《JavaScript 深入理解之变量对象》</a></p>
<h4 id="79-如何编写高性能的-Javascript-？"><a href="#79-如何编写高性能的-Javascript-？" class="headerlink" title="79. 如何编写高性能的 Javascript ？"></a>79. 如何编写高性能的 Javascript ？</h4><ul>
<li>1.使用位运算代替一些简单的四则运算。</li>
<li>2.避免使用过深的嵌套循环。</li>
<li>3.不要使用未定义的变量。</li>
<li>4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。</li>
</ul>
<p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/34780474">《如何编写高性能的 Javascript？》</a></p>
<h4 id="80-简单介绍一下-V8-引擎的垃圾回收机制"><a href="#80-简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="80. 简单介绍一下 V8 引擎的垃圾回收机制"></a>80. 简单介绍一下 V8 引擎的垃圾回收机制</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</span><br><span class="line"></span><br><span class="line">新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</span><br><span class="line"></span><br><span class="line">新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</span><br><span class="line"></span><br><span class="line">（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</span><br><span class="line"></span><br><span class="line">（2）如果对象不存活，则释放对象的空间。</span><br><span class="line"></span><br><span class="line">（3）最后将 From 空间和 To 空间角色进行交换。</span><br><span class="line"></span><br><span class="line">新生代对象晋升到老生代有两个条件：</span><br><span class="line"></span><br><span class="line">（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</span><br><span class="line"></span><br><span class="line">（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</span><br><span class="line"></span><br><span class="line">老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</span><br><span class="line"></span><br><span class="line">由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/b8ed21e8a4fb">《深入理解 V8 的垃圾回收原理》</a><br><a href="https://zhuanlan.zhihu.com/p/23992332">《JavaScript 中的垃圾回收》</a></p>
<h4 id="81-哪些操作会造成内存泄漏？"><a href="#81-哪些操作会造成内存泄漏？" class="headerlink" title="81. 哪些操作会造成内存泄漏？"></a>81. 哪些操作会造成内存泄漏？</h4><p>相关知识点：</p>
<ul>
<li>1.意外的全局变量</li>
<li>2.被遗忘的计时器或回调函数</li>
<li>3.脱离 DOM 的引用</li>
<li>4.闭包</li>
</ul>
<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</span><br><span class="line"></span><br><span class="line">第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留</span><br><span class="line">在内存中，而无法被回收。</span><br><span class="line"></span><br><span class="line">第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回</span><br><span class="line">收。</span><br><span class="line"></span><br><span class="line">第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html">《JavaScript 内存泄漏教程》</a><br><a href="https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/">《4 类 JavaScript 内存泄漏及如何避免》</a><br><a href="https://juejin.im/entry/5a64366c6fb9a01c9332c706">《杜绝 js 中四种内存泄漏类型的发生》</a><br><a href="https://segmentfault.com/a/1190000008901861">《javascript 典型内存泄漏及 chrome 的排查方法》</a></p>
<h4 id="82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"><a href="#82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？" class="headerlink" title="82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"></a>82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history</span><br><span class="line">对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，我们可</span><br><span class="line">以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。</span><br><span class="line"></span><br><span class="line">使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问</span><br><span class="line">题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad">《pushState + ajax 实现浏览器无刷新前进后退》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">《Manipulating the browser history》</a></p>
<h4 id="83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）"><a href="#83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）" class="headerlink" title="83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）"></a>83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof window === &#x27;undefined&#x27; ? &#x27;node&#x27; : &#x27;browser&#x27;;</span><br><span class="line"></span><br><span class="line">通过判断当前环境的 window 对象类型是否为 undefined，如果是undefined，则说明当前脚本运行在node环境，否则说明运行在window环境。</span><br></pre></td></tr></table></figure>

<h4 id="84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"></a>84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</h4><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20027966">《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》</a><br><a href="https://zhuanlan.zhihu.com/p/30558018">《从 Chrome 源码看浏览器如何加载资源》</a></p>
<h4 id="85-移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？"><a href="#85-移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？" class="headerlink" title="85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？"></a>85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</span><br></pre></td></tr></table></figure>

<p>有三种办法来解决这个问题：</p>
<ul>
<li>1.通过 meta 标签禁用网页的缩放。</li>
<li>2.通过 meta 标签将网页的 viewport 设置为 ideal viewport。</li>
<li>3.调用一些 js 库，比如 FastClick</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0">《移动端 300ms 点击延迟和点击穿透》</a></p>
<h4 id="86-什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"><a href="#86-什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？" class="headerlink" title="86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"></a>86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）什么是前端路由？</span><br><span class="line"></span><br><span class="line">前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。</span><br><span class="line"></span><br><span class="line">（2）什么时候使用前端路由？</span><br><span class="line"></span><br><span class="line">在单页面应用，大部分页面结构不变，只改变部分内容的使用</span><br><span class="line"></span><br><span class="line">（3）前端路由有什么优点和缺点？</span><br><span class="line"></span><br><span class="line">优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户</span><br><span class="line"></span><br><span class="line">缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置</span><br><span class="line"></span><br><span class="line">前端路由一共有两种实现方式，一种是通过 hash 的方式，一种是通过使用 pushState 的方式。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/q/1010000005336260">《什么是“前端路由”》</a><br><a href="https://github.com/kaola-fed/blog/issues/137">《浅谈前端路由》 </a><br><a href="https://www.zhihu.com/question/53064386">《前端路由是什么东西？》</a></p>
<h4 id="87-如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？"><a href="#87-如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？" class="headerlink" title="87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？"></a>87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</h4><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b2da89cf265da597f1c7cab">《浅谈前端单元测试》</a></p>
<h4 id="88-检测浏览器版本版本有哪些方式？"><a href="#88-检测浏览器版本版本有哪些方式？" class="headerlink" title="88. 检测浏览器版本版本有哪些方式？"></a>88. 检测浏览器版本版本有哪些方式？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">检测浏览器版本一共有两种方式：</span><br><span class="line"></span><br><span class="line">一种是检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。</span><br><span class="line"></span><br><span class="line">第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/d99f4ca385ac">《JavaScript 判断浏览器类型》</a></p>
<h4 id="89-什么是-Polyfill-？"><a href="#89-什么是-Polyfill-？" class="headerlink" title="89. 什么是 Polyfill ？"></a>89. 什么是 Polyfill ？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。</span><br><span class="line"></span><br><span class="line">比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。</span><br><span class="line"></span><br><span class="line">一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000002593432">《Web 开发中的“黑话”》</a><br><a href="https://juejin.im/post/5a579bc7f265da3e38496ba1">《Polyfill 为何物》</a></p>
<h4 id="90-使用-JS-实现获取文件扩展名？"><a href="#90-使用-JS-实现获取文件扩展名？" class="headerlink" title="90. 使用 JS 实现获取文件扩展名？"></a>90. 使用 JS 实现获取文件扩展名？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String.lastIndexOf() 方法返回指定值（本例中的&#x27;.&#x27;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 &#x27;filename&#x27; 和 &#x27;.hiddenfile&#x27; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFileExtension</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> filename.<span class="title function_">slice</span>(((filename.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>) - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">0</span>) + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000004993946">《如何更有效的获取文件扩展名》</a></p>
<h4 id="91-介绍一下-js-的节流与防抖？"><a href="#91-介绍一下-js-的节流与防抖？" class="headerlink" title="91. 介绍一下 js 的节流与防抖？"></a>91. 介绍一下 js 的节流与防抖？</h4><p>相关知识点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数防抖的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span>,</span><br><span class="line">      args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数节流的实现;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> preTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span>,</span><br><span class="line">      args = <span class="variable language_">arguments</span>,</span><br><span class="line">      nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      preTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</span><br><span class="line"></span><br><span class="line">函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1">《轻松理解 JS 函数节流和函数防抖》</a><br><a href="https://juejin.im/post/5aa60b0e518825556b6c6d1a">《JavaScript 事件节流和事件防抖》</a><br><a href="https://juejin.im/entry/5b1d2d54f265da6e2545bfa4">《JS 的防抖与节流》</a></p>
<h4 id="92-Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#92-Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="92. Object.is() 与原来的比较操作符 “===”、“==” 的区别？"></a>92. Object.is() 与原来的比较操作符 “===”、“==” 的区别？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两等号判等，会在比较时进行类型转换。</span><br><span class="line">三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。</span><br><span class="line"></span><br><span class="line">Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.</span><br><span class="line"></span><br><span class="line">Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</span><br><span class="line"></span><br><span class="line">使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</span><br><span class="line"></span><br><span class="line">使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。</span><br></pre></td></tr></table></figure>

<h4 id="93-escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#93-escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="93. escape,encodeURI,encodeURIComponent 有什么区别？"></a>93. escape,encodeURI,encodeURIComponent 有什么区别？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。</span><br><span class="line">它们的根本区别在于，escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」，而 encode URI 则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个「%」；在处理 0xff 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 16 进制 unicode，同时也是字符的 UTF-8），只是范围（即哪些字符编码哪些字符不编码）不一样。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</span><br><span class="line"></span><br><span class="line">encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</span><br><span class="line"></span><br><span class="line">escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21861899">《escape,encodeURI,encodeURIComponent 有什么区别?》</a></p>
<h4 id="94-Unicode-和-UTF-8-之间的关系？"><a href="#94-Unicode-和-UTF-8-之间的关系？" class="headerlink" title="94. Unicode 和 UTF-8 之间的关系？"></a>94. Unicode 和 UTF-8 之间的关系？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。</span><br><span class="line"></span><br><span class="line">UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.51cto.com/polaris/377468">《字符编码详解》</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">《字符编码笔记：ASCII，Unicode 和 UTF-8》</a></p>
<h4 id="95-js-的事件循环是什么？"><a href="#95-js-的事件循环是什么？" class="headerlink" title="95. js 的事件循环是什么？"></a>95. js 的事件循环是什么？</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</span><br><span class="line"></span><br><span class="line">微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</span><br><span class="line"></span><br><span class="line">宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲</span><br><span class="line">染等。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5afbc62151882542af04112d">《浏览器事件循环机制（event loop）》</a><br><a href="https://zhuanlan.zhihu.com/p/33058983">《详解 JavaScript 中的 Event Loop（事件循环）机制》</a><br><a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html">《什么是 Event Loop？》</a><br><a href="https://juejin.im/post/59e85eebf265da430d571f89">《这一次，彻底弄懂 JavaScript 执行机制》</a></p>
<h4 id="96-js-中的深浅拷贝实现？"><a href="#96-js-中的深浅拷贝实现？" class="headerlink" title="96. js 中的深浅拷贝实现？"></a>96. js 中的深浅拷贝实现？</h4><p>相关资料：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> object;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = <span class="title function_">deepCopy</span>(object[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</span><br><span class="line"></span><br><span class="line">深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/32">《JavaScript 专题之深浅拷贝》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bed40d951882545f73004f6">《前端面试之道》</a></p>
<h4 id="97-手写-call、apply-及-bind-函数"><a href="#97-手写-call、apply-及-bind-函数" class="headerlink" title="97. 手写 call、apply 及 bind 函数"></a>97. 手写 call、apply 及 bind 函数</h4><p>相关资料：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call函数实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply 函数实现</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind 函数实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">    fn = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context,</span><br><span class="line">      args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<p>call 函数的实现步骤：</p>
<ul>
<li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>3.处理传入的参数，截取第一个参数后的所有参数。</li>
<li>4.将函数作为上下文对象的一个属性。</li>
<li>5.使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>6.删除刚才新增的属性。</li>
<li>7.返回结果。</li>
</ul>
<p>apply 函数的实现步骤：</p>
<ul>
<li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>3.将函数作为上下文对象的一个属性。</li>
<li>4.判断参数值是否传入</li>
<li>4.使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>5.删除刚才新增的属性</li>
<li>6.返回结果</li>
</ul>
<p>bind 函数的实现步骤：</p>
<ul>
<li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>2.保存当前函数的引用，获取其余传入参数值。</li>
<li>3.创建一个函数返回</li>
<li>4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li>
</ul>
<p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d8e6fb9a04a044073fe">《手写 call、apply 及 bind 函数》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/11">《JavaScript 深入之 call 和 apply 的模拟实现》</a></p>
<h4 id="98-函数柯里化的实现"><a href="#98-函数柯里化的实现" class="headerlink" title="98. 函数柯里化的实现"></a>98. 函数柯里化的实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, args</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取函数需要的参数长度</span></span><br><span class="line">  <span class="keyword">let</span> length = fn.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> subArgs = args.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接得到现有的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      subArgs.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数的长度是否已经满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (subArgs.<span class="property">length</span> &gt;= length) &#123;</span><br><span class="line">      <span class="comment">// 如果满足，执行函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, subArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span></span><br><span class="line">      <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fn.<span class="property">length</span> &lt;= args.<span class="property">length</span> ? <span class="title function_">fn</span>(...args) : curry.<span class="title function_">bind</span>(<span class="literal">null</span>, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/42">《JavaScript 专题之函数柯里化》</a></p>
<h4 id="99-为什么-0-1-0-2-0-3？如何解决这个问题？"><a href="#99-为什么-0-1-0-2-0-3？如何解决这个问题？" class="headerlink" title="99. 为什么 0.1 + 0.2 != 0.3？如何解决这个问题？"></a>99. 为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</span><br><span class="line"></span><br><span class="line">对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。</span><br><span class="line"></span><br><span class="line">我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以</span><br><span class="line">使用 es6 的 Number.EPSILON</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/Lixuanshengchao/article/details/82049191">《十进制的 0.1 为什么不能用二进制很好的表示？》</a><br><a href="https://blog.csdn.net/zhengyanan815/article/details/78550073">《十进制浮点数转成二进制》</a><br><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">《浮点数的二进制表示》</a><br><a href="https://juejin.im/post/5b372f106fb9a00e6714aa21">《js 浮点数存储精度丢失原理》</a><br><a href="https://juejin.im/post/594a31d0a0bb9f006b0b2624">《浮点数精度之谜》</a><br><a href="https://github.com/camsong/blog/issues/9">《JavaScript 浮点数陷阱及解法》</a><br><a href="https://juejin.im/post/5bd2f10a51882555e072d0c4">《0.1+0.2 !== 0.3？》</a><br><a href="https://juejin.im/entry/59cdd7fb6fb9a00a600f8eef">《JavaScript 中奇特的~运算符》</a></p>
<h4 id="100-原码、反码和补码的介绍"><a href="#100-原码、反码和补码的介绍" class="headerlink" title="100. 原码、反码和补码的介绍"></a>100. 原码、反码和补码的介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。</span><br><span class="line"></span><br><span class="line">正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。</span><br><span class="line">如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。</span><br><span class="line"></span><br><span class="line">正数的补码和其原码一样；负数的补码为其反码加1。</span><br><span class="line"></span><br><span class="line">例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；</span><br><span class="line">[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001</span><br><span class="line"></span><br><span class="line">之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html">《关于 2 的补码》</a></p>
<h4 id="101-toPrecision-和-toFixed-和-Math-round-的区别？"><a href="#101-toPrecision-和-toFixed-和-Math-round-的区别？" class="headerlink" title="101. toPrecision 和 toFixed 和 Math.round 的区别？"></a>101. toPrecision 和 toFixed 和 Math.round 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。</span><br><span class="line">toFixed 是对小数点后指定位数取整，从小数点开始数起。</span><br><span class="line">Math.round 是将一个数字四舍五入到一个整数。</span><br></pre></td></tr></table></figure>

<h4 id="102-什么是-XSS-攻击？如何防范-XSS-攻击？"><a href="#102-什么是-XSS-攻击？如何防范-XSS-攻击？" class="headerlink" title="102. 什么是 XSS 攻击？如何防范 XSS 攻击？"></a>102. 什么是 XSS 攻击？如何防范 XSS 攻击？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</span><br><span class="line"></span><br><span class="line">XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</span><br><span class="line"></span><br><span class="line">XSS 一般分为存储型、反射型和 DOM 型。</span><br><span class="line"></span><br><span class="line">存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。</span><br><span class="line"></span><br><span class="line">反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。</span><br><span class="line"></span><br><span class="line">DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。</span><br><span class="line"></span><br><span class="line">XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。</span><br><span class="line"></span><br><span class="line">对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。</span><br><span class="line"></span><br><span class="line">因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</span><br><span class="line"></span><br><span class="line">还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</span><br><span class="line"></span><br><span class="line">还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5bad9140e51d450e935c6d64">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p>
<h4 id="103-什么是-CSP？"><a href="#103-什么是-CSP？" class="headerlink" title="103. 什么是 CSP？"></a>103. 什么是 CSP？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</span><br><span class="line"></span><br><span class="line">通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 &lt;meta</span><br><span class="line">http-equiv=&quot;Content-Security-Policy&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">《内容安全策略（CSP）》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc721851882516c33430a2">《前端面试之道》</a></p>
<h4 id="104-什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#104-什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被</span><br><span class="line">攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</span><br><span class="line"></span><br><span class="line">CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</span><br><span class="line"></span><br><span class="line">一般的 CSRF 攻击类型有三种：</span><br><span class="line"></span><br><span class="line">第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提</span><br><span class="line">交。</span><br><span class="line"></span><br><span class="line">第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</span><br><span class="line"></span><br><span class="line">第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</span><br><span class="line"></span><br><span class="line">CSRF 可以用下面几种方法来防护：</span><br><span class="line"></span><br><span class="line">第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</span><br><span class="line"></span><br><span class="line">第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。</span><br><span class="line"></span><br><span class="line">第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</span><br><span class="line"></span><br><span class="line">第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc009996fb9a05d0a055192">《前端安全系列之二：如何防止 CSRF 攻击？》</a><br><a href="https://www.jianshu.com/p/1f9c71850299">《[ HTTP 趣谈] origin, referer 和 host 区别》</a></p>
<h4 id="105-什么是-Samesite-Cookie-属性？"><a href="#105-什么是-Samesite-Cookie-属性？" class="headerlink" title="105. 什么是 Samesite Cookie 属性？"></a>105. 什么是 Samesite Cookie 属性？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。</span><br><span class="line"></span><br><span class="line">将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。</span><br><span class="line"></span><br><span class="line">将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。</span><br><span class="line"></span><br><span class="line">使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。</span><br></pre></td></tr></table></figure>

<h4 id="106-什么是点击劫持？如何防范点击劫持？"><a href="#106-什么是点击劫持？如何防范点击劫持？" class="headerlink" title="106. 什么是点击劫持？如何防范点击劫持？"></a>106. 什么是点击劫持？如何防范点击劫持？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</span><br><span class="line"></span><br><span class="line">我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特</span><br><span class="line">定的一些情况才能作为 iframe 来使用。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/251704d8ff18">《web 安全之–点击劫持攻击与防御技术简介》</a></p>
<h4 id="107-SQL-注入攻击？"><a href="#107-SQL-注入攻击？" class="headerlink" title="107. SQL 注入攻击？"></a>107. SQL 注入攻击？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构</span><br><span class="line">造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5bd5b820e51d456f72531fa8">《Web 安全漏洞之 SQL 注入》</a><br><a href="http://blog.720ui.com/2016/security_web/#SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">《如何防范常见的 Web 攻击》</a></p>
<h4 id="108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。</span><br><span class="line"></span><br><span class="line">比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。</span><br><span class="line"></span><br><span class="line">MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Co</span><br><span class="line">ntroller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</span><br><span class="line"></span><br><span class="line">MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的</span><br><span class="line">Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</span><br><span class="line"></span><br><span class="line">MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功</span><br><span class="line">能。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/593021272f301e0058273468">《浅析前端开发中的 MVC/MVP/MVVM 模式》</a><br><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">《MVC，MVP 和 MVVM 的图示》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf">《MVVM》</a><br><a href="https://segmentfault.com/a/1190000015310674">《一篇文章了解架构模式：MVC/MVP/MVVM》</a></p>
<h4 id="109-vue-双向数据绑定原理？"><a href="#109-vue-双向数据绑定原理？" class="headerlink" title="109. vue 双向数据绑定原理？"></a>109. vue 双向数据绑定原理？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。</span><br><span class="line"></span><br><span class="line">首先我们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。</span><br><span class="line"></span><br><span class="line">数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。</span><br><span class="line"></span><br><span class="line">如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。</span><br><span class="line"></span><br><span class="line">如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数</span><br><span class="line">据。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension">《Vue.js 双向绑定的实现原理》</a></p>
<h4 id="110-Object-defineProperty-介绍？"><a href="#110-Object-defineProperty-介绍？" class="headerlink" title="110. Object.defineProperty 介绍？"></a>110. Object.defineProperty 介绍？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。</span><br><span class="line"></span><br><span class="line">一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">《Object.defineProperty()》</a></p>
<h4 id="111-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#111-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。</span><br></pre></td></tr></table></figure>

<h4 id="112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？"><a href="#112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？"></a>112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我对 Virtual DOM 的理解是，</span><br><span class="line"></span><br><span class="line">首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</span><br><span class="line"></span><br><span class="line">当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</span><br><span class="line"></span><br><span class="line">最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</span><br><span class="line"></span><br><span class="line">我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf">《Virtual DOM》</a><br><a href="https://github.com/y8n/blog/issues/5">《理解 Virtual DOM》</a><br><a href="https://github.com/livoras/blog/issues/13">《深度剖析：如何实现一个 Virtual DOM 算法》</a><br><a href="https://www.zhihu.com/question/31809713/answer/53544875">《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》</a></p>
<h4 id="113-如何比较两个-DOM-树的差异？"><a href="#113-如何比较两个-DOM-树的差异？" class="headerlink" title="113. 如何比较两个 DOM 树的差异？"></a>113. 如何比较两个 DOM 树的差异？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</span><br><span class="line"></span><br><span class="line">算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</span><br><span class="line"></span><br><span class="line">在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</span><br></pre></td></tr></table></figure>

<h4 id="114-什么是-requestAnimationFrame-？"><a href="#114-什么是-requestAnimationFrame-？" class="headerlink" title="114. 什么是 requestAnimationFrame ？"></a>114. 什么是 requestAnimationFrame ？</h4><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a82f0626fb9a06358657c9c">《你需要知道的 requestAnimationFrame》</a><br><a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/">《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》</a></p>
<h4 id="115-谈谈你对-webpack-的看法"><a href="#115-谈谈你对-webpack-的看法" class="headerlink" title="115. 谈谈你对 webpack 的看法"></a>115. 谈谈你对 webpack 的看法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源</span><br><span class="line">数。</span><br><span class="line"></span><br><span class="line">我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。</span><br><span class="line"></span><br><span class="line">Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。</span><br><span class="line"></span><br><span class="line">Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。</span><br><span class="line"></span><br><span class="line">Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。</span><br><span class="line"></span><br><span class="line">loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。</span><br><span class="line"></span><br><span class="line">插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。</span><br><span class="line"></span><br><span class="line">使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5b38d27451882574d87aa5d5#heading-0">《不聊 webpack 配置，来说说它的原理》</a><br><a href="https://juejin.im/entry/5b5724d05188251aa01647fd">《前端工程化——构建工具选型：grunt、gulp、webpack》</a><br><a href="https://juejin.im/post/5afa9cd0f265da0b981b9af9#heading-0">《浅入浅出 webpack》</a><br><a href="https://juejin.im/entry/5ae5c8c9f265da0b9f400d8e">《前端构建工具发展及其比较》</a></p>
<h4 id="116-offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><a href="#116-offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？" class="headerlink" title="116. offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？"></a>116. offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。</span><br><span class="line">clientTop 返回的是上边框的宽度。</span><br><span class="line">clientLeft 返回的左边框的宽度。</span><br><span class="line"></span><br><span class="line">offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。</span><br><span class="line">offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。</span><br><span class="line">offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。</span><br><span class="line"></span><br><span class="line">scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。</span><br><span class="line">scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。</span><br><span class="line">scrollLeft 属性返回的是元素滚动条到元素左边的距离。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc9366d5188255c4834e75a">《最全的获取元素宽高及位置的方法》</a><br><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html">《用 Javascript 获取页面元素的位置》</a></p>
<h4 id="117-谈一谈你理解的函数式编程？"><a href="#117-谈一谈你理解的函数式编程？" class="headerlink" title="117. 谈一谈你理解的函数式编程？"></a>117. 谈一谈你理解的函数式编程？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单说，&quot;函数式编程&quot;是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。</span><br><span class="line"></span><br><span class="line">它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是&quot;第一等公民&quot;、只用&quot;表达式&quot;。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html">《函数式编程初探》</a></p>
<h4 id="118-异步编程的实现方式？"><a href="#118-异步编程的实现方式？" class="headerlink" title="118. 异步编程的实现方式？"></a>118. 异步编程的实现方式？</h4><p>相关资料：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">回调函数</span><br><span class="line">优点：简单、容易理解</span><br><span class="line">缺点：不利于维护，代码耦合高</span><br><span class="line"></span><br><span class="line">事件监听（采用时间驱动模式，取决于某个事件是否发生）：</span><br><span class="line">优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</span><br><span class="line">缺点：事件驱动型，流程不够清晰</span><br><span class="line"></span><br><span class="line">发布/订阅（观察者模式）</span><br><span class="line">类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</span><br><span class="line"></span><br><span class="line">Promise 对象</span><br><span class="line">优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数；</span><br><span class="line">缺点：编写和理解，相对比较难</span><br><span class="line"></span><br><span class="line">Generator 函数</span><br><span class="line">优点：函数体内外的数据交换、错误处理机制</span><br><span class="line">缺点：流程管理不方便</span><br><span class="line"></span><br><span class="line">async 函数</span><br><span class="line">优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰。</span><br><span class="line">缺点：错误处理机制</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js 中的异步机制可以分为以下几种：</span><br><span class="line"></span><br><span class="line">第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</span><br><span class="line"></span><br><span class="line">第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</span><br><span class="line"></span><br><span class="line">第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</span><br><span class="line"></span><br><span class="line">第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</span><br></pre></td></tr></table></figure>

<h4 id="119-Js-动画与-CSS-动画区别及相应实现"><a href="#119-Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="119. Js 动画与 CSS 动画区别及相应实现"></a>119. Js 动画与 CSS 动画区别及相应实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSS3 的动画的优点</span><br><span class="line"></span><br><span class="line">在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化</span><br><span class="line">代码相对简单</span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line"></span><br><span class="line">在动画控制上不够灵活</span><br><span class="line">兼容性不好</span><br><span class="line"></span><br><span class="line">JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧</span><br></pre></td></tr></table></figure>

<h4 id="120-get-请求传参长度的误区"><a href="#120-get-请求传参长度的误区" class="headerlink" title="120. get 请求传参长度的误区"></a>120. get 请求传参长度的误区</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</span><br><span class="line"></span><br><span class="line">实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:</span><br></pre></td></tr></table></figure>

<ul>
<li>1.HTTP 协议未规定 GET 和 POST 的长度限制</li>
<li>2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</li>
<li>3.不同的浏览器和 WEB 服务器，限制的最大长度不一样</li>
<li>4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</li>
</ul>
<h4 id="121-URL-和-URI-的区别？"><a href="#121-URL-和-URI-的区别？" class="headerlink" title="121. URL 和 URI 的区别？"></a>121. URL 和 URI 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URI: Uniform Resource Identifier      指的是统一资源标识符</span><br><span class="line">URL: Uniform Resource Location        指的是统一资源定位符</span><br><span class="line">URN: Universal Resource Name          指的是统一资源名称</span><br><span class="line"></span><br><span class="line">URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。</span><br><span class="line"></span><br><span class="line">URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21950864">《HTTP 协议中 URI 和 URL 有什么区别？》</a><br><a href="http://web.jobbole.com/83452/">《你知道 URL、URI 和 URN 三者之间的区别吗？》</a><br><a href="https://segmentfault.com/a/1190000006081973">《URI、URL 和 URN 的区别》</a></p>
<h4 id="122-get-和-post-请求在缓存方面的区别"><a href="#122-get-和-post-请求在缓存方面的区别" class="headerlink" title="122. get 和 post 请求在缓存方面的区别"></a>122. get 和 post 请求在缓存方面的区别</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</span><br><span class="line"></span><br><span class="line">post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改，而 post 请求一般都会对服务器数据造成修改，所以，一般会对 get 请求进行缓存，很少会对 post 请求进行缓存。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/qq_27093465/article/details/50479289">《HTML 关于 post 和 get 的区别以及缓存问题的理解》</a></p>
<h4 id="123-图片的懒加载和预加载"><a href="#123-图片的懒加载和预加载" class="headerlink" title="123. 图片的懒加载和预加载"></a>123. 图片的懒加载和预加载</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</span><br><span class="line"></span><br><span class="line">懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</span><br><span class="line"></span><br><span class="line">两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。</span><br><span class="line"></span><br><span class="line">预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</span><br><span class="line"></span><br><span class="line">这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5b0c3b53f265da09253cbed0">《懒加载和预加载》</a><br><a href="https://juejin.im/entry/5a73f38cf265da4e99575be3">《网页图片加载优化方案》</a><br><a href="https://www.zhangxinxu.com/wordpress/2016/06/image-preload-based-on-user-behavior/">《基于用户行为的图片等资源预加载》</a></p>
<h4 id="124-mouseover-和-mouseenter-的区别？"><a href="#124-mouseover-和-mouseenter-的区别？" class="headerlink" title="124. mouseover 和 mouseenter 的区别？"></a>124. mouseover 和 mouseenter 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 mouseenter 不会冒泡。</span><br><span class="line"></span><br><span class="line">由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://github.com/qianlongo/zepto-analysis/issues/1">《mouseenter 与 mouseover 为何这般纠缠不清？》</a></p>
<h4 id="125-js-拖拽功能的实现"><a href="#125-js-拖拽功能的实现" class="headerlink" title="125. js 拖拽功能的实现"></a>125. js 拖拽功能的实现</h4><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先是三个事件，分别是 mousedown，mousemove，mouseup</span><br><span class="line">当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。</span><br><span class="line">clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示</span><br><span class="line">元素的元素的初始坐标，移动的举例应该是：</span><br><span class="line">鼠标移动时候的坐标-鼠标按下去时候的坐标。</span><br><span class="line">也就是说定位信息为：</span><br><span class="line">鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠</span><br><span class="line">标抬起，拖拽过程结束。</span><br><span class="line"></span><br><span class="line">这三步分别对应了三个事件，mousedown 事件，mousemove 事件和 mouseup 事件。只有在鼠标按下的状态移动鼠标我们才会</span><br><span class="line">执行拖拽事件，因此我们需要在 mousedown 事件中设置一个状态来标识鼠标已经按下，然后在 mouseup 事件中再取消这个状</span><br><span class="line">态。在 mousedown 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠</span><br><span class="line">标的位置。然后在 mousemove 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标。</span><br><span class="line">最后 mouseup 事件触发后，清除状态，结束拖拽事件。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/LZGS_4/article/details/43523465">《原生 js 实现拖拽功能基本思路》</a></p>
<h4 id="126-为什么使用-setTimeout-实现-setInterval？怎么模拟？"><a href="#126-为什么使用-setTimeout-实现-setInterval？怎么模拟？" class="headerlink" title="126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？"></a>126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</h4><p>相关知识点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mySetInterval</span>(<span class="params">fn, timeout</span>) &#123;</span><br><span class="line">  <span class="comment">// 控制器，控制定时器是否继续执行</span></span><br><span class="line">  <span class="keyword">var</span> timer = &#123;</span><br><span class="line">    <span class="attr">flag</span>: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置递归函数，模拟定时器执行。</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">interval</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer.<span class="property">flag</span>) &#123;</span><br><span class="line">      <span class="title function_">fn</span>();</span><br><span class="line">      <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动定时器</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回控制器</span></span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</span><br><span class="line"></span><br><span class="line">针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/32479bdfd851">《用 setTimeout 实现 setInterval》</a><br><a href="https://zhuanlan.zhihu.com/p/51995737">《setInterval 有什么缺点？》</a></p>
<h4 id="127-let-和-const-的注意点？"><a href="#127-let-和-const-的注意点？" class="headerlink" title="127. let 和 const 的注意点？"></a>127. let 和 const 的注意点？</h4><ul>
<li>1.声明的变量只在声明时的代码块内有效</li>
<li>2.不存在声明提升</li>
<li>3.存在暂时性死区，如果在变量声明前使用，会报错</li>
<li>4.不允许重复声明，重复声明会报错</li>
</ul>
<h4 id="128-什么是-rest-参数？"><a href="#128-什么是-rest-参数？" class="headerlink" title="128. 什么是 rest 参数？"></a>128. 什么是 rest 参数？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rest 参数（形式为...变量名），用于获取函数的多余参数。</span><br></pre></td></tr></table></figure>

<h4 id="129-什么是尾调用，使用尾调用有什么好处？"><a href="#129-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="129. 什么是尾调用，使用尾调用有什么好处？"></a>129. 什么是尾调用，使用尾调用有什么好处？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</span><br></pre></td></tr></table></figure>

<h4 id="130-Symbol-类型的注意点？"><a href="#130-Symbol-类型的注意点？" class="headerlink" title="130. Symbol 类型的注意点？"></a>130. Symbol 类型的注意点？</h4><ul>
<li>1.Symbol 函数前不能使用 new 命令，否则会报错。</li>
<li>2.Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li>
<li>3.Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。</li>
<li>4.Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li>
<li>5.Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</li>
<li>6.Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</li>
</ul>
<h4 id="131-Set-和-WeakSet-结构？"><a href="#131-Set-和-WeakSet-结构？" class="headerlink" title="131. Set 和 WeakSet 结构？"></a>131. Set 和 WeakSet 结构？</h4><ul>
<li>1.ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</li>
<li>2.WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，</li>
</ul>
<h4 id="132-Map-和-WeakMap-结构？"><a href="#132-Map-和-WeakMap-结构？" class="headerlink" title="132. Map 和 WeakMap 结构？"></a>132. Map 和 WeakMap 结构？</h4><ul>
<li>1.Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>
<li>2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>
</ul>
<h4 id="133-什么是-Proxy-？"><a href="#133-什么是-Proxy-？" class="headerlink" title="133. 什么是 Proxy ？"></a>133. 什么是 Proxy ？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。</span><br><span class="line"></span><br><span class="line">Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</span><br></pre></td></tr></table></figure>

<h4 id="134-Reflect-对象创建目的？"><a href="#134-Reflect-对象创建目的？" class="headerlink" title="134. Reflect 对象创建目的？"></a>134. Reflect 对象创建目的？</h4><ul>
<li>1.将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty，放到 Reflect 对象上。</li>
<li>2.修改某些 Object 方法的返回结果，让其变得更合理。</li>
<li>3.让 Object 操作都变成函数行为。</li>
<li>4.Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</li>
</ul>
<h4 id="135-require-模块引入的查找方式？"><a href="#135-require-模块引入的查找方式？" class="headerlink" title="135. require 模块引入的查找方式？"></a>135. require 模块引入的查找方式？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当 Node 遇到 require(X) 时，按下面的顺序处理。</span><br><span class="line"></span><br><span class="line">（1）如果 X 是内置模块（比如 require(&#x27;http&#x27;)）</span><br><span class="line">　　a. 返回该模块。</span><br><span class="line">　　b. 不再继续执行。</span><br><span class="line"></span><br><span class="line">（2）如果 X 以 &quot;./&quot; 或者 &quot;/&quot; 或者 &quot;../&quot; 开头</span><br><span class="line">　　a. 根据 X 所在的父模块，确定 X 的绝对路径。</span><br><span class="line">　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</span><br><span class="line">    X</span><br><span class="line">    X.js</span><br><span class="line">    X.json</span><br><span class="line">    X.node</span><br><span class="line"></span><br><span class="line">　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</span><br><span class="line">    X/package.json（main字段）</span><br><span class="line">    X/index.js</span><br><span class="line">    X/index.json</span><br><span class="line">    X/index.node</span><br><span class="line"></span><br><span class="line">（3）如果 X 不带路径</span><br><span class="line">　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。</span><br><span class="line">　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。</span><br><span class="line"></span><br><span class="line">（4）抛出 &quot;not found&quot;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2015/05/require.html">《require() 源码解读》</a></p>
<h4 id="136-什么是-Promise-对象，什么是-Promises-A-规范？"><a href="#136-什么是-Promise-对象，什么是-Promises-A-规范？" class="headerlink" title="136. 什么是 Promise 对象，什么是 Promises/A+ 规范？"></a>136. 什么是 Promise 对象，什么是 Promises/A+ 规范？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。</span><br><span class="line"></span><br><span class="line">Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们</span><br><span class="line">可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.ituring.com.cn/article/66566">《Promises/A+ 规范》</a><br><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-resolve">《Promise》</a></p>
<h4 id="137-手写一个-Promise"><a href="#137-手写一个-Promise" class="headerlink" title="137. 手写一个 Promise"></a>137. 手写一个 Promise</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RESOLVED</span> = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 保存初始化状态</span></span><br><span class="line">  <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 resolve 或者 rejected 传入的值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 resolve 的回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">resolvedCallbacks</span> = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 reject 的回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">rejectedCallbacks</span> = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态转变为 resolved 方法</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证代码的执行顺序为本轮事件循环的末尾</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有状态为 pending 时才能转变，</span></span><br><span class="line">      <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        self.<span class="property">state</span> = <span class="variable constant_">RESOLVED</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置传入的值</span></span><br><span class="line">        self.<span class="property">value</span> = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调函数</span></span><br><span class="line">        self.<span class="property">resolvedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态转变为 rejected 方法</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 保证代码的执行顺序为本轮事件循环的末尾</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有状态为 pending 时才能转变</span></span><br><span class="line">      <span class="keyword">if</span> (self.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        self.<span class="property">state</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置传入的值</span></span><br><span class="line">        self.<span class="property">value</span> = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调函数</span></span><br><span class="line">        self.<span class="property">rejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将两个方法传入函数执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">fn</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 遇到错误时，捕获错误，执行 reject 函数</span></span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span></span><br><span class="line">  onResolved =</span><br><span class="line">    <span class="keyword">typeof</span> onResolved === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onResolved</span><br><span class="line">      : <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> error;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是等待状态，则将函数加入对应列表中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resolvedCallbacks</span>.<span class="title function_">push</span>(onResolved);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectedCallbacks</span>.<span class="title function_">push</span>(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果状态已经凝固，则直接执行对应状态的函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">RESOLVED</span>) &#123;</span><br><span class="line">    <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="138-如何检测浏览器所支持的最小字体大小？"><a href="#138-如何检测浏览器所支持的最小字体大小？" class="headerlink" title="138. 如何检测浏览器所支持的最小字体大小？"></a>138. 如何检测浏览器所支持的最小字体大小？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。</span><br></pre></td></tr></table></figure>

<h4 id="139-怎么做-JS-代码-Error-统计？"><a href="#139-怎么做-JS-代码-Error-统计？" class="headerlink" title="139. 怎么做 JS 代码 Error 统计？"></a>139. 怎么做 JS 代码 Error 统计？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error 统计使用浏览器的 window.error 事件。</span><br></pre></td></tr></table></figure>

<h4 id="140-单例模式模式是什么？"><a href="#140-单例模式模式是什么？" class="headerlink" title="140. 单例模式模式是什么？"></a>140. 单例模式模式是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。</span><br></pre></td></tr></table></figure>

<h4 id="141-策略模式是什么？"><a href="#141-策略模式是什么？" class="headerlink" title="141. 策略模式是什么？"></a>141. 策略模式是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候</span><br><span class="line">用来将视图层的方法定义和方法调用分离。</span><br></pre></td></tr></table></figure>

<h4 id="142-代理模式是什么？"><a href="#142-代理模式是什么？" class="headerlink" title="142. 代理模式是什么？"></a>142. 代理模式是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。</span><br></pre></td></tr></table></figure>

<h4 id="143-中介者模式是什么？"><a href="#143-中介者模式是什么？" class="headerlink" title="143. 中介者模式是什么？"></a>143. 中介者模式是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。</span><br></pre></td></tr></table></figure>

<h4 id="144-适配器模式是什么？"><a href="#144-适配器模式是什么？" class="headerlink" title="144. 适配器模式是什么？"></a>144. 适配器模式是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种</span><br><span class="line">新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种</span><br><span class="line">自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。</span><br></pre></td></tr></table></figure>

<p>更多关于设计模式的资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc74186fb9a049ab0d0b6b">《前端面试之道》</a><br><a href="https://juejin.im/post/59df4f74f265da430f311909#heading-3">《JavaScript 设计模式》</a><br><a href="https://juejin.im/post/5afe6430518825428630bc4d">《JavaScript 中常见设计模式整理》</a></p>
<h4 id="145-观察者模式和发布订阅模式有什么不同？"><a href="#145-观察者模式和发布订阅模式有什么不同？" class="headerlink" title="145. 观察者模式和发布订阅模式有什么不同？"></a>145. 观察者模式和发布订阅模式有什么不同？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发布订阅模式其实属于广义上的观察者模式</span><br><span class="line"></span><br><span class="line">在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</span><br><span class="line"></span><br><span class="line">而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/23486749">《观察者模式和发布订阅模式有什么不同？》</a></p>
<h4 id="146-Vue-的生命周期是什么？"><a href="#146-Vue-的生命周期是什么？" class="headerlink" title="146. Vue 的生命周期是什么？"></a>146. Vue 的生命周期是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。</span><br></pre></td></tr></table></figure>

<h4 id="147-Vue-的各个生命阶段是什么？"><a href="#147-Vue-的各个生命阶段是什么？" class="headerlink" title="147. Vue 的各个生命阶段是什么？"></a>147. Vue 的各个生命阶段是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。</span><br><span class="line"></span><br><span class="line">（1）beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。</span><br><span class="line"></span><br><span class="line">（2）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。</span><br><span class="line"></span><br><span class="line">（3）beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。</span><br><span class="line"></span><br><span class="line">（4）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。</span><br><span class="line"></span><br><span class="line">（5）beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。</span><br><span class="line"></span><br><span class="line">（6）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。</span><br><span class="line"></span><br><span class="line">（7）beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。</span><br><span class="line"></span><br><span class="line">（8）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span><br><span class="line"></span><br><span class="line">当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/entry/5aee8fbb518825671952308c">《vue 生命周期深入》</a><br><a href="https://cn.vuejs.org/v2/guide/instance.html">《Vue 实例》</a></p>
<h4 id="148-Vue-组件间的参数传递方式？"><a href="#148-Vue-组件间的参数传递方式？" class="headerlink" title="148. Vue 组件间的参数传递方式？"></a>148. Vue 组件间的参数传递方式？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）父子组件间通信</span><br><span class="line"></span><br><span class="line">第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事</span><br><span class="line">件来向父组件发送数据。</span><br><span class="line"></span><br><span class="line">第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组</span><br><span class="line">件，这样也可以实现通信。</span><br><span class="line"></span><br><span class="line">第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件</span><br><span class="line">中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。</span><br><span class="line"></span><br><span class="line">（2）兄弟组件间通信</span><br><span class="line"></span><br><span class="line">第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实</span><br><span class="line">例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</span><br><span class="line"></span><br><span class="line">第二种是通过 $parent.$refs 来获取到兄弟组件，也可以进行通信。</span><br><span class="line"></span><br><span class="line">（3）任意组件之间</span><br><span class="line"></span><br><span class="line">使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候</span><br><span class="line">可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个</span><br><span class="line">公共数据进行读写操作，这样达到了解耦的目的。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/entry/5ba215ac5188255c6d0d8345">《VUE 组件之间数据传递全集》</a></p>
<h4 id="149-computed-和-watch-的差异？"><a href="#149-computed-和-watch-的差异？" class="headerlink" title="149. computed 和 watch 的差异？"></a>149. computed 和 watch 的差异？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。</span><br><span class="line"></span><br><span class="line">（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。</span><br><span class="line"></span><br><span class="line">（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5b98c4da6fb9a05d353c5fd7">《做面试的不倒翁：浅谈 Vue 中 computed 实现原理》</a><br><a href="https://juejin.im/post/5af908ea5188254265399009">《深入理解 Vue 的 watch 实现原理及其实现方式》</a></p>
<h4 id="150-vue-router-中的导航钩子函数"><a href="#150-vue-router-中的导航钩子函数" class="headerlink" title="150. vue-router 中的导航钩子函数"></a>150. vue-router 中的导航钩子函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）全局的钩子函数 beforeEach 和 afterEach</span><br><span class="line"></span><br><span class="line">beforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。</span><br><span class="line"></span><br><span class="line">（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。</span><br><span class="line"></span><br><span class="line">（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组</span><br><span class="line">件内部直接进行定义的。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">《导航守卫》</a></p>
<h4 id="151-route-和-router-的区别？"><a href="#151-route-和-router-的区别？" class="headerlink" title="151. $route 和 $router 的区别？"></a>151. $route 和 $router 的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</span><br></pre></td></tr></table></figure>

<h4 id="152-vue-常用的修饰符？"><a href="#152-vue-常用的修饰符？" class="headerlink" title="152. vue 常用的修饰符？"></a>152. vue 常用的修饰符？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；</span><br></pre></td></tr></table></figure>

<h4 id="153-vue-中-key-值的作用？"><a href="#153-vue-中-key-值的作用？" class="headerlink" title="153. vue 中 key 值的作用？"></a>153. vue 中 key 值的作用？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue 中 key 值的作用可以分为两种情况来考虑。</span><br><span class="line"></span><br><span class="line">第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</span><br><span class="line"></span><br><span class="line">第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000016344599">《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》</a><br><a href="https://www.zhihu.com/question/61064119">《Vue2.0 v-for 中 :key 到底有什么用？》</a><br><a href="https://www.cnblogs.com/RainyBear/p/8563101.html">《vue 中 key 的作用》</a></p>
<h4 id="154-computed-和-watch-区别？"><a href="#154-computed-和-watch-区别？" class="headerlink" title="154. computed 和 watch 区别？"></a>154. computed 和 watch 区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。</span><br><span class="line"></span><br><span class="line">watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</span><br></pre></td></tr></table></figure>

<h4 id="155-keep-alive-组件有什么作用？"><a href="#155-keep-alive-组件有什么作用？" class="headerlink" title="155. keep-alive 组件有什么作用？"></a>155. keep-alive 组件有什么作用？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</span><br></pre></td></tr></table></figure>

<h4 id="156-vue-中-mixin-和-mixins-区别？"><a href="#156-vue-中-mixin-和-mixins-区别？" class="headerlink" title="156. vue 中 mixin 和 mixins 区别？"></a>156. vue 中 mixin 和 mixins 区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mixin 用于全局混入，会影响到每个组件实例。</span><br><span class="line"></span><br><span class="line">mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc731b51882516c56ced6f">《前端面试之道》</a><br><a href="https://cn.vuejs.org/v2/guide/mixins.html">《混入》</a></p>
<h4 id="157-开发中常用的几种-Content-Type-？"><a href="#157-开发中常用的几种-Content-Type-？" class="headerlink" title="157. 开发中常用的几种 Content-Type ？"></a>157. 开发中常用的几种 Content-Type ？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL</span><br><span class="line">转码。</span><br><span class="line"></span><br><span class="line">（2）multipart/form-data</span><br><span class="line"></span><br><span class="line">该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</span><br><span class="line"></span><br><span class="line">（3）application/json</span><br><span class="line"></span><br><span class="line">告诉服务器消息主体是序列化后的 JSON 字符串。</span><br><span class="line"></span><br><span class="line">（4）text/xml</span><br><span class="line"></span><br><span class="line">该种方式主要用来提交 XML 格式的数据。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://honglu.me/2015/07/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8DContent-Type/">《常用的几种 Content-Type》</a></p>
<h4 id="158-如何封装一个-javascript-的类型判断函数？"><a href="#158-如何封装一个-javascript-的类型判断函数？" class="headerlink" title="158. 如何封装一个 javascript 的类型判断函数？"></a>158. 如何封装一个 javascript 的类型判断函数？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断数据是 null 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断数据是引用类型的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> valueClass = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value),</span><br><span class="line">      type = valueClass.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    type.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断数据是基本数据类型的情况和函数的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/28">《JavaScript 专题之类型判断(上)》</a></p>
<h4 id="159-如何判断一个对象是否为空对象？"><a href="#159-如何判断一个对象是否为空对象？" class="headerlink" title="159. 如何判断一个对象是否为空对象？"></a>159. 如何判断一个对象是否为空对象？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkNullObj</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span> === <span class="number">0</span> &amp;&amp; <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj).<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://blog.csdn.net/FungLeo/article/details/78113661">《js 判断一个 object 对象是否为空》</a></p>
<h4 id="160-使用闭包实现每隔一秒打印-1-2-3-4"><a href="#160-使用闭包实现每隔一秒打印-1-2-3-4" class="headerlink" title="160. 使用闭包实现每隔一秒打印 1,2,3,4"></a>160. 使用闭包实现每隔一秒打印 1,2,3,4</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用闭包实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 let 块级作用域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="161-手写一个-jsonp"><a href="#161-手写一个-jsonp" class="headerlink" title="161. 手写一个 jsonp"></a>161. 手写一个 jsonp</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">url, params, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否含有参数</span></span><br><span class="line">  <span class="keyword">let</span> queryString = url.<span class="title function_">indexOf</span>(<span class="string">&quot;?&quot;</span>) === -<span class="number">1</span> ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> params) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params.<span class="title function_">hasOwnProperty</span>(k)) &#123;</span><br><span class="line">      queryString += k + <span class="string">&quot;=&quot;</span> + params[k] + <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理回调函数名</span></span><br><span class="line">  <span class="keyword">let</span> random = <span class="title class_">Math</span>.<span class="title function_">random</span>()</span><br><span class="line">      .<span class="title function_">toString</span>()</span><br><span class="line">      .<span class="title function_">replace</span>(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">    callbackName = <span class="string">&quot;myJsonp&quot;</span> + random;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加回调函数</span></span><br><span class="line">  queryString += <span class="string">&quot;callback=&quot;</span> + callbackName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建请求</span></span><br><span class="line">  <span class="keyword">let</span> scriptNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  scriptNode.<span class="property">src</span> = url + queryString;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>[callbackName] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 调用回调函数</span></span><br><span class="line">    <span class="title function_">callback</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除这个引入的脚本</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].<span class="title function_">removeChild</span>(scriptNode);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发起请求</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(scriptNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://www.cnblogs.com/zzc5464/p/jsonp.html">《原生 jsonp 具体实现》</a><br><a href="https://segmentfault.com/a/1190000007665361#articleHeader1">《jsonp 的原理与实现》</a></p>
<h4 id="162-手写一个观察者模式？"><a href="#162-手写一个观察者模式？" class="headerlink" title="162. 手写一个观察者模式？"></a>162. 手写一个观察者模式？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> events = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> topics = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 注册监听函数</span></span><br><span class="line">    <span class="attr">subscribe</span>: <span class="keyword">function</span>(<span class="params">topic, handler</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!topics.<span class="title function_">hasOwnProperty</span>(topic)) &#123;</span><br><span class="line">        topics[topic] = [];</span><br><span class="line">      &#125;</span><br><span class="line">      topics[topic].<span class="title function_">push</span>(handler);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布事件，触发观察者回调事件</span></span><br><span class="line">    <span class="attr">publish</span>: <span class="keyword">function</span>(<span class="params">topic, info</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (topics.<span class="title function_">hasOwnProperty</span>(topic)) &#123;</span><br><span class="line">        topics[topic].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">handler</span>) &#123;</span><br><span class="line">          <span class="title function_">handler</span>(info);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除主题的一个观察者的回调事件</span></span><br><span class="line">    <span class="attr">remove</span>: <span class="keyword">function</span>(<span class="params">topic, handler</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!topics.<span class="title function_">hasOwnProperty</span>(topic)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> handlerIndex = -<span class="number">1</span>;</span><br><span class="line">      topics[topic].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item, index</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item === handler) &#123;</span><br><span class="line">          handlerIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (handlerIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        topics[topic].<span class="title function_">splice</span>(handlerIndex, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除主题的所有观察者的回调事件</span></span><br><span class="line">    <span class="attr">removeAll</span>: <span class="keyword">function</span>(<span class="params">topic</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (topics.<span class="title function_">hasOwnProperty</span>(topic)) &#123;</span><br><span class="line">        topics[topic] = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader1">《JS 事件模型》</a></p>
<h4 id="163-EventEmitter-实现"><a href="#163-EventEmitter-实现" class="headerlink" title="163. EventEmitter 实现"></a>163. EventEmitter 实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="variable language_">this</span>.<span class="property">events</span>[event] || [];</span><br><span class="line">    callbacks.<span class="title function_">push</span>(callback);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event] = callbacks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="variable language_">this</span>.<span class="property">events</span>[event];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event] = callbacks &amp;&amp; callbacks.<span class="title function_">filter</span>(<span class="function"><span class="params">fn</span> =&gt;</span> fn !== callback);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">event, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="variable language_">this</span>.<span class="property">events</span>[event];</span><br><span class="line">    callbacks.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">once</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">wrapFun</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">      <span class="title function_">callback</span>(...args);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(event, wrapFun);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(event, wrapFun);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="164-一道常被人轻视的前端-JS-面试题"><a href="#164-一道常被人轻视的前端-JS-面试题" class="headerlink" title="164. 一道常被人轻视的前端 JS 面试题"></a>164. 一道常被人轻视的前端 JS 面试题</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  getName = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">getName</span>(); <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">getName</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>.<span class="title function_">getName</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>(); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://github.com/Wscats/Good-text-Share/issues/85">《前端程序员经常忽视的一个 JavaScript 面试题》</a><br><a href="https://segmentfault.com/q/1010000008430170">《一道考察运算符优先级的 JavaScript 面试题》</a><br><a href="https://www.cnblogs.com/xxcanghai/p/5189353.html">《一道常被人轻视的前端 JS 面试题》</a></p>
<h4 id="165-如何确定页面的可用性时间，什么是-Performance-API？"><a href="#165-如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="165. 如何确定页面的可用性时间，什么是 Performance API？"></a>165. 如何确定页面的可用性时间，什么是 Performance API？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。</span><br><span class="line"></span><br><span class="line">使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。</span><br><span class="line"></span><br><span class="line">为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒</span><br><span class="line">的千分之一（1秒的百万分之一）。</span><br><span class="line"></span><br><span class="line">navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。</span><br><span class="line"></span><br><span class="line">loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。</span><br></pre></td></tr></table></figure>

<p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = performance.<span class="property">timing</span>;</span><br><span class="line"><span class="keyword">var</span> pageLoadTime = t.<span class="property">loadEventEnd</span> - t.<span class="property">navigationStart</span>;</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://javascript.ruanyifeng.com/bom/performance.html">《Performance API》</a></p>
<h4 id="166-js-中的命名规则"><a href="#166-js-中的命名规则" class="headerlink" title="166. js 中的命名规则"></a>166. js 中的命名规则</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）第一个字符必须是字母、下划线（_）或美元符号（$）</span><br><span class="line">（2）余下的字符可以是下划线、美元符号或任何字母或数字字符</span><br><span class="line"></span><br><span class="line">一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="http://www.w3school.com.cn/js/pro_js_variables.asp">《ECMAScript 变量》</a></p>
<h4 id="167-js-语句末尾分号是否可以省略？"><a href="#167-js-语句末尾分号是否可以省略？" class="headerlink" title="167. js 语句末尾分号是否可以省略？"></a>167. js 语句末尾分号是否可以省略？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有</span><br><span class="line">利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。</span><br></pre></td></tr></table></figure>

<h4 id="168-Object-assign"><a href="#168-Object-assign" class="headerlink" title="168. Object.assign()"></a>168. Object.assign()</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</span><br></pre></td></tr></table></figure>

<h4 id="169-Math-ceil-和-Math-floor"><a href="#169-Math-ceil-和-Math-floor" class="headerlink" title="169. Math.ceil 和 Math.floor"></a>169. Math.ceil 和 Math.floor</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。</span><br><span class="line"></span><br><span class="line">Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。</span><br></pre></td></tr></table></figure>

<h4 id="170-js-for-循环注意点"><a href="#170-js-for-循环注意点" class="headerlink" title="170. js for 循环注意点"></a>170. js for 循环注意点</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">5</span>, j &lt; <span class="number">9</span>; i++, j++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。</span></span><br><span class="line"><span class="comment">// 当判断语句为空时，循环会一直进行。</span></span><br></pre></td></tr></table></figure>

<h4 id="171-一个列表，假设有-100000-个数据，这个该怎么办？"><a href="#171-一个列表，假设有-100000-个数据，这个该怎么办？" class="headerlink" title="171. 一个列表，假设有 100000 个数据，这个该怎么办？"></a>171. 一个列表，假设有 100000 个数据，这个该怎么办？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">（1）将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。</span><br><span class="line"></span><br><span class="line">（2）使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。</span><br><span class="line"></span><br><span class="line">（3）使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。</span><br></pre></td></tr></table></figure>

<h4 id="172-js-中倒计时的纠偏实现？"><a href="#172-js-中倒计时的纠偏实现？" class="headerlink" title="172. js 中倒计时的纠偏实现？"></a>172. js 中倒计时的纠偏实现？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。</span><br><span class="line"></span><br><span class="line">一般解决倒计时中的误差的有这样两种办法：</span><br><span class="line"></span><br><span class="line">（1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。</span><br><span class="line"></span><br><span class="line">（2）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。</span><br></pre></td></tr></table></figure>

<p>详细资料可以参考：<br><a href="https://juejin.im/post/5badf8305188255c8e728adc">《JavaScript 前端倒计时纠偏实现》</a></p>
<h4 id="173-进程间通信的方式？"><a href="#173-进程间通信的方式？" class="headerlink" title="173. 进程间通信的方式？"></a>173. 进程间通信的方式？</h4><ul>
<li>1.管道通信</li>
<li>2.消息队列通信</li>
<li>3.信号量通信</li>
<li>4.信号通信</li>
<li>5.共享内存通信</li>
<li>6.套接字通信</li>
</ul>
<p>详细资料可以参考：<br><a href="https://blog.csdn.net/violet_echo_0908/article/details/51201278">《进程间 8 种通信方式详解》</a><br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">《进程与线程的一个简单解释》</a></p>
<h4 id="174-如何查找一篇英文文章中出现频率最高的单词？"><a href="#174-如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="174. 如何查找一篇英文文章中出现频率最高的单词？"></a>174. 如何查找一篇英文文章中出现频率最高的单词？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findMostWord</span>(<span class="params">article</span>) &#123;</span><br><span class="line">  <span class="comment">// 合法性判断</span></span><br><span class="line">  <span class="keyword">if</span> (!article) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数处理</span></span><br><span class="line">  article = article.<span class="title function_">trim</span>().<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> wordList = article.<span class="title function_">match</span>(<span class="regexp">/[a-z]+/g</span>),</span><br><span class="line">    visited = [],</span><br><span class="line">    maxNum = <span class="number">0</span>,</span><br><span class="line">    maxWord = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  article = <span class="string">&quot; &quot;</span> + wordList.<span class="title function_">join</span>(<span class="string">&quot;  &quot;</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历判断单词出现次数</span></span><br><span class="line">  wordList.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.<span class="title function_">indexOf</span>(item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加入 visited </span></span><br><span class="line">      visited.<span class="title function_">push</span>(item);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> word = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot; &quot;</span> + item + <span class="string">&quot; &quot;</span>, <span class="string">&quot;g&quot;</span>),</span><br><span class="line">        num = article.<span class="title function_">match</span>(word).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (num &gt; maxNum) &#123;</span><br><span class="line">        maxNum = num;</span><br><span class="line">        maxWord = item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxWord + <span class="string">&quot;  &quot;</span> + maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="175-ele-getElementsByClassName和ele-querySelectorAll的区别？"><a href="#175-ele-getElementsByClassName和ele-querySelectorAll的区别？" class="headerlink" title="175. ele.getElementsByClassName和ele.querySelectorAll的区别？"></a>175. ele.getElementsByClassName和ele.querySelectorAll的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">element.getElementsByClassName 返回一个即时更新（动态的）HTMLCollection</span><br><span class="line">element.querySelectorAll 返回一个非即时更新（静态的） NodeList</span><br><span class="line">// 先说什么叫即时更新，（前者是动态的，改变 DOM 结构会同步，后者只会记录调用 api 时的结果，不懂可以看下面的例子）</span><br><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;p class=&quot;p&quot;&gt;1&lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;p&quot;&gt;2&lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;p&quot;&gt;3&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">let list1 = parent.getElementsByClassName(&#x27;p&#x27;);</span><br><span class="line">let list2 = parent.querySelectorAll(&#x27;.p&#x27;);</span><br><span class="line">console.log(list1.length1); // 3</span><br><span class="line">console.log(list2.length1); // 3</span><br><span class="line">let newP = docuemnt.createElement(&quot;p&quot;)</span><br><span class="line">newP.classList.add(&#x27;p&#x27;);</span><br><span class="line">parent.appendChild(newP);</span><br><span class="line">console.log(list1.length1); // 4 (即时更新)</span><br><span class="line">console.log(list2.length1); // 3（非即时更新）</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 在说下返回值</span><br><span class="line">// HTMLCollection 和 NodeList 都是类数组形式</span><br><span class="line">如下一个 div 可以看成是 HTMLDivElement 的实例，其中 Node 的集合为 NodeList；Element 的集合为 HTMLCollection</span><br><span class="line">EventTarget - Node - Element - HTMLElement - HTMLDivElement&lt;br&gt;</span><br><span class="line">EventTarget - Node - Element - SVGElement - SVGPathElement&lt;br&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLDivElement">MDN 上元素 div 继承关系</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
